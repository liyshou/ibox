// Trade.cpp: implementation of the CTrade class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "TissonCTSI.h"
#include "Trade.h"
#include "Tools.h"
#include "Def.h"
#include "Global.h"
#include "TSCTSI.h"
#include "pack.h"
#include "DB.h"
#include "DGBusTrade.h"
#include "DGTBusTrade.h"
#include "YCTYPTrade.h"
#include "xmlParser.h"
#include <winsock2.h>
#include "ks_soap.h"
#include "Des.h"
#include "Print.h"
#include "Connect.h"
#include "ctsipass.h"
#include <algorithm>
#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

#define BIZ_AREA_BIZ_DX 1
#define BIZ_AREA_BIZ_YD 2
#define BIZ_AREA_BIZ_LT_LX 3
#define BIZ_AREA_BIZ_LT_QS 4
#define BIZ_AREA_BIZ_DX_ENQ 5
#define BIZ_AREA_BIZ_SELLCARD 6
#define BIZ_AREA_BIZ_QQB 7
#define BIZ_AREA_BIZ_TRAFFIC 8
#define BIZ_AREA_BIZ_DX_DZDB_ENQ 9
#define BIZ_AREA_BIZ_INTEGRATED 11
#define BIZ_AREA_BIZ_UNICOM_CHARGE 12

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CTrade::CTrade()
{
	//	bbzero(mac_random_num);
}

CTrade::~CTrade()
{
	//	wrLog("【~CTrade】");
}

//设置传入参数：sd和gbl
void CTrade::set_in_par(CGlobal in_gbl)
{
	gbl = in_gbl;	
	getComPar(gbl.posInfo.leftType, gbl.posInfo.rightType, gbl.posInfo.inType, &m_com, &m_comType);
}

//取得成员变量gbl
void CTrade::get_gbl(CGlobal &out_gbl)
{
	out_gbl = gbl;
}

//取得小灵通卡号和磁道信息，供返回至CMenuHdl类中
void CTrade::get_xlt_info(char *card, int &track2_len, char *track2)
{
	strcpy(card, gbl.card_no);
	if(gbl.track2_len)
	{
		strcpy(track2, gbl.track2);
		track2_len = gbl.track2_len;
	}
}


//上笔交易查询
int CTrade::banInqLast()
{
	int iRet=0 , iSelect, len;
	char tmp[512];
	char cDate[11], amo[13], cTime[9];
	BanDetail banDetail;
	
	wrLog("【上笔交易查询】");
	strcpy(gbl.fee_type, "0188");
	strcpy(gbl.pos_serial, "999999");
	pack.wrField(2, gbl);	//写交费域
	/*----------------------------------*/
	bbzero(pack.FIELD3);
	CTools::hex_to_byte((BYTE *)"310060", pack.FIELD3, 6);
	bbzero(pack.FIELD48);
	memcpy(pack.FIELD48, gbl.fee_type, 4);
	pack.Packet_Table[48].Real_Length = 4;
	/*----------------------------------*/
	//打查询包
	iRet = packHdl(1);
	if(iRet < 0)
		return -1;
	
	if (!memcmp(pack.FIELD39,"00",2)) 
	{
		memset(&banDetail, 0, sizeof(banDetail));
		len = 0;
		bbzero(tmp);
		memcpy(tmp, pack.FIELD63, 2);  //卡号长度
		len+=2;
		if(atoi(tmp) > 20)  //卡号长度过大
		{
			wrLog("卡号长度超过20，len=%d", atoi(tmp));
			TS_OutPutMsg(gbl.dPosInfo, "\n\n 取得查询明细错误！\n请稍候再试!\n或按【Ctrl+H】联系在线客服中心 或致电400-80-11888咨询", 1, iSelect, 10);
			return -1;
		}
		memcpy(banDetail.card, pack.FIELD63+len, atoi(tmp));  //卡号
		len+=atoi(tmp);
		strcpy(gbl.card_no, banDetail.card);
		gbl.card_no_len = atoi(tmp);
		memcpy(banDetail.traDate, pack.FIELD63+len, 8);  //日期
		len+=8;
		memcpy(banDetail.traTime, pack.FIELD63+len, 6);  //时间
		len+=6;
		memcpy(banDetail.amount, pack.FIELD63+len, 12);  //金额
		len+=12;
		memcpy(banDetail.serial, pack.FIELD63+len, 6);  //流水
		len+=6;
		memcpy(banDetail.peStan, pack.FIELD63+len, 12);  //pe系统参考号
		len+=12;
		memcpy(banDetail.uniStan, pack.FIELD63+len, 12);  //银联系统参考号
		len+=12;
		bbzero(pack.FIELD12); //时间
		bbzero(pack.FIELD13); //日期
		CTools::hex_to_byte((BYTE *)banDetail.traTime, pack.FIELD12, 6);
		CTools::hex_to_byte((BYTE *)banDetail.traDate, pack.FIELD13, 8);
		wrHex("traTime", pack.FIELD12, 3);
		wrHex("traDate", pack.FIELD13, 4);
		
		bbzero(amo);
		bbzero(cDate);
		bbzero(cTime);
		CTools::chgToMny(banDetail.amount, amo);
		CTools::formatDate(banDetail.traDate, cDate);
		CTools::formatTime(banDetail.traTime, cTime);
		bbzero(tmp);
		sprintf(tmp, "支付卡号:%s\n交易金额:%s\n流水号:%s\n日期:%s\n时间:%s\n【确认】打印\n【返回】退出", banDetail.card, amo, banDetail.serial, cDate, cTime);
		wrLog("查询提示信息：\n%s", tmp);
		iRet = TS_OutPutMsg(gbl.dPosInfo, tmp, 0, iSelect);
		if(iRet!=0 || iSelect==0)
		{
			strcpy(gbl.card_no, banDetail.card);
			gbl.card_no_len = strlen(gbl.card_no);
			CPrint prt;
			prt.set_in_par(gbl);
			prt.print_ban_detail(1);	 //打印明细
		}
		return 0;
	}
	else
	{
		iRet = banReturnFail((char *)pack.FIELD39);
		return -1;
	}
}

//历史记录查询
//inqType: 1-当日交易查询
//		   2-历史交易明细查询
int CTrade::banInqHistory(int inqType)
{
	int iRet=0 , iSelect, len, type, flag;
	int total, remain;
	char currNum[4+1];
	char inqDate[9], tmp[512], title[20], *p = NULL;
	char cDate[11], cTime[9], amo[13];
	char card[22], serial[7], uniStan[13];  //按卡号、流水、银联参考号查询
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	BanDetail banDetail;
	
	bbzero(title);
	if(inqType == 1)
	{
		wrLog("【当日交易明细查询】");
		strcpy(gbl.fee_type, "0189");
		strcpy(title, "当日交易明细查询");
	}
	else if(inqType == 2)
	{
		wrLog("【历史交易明细查询】");
		strcpy(gbl.fee_type, "0190");
		strcpy(title, "历史交易明细查询");
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
		
		strcpy(tradeInfoSend.acMainTitle, "历史交易明细查询");
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents = 1;
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_DATE;		//日期
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		if(iRet != 0)
		{
			wrLog("【banInqHistory】失败，返回码[%d]", iRet);
			wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
			return -1;
		}
		bbzero(gbl.pos_serial);
		strcpy(gbl.pos_serial, (char *)tradeInfoRecv.uTradeID);
		bbzero(inqDate);
		strcpy(inqDate, (char *)tradeInfoRecv.Contents[0].uMsg);
	}
	else
		return -1;
	
	bbzero(currNum);
	strcpy(currNum, "0000");
	flag = 1;
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{	
		if(flag)	//若还有明细，不选择菜单
		{
			type = banInqMenu();	//选择查询方式
			wrLog("type: %d", type);
			if(type == CANCLE_KEY || type<0)
				return CANCLE_KEY;
			memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
			memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
			strcpy(tradeInfoSend.acMainTitle, title);
			tradeInfoSend.uHasTradeID = 1;
			tradeInfoSend.uTotalContents = 1;
			switch(type)
			{
			case 1:  //按卡号
				strcpy(tradeInfoSend.Contents[0].acTitle, "请输入交易帐号");
				tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;
				tradeInfoSend.Contents[0].uMinLen = 12;
				tradeInfoSend.Contents[0].uMaxLen = 20;
				tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
				break;
			case 2:  //按流水号
				strcpy(tradeInfoSend.Contents[0].acTitle, "请输入流水号");
				tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;
				tradeInfoSend.Contents[0].uMinLen = 6;
				tradeInfoSend.Contents[0].uMaxLen = 6;
				tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
				break;
			case 3:  //按银联参考号
				strcpy(tradeInfoSend.Contents[0].acTitle, "请输入银联参考号");
				tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;
				tradeInfoSend.Contents[0].uMinLen = 12;
				tradeInfoSend.Contents[0].uMaxLen = 12;
				tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
				break;
			default:
				break;
			}
			if(type != 4)
			{
				iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
				if(iRet)
				{
					wrLog("【banInqHistory】失败，返回值：[%d]", iRet);
					wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
					continue;
				}
				bbzero(gbl.pos_serial);
				strcpy(gbl.pos_serial, (char *)tradeInfoRecv.uTradeID);
				bbzero(card);
				bbzero(serial);
				bbzero(uniStan);
				if(type == 1)
					p = card;
				else if(type == 2)
					p = serial;
				else if(type == 3)
					p = uniStan;	
				strcpy(p, (char *)tradeInfoRecv.Contents[0].uMsg);
				wrLog("p: [%s]", p);
			}
			else
				strcpy(gbl.pos_serial, "999999");
		}
		pack.wrField(2, gbl);	//写交费域
		/*----------------------------------*/
		bbzero(pack.FIELD3);
		CTools::hex_to_byte((BYTE *)"310060", pack.FIELD3, 6);
		bbzero(pack.FIELD48);
		memcpy(pack.FIELD48, gbl.fee_type, 4);
		pack.Packet_Table[48].Real_Length = 4;
		bbzero(pack.FIELD63);
		if(type == 1)
			sprintf((char *)pack.FIELD63, "%d%02d%s", type, strlen(p), p);
		else if(type == 4)
			sprintf((char *)pack.FIELD63, "%d00", type);
		else
			sprintf((char *)pack.FIELD63, "%d%s", type, p);
		//wrLog("FIELD63: [%s]", pack.FIELD63);
		if(inqType == 1)  //当日明细
		{
			strcat((char *)pack.FIELD63, currNum);
			pack.Packet_Table[63].Real_Length = strlen((char *)pack.FIELD63);
		}
		else if(inqType == 2)  //历史明细
		{
			strcat((char *)pack.FIELD63, inqDate);
			strcat((char *)pack.FIELD63, currNum);
			pack.Packet_Table[63].Real_Length = strlen((char *)pack.FIELD63);
		}
		/*----------------------------------*/
		//打查询包
		iRet = packHdl(1);
		if(iRet < 0)
			return -1;
		if (!memcmp(pack.FIELD39,"00",2)) 
		{
			//wrLog("Bit63: [%s]", pack.FIELD63);
			memset(&banDetail, 0, sizeof(banDetail));
			len = 0;
			bbzero(tmp);
			memcpy(tmp, pack.FIELD63+len, 4);  //总笔数
			len+=4;
			total = atoi(tmp);
			bbzero(tmp);
			memcpy(tmp, pack.FIELD63+len, 2);  //记录数
			len+=2;
			remain = total-atoi(currNum)-1;  //剩余数，仅用于显示给用户看
			sprintf(currNum, "%04d", atoi(currNum)+1);
			wrLog("currNum: [%s]", currNum);
			wrLog("remain: [%d]", remain);
			
			bbzero(tmp);
			memcpy(tmp, pack.FIELD63+len, 2);  //卡号长度
			len+=2;
			if(atoi(tmp) > 20)  //卡号长度过大
			{
				wrLog("卡号长度超过20，len=%d", atoi(tmp));
				TS_OutPutMsg(gbl.dPosInfo, "\n\n 取得查询明细错误！\n请稍候再试!\n或按【Ctrl+H】联系在线客服中心 或致电400-80-11888咨询", 1, iSelect, 10);
				return -1;
			}
			memcpy(banDetail.card, pack.FIELD63+len, atoi(tmp));  //卡号
			len+=atoi(tmp);
			strcpy(gbl.card_no, banDetail.card);
			gbl.card_no_len = atoi(tmp);
			memcpy(banDetail.traDate, pack.FIELD63+len, 8);  //日期
			len+=8;
			memcpy(banDetail.traTime, pack.FIELD63+len, 6);  //时间
			len+=6;
			memcpy(banDetail.amount, pack.FIELD63+len, 12);  //金额
			len+=12;
			memcpy(banDetail.serial, pack.FIELD63+len, 6);  //流水
			len+=6;
			memcpy(banDetail.peStan, pack.FIELD63+len, 12);  //pe系统参考号
			len+=12;
			memcpy(banDetail.uniStan, pack.FIELD63+len, 12);  //银联系统参考号
			len+=12;
			
			bbzero(amo);
			bbzero(cDate);
			bbzero(cTime);
			CTools::chgToMny(banDetail.amount, amo);
			CTools::formatDate(banDetail.traDate, cDate);
			CTools::formatTime(banDetail.traTime, cTime);
			bbzero(tmp);
			sprintf(tmp, "支付卡号:%s\n交易金额:%s\n流水号:%s\n日期:%s\n时间:%s\n【剩余%d条】\n【确认】继续\n【返回】退出", banDetail.card, amo, banDetail.serial, cDate, cTime, remain);
			
			if( TS_OutPutMsg(gbl.dPosInfo, tmp, 0, iSelect) )
				return -1;
			if(iSelect == CANCLE_KEY)
				return CANCLE_KEY;
			//用户选择处理方式
			iRet = banInqMenu(1);
			if(iRet == CANCLE_KEY)
				return CANCLE_KEY;
			wrLog("banInqMenu return: %d", iRet);
			if(iRet == 1) //打印
			{
				CPrint prt;
				prt.set_in_par(gbl);
				prt.print_ban_detail(2);	 //打印明细
				TS_OutPutMsg(gbl.dPosInfo, "     打印成功！\n【确认】查看下一笔\n【返回】退出", 0, iSelect);
				if(iSelect)
					return 0;
				if(atoi(currNum) == total)
				{
					TS_OutPutMsg(gbl.dPosInfo, "\n\n 所有记录查询完毕！", 1, iSelect);
					flag = 1;
					strcpy(currNum, "0000");
				}
				else if(atoi(currNum) < total)
					flag = 0;
				else
					flag = 1;
				continue;
			}
			else if(iRet == 2) //查看下一笔
			{
				if(atoi(currNum) == total)
				{
					TS_OutPutMsg(gbl.dPosInfo, "\n\n 所有记录查询完毕！", 1, iSelect);
					flag = 1;
					strcpy(currNum, "0000");
				}
				else if(atoi(currNum) < total)
					flag = 0;
				else
					flag = 1;
				continue;
			}
			else
				return CANCLE_KEY;
		}
		else
		{
			iRet = banReturnFail((char *)pack.FIELD39);
			return -1;
		}
	}
	return -1;
}

//type: 0-选择查询方式（默认）
//		1-选择处理方式
int CTrade::banInqMenu(int type)
{
	int iRet, iSelect, count=0;
	TSMENULIST menuList;
	
	memset(&menuList,0,sizeof(menuList));
	if(!type)
	{
		strcpy(menuList.acTitle, "请选择查询方式");
		strcpy(menuList.menuItem[0], "交易帐号");
		strcpy(menuList.menuItem[1], "流水号");
		strcpy(menuList.menuItem[2], "银联参考号");
		strcpy(menuList.menuItem[3], "全  部");
		count = 0;
		while(strcmp(menuList.menuItem[count++], ""))
			menuList.iTotalNum++;
		iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
		if(iRet)
			return -1;
		if(iSelect>0 && iSelect<5)
			return iSelect;
		else
			return CANCLE_KEY;
	}
	else
	{
		strcpy(menuList.acTitle, "请选择：");
		strcpy(menuList.menuItem[0], "打  印");
		strcpy(menuList.menuItem[1], "查看下一笔");
		strcpy(menuList.menuItem[2], "取  消");
		
		count = 0;
		while(strcmp(menuList.menuItem[count++], ""))
			menuList.iTotalNum++;
		iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
		if(iRet)
			return -1;
		if(iSelect>0 && iSelect<3)
			return iSelect;
		else
			return CANCLE_KEY;
	}
}

//银行卡余额查询
int CTrade::banInqMoneyTrade(const char *title, char *amount_out)
{
	int iRet=0, iRetB=0, iSelect=0;
	char mark_card[30+1];
	
	bbzero(mark_card);
	strncpy(mark_card, gbl.card_no, sizeof(mark_card)-1);
	iRet = banInqMoneyHdl(title, amount_out);
	if( gbl.get_card == MNG_ONE || gbl.get_card == MNG_ONE_BIND || gbl.get_card == MNG_ONE_BIND_E || gbl.get_card == MNG_MUL_BIND_E )//还原原先刷的卡
	{
		iRetB = bindcard(mark_card, gbl.card_no, &gbl.card_no_len);
		if(iRetB != 0)
		{
			TS_OutPutMsg(gbl.dPosInfo,"绑定原卡号出错!\n请稍候再试!\n或按【Ctrl+H】联系在线客服中心 或致电400-80-11888咨询",0,iSelect);
			TS_HangUp(gbl.dPosInfo);
		}
	}
	return iRet;
}

//银行卡余额查询
int CTrade::banInqMoneyHdl(const char *title, char *amount_out)
{
	int  iRet=0 , iSelect, flag, i=0;
	char tmp[256], amo_buff[13], amount[13], mycard_no[30+1];
	char temp[1024];
	
	if (memcmp(gbl.fee_type,"0185",4)==0)
	{
		bbzero(temp);
		sprintf(temp,"  恭喜交费易新开通\n  【【交通罚款】】\n请按交费易键进入使用\n  咨询电话：400-80-11888\n  请按【确认】继续");
		iRet = TS_OutPutMsg(gbl.dPosInfo,temp,0,iSelect);
		if (iRet < 0)
		{
			return -1;
		}	
	}
	
	flag = 0;
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{
		if(!flag)
		{
			if( gbl.get_card == MNG_ONE || gbl.get_card == MNG_ONE_BIND || gbl.get_card == MNG_ONE_BIND_E || gbl.get_card == MNG_MUL_BIND_E )//还原原先刷的卡
				iRet = mngCard_Hdl(title, "", 0, 1);//业务需要，一定要刷卡，且只能刷卡
			else
				iRet = mngCard_Hdl(title);
			if(iRet == CANCLE_KEY)
				return CANCLE_KEY;
			else if(iRet != 0)
				return -1;
		}
		bbzero(gbl.phone_no);
		strcpy(gbl.phone_no,"00000000");
		gbl.phone_len = strlen(gbl.phone_no);
		pack.wrField(2, gbl);	//写交费域
		/*----------------------------------*/
		bbzero(pack.FIELD3);
		CTools::hex_to_byte((BYTE *)"310060", pack.FIELD3, 6);
		bbzero(pack.FIELD48);
		memcpy(pack.FIELD48, gbl.fee_type, 4);
		pack.Packet_Table[48].Real_Length = 4;
		/*----------------------------------*/
		//打查询包
		iRet = packHdl(1);
		if(iRet < 0)
			return -1;
		
		if (!memcmp(pack.FIELD39,"00",2)) 
		{
			bbzero(amo_buff);
			memcpy(amo_buff, (char *)pack.FIELD63, 12);
			wrLog("余额：[%s]", amo_buff);
			bbzero(amount);
			CTools::chgToMny(amo_buff, amount);
			bbzero(tmp);
			bbzero(mycard_no);
			memcpy(mycard_no, gbl.card_no, gbl.card_no_len);
			for(i=gbl.card_no_len-2;i>gbl.card_no_len-5;i--)	//不显示完整银行卡号
				mycard_no[i] = '*';
			if(amount_out==NULL)
			{
				sprintf(tmp, "卡号：\n%s\n余额：%s\n【确认】返回", mycard_no, amount);
				TS_OutPutMsg(gbl.dPosInfo, tmp, 0, iSelect);
			}
			else
			{
				strcpy(amount_out, amo_buff);
				iSelect = 0;
			}
			return iSelect;
		}
		else if(!memcmp(pack.FIELD39,"55",2) || !memcmp(pack.FIELD62, "P20004855", 9))
		{
			flag = 1;
			if(reGetPwd(title) == 0) //密码错误，重新输入密码
				continue;
			else
				return CANCLE_KEY;
		}
		else
		{
			iRet = banReturnFail((char *)pack.FIELD39);
			return -1;
		}
	}
	return -1;
}

//银行查询交易
//inqType:  1-终端签到
//			2-本机收款账号和户名查询
int CTrade::banInqTrade(int inqType)
{
	int  iRet=0 , iSelect, len;
	char tmp[512], card[25], name[100];
	
	if(inqType == 1)
		strcpy(gbl.fee_type, "0181");
	else if(inqType == 2)
		strcpy(gbl.fee_type, "0186");
	else
		return -1;
	
	strcpy(gbl.pos_serial, "999999");
	pack.wrField(2, gbl);	//写交费域
	/*----------------------------------*/
	bbzero(pack.FIELD3);
	CTools::hex_to_byte((BYTE *)"310060", pack.FIELD3, 6);
	bbzero(pack.FIELD48);
	memcpy(pack.FIELD48, gbl.fee_type, 4);
	pack.Packet_Table[48].Real_Length = 4;
	/*----------------------------------*/
	//打查询包
	iRet = packHdl(1);
	if(iRet < 0)
		return -1;
	
	if (!memcmp(pack.FIELD39,"00",2)) 
	{
		if(inqType == 1)
			TS_OutPutMsg(gbl.dPosInfo, " \n\n    签到成功！", 1, iSelect);
		else
		{
			len = 0;
			bbzero(tmp);
			memcpy(tmp, pack.FIELD63+len, 2);
			len+=2;
			if(atoi(tmp) > 24)
				return -1;
			bbzero(card);
			memcpy(card, pack.FIELD63+len, atoi(tmp));
			len+=atoi(tmp);
			bbzero(tmp);
			memcpy(tmp, pack.FIELD63+len, 2);
			len+=2;
			bbzero(name);
			memcpy(name, pack.FIELD63+len, atoi(tmp));
			bbzero(tmp);
			sprintf(tmp, "用户名：%s\n卡号：%s\n【确认】返回", name, card);
			TS_OutPutMsg(gbl.dPosInfo, tmp, 0, iSelect);
		}
		return 0;
	}
	else
	{
		banReturnFail((char *)pack.FIELD39);
		return -1;
	}
}

int CTrade::banTransfer(const char *title)		//银行转帐交易
{
	int  iRet=0 , flag = 1, curTry=0;
	int  iSelect;
	char tmp[256], card_info[201];
	char amo_buff[13];
	char prc_amo[13], prc_amo_buff[13];	//手续费
	char tra_amo[13], tra_amo_buff[13];	//交易金额
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	
	wrLog("【转账】转账业务");
	strcpy(gbl.fee_type,"0183");
	//刷卡
	wrLog("【转账】开始刷卡");
	for(curTry=0; curTry<MAXTRY; curTry++)
	{
		bbzero(card_info);
		iRet = getCardInfo(title, card_info);//刷卡取得卡信息
		if( iRet == 0 )
			iRet = getCardNum(card_info);//取得卡号
		
		if(!iRet)
			break;
		else if(iRet == CANCLE_KEY)
		{
			wrLog("【转账】取消刷卡");
			return CANCLE_KEY;
		}
		else if(iRet == RE_MNG_CARD)
		{
			wrLog("【转账】重新刷卡");
			continue;
		}
		else if(iRet != 0)
		{
			wrLog("【转账】刷卡失败");
			return -1;
		}
	}
	wrLog("【转账】刷卡成功");
	//输入金额
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	
	strcpy(tradeInfoSend.acMainTitle, title);
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	//	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入交易金额：");
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_MONEY;	//金额
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
	tradeInfoSend.Contents[0].uMinLen = 1;		
	tradeInfoSend.Contents[0].uMaxLen = 8;	
	wrLog("【转账】开始输入金额");
	for(curTry=0; curTry<MAXTRY; curTry++)
	{
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		if(iRet != 0)
		{
			if(iRet == 1 || iRet ==2)
				wrLog("【转账】输入金额用户取消或超时");
			else
				wrLog("【转账】输入金额失败");
			wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
			return -1;
		}
		bbzero(tra_amo);
		strcpy(tra_amo, (char *)tradeInfoRecv.Contents[0].uMsg);	//读入金额
		wrLog("tra_amo: [%s]", tra_amo);
		if(atoi(tra_amo)>10000000)
		{
			TS_OutPutMsg(gbl.dPosInfo, "超过最大金额(10万元)\n【确认】重新输入\n【返回】退出", 0, iSelect);
			if(iSelect)
				return CANCLE_KEY;
			else
				continue;
		}
		else
			break;
	}
	wrLog("【转账】输入金额成功");
	bbzero(gbl.pos_serial);
	strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
	pack.wrField(2, gbl);	//写交费域
	/*-----------------------------------------------*/
	bbzero(pack.FIELD3);
	CTools::hex_to_byte((BYTE *)"310060", pack.FIELD3, 6);
	bbzero(pack.FIELD48);
	memcpy(pack.FIELD48, gbl.fee_type, 4);
	pack.Packet_Table[48].Real_Length = 4;
	bbzero(pack.FIELD63);
	memcpy(pack.FIELD63, tra_amo, 12);
	pack.Packet_Table[63].Real_Length = 12;
	/*-----------------------------------------------*/
	iRet = packHdl(1);
	if(iRet < 0)
		return -1;
		/*---------test----------*
		strcpy((char *)pack.FIELD39,"00");
		sprintf((char *)pack.FIELD63, "%s000000001234", tra_amo);
	/*-----------------------*/
	if (!memcmp(pack.FIELD39,"00",2)) 
	{
		wrLog("【转账】查询手续费成功");
		bbzero(tra_amo);
		bbzero(prc_amo);
		memcpy(tra_amo, pack.FIELD63, 12);		//交易金额
		memcpy(prc_amo, pack.FIELD63+12, 12);	//手续费
		
		bbzero(amo_buff);
		bbzero(prc_amo_buff);
		bbzero(tra_amo_buff);
		bbzero(gbl.amount);
		sprintf(gbl.amount, "%012ld", atoi(tra_amo)+atoi(prc_amo));	//总额
		wrLog("gbl.amount: [%s]", gbl.amount);
		
		CTools::chgToMny(gbl.amount, amo_buff);	//总额
		CTools::chgToMny(tra_amo, tra_amo_buff);	//交易金额
		CTools::chgToMny(prc_amo, prc_amo_buff);	//手续费
		bbzero(tmp);
		sprintf(tmp, "卡号:%s\n交易本金:%s\n手续费:%s\n总额:%s\n按【确定】转帐", gbl.card_no, tra_amo_buff, prc_amo_buff, amo_buff);
		iRet = TS_OutPutMsg(gbl.dPosInfo, tmp, 0, iSelect);
		if(iRet)
		{
			wrLog("【转账】下发提示信息返回失败");
			return -1;
		}
	}
	else
	{
		wrLog("【转账】查询手续费失败");
		return  returnFail((char *)pack.FIELD39);
	}
	if(iSelect)
	{
		wrLog("【转账】用户取消");
		return CANCLE_KEY;
	}
	
	strcpy(gbl.fee_type,"0184");
	flag = 0;
	wrLog("【转账】开始输密码");
	for(curTry=0; curTry<MAXTRY; curTry++)
	{
		if(!flag)
		{
			iRet = getCardPwd(title);	//取得密码
			
			if(iRet == CANCLE_KEY)
			{
				wrLog("【转账】密码取消");
				return CANCLE_KEY;
			}
			else if(iRet != 0)
			{
				wrLog("【转账】密码返回失败");
				return -1;
			}
		}
		wrLog("【转账】输入密码成功");
		pack.wrField(2, gbl);	//写交费域
		/*-----------------------------------------------*/
		bbzero(pack.FIELD3);
		CTools::hex_to_byte((BYTE *)"000000", pack.FIELD3, 6);
		memset(pack.FIELD48,0,sizeof(pack.FIELD48));
		memcpy(pack.FIELD48, gbl.fee_type, 4);
		pack.Packet_Table[48].Real_Length = 4;
		
		memcpy(pack.FIELD63+8, prc_amo, 12);
		pack.Packet_Table[63].Real_Length += 12;
		/*-----------------------------------------------*/
		if( atoi(gbl.amount) > 11000000 )	//若金额过大
		{
			wrLog("【转账】金额过大，错误！");
			return -1;
		}
		//打8583包
		iRet = packHdl(2);
		if(iRet < 0)
			return -1;
			/*---------test----------*
			strcpy((char *)pack.FIELD39,"00");
			wrLog("FIELD39: [%s]", (char *)pack.FIELD39);
		/*-----------------------*/
		if (!memcmp(pack.FIELD39,"00",2)) 
		{
			wrLog("【转账】转帐成功！");
			TS_OutPutMsg(gbl.dPosInfo, "\n      转帐成功！\n   按【确认】打印票据", 0, iSelect);
			//		if(iSelect)
			//			return 0;
			CPrint prt;
			prt.set_in_par(gbl);
			prt.print_ban_detail();	 //打印明细
			return 0;
		}
		else if(!memcmp(pack.FIELD39, "55", 2) || !memcmp(pack.FIELD62, "P20004855", 9))
		{
			wrLog("【转账】密码错误，重新输入");
			flag = 1;
			if(reGetPwd(title) == 0) //密码错误，重新输入密码, 2006-10-25
				continue;
			else
				return CANCLE_KEY;
		}
		else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
			if (iSelect!=0)
			{
				return -1;
			}else
				continue;
		}
		else
		{
			wrLog("【转账】转帐失败");
			iRet = banReturnFail((char *)pack.FIELD39);
			return -1;
		}
	}
	return -1;
}

int CTrade::banTransLocal(const char *title, PTSTradeInfoRecv pTradeInfoRecv)	//银行转帐本地化交易
{
	int  iRet=0 , dataIdx = 0;
	int  iSelect;
	char prc_amo[13];	//手续费
	
	wrLog("【转账】转账业务");
	
	/*-----------------------------------------------*/
	strcpy(gbl.fee_type,"0184");
	strcpy(gbl.pos_serial,(char *)pTradeInfoRecv->uTradeID);
	strcpy(gbl.amount, (char *)pTradeInfoRecv->Contents[0].uMsg);	//读入金额
	
	getCardNum((char *)(char *)pTradeInfoRecv->Contents[1].uMsg);	//取卡号
	
	if(TRADE_FLAG)
		gbl.key_num = 17;	//生产交行KEY
	else
		gbl.key_num = 3;	//测试交行KEY
	
	bbzero(gbl.pos_serial);	//终端流水
	strcpy(gbl.pos_serial, (char *)pTradeInfoRecv->uTradeID);
	bbzero(gbl.password);	//密码
	memcpy( gbl.password, (char *)pTradeInfoRecv->Contents[2].uMsg, pTradeInfoRecv->Contents[2].uMsgLen);	//密码
	if(DEBUG_LEVEL<2)
	{
		//平台测试整改(不记录密码信息)
		//wrLog("终端流水: [%s]", gbl.pos_serial);
		//wrHex("密码", (BYTE *)gbl.password, 8);
	}
	if(!gbl.posInfo.enyFlag)	//加密改造，旧加密体系
	{
		if( gbl.key_num % 2 )	//奇数key写随机数
		{
			bbzero(gbl.random_num);
			memcpy(gbl.random_num,(char *)pTradeInfoRecv->Contents[2].uKeyRand,8);
		}
	}
	/*-----------------------------------------------*/
	
	if( atoi(gbl.amount) > 10000000 )	//若金额过大
	{
		wrLog("【转账】金额过大，错误！");
		return -1;
	}
	else if( atoi(gbl.amount) < 1000000 )
	{
		memcpy(prc_amo,"000000000500",13);
	}
	else
	{
		memcpy(prc_amo,"000000001000",13);
	}
	pack.wrField(2, gbl);	//写交费域
	/*-----------------------------------------------*/
	bbzero(pack.FIELD3);
	CTools::hex_to_byte((BYTE *)"000000", pack.FIELD3, 6);
	memset(pack.FIELD48,0,sizeof(pack.FIELD48));
	memcpy(pack.FIELD48, gbl.fee_type, 4);
	pack.Packet_Table[48].Real_Length = 4;
	
	memcpy(pack.FIELD63+8, prc_amo, 12);
	pack.Packet_Table[63].Real_Length += 12;
	/*-----------------------------------------------*/
	
	//打8583包
	iRet = packHdl(2);
	if(iRet < 0){
		wrLog("【转账】转帐失败！中心超时");
		TS_OutPutMsg(gbl.dPosInfo, "\n网络超时，转帐失败！\n\n\n请稍候再试!\n 如果交易结果不明确请做 最后一笔交易查询\n   按【确认】退出", 0, iSelect);
		return -2;
	}
	if (!memcmp(pack.FIELD39,"00",2)) 
	{
		wrLog("【转账】转帐成功！");
		TS_OutPutMsg(gbl.dPosInfo, "\n      转帐成功！\n   按【确认】打印票据", 0, iSelect);
		CPrint prt;
		prt.set_in_par(gbl);
		prt.print_ban_detail();	 //打印明细
		return 0;
	}
	else if(!memcmp(pack.FIELD39, "55", 2) || !memcmp(pack.FIELD62, "P20004855", 9))
	{
		TS_OutPutMsg(gbl.dPosInfo, "\n密码错误，转帐失败！\n   按【确认】退出", 0, iSelect);
		wrLog("【转账】密码错误，转帐失败");
		return -3;
	}
	else
	{
		wrLog("【转账】转帐失败");
		iRet = banReturnFail((char *)pack.FIELD39);
		return -4;
	}
}


//车船税
int CTrade::taxTrade( char *type, int input_flag)
{
	int iSelect, iRet = 0;
	iRet=bankInfoQry();
	if (iRet!=0)
	{
		TS_OutPutMsg(gbl.dPosInfo,"对不起，您尚未绑定建行银行卡。如有疑问，请咨询在线客服或致电400-80-11888咨询",1,iSelect);
		return CANCLE_KEY;
	}
	//界面设置

	iSelect = taxInqHdl(type, input_flag);
	if( iSelect==0 )
	{
		iRet = taxPayHdl(type);
	}

	return iRet;
}

//银行信息查询
int CTrade::bankInfoQry()
{

	int iRet;
	iRet=getBankInfoService("INF02002","客户银行信息查询接口",gbl.pos_no,"");
	if (iRet!=0)
	{
		return -1;
	}

	return 0;

}

int CTrade::taxInqHdl( char *type, int input_flag)
{
	int  iRet;
	string err;
	int iSelect;
	char errMsg[200];
	wrLog("%s【查询】",type);

	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	bbzero(errMsg);

	if (input_flag==0)
	{
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
		
		strcpy(tradeInfoSend.acMainTitle, type);
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents = 1;
		
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入末5位车牌号：");	
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//全字符
		tradeInfoSend.Contents[0].uCount = 0;		//输入1次		
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME + 10;	//超时40秒
		tradeInfoSend.Contents[0].uMinLen = 5;		
		tradeInfoSend.Contents[0].uMaxLen = 5;
		
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	
	
		if(iRet != 0)
		{
			wrLog("TS_TradeControl返回错误[%d]", iRet);
			wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
			return iRet;
		}
		
		memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
		strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
		memset( gbl.car_no,0,sizeof(gbl.car_no) );
		strcpy(gbl.car_no, "01A");
		strcat( gbl.car_no,(char *)tradeInfoRecv.Contents[0].uMsg );
		for(int i = 3; i < 8; i++)	//小写转换成大写
		{
			if((gbl.car_no[i] >= 97) && (gbl.car_no[i] <= 122) )
				gbl.car_no[i] = gbl.car_no[i] - 32; 
		}
	}
	else
	{
		if (gbl.phone_len==5)
		{
			strcpy(gbl.car_no, "01A");
		}
		
		else
		{
			strcpy(gbl.car_no, "01");
		}
		strcat( gbl.car_no,gbl.phone_no );
		for(int i = 3; i < 8; i++)	//小写转换成大写
		{
			if((gbl.car_no[i] >= 97) && (gbl.car_no[i] <= 122) )
				gbl.car_no[i] = gbl.car_no[i] - 32; 
		}
	}

	wrLog("车牌号码：[%s]", gbl.car_no);
	iRet=carTax_query_service(gbl,"车船税账单查询","INF06006",&gbl.billNum,gbl.TRANSSEQ,err);
	if (iRet!=0)
	{
		strcpy(errMsg,err.c_str());
		TS_OutPutMsg(gbl.dPosInfo,errMsg,0,iSelect);
		return -1;
	}
	//返回数据给终端
	iRet = taxInqMsg(type);
	return iRet;
}

int CTrade::taxInqMsg( char *type)
{
	char temp_buff[512],mny[20],tmp[20];
	int iRet;
	TSTxnLogs txnLogs;
	long total_fee=0;

	bbzero(gbl.amount);

	memset(&txnLogs,0,sizeof(txnLogs));
	memset(mny,0,sizeof(mny));
	CTools::chgToMny(gbl.amount,mny);
	memset(temp_buff,0,sizeof(temp_buff));
	memset(tmp,0,sizeof(tmp));
	strcpy(tmp,"粤A");
	strncat(tmp, gbl.car_no+3, 5);
	//sprintf(temp_buff,"车牌号：%s\n车主名：%s\n车船类型：%s\n应缴税额：%s\n【确认】交费\n【返回】返回", tmp,gbl.user_name, type, mny);
	//TS_OutPutMsg(gbl.dPosInfo, temp_buff, 0,iSelect);
	txnLogs.colsnum = 4;
	txnLogs.colsWidth[0] = 50;
	txnLogs.colsWidth[1] = 100;
	txnLogs.colsWidth[2] = 100;
	txnLogs.colsWidth[3] = 100;
	txnLogs.colsNameLen = 60; 
	memcpy(txnLogs.colsName, "\x00缴纳年度\x00缴纳金额(元)\x00滞纳金(元)\x00罚款金额(元)",txnLogs.colsNameLen);
	sprintf(txnLogs.top, "车牌号:%s 车主姓名:%s",gbl.card_no,gbl.user_name);
	
	for(int i=0;i<gbl.carTaxBills.nCnt;i++)
	{
		//查询
		total_fee+=atoi(gbl.carTaxBills.cardTaxDatas[i].BILLMONTH);
		
		if( txnLogs.itemsLen+strlen(gbl.carTaxBills.cardTaxDatas[i].BILLMONTH) < MAX_INTERM_BUF ) //缴纳年度
		{
			strcpy(txnLogs.items+txnLogs.itemsLen, gbl.carTaxBills.cardTaxDatas[i].BILLMONTH);
			
			txnLogs.itemsLen = txnLogs.itemsLen + strlen(txnLogs.items+txnLogs.itemsLen) + 1;
			
		}
		
		else
		{
			break;
		}

		if( txnLogs.itemsLen+strlen(gbl.carTaxBills.cardTaxDatas[i].BILLMONTH) < MAX_INTERM_BUF ) //应征金额
		{
			strcpy(txnLogs.items+txnLogs.itemsLen, gbl.carTaxBills.cardTaxDatas[i].CONTRACTNO);
			
			txnLogs.itemsLen = txnLogs.itemsLen + strlen(txnLogs.items+txnLogs.itemsLen) + 1;
			
		}
		
		else
		{
			break;
		}

		if( txnLogs.itemsLen+strlen(gbl.carTaxBills.cardTaxDatas[i].BILLDELAY) < MAX_INTERM_BUF ) //滞纳金
		{
			strcpy(txnLogs.items+txnLogs.itemsLen, gbl.carTaxBills.cardTaxDatas[i].BILLDELAY);
			
			txnLogs.itemsLen = txnLogs.itemsLen + strlen(txnLogs.items+txnLogs.itemsLen) + 1;
			
		}
		
		else
		{
			break;
		}
		if( txnLogs.itemsLen+strlen(gbl.carTaxBills.cardTaxDatas[i].BALANCE) < MAX_INTERM_BUF ) //罚款金额
		{
			strcpy(txnLogs.items+txnLogs.itemsLen, gbl.carTaxBills.cardTaxDatas[i].BALANCE);
			
			txnLogs.itemsLen = txnLogs.itemsLen + strlen(txnLogs.items+txnLogs.itemsLen) + 1;
			
		}
		
		else
		{
			break;
		}



	}

	//充值金额转换为12位

	CTools::longToMny(total_fee,gbl.amount);
	sprintf(txnLogs.bottom,"合计:%.2f元\n【业务说明】本终端不能缴纳单年度车船税、需全部缴纳",total_fee/100);
	iRet=TS_ShowTxnLogs(gbl.dPosInfo,&txnLogs);
	if (iRet!=0)
	{
		wrLog("TS_ShowTxnLogs返回错误[%d]", iRet); 
		return -1;
	}
	
	return iRet ;
	
}


int CTrade::taxPayHdl(char *type)
{
	int  iRet, iSelect,flag;
	char errMsg[500];
	
	bbzero(errMsg);
	wrLog("车船税【交费】");
	
	flag = 0;
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{
		if(!flag)
		{
			if( gbl.get_card == MNG_ONE_BIND_E || gbl.get_card == MNG_MUL_BIND_E )
				iRet = mngCard_Hdl(type, "", 0, 1);//只能刷卡，多次刷卡模式
			else
				iRet = mngCard_Hdl(type);
			if(iRet == CANCLE_KEY)
				return CANCLE_KEY;
			else if(iRet != 0)
				return -1;
		}
	
		iRet=pay(type,errMsg);
		if (iRet!=0) //此处需要处理的是密码验证错误的时候返回是多少。通过返回进行处理
		{
			TS_OutPutMsg(gbl.dPosInfo,errMsg,0,iSelect);
			return CANCLE_KEY;
		}
	
			iRet = TS_OutPutMsg(gbl.dPosInfo,"     交费成功！\n    谢谢您的使用\n请按【确认】打印发票",0,iSelect);
			if(iRet!=0 || iSelect==0)
			{
				CPrint prt;
				prt.set_in_par(gbl);
				prt.print_carTax_detail("车船税");
			}
			return 0;
	}

	return 0;
}


//全省交罚
int CTrade::provinceTrafficTrade(const char *title)
{
	int iSelect, iRet = 0, iRetB = 0;
	char mark_card[30+1];
    strcpy(gbl.fee_type,"0320");//省交罚的业务代码：0320
	bbzero(mark_card);
	strncpy(mark_card, gbl.card_no, sizeof(mark_card)-1);
	iSelect = provinceTrafficInqHdl(title);
	if( iSelect==0 )
	{
		iRet = provinceTrafficPayHdl(title);
	}
	
	if( gbl.get_card == MNG_ONE_BIND_E || gbl.get_card == MNG_MUL_BIND_E )//还原原先刷的卡
	{
		iRetB = bindcard(mark_card, gbl.card_no, &gbl.card_no_len);
		if(iRetB != 0)
		{
			TS_OutPutMsg(gbl.dPosInfo,"绑定原卡号出错!请挂机重连!",0,iSelect);
			TS_HangUp(gbl.dPosInfo);
		}
	}
	return iRet;
}


int CTrade::provinceTrafficInqHdl(const char *title)
{
	int  iRet,iSelect,iSelect2;
	int  b48_len,b63_len;
	int flag_carno = 0, flag_engineno = 0;
	//	TSMENULIST menuList;
	char temp_buff[512],tmp[20], response_code[2+1];
	TSTxnLogs txnLogs;
	wrLog("%s【查询】",title);
	
	//全省交罚优化
	memset(gbl.paper_no,0,sizeof(gbl.paper_no));//文书号
	strcpy(gbl.paper_no,(char *) "00"); //保留文书号，设置文书号为00
	wrLog("gbl.paper_no:%s",gbl.paper_no);
	
	memset(&txnLogs,0, sizeof(txnLogs));
	iRet = CDB::getTrafficCode(&txnLogs);
	if(iRet)
	{
		TS_OutPutMsg(gbl.dPosInfo, "无法获取地区码，请稍候再试。", 0, iSelect); //界面上输出不成功信息
		return -1;
	}
	
	iRet = TS_ShowTxnLogs(gbl.dPosInfo, &txnLogs);
	if(iRet)
	{
		TS_OutPutMsg(gbl.dPosInfo, "网络繁忙，请稍候再试。", 0, iSelect);
		return -1;
	}
	
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));		
	strcpy(tradeInfoSend.acMainTitle, title);
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 2;//项目个数	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入违章地区代码：");	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
	tradeInfoSend.Contents[0].uCount = 0;		//输入1次		
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME + 10;	//超时40秒
	tradeInfoSend.Contents[0].uMinLen = 2;		
	tradeInfoSend.Contents[0].uMaxLen = 2;
	
	//输入违章地点
	strcpy(tradeInfoSend.Contents[1].acTitle,"请输入违章地点（请从罚单查询页面拷贝粘贴）");
	tradeInfoSend.Contents[1].uCount=0;
	tradeInfoSend.Contents[1].uCommand=TS_INPUT_ALL_CHAR; //违章地点的格式
	tradeInfoSend.Contents[1].uTimeOut=EPOS_OVER_TIME+10;//超时40秒
	tradeInfoSend.Contents[1].uMinLen = 1;		
	tradeInfoSend.Contents[1].uMaxLen = 80;
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv,150);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	
	
	memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
	strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);//交易流水号
	
	memset(gbl.traffic_area,0,sizeof(gbl.traffic_area) );
	wrLog("(char *)tradeInfoRecv.Contents[0].uMsg:%s",(char *)tradeInfoRecv.Contents[0].uMsg);
	strcpy(gbl.traffic_area,(char *)tradeInfoRecv.Contents[0].uMsg ); //违章地区
	wrLog("gbl.traffic_area:%s",gbl.traffic_area);
	
	
	memset(gbl.traffic_place,0,sizeof(gbl.traffic_place));
	strcpy(gbl.traffic_place,(char *)tradeInfoRecv.Contents[1].uMsg);//违章地点
	wrLog("gbl.traffic_place:%s",gbl.traffic_place); 
	trim(gbl.traffic_place, 80);
	
	/*
	if(atoi(gbl.traffic_area)>21||atoi(gbl.traffic_area)==6){
	TS_OutPutMsg(gbl.dPosInfo, "该地区暂不提供交罚代办服务!", 0,iSelect);
	return -1;
}*/
    
	
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));	
		strcpy(tradeInfoSend.acMainTitle, title);
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents = 1;
		
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入违章行为（请从罚单查询页面拷贝粘贴）");	
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//全字符
		tradeInfoSend.Contents[0].uCount = 0;		//输入1次		
		tradeInfoSend.Contents[0].uTimeOut = 60;	//超时60秒
		tradeInfoSend.Contents[0].uMinLen = 2;		
		tradeInfoSend.Contents[0].uMaxLen = 200;
		
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv,150);
		if(iRet != 0)
		{
			wrLog("TS_TradeControl返回错误[%d]", iRet);
			wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
			return iRet;
		}
		
		memset(gbl.traffic_code,0,sizeof(gbl.traffic_code) );
		strcpy(gbl.traffic_code,(char *)tradeInfoRecv.Contents[0].uMsg );
		wrLog("gbl.traffic_code:%s",gbl.traffic_code);
		
		
		int i=0;
		int length=strlen(gbl.traffic_code);
		for(i=0;i<length;i++){
			if(gbl.traffic_code[i]>=0 && gbl.traffic_code[i]<=127){
				continue;
			}
			else
				break;
		}
		
		memset(temp_buff,0,sizeof(temp_buff));
		memcpy(temp_buff,gbl.traffic_code+i,length-i);
		memset(gbl.traffic_code,0,sizeof(gbl.traffic_code));
		strcpy(gbl.traffic_code,temp_buff); //设置gbl.traffic_code;
		
		
		
		
		//写查询域
		pack.wrField(1, gbl);
		/************修改一些域*********/
		bbzero(pack.FIELD48);
		memcpy(pack.FIELD48,gbl.fee_type,4);	//4位信息码
		b48_len =4;
		memcpy(pack.FIELD48+b48_len, "06", 2);	//车牌号的长度:车牌号(6)
		b48_len +=2;
		memcpy(pack.FIELD48+b48_len, "AAAAAA", 6);
		b48_len +=6;
		memcpy(pack.FIELD48+b48_len, "0", 1);
		b48_len +=1;
		
		bbzero(pack.FIELD63);
		memcpy(pack.FIELD63,gbl.traffic_code,strlen(gbl.traffic_code));       //违章代码
		b63_len=strlen(gbl.traffic_code);
		memcpy(pack.FIELD63+b63_len,"|",1);       //分隔符
		b63_len+=1;
		
		memcpy(pack.FIELD63+b63_len,gbl.traffic_area,strlen(gbl.traffic_area));	//违章地点
		b63_len += strlen(gbl.traffic_area);
		memcpy(pack.FIELD63+b63_len,"|",1);       //分隔符
		b63_len+=1;
		
		
		pack.Packet_Table[48].Real_Length=b48_len;
		pack.Packet_Table[63].Real_Length=b63_len;
		/*******************************/
		//  查询包打包
		iRet = packHdl(1);
		if(iRet < 0)
			return -1;
		
		wrLog("查询返回bit63:[%s]",pack.FIELD63);
		//返回数据给终端	
		memset(response_code,0,sizeof(response_code));
		memcpy(response_code,pack.FIELD39,2);	
		if (!memcmp(response_code,"00",2)) 
		{   
			b63_len=0;
			memset(tmp,0,sizeof(tmp));
			memcpy(tmp,pack.FIELD63,12);
			memset(gbl.traffic_mny,0,sizeof(gbl.traffic_mny));
			CTools::chgToMny(tmp,gbl.traffic_mny);
			b63_len+=13;
			
			memset(tmp,0,sizeof(tmp));
			memcpy(tmp,pack.FIELD63+b63_len,12);
			memset(gbl.service_mny,0,sizeof(gbl.service_mny));
			CTools::chgToMny(tmp,gbl.service_mny);
			b63_len+=13;
			
			// 		memset(tmp,0,sizeof(tmp));
			//      memcpy(tmp,pack.FIELD63+b63_len,12);
			// 		memset(gbl.transfer_mny,0,sizeof(gbl.transfer_mny));
			// 		CTools::chgToMny(tmp,gbl.transfer_mny);
			b63_len+=13;
			
			memset(gbl.amount,0,sizeof(gbl.amount));
			memcpy(gbl.amount,pack.FIELD63+b63_len,12);
			memset(gbl.total_mny,0,sizeof(gbl.total_mny));
			CTools::chgToMny(gbl.amount,gbl.total_mny);
			break;
		}else if(!memcmp(pack.FIELD39,"80",2)&&!memcmp(&pack.FIELD62[1+6],"04",2))
		{   
			if(strcmp(gbl.city_no, "020")==0)
				TS_OutPutMsg(gbl.dPosInfo, "违章行为内容输入有误\n请认真确认是否与罚单查询网站上的内容一致\n罚单查询请使用【655】\n\n【确认】重新输入，【返回】返回主菜单", 0,iSelect);
			else
				TS_OutPutMsg(gbl.dPosInfo, "违章行为内容输入有误\n请认真确认是否与罚单查询网站上的内容一致\n罚单查询请使用【615】\n\n【确认】重新输入，【返回】返回主菜单", 0,iSelect);
			if(iSelect == 0) //密码错误，重新输入密码, 2006-10-25
				continue;
			else
				return CANCLE_KEY;
		}else
			
		{
			returnFail(response_code);
			return -1;
		}
		
    }
	
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));	
	strcpy(tradeInfoSend.acMainTitle, title);
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	
	//输入违章时间
	strcpy(tradeInfoSend.Contents[0].acTitle,"请输入违章时间（从罚单查询页面上拷贝粘贴）");
	tradeInfoSend.Contents[0].uCount=0;
	tradeInfoSend.Contents[0].uMinLen = 21;		
	tradeInfoSend.Contents[0].uMaxLen = 200;
	tradeInfoSend.Contents[0].uTimeOut=EPOS_OVER_TIME;
	tradeInfoSend.Contents[0].uCommand=TS_INPUT_ALL_CHAR;
	
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	
	
	memset(gbl.traffic_date,0,sizeof(gbl.traffic_date));
	strcpy(gbl.traffic_date,(char *) tradeInfoRecv.Contents[0].uMsg);
	wrLog("gbl.traffic_date:%s",gbl.traffic_date);
	CTools::trim(gbl.traffic_date);
	
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));		
	strcpy(tradeInfoSend.acMainTitle, title);
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;		
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入车牌号：粤");	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//全字符
	tradeInfoSend.Contents[0].uCount = 0;		//输入1次		
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME + 10;	//超时40秒
	tradeInfoSend.Contents[0].uMinLen = 6;
	if(atoi(gbl.car_type)==4)
		tradeInfoSend.Contents[0].uMaxLen = 7;
	else
		tradeInfoSend.Contents[0].uMaxLen = 6;

	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv,90);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	
	memset(gbl.car_no,0,sizeof(gbl.car_no) );
	strcpy(gbl.car_no,(char *)tradeInfoRecv.Contents[0].uMsg );
	CTools::lowerToUpper(gbl.car_no);


	/*---------控制用户输入的字符不为字母和数字以外的字符-------*/
	while (1)
	{
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));		
		strcpy(tradeInfoSend.acMainTitle, title);
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents = 1;	
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入车架号(或车辆识别代号)后6位：");	
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//全字符
		tradeInfoSend.Contents[0].uCount = 0;		//输入1次		
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME + 10;	//超时40秒
		tradeInfoSend.Contents[0].uMinLen = 6;//改为输入编号后6位		
		tradeInfoSend.Contents[0].uMaxLen = 6;//改为输入编号后6位

		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv,90);
		if(iRet != 0)
		{
			wrLog("TS_TradeControl返回错误[%d]", iRet);
			wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
			return iRet;
		}
		
		memset(gbl.car_id,0,sizeof(gbl.car_id) );
		strcpy(gbl.car_id,(char *)tradeInfoRecv.Contents[0].uMsg );

		flag_carno = CTools::isAllNumLetter(gbl.car_id);
		if (flag_carno == 1)
		{
			TS_OutPutMsg(gbl.dPosInfo, "您输入的车架号含有字母和数字以外的字符，请重新输入车架号!", 0,iSelect);
			continue;
		}
		else if (flag_carno == 0)
		{
			break;
		}
	}

	while (1)
	{
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));		
		strcpy(tradeInfoSend.acMainTitle, title);
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents = 1;	
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入发动机号后6位：");	
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//全字符
		tradeInfoSend.Contents[0].uCount = 0;		//输入1次		
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME + 10;	//超时40秒
		tradeInfoSend.Contents[0].uMinLen = 6;//改为输入编号后6位		
		tradeInfoSend.Contents[0].uMaxLen = 6;//改为输入编号后6位
		
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv,90);
		if(iRet != 0)
		{
			wrLog("TS_TradeControl返回错误[%d]", iRet);
			wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
			return iRet;
		}

		memset(gbl.engine_no,0,sizeof(gbl.engine_no) );
		strcpy(gbl.engine_no,(char *)tradeInfoRecv.Contents[0].uMsg );

		flag_engineno = CTools::isAllNumLetter(gbl.engine_no);
		if (flag_engineno == 1)
		{
			TS_OutPutMsg(gbl.dPosInfo, "您输入的发动机号含有字母和数字以外的字符，请重新输入发动机号!", 0,iSelect);
			continue;
		}
		else if (flag_engineno == 0)
		{
			break;
		}
	}
	/*---------控制用户输入的字符不为字母和数字以外的字符-------*/

	memset(gbl.traffic_area_name,0,sizeof(gbl.traffic_area_name));	
	iRet = CDB::getAreaName(atoi(gbl.traffic_area), gbl.traffic_area_name);
	if(iRet)
	{
		TS_OutPutMsg(gbl.dPosInfo, "未找到对应的违章地区", 0, iSelect);
		wrLog("【查找地区出错】");
		return -1;
	} 
	/*
	switch(atoi(gbl.traffic_area)){
	case 0:
	strcpy(gbl.traffic_area_name,"广州");
	break;
		  case 1:
		  strcpy(gbl.traffic_area_name,"深圳");
		  break;
		  case 2:
		  strcpy(gbl.traffic_area_name,"东莞");
		  break;
		  case 3:
		  strcpy(gbl.traffic_area_name,"惠州");
		  break;
		  case 4:
		  strcpy(gbl.traffic_area_name,"河源");
		  break;
		  case 5:
		  strcpy(gbl.traffic_area_name,"肇庆");
		  break;
		  case 6:
		  strcpy(gbl.traffic_area_name,"汕尾");
		  break;
		  case 7:
		  strcpy(gbl.traffic_area_name,"珠海");
		  break;
		  case 8:
		  strcpy(gbl.traffic_area_name,"南海");
		  break;
		  case 9:
		  strcpy(gbl.traffic_area_name,"潮州");
		  break;
		  case 10:
		  strcpy(gbl.traffic_area_name,"湛江");
		  break;
		  case 11:
		  strcpy(gbl.traffic_area_name,"顺德");
		  break;
		  case 12:
		  strcpy(gbl.traffic_area_name,"揭阳");
		  break;
		  case 13:
		  strcpy(gbl.traffic_area_name,"梅州");
		  break;
		  case 14:
		  strcpy(gbl.traffic_area_name,"中山");
		  break;
		  case 15:
		  strcpy(gbl.traffic_area_name,"韶关");
		  break;
		  case 16:
		  strcpy(gbl.traffic_area_name,"茂名");
		  break;
		  case 17:
		  strcpy(gbl.traffic_area_name,"江门");
		  break;
		  case 18:
		  strcpy(gbl.traffic_area_name,"清远");
		  break;
		  case 19:
		  strcpy(gbl.traffic_area_name,"云浮");
		  break;
		  case 20:
		  strcpy(gbl.traffic_area_name,"佛山");
		  break;
		  case 21:
		  strcpy(gbl.traffic_area_name,"阳江");
		  break;
		  case 22:
		  strcpy(gbl.traffic_area_name,"汕头");
		  break;
          default:
		  strcpy(gbl.traffic_area_name,"未知地区");
		  break;
		  }
	*/
	wrLog("违章地区：[%s]，车牌号：[%s]，车架号：[%s]，发动机号：[%s]，违章代码：[%s]，文书号：[%s]", gbl.traffic_area,gbl.car_no,gbl.car_id,gbl.engine_no,gbl.traffic_code,gbl.paper_no);
	
	TS_OutPutMsg(gbl.dPosInfo, "【温馨提示】目前暂不提供该地区回执邮递服务", 0, iSelect);
	/*暂时取消选择，都按无需投递处理
	memset(&menuList,0,sizeof(menuList));
	menuList.iTotalNum = 2;
	strcpy(menuList.acTitle, "是否投递回执(投递费15元)");
	strcpy(menuList.menuItem[0], "需要投递");
	strcpy(menuList.menuItem[1], "无需投递");
	iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
	*/
	iSelect = 2;
	if(iSelect==1){
		bbzero(gbl.transfer_flag);
		strcpy(gbl.transfer_flag,"1");
        
		//修改投递费及总金额
		memset(gbl.transfer_mny,0,sizeof(gbl.transfer_mny));
		CTools::chgToMny("000000001500",gbl.transfer_mny);
		int total=atoi(gbl.amount)+1500;
		sprintf(gbl.amount,"%012d",total);
		memset(gbl.total_mny,0,sizeof(gbl.total_mny));
		CTools::chgToMny(gbl.amount,gbl.total_mny);
		
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));		
		strcpy(tradeInfoSend.acMainTitle, title);
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents = 1;		
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入投递地址：");	
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//全字符
		tradeInfoSend.Contents[0].uCount = 0;		//输入1次		
		tradeInfoSend.Contents[0].uTimeOut = 60;	//超时40秒
		tradeInfoSend.Contents[0].uMinLen = 2;		
		tradeInfoSend.Contents[0].uMaxLen = 60;
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv,255);
		if(iRet != 0)
		{
			wrLog("TS_TradeControl返回错误[%d]", iRet);
			wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
			return iRet;
		}		
		memset(gbl.address,0,sizeof(gbl.address) );
		strcpy(gbl.address,(char *)tradeInfoRecv.Contents[0].uMsg );
		
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));		
		strcpy(tradeInfoSend.acMainTitle, title);
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents = 1;		
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入收件人姓名：");	
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//全字符
		tradeInfoSend.Contents[0].uCount = 0;		//输入1次		
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME + 30;	//超时40秒
		tradeInfoSend.Contents[0].uMinLen = 2;		
		tradeInfoSend.Contents[0].uMaxLen = 25;
		
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv,120);
		if(iRet != 0)
		{
			wrLog("TS_TradeControl返回错误[%d]", iRet);
			wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
			return iRet;
		}
		memset(gbl.user_name,0,sizeof(gbl.user_name) );
		strcpy(gbl.user_name,(char *)tradeInfoRecv.Contents[0].uMsg );
		
		
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));		
		strcpy(tradeInfoSend.acMainTitle, title);
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents = 1;		
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入手机号码：");	
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
		tradeInfoSend.Contents[0].uCount = 1;		//输入2次		
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME + 10;	//超时40秒
		tradeInfoSend.Contents[0].uMinLen = 11;		
		tradeInfoSend.Contents[0].uMaxLen = 11;		
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv,120);
		if(iRet != 0)
		{
			wrLog("TS_TradeControl返回错误[%d]", iRet);
			wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
			return iRet;
		}		
		memset(gbl.telphone,0,sizeof(gbl.telphone) );
		strcpy(gbl.telphone,(char *)tradeInfoRecv.Contents[0].uMsg );
		
		memset(temp_buff,0,sizeof(temp_buff));
		sprintf(temp_buff,"违章地区：%s\n 违章地点：%s\n车牌号：粤%s\n违章行为：%s\n 违章时间：%s\n 车架号后6位：%s\n发动机号后6位：%s\n收件人：%s\n手机号：%s\n地址：%s\n【确认】继续 【返回】取消", gbl.traffic_area_name,gbl.traffic_place,gbl.car_no,gbl.traffic_code,gbl.traffic_date,gbl.car_id,gbl.engine_no,gbl.user_name,gbl.telphone,gbl.address);
		iRet =TS_OutPutMsg(gbl.dPosInfo, temp_buff, 0,iSelect2);
		if(iRet!=0||iSelect2!=0){
			return -1;
		}
	}
	
	else if(iSelect==2){
		bbzero(gbl.transfer_flag);
        strcpy(gbl.transfer_flag,"0");
		
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));		
		strcpy(tradeInfoSend.acMainTitle, title);
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents = 1;		
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入联系人姓名：");	
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//全字符
		tradeInfoSend.Contents[0].uCount = 0;		//输入1次		
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME + 30;	//超时40秒
		tradeInfoSend.Contents[0].uMinLen = 2;		
		tradeInfoSend.Contents[0].uMaxLen = 25;
		
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv,120);
		if(iRet != 0)
		{
			wrLog("TS_TradeControl返回错误[%d]", iRet);
			wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
			return iRet;
		}
		memset(gbl.user_name,0,sizeof(gbl.user_name) );
		strcpy(gbl.user_name,(char *)tradeInfoRecv.Contents[0].uMsg );
		
		
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));		
		strcpy(tradeInfoSend.acMainTitle, title);
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents = 1;		
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入手机号码：");	
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
		tradeInfoSend.Contents[0].uCount = 1;		//输入2次		
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME + 10;	//超时40秒
		tradeInfoSend.Contents[0].uMinLen = 11;		
		tradeInfoSend.Contents[0].uMaxLen = 11;		
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv,120);
		if(iRet != 0)
		{
			wrLog("TS_TradeControl返回错误[%d]", iRet);
			wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
			return iRet;
		}		
		memset(gbl.telphone,0,sizeof(gbl.telphone) );
		strcpy(gbl.telphone,(char *)tradeInfoRecv.Contents[0].uMsg );
		
		memset(temp_buff,0,sizeof(temp_buff));
		sprintf(temp_buff,"违章地区：%s\n违章地点：%s\n车牌号：粤%s\n违章行为：%s\n违章时间：%s\n车架号后6位：%s\n发动机号后6位：%s\n联系人：%s\n手机号：%s\n【确认】继续 【返回】取消",gbl.traffic_area_name,gbl.traffic_place,gbl.car_no,gbl.traffic_code,gbl.traffic_date,gbl.car_id,gbl.engine_no,gbl.user_name,gbl.telphone);
		iRet =TS_OutPutMsg(gbl.dPosInfo, temp_buff, 0,iSelect2);
		if(iRet!=0||iSelect2!=0){
			return -1;
		}
	}else
		
        return -1;
	
	memset(temp_buff,0,sizeof(temp_buff));
	if(atoi(gbl.transfer_flag)==1){
		sprintf(temp_buff,"罚款：%s\n投递费：%s\n代办费：%s\n合计：%s\n【确认】交费 【返回】取消", gbl.traffic_mny,gbl.transfer_mny,gbl.service_mny,gbl.total_mny);
	}else{
		sprintf(temp_buff,"罚款：%s\n代办费：%s\n合计：%s\n【确认】交费 【返回】取消", gbl.traffic_mny,gbl.service_mny,gbl.total_mny);
	}
	TS_OutPutMsg(gbl.dPosInfo, temp_buff, 0,iSelect);	
	return iSelect;
	
}


int CTrade::provinceTrafficPayHdl(const char *title)
{
	int  iRet, iSelect,flag;
	int  b48_len,b63_len;
	char response_code[3];
	
	wrLog("全省交罚【交费】");
	
	flag = 0;
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{
		if(!flag)
		{
			iRet = mngCard_Hdl(title);
			if(iRet == CANCLE_KEY)
				return CANCLE_KEY;
			else if(iRet != 0)
				return -1;
		}
		
		pack.wrField(2, gbl);	//写交费域
		/***************修改一些域****************/
		bbzero(pack.FIELD48);
		memcpy(pack.FIELD48,gbl.fee_type,4);
		b48_len = 4;
		memcpy(pack.FIELD48 + b48_len, "06", 2);	//长度：6
		b48_len += 2;
		memcpy(pack.FIELD48 + b48_len,gbl.car_no, 6);
		b48_len += 6;
		memcpy(pack.FIELD48 + b48_len,gbl.transfer_flag, 1); 
		b48_len += 1;
		
        b63_len=8;
		memcpy(pack.FIELD63+b63_len,gbl.car_type,strlen(gbl.car_type));       //车类型
		b63_len+=strlen(gbl.car_type);
		memcpy(pack.FIELD63+b63_len,"|",1);       //分隔符
		b63_len+=1;
		//memcpy(pack.FIELD63+b63_len,gbl.car_id, 4);	//车辆识别码
		//b63_len += 4;
		memcpy(pack.FIELD63+b63_len,gbl.car_id, 6);//改为6位
		b63_len += 6;

		memcpy(pack.FIELD63+b63_len,"|",1);       //分隔符
		b63_len+=1;
		
		memcpy(pack.FIELD63+b63_len,gbl.engine_no, 6);	//发动机号(修改为六位)
		b63_len += 6;
		memcpy(pack.FIELD63+b63_len,"|",1);       //分隔符
		b63_len+=1;
		
		memcpy(pack.FIELD63+b63_len,gbl.traffic_code, strlen(gbl.traffic_code));	//违章代码
		b63_len += strlen(gbl.traffic_code);
		memcpy(pack.FIELD63+b63_len,"|",1);       //分隔符
		b63_len+=1;
		
		memcpy(pack.FIELD63+b63_len,gbl.traffic_area, strlen(gbl.traffic_area));	//违章地区
		b63_len += strlen(gbl.traffic_area);
		memcpy(pack.FIELD63+b63_len,"|",1);       //分隔符
		b63_len+=1;
		
		memcpy(pack.FIELD63+b63_len,gbl.telphone, strlen(gbl.telphone));	//电话
		b63_len += strlen(gbl.telphone);
		memcpy(pack.FIELD63+b63_len,"|",1);       //分隔符
		b63_len+=1;
		
		memcpy(pack.FIELD63+b63_len,gbl.paper_no, strlen(gbl.paper_no));	//公文号
		b63_len += strlen(gbl.paper_no);
		memcpy(pack.FIELD63+b63_len,"|",1);       //分隔符
		b63_len+=1;
        
		memcpy(pack.FIELD63+b63_len,gbl.user_name, strlen(gbl.user_name));	//用户名
		b63_len += strlen(gbl.user_name);
		memcpy(pack.FIELD63+b63_len,"|",1);       //分隔符
		b63_len+=1;
        
		if(atoi(gbl.transfer_flag)==1){
			memcpy(pack.FIELD63+b63_len,gbl.address, strlen(gbl.address));	//投递地址
			b63_len += strlen(gbl.address);
		}
		memcpy(pack.FIELD63+b63_len,"|",1);       //分隔符
		b63_len+=1;
		
		memcpy(pack.FIELD63+b63_len,gbl.traffic_date, strlen(gbl.traffic_date));	//违章时间
		b63_len += strlen(gbl.traffic_date);
		memcpy(pack.FIELD63+b63_len,"|",1);       //分隔符
		b63_len+=1;
		
		memcpy(pack.FIELD63+b63_len,gbl.traffic_place,strlen(gbl.traffic_place)); //违章地址
		b63_len+=strlen(gbl.traffic_place);
		memcpy(pack.FIELD63+b63_len,"|",1);
		b63_len+=1;
		
		pack.Packet_Table[48].Real_Length=b48_len;
		pack.Packet_Table[63].Real_Length=b63_len;
		/*****************************************/
		
		iRet = packHdl(2);
		if(iRet < 0)
			return -1;
		
		memset(response_code,0,sizeof(response_code));
		memcpy(response_code,pack.FIELD39,2);
		if (!memcmp(response_code,"00",2)) 
		{
			iRet = TS_OutPutMsg(gbl.dPosInfo,"     交费成功！\n    谢谢您的使用\n请按【确认】打印发票",0,iSelect);
			if(iRet!=0 || iSelect==0)
			{
				CPrint prt;
				prt.set_in_par(gbl);
				//prt.print_detail(17, "全省交罚代缴");	//打印欠费明细
				prt.print_province_traffic_detail(pack,"全省交罚代缴");
			}
			return 0;
		}
		else if(!memcmp(pack.FIELD39,"55",2))
		{
			flag = 1;
			if(reGetPwd(title) == 0) //密码错误，重新输入密码, 2006-10-25
				continue;
			else
				return CANCLE_KEY;
		}
		else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
			if (iSelect!=0)
			{
				return -1;
			}else
				continue;
		}
		
		else
			returnFail(response_code);
		
		return 1;
	}
	
	return -1;
}


//type：标题
int CTrade::telTrade(const char *type, int inputTel)		//电信交易
{
	int iSelect,iRet=0,first3mon=1;
	
	if(strcmp(gbl.city_no, "020")!=0 && strcmp(gbl.fee_type,"0047")&&strcmp(gbl.city_no, "0769")!=0)//非广州、东莞用户并且不是用综合收费进来
	{
		TS_OutPutMsg(gbl.dPosInfo,"本业务未开通\n\n请使用【电信直充】",1,iSelect);
		return -1;
	}
	
	for(int i=0; first3mon && i<10; i++)
	{
		iSelect = telInqHdl(type, inputTel, first3mon);

		if(iSelect==0)
		{
			//如果不是电信综合收费
			if(strcmp(gbl.fee_type,"0047"))
				iRet = telPayHdl(type, 0, first3mon);

			else
				iRet = telPayHdls(type, first3mon);
		}else
		{
			break;
		}
		inputTel = 1;
	}
	return iRet;
}

//first3mon:0-非三个月以上欠费的前3个月的交费 1-三个月以上欠费的前3个月的交费
int CTrade::telInqHdl(const char *type, int inputTel, int &first3mon)	//电信查询
{
	int  iRet,iSelect;
	int  b48_len;
	char len_buff[10];
	
	wrLog("%s【查询】", type);
	
	if(inputTel==0){//如果需要输入电话号码等查询信息
		
		if (atoi(gbl.fee_type)==241)
		{
			if(atoi(gbl.dPosInfo.prmVer)>=9000)
			{
				;
			}
			else
				TS_OutPutMsg(gbl.dPosInfo,"    CDMA主副卡请分开交费，合单收费正在开发中，如有不便，敬请见谅!\n  请按【确认】继续",0,iSelect);
			
			
		}
		
		TSTradeInfoSend tradeInfoSend;
		TSTradeInfoRecv tradeInfoRecv;
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
		
		strcpy(tradeInfoSend.acMainTitle, type);
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents = 1;
		
		switch( atoi(gbl.fee_type) )
		{
		case 46://电信预缴费
			strcpy(tradeInfoSend.Contents[0].acTitle, "请输入预缴费卡号(蓝色小卡)后9位：");	
			tradeInfoSend.Contents[0].uMinLen = 9;		
			tradeInfoSend.Contents[0].uMaxLen = 9;
			break;
		case 13://ADSL网费
        case 97://ADSL网费预存
			strcpy(tradeInfoSend.Contents[0].acTitle, "请输入电话或ADSL号码");	
			tradeInfoSend.Contents[0].uMinLen = 5;
			tradeInfoSend.Contents[0].uMaxLen = 8;
			break;
		case 137:  //ITV费用	add by lihk, 20070109
		case 138:  //ITV预付金
			strcpy(tradeInfoSend.Contents[0].acTitle, "请输入ITV接入号：");	
			tradeInfoSend.Contents[0].uMinLen = 11;		
			tradeInfoSend.Contents[0].uMaxLen = 11;
			break;
		case 143:
			strcpy(tradeInfoSend.Contents[0].acTitle, "请输入帐号中的11位数字信息：");	
			tradeInfoSend.Contents[0].uMinLen = 11;		
			tradeInfoSend.Contents[0].uMaxLen = 11;
			break;
		case 241:
		case 242: //20130105
			strcpy(tradeInfoSend.Contents[0].acTitle, "请输入11位CDMA号码：");	
			tradeInfoSend.Contents[0].uMinLen = 11;		
			tradeInfoSend.Contents[0].uMaxLen = 11;
			break;
		case 131://东莞电信后付费
			strcpy(tradeInfoSend.Contents[0].acTitle, "请输入电话号码：");	
			tradeInfoSend.Contents[0].uMinLen = 8;		
			tradeInfoSend.Contents[0].uMaxLen = 11;
			break;
		default:
			strcpy(tradeInfoSend.Contents[0].acTitle, "请输入电话号码：");	
			tradeInfoSend.Contents[0].uMinLen = 8;		
			tradeInfoSend.Contents[0].uMaxLen = 8;
			break;
		}
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
		tradeInfoSend.Contents[0].uCount = 0;		//输入1次		
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
		
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		
		if(iRet != 0)
		{
			wrLog("TS_TradeControl返回错误[%d]", iRet);
			wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
			return iRet;
		}
		memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
		strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
		gbl.phone_len = tradeInfoRecv.Contents[0].uMsgLen;
		memset( gbl.phone_no,0,sizeof(gbl.phone_no) );
		strcpy( gbl.phone_no,(char *)tradeInfoRecv.Contents[0].uMsg );
	}
	wrLog("电话号码：[%s]", gbl.phone_no);
	
	//写查询域
	pack.wrField(1, gbl);
	/***********修改一些域信息*********/
	switch( atoi(gbl.fee_type) )
	{
	case 71: 	//宽带预缴费
		bbzero(pack.FIELD48);
		memcpy(pack.FIELD48,gbl.fee_type,4);	//4位信息码
		b48_len = 4;
		memset(len_buff,0,sizeof(len_buff));
		sprintf(len_buff,"%02d",gbl.phone_len+2);	//电话号码+子业务代码长度（2位）
		memcpy(pack.FIELD48+b48_len,len_buff,2);	
		b48_len +=2;
		memcpy(pack.FIELD48+b48_len,gbl.phone_no,gbl.phone_len);	//电话号码
		b48_len +=gbl.phone_len;
		memcpy(pack.FIELD48+b48_len,gbl.sub_code,2);	//子业务代码
		b48_len += 2;
		pack.Packet_Table[48].Real_Length=b48_len;
		break;
		
	case 143:  //自由互联业务
	case 241:  //CDMA后付费
	case 242:  //CDMA预付费
		bbzero(pack.FIELD48);
		memcpy(pack.FIELD48,gbl.fee_type,4);	//4位信息码
		b48_len = 4;
		memset(len_buff,0,sizeof(len_buff));
		sprintf(len_buff,"%02d",gbl.phone_len);	//帐号长度
		memcpy(pack.FIELD48+b48_len,len_buff,2);	
		b48_len +=2;
		memcpy(pack.FIELD48+b48_len, gbl.phone_no, gbl.phone_len);	//电话号码
		b48_len += gbl.phone_len;
		pack.Packet_Table[48].Real_Length=b48_len;
		break;
	default:
		break;
	}
	/**********************************/
	
	//查询包打包   
	iRet = packHdl(1);
	if(iRet < 0)
		return -1;
	
	//返回数据给终端
	iRet = telInqMsg(type, first3mon);
	return iRet;
}


//下发电信查询信息
//first3mon:0-非三个月以上欠费的前3个月的交费 1-三个月以上欠费的前3个月的交费
int CTrade::telInqMsg(const char *type, int &first3mon)	
{
	wrLog("phone no1:[%s]",gbl.phone_no);
	char response_code[3],user_name_tmp[60+1];
	int b63_offset;
	char temp_buff[512],len_buff[10],mny[20];
	int i,iSelect,pMonNum=0,tMonNum=0;//pMonNum缴费月份数,tMonNum总欠费月份数
	double totalAmount = 0.0;//综合收费总金额，by kf
	char sBizNum [2+1];//综合收费业务数量
	char sNum [2+1];//综合收费业务名称长度
	
	memset(gbl.amount,0,sizeof(gbl.amount));
	memset(gbl.total_fee_type,0,sizeof(gbl.total_fee_type));//综合收费业务组
	memset(gbl.total_amount,0,sizeof(gbl.total_amount));//综合收费业务欠费组
	memset(response_code,0,sizeof(response_code));
	memset(temp_buff,0,sizeof(temp_buff));
	memset(len_buff,0,sizeof(len_buff));
	memset(mny,0,sizeof(mny));
	
	memcpy(response_code,pack.FIELD39,2);
	wrLog("业务代码:[%s]",gbl.fee_type);
	first3mon = 0;//非三个月以上欠费的前3个月的交费
	if (!memcmp(response_code,"00",2))
	{
		wrLog("phone no2:[%s]",gbl.phone_no);
		switch(atoi(gbl.fee_type))
		{
		case 131://东莞电信后付费缴费
			bbzero(gbl.stan_no);
			memcpy(gbl.stan_no, (char *)pack.FIELD37, 12);
			bbzero(len_buff);
            memcpy(len_buff,pack.FIELD63,2);
            b63_offset=2+atoi(len_buff);
			memcpy(gbl.amount, pack.FIELD63 + b63_offset, 12);
			bbzero(mny);
			CTools::chgToMny(gbl.amount, mny);
			b63_offset += 12;
			bbzero(len_buff);
            memcpy(len_buff, pack.FIELD63+b63_offset, 2);
            b63_offset += 2;
            memcpy(gbl.user_name,pack.FIELD63+b63_offset,atoi(len_buff));
			bbzero(temp_buff);
			sprintf(temp_buff, "用户名：%s\n电话号码：%s\n欠费总额：%s\n【确认】刷卡缴费\n【挂断】退出", gbl.user_name, gbl.phone_no, mny);
			TS_OutPutMsg(gbl.dPosInfo, temp_buff, 0, iSelect);
			break;
		case 64:	//小灵通预付费
		case 98:	//固话预付费
		case 140:   //预付费ADSL充值
		case 143:   //自由互联
			memcpy(gbl.user_name,pack.FIELD63,30);
			gbl.user_name_len = trim(gbl.user_name, 30);
			bbzero(user_name_tmp);
			strcpy(user_name_tmp,gbl.user_name);
			if(gbl.group_type != 0 && strlen(gbl.user_name)>2 ){//如果不是商户版，用户名最后一位要变为*
				user_name_tmp[gbl.user_name_len-2]='*';
				user_name_tmp[gbl.user_name_len-1]='\0';				
			}
			b63_offset = 30;
			char c;
			c = pack.FIELD63[b63_offset];
			b63_offset += 1;
			memcpy( gbl.amount, pack.FIELD63 + b63_offset, 12);	
			CTools::chgToMny(gbl.amount,mny);
			if(c == 'C')
			{
				if( atoi(gbl.fee_type)==140)
				{
					if( atoi(gbl.amount)==0 )
						sprintf(temp_buff,"用户名：%s\n电话号码：%s\n【确认】充值\n【返回】返回",user_name_tmp, gbl.phone_no, mny);
					else
						sprintf(temp_buff,"用户名：%s\n预付费余额：%s\n【确认】充值\n【返回】返回",user_name_tmp,mny);
				}
				else if( atoi(gbl.fee_type)==143)
				{
					if( atoi(gbl.amount)==0 )
						sprintf(temp_buff,"用户名：%s\n帐  号：%s\n【确认】充值\n【返回】返回",user_name_tmp, gbl.phone_no, mny);
					else
						sprintf(temp_buff,"用户名：%s\n预付费余额：%s\n【确认】充值\n【返回】返回",user_name_tmp,mny);
				}
				else
					sprintf(temp_buff,"用户名：%s\n预付费余额：%s\n【确认】充值\n【返回】返回",user_name_tmp,mny);
			}
			else
				sprintf(temp_buff,"用户名：%s\n欠费：%s\n【确认】充值\n【返回】返回",user_name_tmp,mny);
			TS_OutPutMsg(gbl.dPosInfo, temp_buff, 0,iSelect);
			//	iSelect = safeOutPutMsg(sd, temp_buff, 3);
			break;
			
		case 71:	//宽带预缴费
			memcpy(gbl.user_name,pack.FIELD63,30);
			gbl.user_name_len = trim(gbl.user_name, 30);
			bbzero(user_name_tmp);
			strcpy(user_name_tmp,gbl.user_name);
			if(gbl.group_type != 0 && strlen(gbl.user_name)>2 ){//如果不是商户版，用户名最后一位要变为*
				user_name_tmp[gbl.user_name_len-2]='*';
				user_name_tmp[gbl.user_name_len-1]='\0';				
			}
			b63_offset = 60;
			memcpy( gbl.amount, pack.FIELD63 + b63_offset, 12);	
			CTools::chgToMny(gbl.amount,mny);
			sprintf(temp_buff,"用户名：%s\n电话号码：%s\n【确认】交费\n【返回】返回",user_name_tmp,gbl.phone_no);
			TS_OutPutMsg(gbl.dPosInfo, temp_buff, 0,iSelect);			
			break;
			
		case 46:	//电信预缴费……需添加明细供打印
			memcpy(gbl.user_name,pack.FIELD63,30);
			gbl.user_name_len = trim(gbl.user_name, 30);
			bbzero(user_name_tmp);
			strcpy(user_name_tmp,gbl.user_name);
			if(gbl.group_type != 0 && strlen(gbl.user_name)>2 ){//如果不是商户版，用户名最后一位要变为*
				user_name_tmp[gbl.user_name_len-2]='*';
				user_name_tmp[gbl.user_name_len-1]='\0';				
			}
			bbzero(gbl.amount);
			CTools::byte_to_hex(pack.FIELD4, (BYTE *)gbl.amount, 6);
			CTools::chgToMny(gbl.amount,mny);
			if(!memcmp(gbl.sub_code,"46",2))
				sprintf(temp_buff,"用户名：%s\n余额：%s\n【确认】交费\n【返回】返回",user_name_tmp, mny);
			else
				sprintf(temp_buff,"用户名：%s\n编号：%s\n余额：%s\n【确认】交费\n【返回】返回",user_name_tmp,gbl.phone_no, mny);
			TS_OutPutMsg(gbl.dPosInfo, temp_buff, 0,iSelect);
			//	iSelect = safeOutPutMsg( temp_buff, 3);
			break;
			
		case 96:	//长市话费预付金
		case 97:	//ADSL话费预付金
		case 138:	//ITV预付金 add by lihk, 20070109
		case 242:   //CDMA预付金
			memcpy(gbl.user_name,pack.FIELD63,30);
			gbl.user_name_len = trim(gbl.user_name, 30);
			bbzero(user_name_tmp);
			strcpy(user_name_tmp,gbl.user_name);
			if(gbl.group_type != 0 && strlen(gbl.user_name)>2 ){//如果不是商户版，用户名最后一位要变为*
				user_name_tmp[gbl.user_name_len-2]='*';
				user_name_tmp[gbl.user_name_len-1]='\0';				
			}
			b63_offset = 60;
			memcpy( gbl.amount, pack.FIELD63 + b63_offset, 12);	
			CTools::chgToMny(gbl.amount,mny);
			sprintf(temp_buff,"%s\n电话号码：%s\n用户名：%s\n预存余额：%s\n【确认】预存\n【返回】返回",type,gbl.phone_no,user_name_tmp,mny);
			TS_OutPutMsg(gbl.dPosInfo, temp_buff, 0,iSelect);
			break;
		case 47:	//电信综合收费
			memcpy(gbl.user_name,pack.FIELD63,30);
			gbl.user_name_len = trim(gbl.user_name, 30);
			bbzero(user_name_tmp);
			strcpy(user_name_tmp,gbl.user_name);
			if(gbl.group_type != 0  && strlen(gbl.user_name)>2 ){//如果不是商户版，用户名最后一位要变为*
				user_name_tmp[gbl.user_name_len-2]='*';
				user_name_tmp[gbl.user_name_len-1]='\0';				
			}
			b63_offset = 62;
			//取欠费业务数量			
			memset(sBizNum,0,sizeof(sBizNum));
			memcpy( sBizNum, pack.FIELD63 + b63_offset, 2);
			b63_offset += 2;
			//取欠费业务明细
			sprintf(temp_buff,"用户名:%s: ",user_name_tmp);			
			for ( i=0; i<atoi(sBizNum); i++){
				//业务代码
				memcpy( gbl.total_fee_type[i], pack.FIELD63 + b63_offset, 4);
				b63_offset += 4;
				//业务名
				memset(sNum,0,sizeof(sNum));
				memcpy( sNum, pack.FIELD63 + b63_offset, 2);
				b63_offset += 2;
				memcpy( temp_buff+strlen(temp_buff), pack.FIELD63+b63_offset, atoi(sNum));
				b63_offset += atoi(sNum);
				//金额
				memcpy( gbl.total_amount[i], pack.FIELD63 + b63_offset, 12);
				b63_offset += 12;
				CTools::chgToMny(gbl.total_amount[i],mny);
				sprintf(temp_buff+strlen(temp_buff), ":%s; ",mny);
				totalAmount += atof(gbl.total_amount[i]);
			}
			totalAmount = totalAmount/100;
			sprintf(temp_buff+strlen(temp_buff), "总欠费金额%.2lf\n【确认】交费\n【返回】返回",totalAmount);
			TS_OutPutMsg(gbl.dPosInfo, temp_buff, 0,iSelect);
			break;
		default:	//固话、小灵通话费、ITV费用、CDMA后付费（偷懒程序，未解for循环）
			CTools::byte_to_hex( pack.FIELD4, (BYTE *)gbl.amount, 6 );
			CTools::chgToMny(gbl.amount,mny);
			b63_offset = 0;
			pMonNum = (pack.FIELD63)[b63_offset]-0x30;
			b63_offset++;
			bbzero(user_name_tmp);
			memcpy(user_name_tmp,pack.FIELD63+b63_offset,6);
			b63_offset += 6;
			tMonNum = atoi(user_name_tmp);			
			memcpy(gbl.user_name,pack.FIELD63+b63_offset,60);
			b63_offset += 60;
			gbl.user_name_len = trim(gbl.user_name, 60);
			bbzero(user_name_tmp);
			strcpy(user_name_tmp,gbl.user_name);
			if(gbl.group_type != 0 && strlen(gbl.user_name)>2 ){//如果不是商户版，用户名最后一位要变为*
				user_name_tmp[gbl.user_name_len-2]='*';
				user_name_tmp[gbl.user_name_len-1]='\0';				
			}
			if(tMonNum<=3 || tMonNum>100000)
			{
				sprintf(temp_buff,"用户名：%s\n金额：%s\n欠费月份数为%d个月\n请按【确认】交费",user_name_tmp,mny,tMonNum);
			}
			else{
				sprintf(temp_buff,"用户名：%s\n金额：%s\n欠费月份数为%d个月\n请按【确认】交纳前3个月费用",user_name_tmp,mny,tMonNum);
				first3mon = 1;//三个月以上欠费的前3个月的交费
			}
			TS_OutPutMsg(gbl.dPosInfo, temp_buff, 0,iSelect);
			//	iSelect = safeOutPutMsg( temp_buff, 3);
			break;
		}
		return iSelect;
	}
	else
	{
		if( atoi(gbl.fee_type) == 140 ) //2007-02-02
		{
			if( !memcmp(pack.FIELD62, "P20001002", 9) && atoi(response_code) == 80 )
			{
				memcpy(gbl.user_name,pack.FIELD63,30);
				gbl.user_name_len = trim(gbl.user_name, 30);
				bbzero(user_name_tmp);
				strcpy(user_name_tmp,gbl.user_name);
				if(gbl.group_type != 0  && strlen(gbl.user_name)>2 ){//如果不是商户版，用户名最后一位要变为*
					user_name_tmp[gbl.user_name_len-2]='*';
					user_name_tmp[gbl.user_name_len-1]='\0';				
				}
				bbzero(temp_buff);
				sprintf(temp_buff,"用户名：%s\n已有成功受理记录，是否继续充值？\n【确认】继续\n【返回】返回", user_name_tmp);
				TS_OutPutMsg(gbl.dPosInfo, temp_buff, 0,iSelect);
				return iSelect;
			}
		}
		if( (!memcmp(gbl.fee_type,"0241",4) ||!memcmp(gbl.fee_type,"0001",4) || !memcmp(gbl.fee_type,"0013",4) || !memcmp(gbl.fee_type,"0137",4) ) && !memcmp(pack.FIELD39,"80",2) && !memcmp(&pack.FIELD62[1+6],"82",2)){//无欠费,提示交预付金和办理预授权
			TS_OutPutMsg(gbl.dPosInfo, " \n\n   该号码无欠费!", 1, iSelect);
			telPayExtend(type);//提示交预付金和办理银行划扣受理
			return -1;
		}
		returnFail(response_code);
		return -1;
	}
}

//返回0表示成功
//first3mon:0-非三个月以上欠费的前3个月的交费 1-三个月以上欠费的前3个月的交费
int CTrade::telPayHdls(const char *type, int first3mon){	//电信多业务交费(综合收费)
	int bizNum=0;
	int iSelect;
	char tmp[100];
	bbzero (tmp);
	int biz_index=0; //交费业务次序
	char last_amount[12+1];
	bbzero(last_amount);
	for(bizNum=0; bizNum<sizeof(gbl.total_fee_type)/sizeof(gbl.total_fee_type[0]) && strcmp(gbl.total_fee_type[bizNum],""); bizNum++);
	wrLog("【电信综合收费】共%d个业务",bizNum);
	memcpy(last_amount,gbl.total_amount[bizNum-1],sizeof(last_amount));
	for(int i=0,iRet=0; i<bizNum; i++)
	{
		bbzero(gbl.fee_type);
		bbzero(gbl.amount);
		memcpy( gbl.fee_type, gbl.total_fee_type[i], sizeof(gbl.fee_type));
		memcpy( gbl.amount, gbl.total_amount[i], sizeof(gbl.amount));
		wrLog("电信综合收费:第%d个业务，业务代码[%s]，金额[%s]", i+1, gbl.fee_type, gbl.amount);
		if (atoi(gbl.amount)==0 )
		{
			continue;
		}

		biz_index++;
		CTools::get_time(gbl.pos_serial);
		iRet = telPayHdl( type, biz_index);
		if(iRet!=0)
		{
			wrLog("电信综合收费:第%d个业务交费不成功，B39[%s],B62[%s]",i+1,pack.FIELD39,pack.FIELD62);
			if ((i+1)==bizNum || ((i+2)==bizNum && atoi(last_amount)==0))  //如果这是最后一个业务
			{	

				wrLog("电信综合收费，程序异常，退出");
				break;
				
			}

			if(iRet==-1)
			{
					wrLog("电信综合收费:第%d个业务交费不成功，B39[%s],B62[%s]",i+1,pack.FIELD39,pack.FIELD62);
					sprintf(tmp,"您的第[%d]个业务，交费失败， \n 继续下一个业务请按【Enter】，取消请按【Esc】",i+1);
					TS_OutPutMsg(gbl.dPosInfo,tmp,0,iSelect);
					if(iSelect != 0)
					{
						wrLog("电信综合收费，用户取消，退出");
						break;
					}
					else
					{
						continue;
						
					}

			}
			if(iRet==CANCLE_KEY)
			{
				wrLog("电信综合收费，用户取消，退出");
				break;
			}
			if(!memcmp(pack.FIELD39,"80",2))
			{
				wrLog("电信综合收费，交易失败");
				sprintf(tmp,"您的第[%d]个业务，交费失败 \n 继续下一个业务请按【Enter】，取消请按【Esc】",i+1);
				TS_OutPutMsg(gbl.dPosInfo,tmp,0,iSelect);
				if(iSelect != 0)
				{
					wrLog("电信综合收费，用户取消，退出");
					break;
				}
				else
				{
					continue;
					
				}
			
			}
		}

	}
	return 0;
}

//返回值0：返回后应该用原模式交费 -1：返回后不再缴费
int CTrade::payModeSelect(const char *type, char *fee_type, char *amount, char *city_no, char *phone_no)
{
	int iRet=0, iSelect=0, iTotalNum=0, mustBigger=0;
	char mny[20], camount[12+1], clamount[12+1];//camount比实际金额大, clamount比实际金额小
	char dest_list[1+1], m_fee_type[4+1];
	
	bbzero(dest_list);
	bbzero(m_fee_type);
	
	switch(atoi(fee_type))
	{
	case 1://固话/小灵通话费
	case 92://佛山
		strcpy(dest_list, "9");//固话或小灵通，未确定
		strcpy(m_fee_type, "0089");
		break;
	case 131://东莞后付费
		strcpy(dest_list, "9");//固话或小灵通，未确定
		strcpy(m_fee_type, "0153");
		break;
	case 210://全省
		mustBigger = 1;
		strcpy(dest_list, "9");//固话或小灵通，未确定
		strcpy(m_fee_type, "0089");
		break;
	case 13://ADSL网费
	case 140://预付费ADSL充值
		strcpy(dest_list, "3");//ADSL
		strcpy(m_fee_type, "0089");
		break;
	case 241://CDMA后付费
		strcpy(dest_list, "2");//手机
		strcpy(m_fee_type, "0089");
		break;
	default:
		return 0;
		break;
	}
	
	bbzero(mny);
	CTools::chgToMny(amount, mny);
	
	TSMENULIST menuList;
	sprintf(menuList.acTitle, "金额%s 请选择支付方式", mny);
	iTotalNum = 0;
	
	bbzero(mny);
	bbzero(camount);
	sprintf(camount, "%012d", ((atoi(amount)-1)/1000+1)*1000);
	CTools::chgToMny(camount, mny);
	sprintf(menuList.menuItem[iTotalNum++], "付费卡缴%s(推荐)", mny);
	
	
	if(mustBigger==0)
	{
		if(memcmp(camount, amount, 12)!=0)
		{
			bbzero(mny);
			bbzero(clamount);
			sprintf(clamount, "%012d", ((atoi(amount)-1)/1000)*1000);
			CTools::chgToMny(clamount, mny);
			if(memcmp(clamount, "000000000000", 12)!=0 && memcmp(clamount, camount, 12)!=0)
			{
				sprintf(menuList.menuItem[iTotalNum++], "付费卡缴%s", mny);
			}
			else
			{
				NULL;
			}
		}
		else
		{
			NULL;
		}
		
		bbzero(mny);
		CTools::chgToMny(amount, mny);
		sprintf(menuList.menuItem[iTotalNum++], "代收费缴%s", mny);
	}
	else
	{
		NULL;
	}	
	
	menuList.iTotalNum = iTotalNum;
	iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
	if(iTotalNum==1)
	{
		if(iRet)
			return -1;
		switch(iSelect)
		{
		case 1:				
			cardPayTel("使用充值付费卡缴费", city_no, dest_list, phone_no, camount, m_fee_type);
			return -1;
		default: 
			return -1;
		}
	}
	else if(iTotalNum==2)
	{
		if(iRet)
			return -1;
		switch(iSelect)
		{
		case 1:				
			cardPayTel("使用充值付费卡缴费", city_no, dest_list, phone_no, camount, m_fee_type);
			return -1;
		case 2:
			return 0;
			break;
		default: 
			return -1;
		}
	}
	else
	{
		if(iRet)
			return -1;
		switch(iSelect)
		{
		case 1:			
			cardPayTel("使用充值付费卡缴费", city_no, dest_list, phone_no, camount, m_fee_type);
			return -1;
		case 2:				
			cardPayTel("使用充值付费卡缴费", city_no, dest_list, phone_no, clamount, m_fee_type);
			return -1;
		case 3:
			return 0;
			break;
		default: 
			return -1;
		}
	}
}

//type：标题；bizIdx：0:表示一般业务，1...n表示综合收费的第bizIdx个业务, first3mon:0-非三个月以上欠费的前3个月的交费 1-三个月以上欠费的前3个月的交费
//返回0表示成功
int CTrade::telPayHdl(const char *type, int bizIdx, int first3mon)	//电信交费
{
	int  iRet, flag,iSelect;
	int b48_len = 0;
	char len_buff[10];
	
	wrLog("电信入口【交费】");
	iRet = selectAmount();
	if(iRet == CANCLE_KEY)
		return CANCLE_KEY;
	else if(iRet < 0)
		return -1;
	wrLog("phone no3:[%s]", gbl.phone_no);
	
	//////////////////////////////////////////////////////////////////////////
	if( atoi(gbl.dPosInfo.prmVer)>=9000 && ( strstr(CT10000_TERM, "00000000")!=NULL || strstr(CT10000_TERM, gbl.pos_no)!=NULL ) )
	{
		iRet = payModeSelect(type, gbl.fee_type, gbl.amount, gbl.city_no, gbl.phone_no);
		if(iRet==0)
		{
			NULL;
		}
		else
		{
			return 0;
		}
	}
	//////////////////////////////////////////////////////////////////////////
	
	
	flag = 0;	//重输密码标识
	/********************请求刷卡****************/
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{
		if(bizIdx<=1 && !flag) 
		{
			iRet = mngCard_Hdl(type);
			if(iRet == CANCLE_KEY)
				return CANCLE_KEY;
			else if(iRet != 0){
				TS_OutPutMsg(gbl.dPosInfo,"读取输入数据错误!\n交易失败!\n按【确认】返回",1,iSelect);
				return -1;
			}
			
			if(!memcmp(gbl.card_no,"8828",4))	//若是付费易卡,走付费易卡刷卡流程（多卡交易）
			{
				memset(gbl.xlt_type, 0, sizeof(gbl.xlt_type));
				memcpy(gbl.xlt_type, "01",2);
				iRet = xltMulCard( type, 0);
				return iRet;
			}
		}
		
		pack.wrField(2, gbl);	//写交费域
		/***********修改一些域信息*********/
		switch( atoi(gbl.fee_type) )
		{
		case 71:	//宽带预缴费
			memset(len_buff,0,sizeof(len_buff));
			sprintf(len_buff,"%02d",gbl.phone_len+2);	//电话号码+子业务代码长度（2位）
			memcpy(pack.FIELD48+4, len_buff, 2);	//跳过4位业务代码
			strcat((char *)pack.FIELD48, gbl.sub_code);	//加上2位子业务代码
			pack.Packet_Table[48].Real_Length += 2;
			break;
			
		case 143:  //自由互联业务
		case 241:  //CDMA后付费
		case 242:  //CDMA预付费
			bbzero(pack.FIELD48);
			memcpy(pack.FIELD48,gbl.fee_type,4);	//4位信息码
			b48_len = 4;
			memset(len_buff,0,sizeof(len_buff));
			sprintf(len_buff,"%02d",gbl.phone_len);	//电话号码长度
			memcpy(pack.FIELD48+b48_len,len_buff,2);	
			b48_len +=2;
			memcpy(pack.FIELD48+b48_len, gbl.phone_no, gbl.phone_len);	//电话号码
			b48_len += gbl.phone_len;
			pack.Packet_Table[48].Real_Length=b48_len;			
			break;
		case 131://电信后付费缴费
			bbzero(pack.FIELD55);
			memcpy(pack.FIELD55,gbl.stan_no,12);
			memcpy(pack.FIELD55+12,"011",3);
			pack.Packet_Table[55].Real_Length=15;
            break;
		default:
			break;
		}
		switch( atoi(gbl.fee_type) )
		{
		case 241:  //CDMA后付费
		case 1:		//电信发票修改20080129
		case 13:
		case 137:		
			bbzero(pack.FIELD3);	
			if(gbl.key_num == 8)
				CTools::hex_to_byte((BYTE *)"400080", pack.FIELD3, 6);
			else
				CTools::hex_to_byte((BYTE *)"400000", pack.FIELD3, 6);
			break;
		default:
			break;
		}
		/**********************************/
		
		//交费包处理
		iRet = packHdl(2);
		if(iRet < 0)
			return -1;
		
		if (!memcmp(pack.FIELD39,"00",2)) 
		{
			
			iRet = TS_OutPutMsg(gbl.dPosInfo,"     交费成功！\n    谢谢您的使用\n请按【确认】打印发票",0,iSelect);
			
			if(iRet || iSelect==0)
			{
				CPrint prt;
				prt.set_in_par(gbl);
				if(memcmp(gbl.card_no,"8828",4)==0){//若是付费易卡
					switch(atoi(gbl.fee_type))
					{
					case 96:	//小灵通话费预付金
					case 97:	//adsl网费预付金
					case 138:	//ITV预付金
					case 242:   //CDMA预付金
						memcpy(gbl.amount, pack.FIELD63, 12);
					}
				//	prt.print_detail(2, type);	 //打印预付费明细
					prt.print_pre_detail(pack,type);
				}else{
					switch(atoi(gbl.fee_type))
					{
					case 96:	//小灵通话费预付金
					case 97:	//adsl网费预付金
					case 138:	//ITV预付金
					case 242:   //CDMA预付金
						memcpy(gbl.amount, pack.FIELD63, 12);
					case 46:
					case 64:
					case 71:
					case 98:
					case 140: //预付费ADSL充值, 2007-02-02
					case 143: //自由互联, 2007-03-05
						//prt.print_detail(2, type);	 //打印预付费明细
						prt.print_pre_detail(pack,type);
						break;
					default:
						//prt.print_detail(1, type);	//打印欠费明细
						prt.print_pym_detail(pack,type);
					}
				}
			}
			if(bizIdx==0 && first3mon==0){//如果不是综合收费 并且 不是欠费3月以上的前3个月的交费
				switch(atoi(gbl.fee_type))
				{
				case 1:		//若长市话费
				case 13:	//ADSL
				case 137:	//ITV
				case 96:	//长市话费预付金
				case 97:	//ADSL预付金
				case 138:	//ITV预付金
				case 241:   //CDMA后付费
				case 242:   //CDMA预付金
					telPayExtend(type);//提示交预付金和办理预授权
					break;
				}
			}			
			return 0;
		}// end if (!memcmp(pack.FIELD39,"00",2))
		else if(!memcmp(pack.FIELD39,"55",2))
		{
			flag = 1;
			if(reGetPwd( type) == 0) //密码错误，重新输入密码, 2006-10-25
				continue;
			else
				return CANCLE_KEY;
		}
		else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
			if (iSelect!=0)
			{
				return -1;
			}else
				continue;
		}
		returnFail((char *)pack.FIELD39);		
		return -1;
	}
	return -1;
}

int CTrade::QQTrade(const char *type, int select,int input_flag)		//QQ交易 KF:2006.10.23
{
	int iSelect,iRet=0;
	wrLog("%s",type);
	
	iSelect = QQInqHdl(type,input_flag);
	
	if(iSelect==0)
	{
		iRet = QQPayHdl( type,select,input_flag);
	}
	return iRet;
}


//广禄qq充值
int CTrade::GLQQTrade(const char *type, int select,int input_flag)
{

	int  iRet;
	char msg[300];
	char amoMny[15];
	char errMsg[1024];
	int iSelect;

	bbzero(amoMny);
	bbzero(errMsg);
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;

	if (atoi(gbl.fee_type)==76 || atoi(gbl.fee_type)==167)
	{
		bbzero(gbl.QQrate);
		strcpy(gbl.QQrate,"100"); 
	}
	else
	{
	
		bbzero(gbl.QQrate);
		strcpy(gbl.QQrate,"10"); 

	}

	if (input_flag == 0)
	{
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
		
		strcpy(tradeInfoSend.acMainTitle, type);
		
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents = 1;
		
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入QQ号码：");	
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
		tradeInfoSend.Contents[0].uCount = 0;		//输入1次卡号
		tradeInfoSend.Contents[0].uTimeOut = 30;	//超时30秒
		tradeInfoSend.Contents[0].uMinLen = 1;
		tradeInfoSend.Contents[0].uMaxLen = 11;
		
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		
		if(iRet != 0)
		{
			wrLog("TS_TradeControl返回错误[%d]", iRet);
			wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
			return iRet;
		}

		bbzero(gbl.pos_serial);
		strcpy(gbl.pos_serial, (char *)tradeInfoRecv.uTradeID);
		memset( gbl.glQQPayInfo.ACCTCODE,0,sizeof(gbl.glQQPayInfo.ACCTCODE) );
		strcpy( gbl.glQQPayInfo.ACCTCODE,(char *)tradeInfoRecv.Contents[0].uMsg );
	}

	if (input_flag == 0)
	{
		iRet = selectAmount(0,select);
	}

	else
	{
		iRet = selectAmount(2,select);
		if (iRet == 8)
		{
			return 8;
		}
	}
	
	if(iRet == CANCLE_KEY)
		return CANCLE_KEY;
	else if(iRet < 0)
		return -1;
	/********************请求刷卡****************/
	wrLog("gbl.amount: [%s]", gbl.amount);
	
	if(atoi(gbl.dPosInfo.prmVer)>=9000)
	{
		bbzero(amoMny);
		CTools::chgToMny(gbl.amount,amoMny);
		bbzero(msg);
		sprintf(msg, "%s\n\nQQ号：%s\n金额：%s\n\n【是 Enter】  【否 Esc】", type,gbl.glQQPayInfo.ACCTCODE, amoMny);
		bbzero(gbl.phone_no);
		strcpy(gbl.phone_no,gbl.glQQPayInfo.ACCTCODE);
		iRet = TS_OutPutMsg(gbl.dPosInfo, msg, 0, iSelect);
		if(iSelect)
		{
			return -1;
		}
	}
	
	bbzero(msg);
	strcat(msg, "0076','0077','0078','0087','0088','0167','0168','0273','0274','0275','0277','0278','0293','0294','0322','0341");
	
	if(CDB::chKChinaUnicom(msg, gbl.phone_no, atoi(gbl.amount))==0)
	{
		NULL;
	}
	else
	{
		bbzero(msg);
		sprintf(msg, "业务运营商规定：\n同一号码%s\n同一金额%d元\n%d分钟内不能连续充值\n请稍后再试", gbl.phone_no, atoi(gbl.amount)/100,FORBID_TIME);
		TS_OutPutMsg(gbl.dPosInfo, msg, 1, iSelect);
		return -1;
	}
		//调用扣费接口进行扣费
	iRet=pay(type,errMsg);
	if (iRet==0)
	{
		TS_OutPutMsg(gbl.dPosInfo,"     交费成功！\n    谢谢您的使用\n请按【确认】打印发票",0,iSelect);
		if( !iSelect)
		{
			CPrint prt;
			prt.set_in_par(gbl);
			prt.print_glQQ_detail(type);
		}
			return 0;
	}
	else
	{
		
		TS_OutPutMsg(gbl.dPosInfo,errMsg,1,iSelect);
		return -1;
	}
	

}


int CTrade::QQInqHdl(const char *type, int input_flag)	//QQ查询
{
	int  iRet;
	
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	if (input_flag == 0)
	{
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
		
		strcpy(tradeInfoSend.acMainTitle, type);
		
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents = 1;
		
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入QQ号码：");	
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
		tradeInfoSend.Contents[0].uCount = 0;		//输入1次卡号
		tradeInfoSend.Contents[0].uTimeOut = 30;	//超时30秒
		tradeInfoSend.Contents[0].uMinLen = 1;
		tradeInfoSend.Contents[0].uMaxLen = 11;
		
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		
		if(iRet != 0)
		{
			wrLog("TS_TradeControl返回错误[%d]", iRet);
			wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
			return iRet;
		}
		memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
		strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
		gbl.phone_len = tradeInfoRecv.Contents[0].uMsgLen;
		memset( gbl.phone_no,0,sizeof(gbl.phone_no) );
		strcpy( gbl.phone_no,(char *)tradeInfoRecv.Contents[0].uMsg );
	}
	
	
	//写查询域
	pack.wrField(1, gbl);
	
	//  查询包打包   
	iRet = packHdl(1);
	if(iRet < 0)
		return -1;
	
	//返回数据给终端
	iRet = QQInqMsg();
	return iRet;
}

int CTrade::QQInqMsg()//KF:2006.10.24
{
	wrLog("QQ_no:[%s]",gbl.phone_no);
	char response_code[3];
	char temp_buff[2048],len_buff[10],lastYear[4+1],lastMonth[2+1],lastDay[2+1];
	//	char *PQQrate = NULL;
	int iSelect,i;
	
	memset(response_code,0,sizeof(response_code));
	memset(temp_buff,0,sizeof(temp_buff));
	memset(len_buff,0,sizeof(len_buff));
	memset(lastYear,0,sizeof(lastYear));
	memset(lastMonth,0,sizeof(lastMonth));
	memset(lastDay,0,sizeof(lastDay));
	memset(gbl.QQrate,0,sizeof(gbl.QQrate));
	
	memcpy(response_code,pack.FIELD39,2);
	wrLog("业务代码:[%s]",gbl.fee_type);
	if (!memcmp(response_code,"00",2)) 
	{
		memcpy(len_buff,&pack.FIELD48[4],2);
		gbl.phone_len =atoi(len_buff);
		memset( gbl.phone_no,0,sizeof(gbl.phone_no));
		memcpy(gbl.phone_no,&pack.FIELD48[6],gbl.phone_len);
		
		//wrLog("pack.FIELD63:[%s]",pack.FIELD63);
		memcpy(lastYear,pack.FIELD63,4);
		lastYear[4]='\0';
		memcpy(lastMonth,pack.FIELD63+4,2);
		lastMonth[2]='\0';
		memcpy(lastDay,pack.FIELD63+6,2);
		lastDay[2]='\0';
		switch(atoi(gbl.fee_type))
		{
		case 76:	//Q币充值
		case 167:   //东莞Q币充值
			for(i=0;i<sizeof(pack.FIELD63)-10 && pack.FIELD63[i]!=':';i++);
			sprintf(gbl.QQrate, "%0.2d", (int) ( atof( (const char *)(pack.FIELD63+i+1) )*100 )) ;
			wrLog("gbl.QQrate: [%s]", gbl.QQrate);
			sprintf(temp_buff,"QQ号：%s\n最近充值日期：%s年%s月%s日\nQ币:人民币 1:%s\n【确认】Q币充值\n【返回】返回",gbl.phone_no,lastYear,lastMonth,lastDay, pack.FIELD63+i+1);
			//TS_OutPutMsg(gbl.dPosInfo, temp_buff, 0,iSelect);
			iSelect = 0;
			break;
		case 77:	//QQ会员
		case 168:   //东莞QQ会员
			memcpy(gbl.QQrate,pack.FIELD63+8,2);
			sprintf(temp_buff,"QQ号：%s\n会员使用截止日期：%s年%s月%s日\n月租：%d元/月\n【确认】会员包月\n【返回】返回",gbl.phone_no,lastYear,lastMonth,lastDay,atoi(gbl.QQrate));
			//TS_OutPutMsg(gbl.dPosInfo, temp_buff, 0,iSelect);
			iSelect = 0;
			break;
		case 273:
		case 88:
		case 87:
		case 274:
		case 277:
		case 294:
		case 293:
		case 278:
			memcpy(gbl.QQrate,pack.FIELD63+8,2);
			iSelect = 0;
			break;
		default:	//错误的业务代码
			return -1;
			break;
		}
		return iSelect;
	}
	else
	{
		returnFail(response_code);
		return -1;
	}
}

int CTrade::QQPayHdl(const char *type, int select,int input_flag)	//QQ交费
{
	int  iRet, recharge_flag;
	int  iSelect;
	char amoMny[15], msg[200], temp[10];
	
	wrLog("QQ入口【交费】");
	if (input_flag == 0)
	{
		iRet = selectAmount(0,select);
	}else{
		iRet = selectAmount(2,select);
		if (iRet == 7)
		{
			return 7;
		}
	}
	
	if(iRet == CANCLE_KEY)
		return CANCLE_KEY;
	else if(iRet < 0)
		return -1;
	/********************请求刷卡****************/
	wrLog("gbl.amount: [%s]", gbl.amount);
	
	if(atoi(gbl.dPosInfo.prmVer)>=9000)
	{
		bbzero(amoMny);
		CTools::chgToMny(gbl.amount,amoMny);
		bbzero(msg);
		sprintf(msg, "%s\n\nQQ号：%s\n金额：%s\n\n【是 Enter】  【否 Esc】", type, gbl.phone_no, amoMny);
		iRet = TS_OutPutMsg(gbl.dPosInfo, msg, 0, iSelect);
		if(iSelect)
		{
			return -1;
		}
	}
	
	bbzero(msg);
	strcat(msg, "0076','0077','0078','0087','0088','0167','0168','0273','0274','0275','0277','0278','0293','0294','0322','0341");
	
	if(CDB::chKChinaUnicom(msg, gbl.phone_no, atoi(gbl.amount))==0)
	{
		NULL;
	}
	else
	{
		bbzero(msg);
		sprintf(msg, "业务运营商规定：\n同一号码%s\n同一金额%d元\n%d分钟内不能连续充值\n请稍后再试", gbl.phone_no, atoi(gbl.amount)/100,FORBID_TIME);
		TS_OutPutMsg(gbl.dPosInfo, msg, 1, iSelect);
		return -1;
	}
	
	bbzero(temp);
	
	//qq充值直接走腾讯接口
	
	if(atoi(gbl.fee_type) == 76)
	{
		recharge_flag = 2;
		
	}
	wrLog("直接走腾讯接口】"); //更改为走广禄qq充值。超爽交费易。
	
	int flag = 0;

	for(int curTry=0; curTry<MAXTRY; curTry++)
	{
		if(recharge_flag != 1)
		{
			if(!flag)
			{
				iRet = mngCard_Hdl(type);
				if(iRet == CANCLE_KEY)
					return CANCLE_KEY;
				else if(iRet != 0)
					return -1;
			}
			if(!memcmp(gbl.card_no,"8828",4))	//若是付费易卡
			{
				memset(gbl.xlt_type, 0, sizeof(gbl.xlt_type));
				memcpy(gbl.xlt_type, "01",2);
				iRet = xltMulCard( type, 0);
				return iRet;
			}
		}
		pack.wrField(2, gbl);	//写交费域
		
		//因为是QQ，所以要在63域加Q币个数或月数
		/*------------------------------*/
		memcpy(pack.FIELD63+pack.Packet_Table[63].Real_Length, gbl.QQ_amount, 4);
		pack.Packet_Table[63].Real_Length += 4;
		/*------------------------------*/
		
		iRet = packHdl(2);
		if(iRet < 0)
			return -1;
		
		if (!memcmp(pack.FIELD39,"00",2))
		{
			iRet = TS_OutPutMsg(gbl.dPosInfo,"     交费成功！\n    谢谢您的使用\n请按【确认】打印发票",0,iSelect);
			if(!iRet && !iSelect)
			{
				CPrint prt;
				prt.set_in_par(gbl);
				//prt.print_detail(2, type);	//打印明细
				prt.print_pre_detail(pack,type);
			}
			return 0;
		}
		else if(!memcmp(pack.FIELD39,"55",2))
		{
			flag = 1;
			if(reGetPwd( type) == 0) //密码错误，重新输入密码, 2006-11-09 KF ADD
				continue;
			else
				return CANCLE_KEY;
		}
		else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
			if (iSelect!=0)
			{
				return -1;
			}else
				continue;
		}
		/*		else if(!memcmp(pack.FIELD62+7, "01", 2) || !memcmp(pack.FIELD62+7, "13", 2))		//可尝试广信QQ充值的响应码
		{
		if(atol(gbl.amount) <= 3000 && atoi(gbl.fee_type) == 76)
		{
		//strcpy(temp, gbl.fee_type);
		strcpy(gbl.fee_type, "0295");
		break;
		}
		else
		{
		returnFail((char *)pack.FIELD39);
		}
	}*/
		else
			returnFail((char *)pack.FIELD39);
		return -1;
	}
	/*
	//======================腾讯QQ失败走广信================================
	wrLog("【腾讯接口失败，走广信QQ充值】");
	
	  pack.wrField(2, gbl);	//写交费域
	  //================================================
	  bbzero(pack.FIELD3);
	  CTools::hex_to_byte((BYTE *)"000000", pack.FIELD3, 6);
	  //================================================
	  
		iRet = packHdl(2);
		if(iRet < 0)
		return -1;
		
		  if (!memcmp(pack.FIELD39,"00",2))
		  {
		  iRet = TS_OutPutMsg(gbl.dPosInfo,"     交费成功！\n    谢谢您的使用\n请按【确认】打印发票",0,iSelect);
		  if(iRet!=0 || iSelect==0)
		  {
		  CPrint prt;
		  prt.set_in_par(gbl, pack);
		  prt.print_detail(2, type);	//打印明细
		  }
		  return 0;
		  }
		  else
		  {
		  returnFail((char *)pack.FIELD39);
		  return -1;
		  }
		  
			return -1;*/
			return -1;
}





int CTrade::RaffleTrade(const char *type, int select) //体彩账户充值
{
	int iSelect,iRet=0;
	wrLog("%s",type);
	
	iSelect = RaffleInqHdl(type);
	
	if(iSelect==0)
	{
		iRet = RafflePayHdl( type,select);
	}
	return iRet;
}


int CTrade::RaffleInqHdl(const char *type)	//体彩账户查询
{
	int  iRet;
	char response_code[3];
	
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, type);
	
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入体彩账号：");	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
	tradeInfoSend.Contents[0].uCount = 0;		//输入1次卡号
	tradeInfoSend.Contents[0].uTimeOut = 30;	//超时30秒
	tradeInfoSend.Contents[0].uMinLen = 1;
	tradeInfoSend.Contents[0].uMaxLen = 11;
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
	strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
	gbl.phone_len = tradeInfoRecv.Contents[0].uMsgLen;
	memset( gbl.phone_no,0,sizeof(gbl.phone_no) );
	strcpy( gbl.phone_no,(char *)tradeInfoRecv.Contents[0].uMsg );
	
	
	
	//写查询域
	pack.wrField(1, gbl);
	
	//  查询包打包   
	iRet = packHdl(1);
	if(iRet < 0)
		return -1;
	memset(response_code,0,sizeof(response_code));
	memcpy(response_code,pack.FIELD39,2);
	wrLog("业务代码:[%s]",gbl.fee_type);
	if (!memcmp(response_code,"00",2)) 
	{
		//         bbzero(balance);
		// 		CTools::byte_to_hex(pack.FIELD4, (BYTE *)balance, 6);
		// 		CTools::chgToMny(balance,balance_mny);
		// 		sprintf(temp_buff,"体彩账号：%s\n账户余额:%s\n【确认】充值\n【返回】返回",gbl.phone_no,balance_mny);
		// 		TS_OutPutMsg(gbl.dPosInfo, temp_buff, 0,iSelect);
		
		return 0;
	}
	else
	{
		returnFail(response_code);
		return -1;
	}
	
}


int CTrade::RafflePayHdl(const char *type, int select)	//体彩充值
{
	int  iRet;
	int  iSelect;
	char amoMny[15], msg[200];
	
	wrLog("体彩账户充值【交费】");
	iRet = selectAmount(0,select);	
	if(iRet == CANCLE_KEY)
		return CANCLE_KEY;
	else if(iRet < 0)
		return -1;
	/********************请求刷卡****************/
	wrLog("gbl.amount: [%s]", gbl.amount);
	
	if(atoi(gbl.dPosInfo.prmVer)>=9000)
	{
		bbzero(amoMny);
		CTools::chgToMny(gbl.amount,amoMny);
		bbzero(msg);
		sprintf(msg, "%s\n\n%s\n\n【是 Enter】  【否 Esc】", type, amoMny);
		iRet = TS_OutPutMsg(gbl.dPosInfo, msg, 0, iSelect);
		if(iSelect)
		{
			return -1;
		}
	}
	
	
	int flag = 0;
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{
		if(!flag)
		{
			iRet = mngCard_Hdl(type);
			if(iRet == CANCLE_KEY)
				return CANCLE_KEY;
			else if(iRet != 0)
				return -1;
		}
		if(!memcmp(gbl.card_no,"8828",4))	//若是付费易卡
		{
			memset(gbl.xlt_type, 0, sizeof(gbl.xlt_type));
			memcpy(gbl.xlt_type, "01",2);
			iRet = xltMulCard( type, 0);
			return iRet;
		}
		
		pack.wrField(2, gbl);	//写交费域
		
		iRet = packHdl(2);
		if(iRet < 0)
			return -1;
		
		if (!memcmp(pack.FIELD39,"00",2))
		{
			iRet = TS_OutPutMsg(gbl.dPosInfo,"     充值成功！\n    谢谢您的使用\n请按【确认】打印发票",0,iSelect);
			if(iRet!=0 || iSelect==0)
			{
				CPrint prt;
				prt.set_in_par(gbl);
				//prt.print_detail(2, type);	//打印明细
				prt.print_pre_detail(pack,type);
			}
			return 0;
		}
		else if(!memcmp(pack.FIELD39,"55",2))
		{
			flag = 1;
			if(reGetPwd( type) == 0) //密码错误，重新输入密码, 2006-11-09 KF ADD
				continue;
			else
				return CANCLE_KEY;
		}
		else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
			if (iSelect!=0)
			{
				return -1;
			}else
				continue;
		}
		else
			returnFail((char *)pack.FIELD39);
		return -1;
	}
	return -1;
}

//ePOS返回失败处理
int CTrade::posReturnFail(int iRet,char *acErrMsgBuf)//KF:2006.10.25
{
	int iSelect;
	wrLog("返回码[%d]\n错误信息[%s]\n", iRet, acErrMsgBuf);
	//用户按“取消”键 或　用户输入超时
	if( (iRet == 0xf0) || strstr(acErrMsgBuf,"取消键快捷") || strstr(acErrMsgBuf,"返回键快捷") || strstr(acErrMsgBuf,"输入超时") )
		return CANCLE_KEY;			
	else
	{
		if(strstr(acErrMsgBuf,"卡解密操作失败") || strstr(acErrMsgBuf,"加密失败"))
			TS_OutPutMsg(gbl.dPosInfo,"\n     加密出错！\n请稍候再试!\n或按【Ctrl+H】联系在线客服中心 或致电400-80-11888咨询\n   按【确认】返回",1,iSelect);
		else
			TS_OutPutMsg(gbl.dPosInfo,"\n     操作出错！\n请稍候再试!\n或按【Ctrl+H】联系在线客服中心 或致电400-80-11888咨询\n   按【确认】返回",1,iSelect);
		return ERROR_CODE;
	}
}

//交行返回失败处理
int CTrade::banReturnFail(char *response_code)	
{
	int iSelect;
	char tmp[100];
	
	bbzero(tmp);
	wrLog("返回失败,返回码[%s]",response_code);
	if(!strcmp(response_code, "A0") || !strcmp(response_code, "99"))
		strcpy(tmp, "\n\n 校验错，请重新签到");
	else if( !strcmp(response_code, "A0") )
		strcpy(tmp, "银联返回包MAC校验失败，需冲正，冲正原因码为“A0”");
	else if( !strcmp(response_code, "AA") )
		strcpy(tmp, "\n\n    交行网络故障");
	else
	{
		switch(atoi(response_code))
		{
		case 1:
		case 2:
		case 5:
		case 6:
		case 19:
		case 20:
		case 21:
		case 23:
		case 25:
		case 39:
		case 40:
		case 42:
		case 44:
		case 52:
		case 53:
		case 56:
		case 57:
		case 59:
		case 60:
		case 64:	
			strcpy(tmp, "交易失败，请联系发卡行");
			break;
		case 3:	
			strcpy(tmp, "\n\n     商户未登记");
			break;
		case 4:	
		case 7:	
		case 34:
		case 35:
		case 43:
		case 41:	
			strcpy(tmp, "\n\n没收卡，请联系收单行");
			break;
			
		case 9:	
		case 12:
		case 30:
		case 91:
		case 92:
		case 94:
		case 95:
		case 96:	
			strcpy(tmp, "\n\n交易失败，请稍后重试");
			break;
		case 13:	
			strcpy(tmp, "\n\n交易金额超限，请重试");
			break;
		case 14:
			strcpy(tmp, "\n无效卡号，请联系发卡行");
			break;
		case 15:
			strcpy(tmp, "\n\n    此卡不能受理");
			break;
		case 22:	
			strcpy(tmp, "\n\n  操作有误，请重试");
			break;
		case 31:	
			strcpy(tmp, "\n\n    此卡不能受理");
			break;
		case 33:	
			strcpy(tmp, "\n\n过期卡，请联系发卡行");
			break;
		case 36:
			strcpy(tmp, "\n\n此卡有误，请换卡重试");
			break;
		case 37:
			strcpy(tmp, "\n\n没收卡，请联系收单行");
			break;
		case 38:
			strcpy(tmp, "\n\n  密码错误次数超限");
			break;
		case 51:
			strcpy(tmp, "\n\n  余额不足，请查询");
			break;
		case 54:
			strcpy(tmp, "\n\n过期卡，请联系发卡行");
			break;	
		case 58:
			strcpy(tmp, "\n不允许终端进行的交易，请签到");
			break;
		case 61:
			strcpy(tmp, "\n\n      金额太大");
			break;
		case 62:
			strcpy(tmp, "\n\n    不受理信用卡");
			break;
		case 63:
			strcpy(tmp, "\n\n  终端未在交行登记");
			break;
		case 65:
			strcpy(tmp, "\n\n  超出取款次数限制");
			break;
		case 66:	
			strcpy(tmp, "\n交易失败，请联系收单行或银联");
			break;
		case 67:	
			strcpy(tmp, "\n\n       没收卡");
			break;
		case 68:	
			strcpy(tmp, "\n\n  交易超时，请重试");
			break;
		case 75:
			strcpy(tmp, "\n\n  密码错误次数超限");
			break;
		case 77:
			strcpy(tmp, "\n\n  请向网络中心签到");
			break;
		case 79:	
			strcpy(tmp, "\n\nPOS终端重传脱机数据");
			break;
		case 80:
			strcpy(tmp, "\n\n网络繁忙，请稍后再试");
			break;
		case 87:
			strcpy(tmp, "\n\n   银联MAC校验错");
			break;
		case 89:	
			strcpy(tmp, "\n\n     无交易记录");
			break;
		case 90:	
			strcpy(tmp, "\n\n     日结中…");
			break;
		case 93:
			strcpy(tmp, "\n\n      批次号错");
			break;
		case 97:
			strcpy(tmp, "\n终端未登记，请联系收单行或银联");
			break;
		case 98:
			strcpy(tmp, "\n\n     银行无响应");
			break;
		case 48:
			strcpy(tmp, "\n\n不允许IC卡降级交易\n按【确认】返回");
			break;
		default:
			strcpy(tmp, "\n\n网络繁忙，请稍后再试");
			break;
		}
	}
	TS_OutPutMsg(gbl.dPosInfo, tmp, 1, iSelect, 10);
	return iSelect;
}

//新返回失败处理
int CTrade::returnFail(char *response_code)	
{
	int iSelect, i, ret;
	char correct_code[3],party_code[7], temp[3];
	char message[512];
	
	memset(party_code,0,sizeof(party_code));
	memset(correct_code,0,sizeof(correct_code));
	wrLog("返回失败,返回码[%s]",response_code);
	
	bbzero(temp);
	memcpy(temp, response_code, 2);
	bbzero(message);
	if(atoi(temp) == 80)
	{
		memcpy(party_code,&pack.FIELD62[1],6);
		memcpy(correct_code,&pack.FIELD62[1+6],2);
		wrLog("62域correct_code返回码[%s]",correct_code);	
		//--------------------------------------------------------------------------------------------------------------
		if(!memcmp(party_code, "988620", 6)) //加密改造，新加密体系，需更新密匙
		{
			switch(atoi(correct_code))
			{
			case 86:	//TEK签到
				ret = logonHdl(3);
				if( ret== 0)
					TS_OutPutMsg(gbl.dPosInfo, "\n网络繁忙[8086]\n请稍候再试!\n或按【Ctrl+H】联系在线客服中心 或致电400-80-11888咨询\n   按【确认】返回", 0,iSelect);
				else{
					CDB::setEposLogonStatus(6, gbl.pos_no);
					TS_OutPutMsg(gbl.dPosInfo, "\n网络繁忙[8086]\n请稍候再试!\n或按【Ctrl+H】联系在线客服中心 或致电400-80-11888咨询", 0,iSelect);
					if(atoi(gbl.dPosInfo.prmVer)>=9000)
					{
						NULL;
					}
					else
					{
						TS_HangUp(gbl.dPosInfo);
					}
				}
				break;
			case 87:	//TAK签到
				ret = logonHdl(2);
				if(ret == 0)
					TS_OutPutMsg(gbl.dPosInfo, "\n网络繁忙[8087]\n请稍候再试!\n或按【Ctrl+H】联系在线客服中心 或致电400-80-11888咨询\n   按【确认】返回", 0,iSelect);
				else{
					CDB::setEposLogonStatus(5, gbl.pos_no);
					TS_OutPutMsg(gbl.dPosInfo, "\n网络繁忙[8087]\n请稍候再试!\n或按【Ctrl+H】联系在线客服中心 或致电400-80-11888咨询", 0,iSelect);
					if(atoi(gbl.dPosInfo.prmVer)>=9000)
					{
						NULL;
					}
					else
					{
						TS_HangUp(gbl.dPosInfo);
					}
				}
				break;
			case 88:	//TPK签到
				ret = logonHdl(1);
				if(ret == 0)
					TS_OutPutMsg(gbl.dPosInfo, "\n网络繁忙[8088]\n请稍候再试!\n或按【Ctrl+H】联系在线客服中心 或致电400-80-11888咨询\n   按【确认】返回", 0,iSelect);
				else{
					CDB::setEposLogonStatus(4, gbl.pos_no);
					TS_OutPutMsg(gbl.dPosInfo, "\n网络繁忙[8088]\n请稍候再试!\n或按【Ctrl+H】联系在线客服中心 或致电400-80-11888咨询", 0,iSelect);
					if(atoi(gbl.dPosInfo.prmVer)>=9000)
					{
						NULL;
					}
					else
					{
						TS_HangUp(gbl.dPosInfo);
					}
				}
				break;
			case 89:	//完整签到
				ret = logonHdl(4);
				if(ret == 0)
					TS_OutPutMsg(gbl.dPosInfo, "\n网络繁忙[8089]\n请稍候再试!\n或按【Ctrl+H】联系在线客服中心 或致电400-80-11888咨询\n   按【确认】返回", 0,iSelect);
				else{
					CDB::setEposLogonStatus(3, gbl.pos_no);
					TS_OutPutMsg(gbl.dPosInfo, "\n网络繁忙[8089]\n请稍候再试!\n或按【Ctrl+H】联系在线客服中心 或致电400-80-11888咨询", 0,iSelect);
					if(atoi(gbl.dPosInfo.prmVer)>=9000)
					{
						NULL;
					}
					else
					{
						TS_HangUp(gbl.dPosInfo);
					}
				}
				break;
			case 90:	//TMK签到
				ret = logonHdl(9);
				if(ret == 0)
					TS_OutPutMsg(gbl.dPosInfo, "\n客户端故障，请换机再试\n   按【确认】返回", 0,iSelect);
				else{
					CDB::setEposLogonStatus(2, gbl.pos_no);
					TS_OutPutMsg(gbl.dPosInfo, "\n客户端故障，请换机再试", 0,iSelect);
					if(atoi(gbl.dPosInfo.prmVer)>=9000)
					{
						NULL;
					}
					else
					{
						TS_HangUp(gbl.dPosInfo);
					}
				}
				break;
			case 71:
				TS_OutPutMsg(gbl.dPosInfo, "\n冲正中，请稍后再试！\n   按【确认】返回", 0,iSelect);
				break;
			case 75:
			case 81:
			case 85:
				TS_OutPutMsg(gbl.dPosInfo, "\n非法终端，请换机再试！", 0,iSelect);
				CDB::setEposLogonStatus(7, gbl.pos_no);//暂停服务
				if(atoi(gbl.dPosInfo.prmVer)>=9000)
				{
					NULL;
				}
				else
				{
					TS_HangUp(gbl.dPosInfo);
				}
				break;
			default:
				TS_OutPutMsg(gbl.dPosInfo, "\n网络繁忙，请稍后再试\n   按【确认】返回", 0,iSelect);
				break;
			}
			return 0;
		}
		//--------------------------------------------------------------------------------------------------------------
		for(i = 0; i < fail_message.size(); i++)
		{
			if(!strcmp(party_code, fail_message[i].party_code) && !strcmp(correct_code, fail_message[i].bit62_rsp))
			{
				strcpy(message, fail_message[i].busi_desc);
				break;
			}
		}
	}
	else
	{
		if(atoi(temp) == 87 && !gbl.posInfo.enyFlag)
			logonHdl();

		memcpy(party_code,&pack.FIELD62[1],6);
		
		for(i = 0; i < fail_message.size(); i++)
		{
			if(!memcmp(response_code, fail_message[i].bit39_rsp, 2))
			{
				strcpy(message, fail_message[i].busi_desc);
				if(!strcmp(party_code, fail_message[i].party_code))
				{
					strcpy(message, fail_message[i].busi_desc);
					break;
				}
			}
		}
	}
	
	if(strlen(message) < 3)
	{
		if(atoi(temp) == 99)
			TS_OutPutMsg(gbl.dPosInfo, "羊城通充值成功未确认，请重新打开iPos进行确认\n   按【确认】返回", 0,iSelect);
		else
		{
		     TS_OutPutMsg(gbl.dPosInfo, "\n网络繁忙，请稍后再试\n   按【确认】返回", 0,iSelect);
		}
	}
	else
	{
		TS_OutPutMsg(gbl.dPosInfo, message, 0,iSelect);
	}
	
	return 0;
}

int CTrade::mblTrade()		//移动交易
{
	int iSelect,iRet=0;
	
	iSelect = mblInqHdl();
	if(iSelect==0)
		iRet = mblPayHdl();
	return iRet;
}

int CTrade::mblInqHdl()	//移动查询
{
	int  iRet,password_len;
	char tmp[256], mbl_password[8+1];
	
	wrLog("移动【查询】");	
	strcpy(gbl.fee_type,"3012");
	
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, "移动话费");
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 2;
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入手机号码：");	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
	tradeInfoSend.Contents[0].uCount = 0;		//输入1次电话号码		
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
	tradeInfoSend.Contents[0].uMinLen = 11;		
	tradeInfoSend.Contents[0].uMaxLen = 11;	
	
	strcpy(tradeInfoSend.Contents[1].acTitle, "请输入密码：");	
	tradeInfoSend.Contents[1].uCount = 0;		//输入1次
	tradeInfoSend.Contents[1].uTimeOut = EPOS_OVER_TIME;	//超时30秒
	tradeInfoSend.Contents[1].uMinLen = 6;		
	tradeInfoSend.Contents[1].uMaxLen = 8;
	if(!gbl.posInfo.enyFlag)	//加密改造，旧加密体系
	{
		tradeInfoSend.Contents[1].uCommand = TS_INPUT_PWD;	//密码(明文)
	}
	else
	{
		tradeInfoSend.Contents[1].uCommand = TS_INPUT_PWD;	//密码
		tradeInfoSend.Contents[1].uCardType = CARD_TYPE;	//大卡加密，修改密码标志
		tradeInfoSend.Contents[1].uDesMode = TS_DES_3_TEK_ENC;		//3次des
		tradeInfoSend.Contents[1].uKeyIndex = TS_TEK_KEY;	//密钥组号 
	}
	
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	
	bbzero(gbl.pos_serial);
	strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
	gbl.phone_len = tradeInfoRecv.Contents[0].uMsgLen;
	bbzero( gbl.phone_no );
	strcpy( gbl.phone_no,(char *)tradeInfoRecv.Contents[0].uMsg );
	bbzero( mbl_password );
	if(!gbl.posInfo.enyFlag)	//加密改造，旧加密体系
	{
		bbzero(tmp);
		strcpy(tmp, (char *)tradeInfoRecv.Contents[1].uMsg );
		CTools::Encrypt(tmp, mbl_password, 0);
	}
	else
		memcpy(mbl_password, (char *)tradeInfoRecv.Contents[1].uMsg, tradeInfoRecv.Contents[1].uMsgLen);
	password_len = tradeInfoRecv.Contents[1].uMsgLen;
	wrLog("移动手机号码:[%s]", gbl.phone_no);
	//写查询域
	pack.wrField(1, gbl);
	/************修改一些域*********/
	if(!gbl.posInfo.enyFlag){
		memcpy(pack.FIELD48 + pack.Packet_Table[48].Real_Length, mbl_password, password_len);
		pack.Packet_Table[48].Real_Length += password_len;
	}
	//加密机
	if(gbl.posInfo.enyFlag)		//加密改造
	{
		memcpy(pack.FIELD48 + pack.Packet_Table[48].Real_Length, mbl_password, password_len);
		pack.Packet_Table[48].Real_Length += password_len;
		pack.FIELD46[0] = 0x39;
		pack.FIELD46[1] = 0x64;
		pack.Packet_Table[46].Real_Length = 2;
		memcpy((char *)pack.FIELD53, gbl.posInfo.psamNum, 8);
		pack.Packet_Table[53].Real_Length = 8;
	}
	/*******************************/
	//  查询包打包
	iRet = packHdl(1);
	if(iRet < 0)
		return -1;
	
	return 0;
}


//返回值：
//0，确认；
//小于0：取消
//2：交预付费；
int CTrade::mblInqMsg()	//移动查询返回
{
	int b63_offset;
	char temp_buff[2048],len_buff[10],realMny[20],agoMny[20],preMny[20],amoMny[20];
	char response_code[3];
	int temp_len,i,j,iSelect;
	
	memset(gbl.user_name,0,sizeof(gbl.user_name));
	memset(len_buff,0,sizeof(len_buff));
	memset(response_code,0,sizeof(response_code));
	
	memcpy(response_code,pack.FIELD39,2);
	b63_offset =0;
	wrLog("移动response_code:%s",response_code);
	if (!memcmp(response_code,"00",2))		//查询成功
	{
		//	memset(pack.FIELD4, 0, sizeof(pack.FIELD4));
		wrHex("bit4",pack.FIELD4, 6);
		memset(gbl.real_fee_buffer, 0, sizeof(gbl.real_fee_buffer));//实时话费
		CTools::byte_to_hex(pack.FIELD4, (BYTE *)gbl.real_fee_buffer, 6);
		wrLog("gbl.real_fee_buffer:[%s]",gbl.real_fee_buffer);
		memset(realMny,0,sizeof(realMny));
		CTools::chgToMny(gbl.real_fee_buffer,realMny);
		
		memset(temp_buff,0,sizeof(temp_buff));
		memcpy(temp_buff,pack.FIELD63+b63_offset,1);
		b63_offset +=1;
		CTools::byte_to_hex((BYTE *)temp_buff, (BYTE *)len_buff, 1);
		wrLog("姓名长度：%s",len_buff);
		gbl.user_name_len =atol(len_buff);
		memcpy(gbl.user_name, pack.FIELD63 + b63_offset, gbl.user_name_len);
		wrLog("姓名：%s",gbl.user_name);
		b63_offset += gbl.user_name_len;
		
		memset(temp_buff,0,sizeof(temp_buff));
		memset(len_buff,0,sizeof(len_buff));
		memcpy(temp_buff,pack.FIELD63 + b63_offset, 1);
		b63_offset +=1;
		CTools::byte_to_hex((BYTE *)temp_buff, (BYTE *)len_buff, 1);
		wrLog("欠费数目： %s",len_buff);	
		j =atol(len_buff);
		if (j==0)
		{
			TS_OutPutMsg(gbl.dPosInfo, "	\n\n  	该电话无欠费！【确认】交预付费\n【返回】返回", 0,iSelect);
			if(iSelect != 0)
				return -1;
			else 
				return 2;	//返回2表示交预付费
		}
		else
		{
			memset(gbl.ago_fee_buffer,0,sizeof(gbl.ago_fee_buffer));
			memset(gbl.pre_fee_buffer,0,sizeof(gbl.pre_fee_buffer));
			memset(gbl.amount,0,sizeof(gbl.amount));
			for (i=0;i<j;i++)
			{
				memset(temp_buff,0,sizeof(temp_buff));
				memset(len_buff,0,sizeof(len_buff));
				memcpy(temp_buff,pack.FIELD63 + b63_offset,1);
				b63_offset += 1;
				CTools::byte_to_hex( (BYTE *)temp_buff, (BYTE *)len_buff, 1);
				
				memset(temp_buff,0,sizeof(temp_buff));
				memcpy(temp_buff, pack.FIELD63+b63_offset,6);
				b63_offset +=6;
				char detail_buffer[12+1];
				bbzero(detail_buffer);
				CTools::byte_to_hex( (BYTE *)temp_buff, (BYTE *)detail_buffer, 6);	//"费用金额" gbl.detail_buffer
				
				temp_len =0;
				temp_len =atol(len_buff);
				switch (temp_len) 
				{
					/*     往月欠费    */
				case 1:
					memcpy(gbl.ago_fee_buffer,detail_buffer,12);
					break;
					/*     当前预付费      */
				case 2:
					memcpy(gbl.pre_fee_buffer,detail_buffer,12);
					break;
					/*     应交话费    */
				case 3:
					memcpy(gbl.amount,detail_buffer,12);
					break;
				}
			}/* end for */
			
			memset(agoMny,0,sizeof(realMny));
			memset(preMny,0,sizeof(preMny));
			memset(amoMny,0,sizeof(amoMny));
			CTools::chgToMny(gbl.ago_fee_buffer,agoMny);
			CTools::chgToMny(gbl.pre_fee_buffer,preMny);
			CTools::chgToMny(gbl.amount, amoMny);
			wrLog("gbl.amount:[-%s-]", gbl.amount);			
			memset(temp_buff,0,sizeof(temp_buff));
			if(!memcmp(gbl.real_fee_buffer, "000000000000",12) && strcmp(gbl.amount,""))
				sprintf(temp_buff,"用户名：%s\n往月欠费：%s\n当前预付费：%s\n应交话费：%s\n按【确认】交费",gbl.user_name,agoMny,preMny,amoMny);
			else if(!strcmp(gbl.amount,"") || !strcmp(gbl.amount,"000000000000"))
				sprintf(temp_buff,"用户名：%s\n往月欠费：%s\n当前预付费：%s\n应交话费：%s\n按【确认】交预付费",gbl.user_name,agoMny,preMny,amoMny);
			else
				sprintf(temp_buff,"用户名：%s\n往月欠费：%s\n当前预付费：%s\n实时话费：%s\n应交话费：%s\n按【确认】交费",gbl.user_name,agoMny,preMny,realMny,amoMny);
			TS_OutPutMsg(gbl.dPosInfo, temp_buff, 0,iSelect);
			if(iSelect == 0)
			{
				if(!strcmp(gbl.amount,"") || !strcmp(gbl.amount,"000000000000"))	//返回2表示交预付费
					return 2;
			}
			else
				return CANCLE_KEY;
			return iSelect;
		}
	}
	else
	{
		returnFail(response_code);
		return -1;
	}
}

int CTrade::mblPayHdl()	//移动交费
{
	int  iRet, flag;
	int  iSelect;
	char tmp[256],mny[12];
	char response_code[3];
	
	strcpy(gbl.fee_type,"3012");
	wrLog("移动【交费】");
	//返回终端数据
    iRet =  mblInqMsg();
	if(iRet < 0)
		return -1;
	else if(iRet == CANCLE_KEY)
		return CANCLE_KEY;
	if(iRet == 2)	//只交预付费，没有欠费
	{
		iRet = selectAmount();
		if((iRet < 0) || (iRet == CANCLE_KEY))
			return -1;
		gbl.mbl_flag = 0;
	}
	else	//有欠费
	{
		iRet = selectAmount( 2);
		if((iRet < 0) || (iRet == CANCLE_KEY))
			return -1;
		if(iRet == 1)	//交欠费
		{
			gbl.mbl_flag = 1;
		}
		else if(iRet == 2) //交预付费
		{
			iRet = selectAmount();	//选择预付费金额
			if((iRet < 0) || (iRet == CANCLE_KEY))
				return -1;
			wrLog("gbl.amount:[%s]",gbl.amount);		
			memset(mny, 0, sizeof(mny));
			CTools::chgToMny(gbl.amount,mny);
			memset(tmp, 0, sizeof(tmp));
			sprintf(tmp,"您共需缴费%s\n【确认】继续\n【返回】返回",mny);
			TS_OutPutMsg(gbl.dPosInfo, tmp, 0,iSelect);
			if(iSelect)
				return 0;
			gbl.mbl_flag = 2;
		}
	}
	wrLog("tmp_pre_amount:[-%s-]",gbl.tmp_pre_amount);
	flag = 0;
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{	
		if(!flag)
		{
			iRet = mngCard_Hdl("中国移动");
			if(iRet == CANCLE_KEY)
				return CANCLE_KEY;
			else if(iRet != 0)
				return -1;
		}
		pack.wrField(2, gbl);	//写交费域
		/**************修改域48****************/
		memcpy(pack.FIELD48,"3002",4);
		/**************************************/
		
		iRet = packHdl(2);
		if(iRet < 0)
			return -1;
		
		memset(response_code,0,sizeof(response_code));
		memcpy(response_code,pack.FIELD39,2);
		if (!memcmp(response_code,"00",2)) 
		{
			iRet = TS_OutPutMsg(gbl.dPosInfo,"     交费成功！\n    谢谢您的使用\n请按【确认】打印发票",0,iSelect);
			if(iRet!=0 || iSelect==0)
			{
				CPrint prt;
				prt.set_in_par(gbl);
				if( gbl.mbl_flag )
					//prt.print_detail(1, "移动话费");	//打印欠费明细
					prt.print_pym_detail(pack, "移动话费");
				else
				//	prt.print_detail(2, "移动话费(预付费)");	 //打印预付费明细
					prt.print_pre_detail(pack,"移动话费(预付费)");
			}
			return 0;
		}
		else if(!memcmp(response_code,"55",2))
		{
			flag = 1;
			if(reGetPwd( "中国移动") == 0) //密码错误，重新输入密码, 2006-10-25
				continue;
			else
				return CANCLE_KEY;
		}
		else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
			if (iSelect!=0)
			{
				return -1;
			}else
				continue;
		}
		else
			returnFail(response_code);
		return 1;
	}
	return -1;
}


/*************************************************************/
//东莞移动全球通充值
/*************************************************************/
int CTrade::mblTrade_pre(const char *title)
{
	int iRet, flag = 1, iSelect,b63_offset=0;
	char response_code[3],mbl_pp_type[2+1],mbl_pp_name[32];
	char amoMny[15], msg[200];
	char tmp[100],len_buff[10],phone_buff[15], phone_area[10];
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	
	wrLog("【东莞移动直充】");
	strcpy(gbl.fee_type, "0176");
	/*====================查询==================*/
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	strcpy(tradeInfoSend.acMainTitle, title);
	tradeInfoSend.uHasTradeID = 1; //返回终端流水
	tradeInfoSend.uTotalContents = 1;	//项数
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入手机号码");	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字	
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
	tradeInfoSend.Contents[0].uMinLen = 11;		
	tradeInfoSend.Contents[0].uMaxLen = 11;	
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	
	bbzero(gbl.pos_serial);
	strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
	gbl.phone_len = tradeInfoRecv.Contents[0].uMsgLen;
	bbzero( gbl.phone_no );
	strcpy( gbl.phone_no,(char *)tradeInfoRecv.Contents[0].uMsg );
	
	bbzero(phone_area);
	
	if(gbl.phone_no[0]=='1')//如果是手机
	{
		bbzero(gbl.phone_province);
		bbzero(gbl.phone_city);
		iRet=CDB::phone_district_qry(gbl.phone_no,gbl.phone_province,gbl.phone_city,&gbl.phone_owner);
		if(iRet !=0) //如果不是广东号码。
		{
			
			TS_OutPutMsg(gbl.dPosInfo,"\n\n该号码不属于广东地区\n   请更换号码再试",0,iSelect);

			return -1;
		}
		else
		{
		
			if (gbl.phone_owner!=2) //如果不是广东移动号码
			{
				TS_OutPutMsg(gbl.dPosInfo,"\n\n该业务支持移动号码充值，请输入移动号码",0,iSelect);
				return -1;
			}
		}

		strcpy(phone_area,gbl.phone_city);
	}
	
	
	//写查询域
	pack.wrField(1, gbl);
	
	
	//包处理
	iRet = packHdl(1);
	if(iRet < 0)
		return -1;
	bbzero(response_code);
	memcpy(response_code,pack.FIELD39,2);
	if(atoi(response_code) != 0)  //返回错误
	{
		TS_OutPutMsg(gbl.dPosInfo, " \n\n 查询错误！请重试！", 1, iSelect);
		return -1;
	}
	
	if (!memcmp(response_code,"00",2))		//查询成功
	{   
		bbzero(gbl.stan_no);
		memcpy(gbl.stan_no, (char *)pack.FIELD37, 12);
        bbzero(mbl_pp_name);
		bbzero(mbl_pp_type);
		memcpy(mbl_pp_type, (char *)pack.FIELD63, 2);
		bbzero(len_buff);
		memcpy(len_buff, (char *)pack.FIELD63+2, 2);
		if (memcmp(mbl_pp_type,"01",2)==0)
		{
			strcpy(mbl_pp_name, "全球通");
		}else if (memcmp(mbl_pp_type,"02",2)==0)
		{
			strcpy(mbl_pp_name, "神州行");
		}else if (memcmp(mbl_pp_type,"03",2)==0)
		{
			strcpy(mbl_pp_name, "动感地带");
		}else 
			strcpy(mbl_pp_name, "中国移动");
	}
	
	/*====================交费==================*/
	
	iRet = selectAmount();
	if(iRet==CANCLE_KEY)
		return CANCLE_KEY;
	else if(iRet < 0)
		return -1;
	
	
	//刷卡交费
	if(atoi(gbl.dPosInfo.prmVer)>=9000)
	{
		bbzero(amoMny);
		CTools::chgToMny(gbl.amount,amoMny);
		bbzero(msg);
		bbzero(phone_buff);
		memcpy(phone_buff,gbl.phone_no,3);
		strcat(phone_buff,"-");
		memcpy(phone_buff+4,gbl.phone_no+3,4);
		strcat(phone_buff,"-");
		memcpy(phone_buff+9,gbl.phone_no+7,4);
		sprintf(msg, "用户类型：%s\n用户号码：%s\t%s\n充值金额：%s\n\n【是 Enter】  【否 Esc】", mbl_pp_name,phone_area,phone_buff,amoMny);
		iRet = TS_OutPutMsg(gbl.dPosInfo, msg, 0, iSelect);
		if(iSelect)
		{
			return -1;
		}
	}else{
		bbzero(amoMny);
		CTools::chgToMny(gbl.amount,amoMny);
		bbzero(msg);
		sprintf(msg, "用户类型：%s\n用户号码：%s\t%s\n充值金额：%s\n按【确认】充值\n按【返回】返回", mbl_pp_name,phone_area,gbl.phone_no,amoMny);
		iRet = TS_OutPutMsg(gbl.dPosInfo, msg, 0, iSelect);
		if(iSelect)
		{
			return -1;
		}
	}
	flag = 0;
	for(int icount=0; icount<MAXTRY;  icount++)
	{
		if(!flag)
		{
			iRet = mngCard_Hdl(title);
			if(iRet == CANCLE_KEY)
				return CANCLE_KEY;
			else if(iRet != 0)
				return -1;
		}
		pack.wrField(2, gbl);	//写交费域
		/**************修改域55****************/
		bbzero(pack.FIELD55);
		memcpy(pack.FIELD55,gbl.stan_no,12);
		memcpy(pack.FIELD55+12,"011",3);
		pack.Packet_Table[55].Real_Length=15;
		bbzero(pack.FIELD48);
		memcpy(pack.FIELD48,gbl.fee_type,4);
		bbzero(len_buff);
		sprintf(len_buff,"%02d",gbl.phone_len+2);
		memcpy(pack.FIELD48+4,len_buff,2);
		memcpy(pack.FIELD48+6,gbl.phone_no,gbl.phone_len);
		memcpy(pack.FIELD48+6+gbl.phone_len,mbl_pp_type,2);
		pack.Packet_Table[48].Real_Length=8+gbl.phone_len;
		/**************************************/
		
		iRet = packHdl(2);
		if(iRet < 0)
			return -1;
		
		memset(response_code,0,sizeof(response_code));
		memcpy(response_code,pack.FIELD39,2);
		if (!memcmp(response_code,"00",2)) 
		{   
			memset(tmp,0,sizeof(tmp));
			//			if (gbl.tgroup == 7)
			//			{
			strcpy(tmp, "     充值成功！\n\n\n【确认】打印票据\n【挂断】退出");
			//			}else
			//				sprintf(tmp, "     充值成功！\n您充值后的余额为：\n%s\n【确认】打印票据\n【挂断】退出", mny);
			TS_OutPutMsg(gbl.dPosInfo,tmp, 0, iSelect);
			if(iSelect==0)
			{
				CPrint prt;
				prt.set_in_par(gbl);
			//	prt.print_detail(2,title);
				prt.print_pre_detail(pack,title);
			}
			return 0;
		}
		else if(!memcmp(response_code,"55",2))
		{
			flag = 1;
			if(reGetPwd( title) == 0) //密码错误，重新输入密码, 2006-10-25
				continue;
			else
				return CANCLE_KEY;
		}
		else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
			if (iSelect!=0)
			{
				return -1;
			}else
				continue;
		}
		else
			returnFail(response_code);
		return 1;
	}
	
	return 0;
}

int CTrade::uniTrade()		//联通交易
{
	int iSelect,iRet=0;
	iSelect = uniInqHdl();
	if(iSelect==0)
		iRet = uniPayHdl();
	return iRet;
}

int CTrade::uniInqHdl()	//联通查询
{
	int  iRet;
	int  b48_len;
	
	wrLog("联通【查询】");	
	strcpy(gbl.fee_type,"0049");
	
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, "联通话费");
	
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入手机号码：");	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
	tradeInfoSend.Contents[0].uCount = 0;		//输入1次电话号码		
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
	tradeInfoSend.Contents[0].uMinLen = 11;		
	tradeInfoSend.Contents[0].uMaxLen = 11;	
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	
	memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
	strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
	gbl.phone_len = tradeInfoRecv.Contents[0].uMsgLen;
	memset( gbl.phone_no,0,sizeof(gbl.phone_no) );
	strcpy( gbl.phone_no,(char *)tradeInfoRecv.Contents[0].uMsg );
	wrLog("联通手机号码:[%s]", gbl.phone_no);
	
	//写查询域
	pack.wrField(1, gbl);
	/************修改一些域*********/
	b48_len = pack.Packet_Table[48].Real_Length;
	memcpy(pack.FIELD48+b48_len,gbl.uni_flag,1);
	b48_len +=1;
	memcpy(pack.FIELD48+b48_len,gbl.sub_code,2);
	b48_len +=2;
	wrLog("bit48:[%s]",pack.FIELD48);
	pack.Packet_Table[48].Real_Length = b48_len;
	/*******************************/
	
	//  查询包打包   
	iRet = packHdl(1);
	if(iRet < 0)
		return -1;
	//返回终端数据
	iRet =  uniInqMsg();
	return iRet;
}

//联通下传信息
int CTrade::uniInqMsg()	
{
	char temp_buff[2048],len_buff[10],preMny[20],amoMny[20],realMny[20];
	char response_code[3];
	int iSelect;
	
	memset(response_code,0,sizeof(response_code));
	memcpy(response_code,pack.FIELD39,2);
	//	wrLog("联通response_code:%s",response_code);
	if (!memcmp(response_code,"00",2)) 
	{
		CPrint prt;
		prt.set_in_par(gbl);
		if( prt.rdField63(gbl) )	//保留查询返回信息供打印和显示信息用
			return -1;
		memset(gbl.amount,0,sizeof(gbl.amount));
		CTools::byte_to_hex(pack.FIELD4, (BYTE *)gbl.amount, 6);
		
		memset(len_buff,0,sizeof(len_buff));
		memcpy(len_buff,pack.FIELD48+4,2);
		gbl.phone_len =atol(len_buff);
		memset(gbl.phone_no,0,sizeof(gbl.phone_no));
		memcpy(gbl.phone_no,pack.FIELD48+6,gbl.phone_len);
		
		memset(preMny,0,sizeof(preMny));
		memset(realMny,0,sizeof(realMny));
		memset(amoMny,0,sizeof(amoMny));
		CTools::chgToMny(gbl.amount,amoMny);
		CTools::chgToMny(gbl.pre_fee_buffer,preMny);
		CTools::chgToMny(gbl.real_fee_buffer,realMny);
		
		memset(temp_buff,0,sizeof(temp_buff));
		if(atoi(gbl.uni_flag)) //预付费
			sprintf(temp_buff,"用户名：%s\n预付费余额：%s\n实时话费：%s\n【确认】交费\n【返回】返回",gbl.user_name,preMny,realMny);
		else
			sprintf(temp_buff,"用户名：%s\n欠费：%s\n【确认】交费\n【返回】返回",gbl.user_name,amoMny);
		
		TS_OutPutMsg(gbl.dPosInfo, temp_buff, 0,iSelect);
		
		return iSelect;
	}//end if (!memcmp(response_code,"00",2)) 
	else
	{
		returnFail(response_code);
		return -1;
	}
}

int CTrade::uniPayHdl()	//联通交费
{
	int  iRet, iSelect, flag;
	int  b48_len;
	char tmp[256];
	char response_code[3];
	char len_buff[10];
	
	wrLog("联通【交费】");
	if(atoi(gbl.uni_flag))
	{
		iRet = selectAmount();
		if((iRet < 0) || (iRet == CANCLE_KEY))
			return CANCLE_KEY;
		else if(iRet < 0)
			return -1;
	}
	
	/************刷卡****************/
	flag = 0;
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{
		if(!flag)
		{
			iRet = mngCard_Hdl("中国联通");
			if(iRet == CANCLE_KEY)
				return CANCLE_KEY;
			else if(iRet != 0)
				return -1;
		}
		pack.wrField(2, gbl);	//写交费域
		/**************修改一些域**************/
		bbzero(pack.FIELD48);
		bbzero(len_buff);
		sprintf(len_buff,"%02d",gbl.pay_no_len);
		memcpy(pack.FIELD48,gbl.fee_type,4);
		b48_len =4;
		memcpy(pack.FIELD48+b48_len,len_buff,2);
		b48_len +=2;
		memcpy(pack.FIELD48+b48_len,gbl.pay_no,gbl.pay_no_len);
		b48_len +=gbl.pay_no_len;
		memcpy(pack.FIELD48+b48_len,gbl.uni_flag,1);
		b48_len +=1;
		memcpy(pack.FIELD48+b48_len,gbl.sub_code,2);
		b48_len +=2;
		memset(pack.FIELD48+b48_len,'A',1);
		b48_len +=1;
		pack.Packet_Table[48].Real_Length=b48_len;
		/**************************************/
		//交费包
		iRet = packHdl(2);
		if(iRet < 0)
			return -1;
		
		memset(response_code,0,sizeof(response_code));
		memcpy(response_code,pack.FIELD39,2);
		if (!memcmp(response_code,"00",2)) 
		{
			iRet = TS_OutPutMsg(gbl.dPosInfo,"     交费成功！\n    谢谢您的使用\n请按【确认】打印发票",0,iSelect);
			if(iRet!=0 || iSelect==0)
			{
				CPrint prt;
				prt.set_in_par(gbl);
				if(atoi(gbl.uni_flag))
				{
					memset(tmp, 0, sizeof(tmp));
					if(atoi(gbl.sub_code) == 1)
						strcpy(tmp,"联通预付费(GSM)");
					if(atoi(gbl.sub_code) == 2)
						strcpy(tmp,"联通预付费(CDMA)");
					if(atoi(gbl.sub_code) == 3)
						strcpy(tmp,"联通预付费(193/17911)");
					
					//prt.print_detail(2, tmp);	 //打印预付费明细
					prt.print_pre_detail(pack,tmp);
				}
				else
				//	prt.print_detail(1, "联通话费");	//打印欠费明细
					prt.print_pym_detail(pack,"联通话费");
				
			}
			return 0;
		}
		else if(!memcmp(response_code,"55",2))
		{
			flag = 1;
			if(reGetPwd( "中国联通") == 0) //密码错误，重新输入密码, 2006-10-25
				continue;
			else
				return CANCLE_KEY;
		}
		else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
			if (iSelect!=0)
			{
				return -1;
			}else
				continue;
		}
		else
			returnFail(response_code);
		return 1;	
	}
	return -1;
}

int CTrade::cardno_fee(char bank[6+1], char *fee_type, char *acc_city_no, int pos_type)
{
	int i, iSelect;
	char mybank[6+1];
	
	if (memcmp(gbl.pos_no+1,"8",1)==0)
	{
		wrLog("【东莞所有银行卡走银联】");
		if(strcmp(gbl.bank,"105810")!=0){	//非e卡
			gbl.key_num = 8;
			strcpy(gbl.bank,"305810");
			bbzero(mybank);
			strcpy(mybank,"305810");
		}else{
			bbzero(mybank);
			memcpy(mybank,bank,sizeof(mybank));
		}
	}else{
		bbzero(mybank);
		memcpy(mybank,bank,sizeof(mybank));
	}
	
	
	if( !memcmp(fee_type, "-1", 2) ) //第一次刷卡
		return 0;
	
	if( CDB::isLock() )
		return -1;
	
	if(!strcmp(fee_type, "0184") || !strcmp(fee_type, "0185")|| !strcmp(fee_type, "0238"))  //交行转帐与查询余额
	{
		strcpy(mybank,"600001");
	}
	if(!strcmp(fee_type, "0092") || !strcmp(fee_type, "0210") || !strcmp(gbl.fee_type, "0337") || !strcmp(fee_type, "0099"))	//全省综合收费，交罚
	{
		if(strcmp(mybank,"105810")!=0){	//非e卡
			strcpy(mybank,"305810");
		}
	}
	
	for(i = 0; i< bank_busi.size(); i++)
	{   
		if (gbl.tgroup == 40)
		{
			if( !memcmp(bank_busi[i].bank, mybank, 6) && !memcmp(bank_busi[i].biz_type, fee_type, 4) && memcmp(bank_busi[i].bank, "105810", 6))
				return 0;
		}else{
			if( !memcmp(bank_busi[i].bank, mybank, 6) && !memcmp(bank_busi[i].biz_type, fee_type, 4) && (!strcmp(bank_busi[i].acc_area, "0000") || !strcmp(bank_busi[i].acc_area, gbl.acc_city_no)) && ( bank_busi[i].pos_type==0 || bank_busi[i].pos_type==pos_type) )
				return 0;
		}
	}
	wrLog("本业务不支持该卡 bank[%s]--biz_type[%s]--acc_area[%s]--pos_type[%d]",mybank,fee_type,acc_city_no,pos_type);
	TS_OutPutMsg(gbl.dPosInfo, " \n 本业务不支持该卡！\n  按【确认】重新刷卡\n  按【返回】返回", 0, iSelect);
	if(iSelect == 0)
		return RE_MNG_CARD;
	else
		
		return -1;
}

//入参：
//biz_flag:1:电信空充;2:移动空充;3:联通空充
//area:物理地区的区号
//accarea:帐户地区的区号（若物理地区的区号不为0000，则帐户地区的区号也不能为0000）
//出参：
//biz_type:业务代码
//返回值：
//0:成功
//-1:失败
int CTrade::get_area_biz(int biz_flag, char *area, char *accarea, char *biz_type)
{
	int iSelect=0,has=0;
	for(int i = 0; i < area_biz.size(); i++)
	{   
		if( area_biz[i].biz_flag==biz_flag && (!strcmp(area_biz[i].area, "0000") || !strcmp(area_biz[i].area, area)) && (!strcmp(area_biz[i].accarea, "0000") || !strcmp(area_biz[i].accarea, accarea)) )
		{
			strcpy(biz_type, area_biz[i].biz_type);
			has=1;
			break;
		}
	}
	
	if(has==1){
		if(area_biz[i].status==1){
			wrLog("业务代码为 biz_type[%s]--biz_flag[%d]--area[%s]--accarea[%s]--status[%d]",biz_type, biz_flag, area, accarea,area_biz[i].status);
			return 0;
		}else{
			wrLog("业务代码状态为关 biz_type[%s]--biz_flag[%d]--area[%s]--accarea[%s]--status[%d]",biz_type, biz_flag, area, accarea,area_biz[i].status);
			TS_OutPutMsg(gbl.dPosInfo, "本业务暂停",0,iSelect);
			return -1;
		}
	}
	else{
		wrLog("没找到相应的业务代码 biz_flag[%d]--area[%s]--accarea[%s]", biz_flag, area, accarea);
		TS_OutPutMsg(gbl.dPosInfo, "本业务未开通",0,iSelect);
		return -1;
	}
	
}

int CTrade::get_favorable_menu(char *area,char *biz_type,int menu[])
{
	int iSelect=0,has=0,j=0;
	for(int i = 0; i < favorable_air_pay.size(); i++)
	{   
		if( strcmp(favorable_air_pay[i].biz_type,biz_type)==0 && strcmp(favorable_air_pay[i].area,area)==0 )
		{
			menu[j]=i;
			j++;
		}
	}
	
	if(j>0)
	{
		
		return j;
	}
	else{
		wrLog("没找到相应的优惠充值菜单 area[%s]--biz_type[%s]",area, biz_type);
		TS_OutPutMsg(gbl.dPosInfo, "本地区暂无优惠直充",0,iSelect);
		return -1;
	}
	
}


/******************取卡密匙组号***************/
int CTrade::get_key_num(char *bank_code)
{
	int i;
	for(i = 0; i < bank_info.size(); i++)
	{
		if( !memcmp(bank_code, bank_info[i].bank, strlen(bank_info[i].bank)) )
		{
			return bank_info[i].key;
		}
	}
	return 8;
}


//查找2磁道的卡信息是否在卡表中，lihk,2006-12-21
//返回值：0，成功，1，失败
//pos: 找到卡信息对应的bank_card数组位置
int CTrade::isTrack2(char *track2, int &pos)
{
	int i;
	for(i = 0; i < bank_card.size(); i++)
	{
		if( !memcmp(track2, bank_card[i].card, bank_card[i].card_len) )
		{
			pos = i;
			return 0;
		}
	}
	return 1;
}

//查找3磁道的卡信息是否在卡表中，lihk,2006-12-21
//返回值：0，成功，1，失败
//pos: 找到卡信息对应的bank_card数组位置
int CTrade::isTrack3(char *track3, int &pos)
{
	int i;
	for(i  =0; i < bank_card.size(); i++)
	{
		if( !memcmp(track3, bank_card[i].card, bank_card[i].card_len) )
		{
			pos = i;
			return 0;
		}
	}
	return 1;
}

int CTrade::bindcard(char *cardno_in, char *cardno_out, int *cardno_out_len){
	int iRet=0, cardno_in_len=0;
	cardno_in_len = strlen(cardno_in);
	if( cardno_in_len>=1 && cardno_in_len<=20 )
	{
		iRet = TS_SetCardNum(&gbl.dPosInfo, cardno_in, (int)gbl.posInfo.inType);
		if( iRet==0 )
		{
			strcpy(cardno_out, cardno_in);
			*cardno_out_len = strlen(cardno_in);
			return 0;
		}
	}
	return -1;
}

//刷卡取得卡信息
//type: 刷卡标题
//title:刷卡提示语（默认：请刷卡）
//minLen: 手输卡号最小长度，默认为12
//maxLen: 手输卡号最大长度，默认为12
//card_info:用来存放刷卡信息
//card_flag:
//ONLY_MNG(0)，只刷卡(默认)
//ONLY_INPUT(1), 只输卡号
//MNG_OR_INPUT(2), 刷卡或输卡号(所有卡)
//pay_flag:	刷卡交费流程标志By:KF 06.11.09
//MNG_ONE(0默认):一次刷卡输密码连续交费(默认), 取此值时进入函数不需刷卡，只输密码
//MNG_MUL(1):每次交费都刷卡, 取此值时进入函数需要刷卡
//MNG_ONE_BIND(2):一次刷卡输密码连续交费(可用绑定e卡或刷银行卡)
//MNG_MUL_BIND(3):每次交费都刷卡(可用绑定e卡或刷银行卡), 取此值时进入函数需要刷卡
//MNG_ONE_BIND_E(4):一次刷卡输密码连续交费(用绑定e卡)
//MNG_MUL_BIND_E(5):每次交费都刷卡(可用绑定e卡), 取此值时进入函数需要刷卡
int CTrade::getCardInfo(const char *type, char *card_info, int card_flag, int pay_flag, const char *title, int minLen, int maxLen)
{
	int iRet=0, bind_flag=0, iSelect=0;//bind_flag 0:不绑定
	char msgStr[200];
	
	wrLog("【getCardInfo】card_flag[%d] pay_flag[%d]", card_flag, pay_flag);
	
	if( pay_flag == MNG_ONE_BIND || pay_flag == MNG_MUL_BIND )//可以用绑定的卡
	{
		if(strlen(gbl.mer_ecard)!=0){
			bind_flag = 1;
			TSMENULIST menuList;
			memset(&menuList,0,sizeof(menuList));
			menuList.iTotalNum = 3;
			strcpy(menuList.acTitle, "请选择交费卡类型");
			strcpy(menuList.menuItem[0], "终端绑定的e卡");
			strcpy(menuList.menuItem[1], "银行卡");
			strcpy(menuList.menuItem[2], "退出");
			iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
			if((iRet < 0) || (iRet == CANCLE_KEY))
				return CANCLE_KEY;
			else if(iRet < 0)
				return -1;
			
			if(iSelect==1)
				bind_flag = 1;
			else
				bind_flag = 0;
		}else{
			TS_OutPutMsg(gbl.dPosInfo,"   e卡卡号为空\n  绑定e卡卡号出错!",1,iSelect);
			return CANCLE_KEY;
		}
	}
	else if( pay_flag == MNG_ONE_BIND_E || pay_flag == MNG_MUL_BIND_E )//用绑定的e卡
	{		
		if(strlen(gbl.mer_ecard)!=0){
			bind_flag = 1;
		}else{
			TS_OutPutMsg(gbl.dPosInfo,"   e卡卡号为空\n  绑定e卡卡号出错!",1,iSelect);
			return CANCLE_KEY;
		}
	}
	else{
		bind_flag = 0;
	}
	
	if( bind_flag == 1 ){//用绑定的卡
		iRet = bindcard(gbl.mer_ecard, gbl.card_no, &gbl.card_no_len);				//下发绑定卡号
		if(iRet != 0)
		{
			TS_OutPutMsg(gbl.dPosInfo,"绑定e卡卡号出错!",1,iSelect);
			return iRet;
		}else{
			bbzero(msgStr);
			if(atoi(gbl.dPosInfo.prmVer)>=9000)
			{
				NULL;
			}
			else
			{
				if(strcmp(gbl.curworkid,"00000000"))
				{
					sprintf(msgStr,"您使用的e卡卡号是\n%s\n当前工号:%s\n   按【确认】继续\n   按【返回】返回",gbl.card_no,gbl.curworkid);
				}else{
					sprintf(msgStr,"您使用的e卡卡号是\n%s\n   按【确认】继续\n   按【返回】返回",gbl.card_no);
				}		
				TS_OutPutMsg(gbl.dPosInfo, msgStr, 0, iSelect);
				if(iSelect != 0)
					return CANCLE_KEY;
			}
		}
		sprintf(card_info,"99%sD0000520200024FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF",gbl.card_no);
	}
	else if( bind_flag == 0 )
	{
		TSTradeInfoSend tradeInfoSend;
		TSTradeInfoRecv tradeInfoRecv; 
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
		
		strcpy(tradeInfoSend.acMainTitle, type);
		tradeInfoSend.uTotalContents = 1;	
		tradeInfoSend.uHasTradeID = 1;
		
		tradeInfoSend.Contents[0].uCount = 0;
		tradeInfoSend.Contents[0].uDesMode = TS_NO_ENC;		//不加密
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
		
		if(card_flag==ONLY_INPUT)  //只输卡号
		{
			strcpy(tradeInfoSend.Contents[0].acTitle, title);
			tradeInfoSend.Contents[0].uCommand = TS_INPUT_CARD;	//手输卡号
			tradeInfoSend.Contents[0].uMaxLen = maxLen;
			tradeInfoSend.Contents[0].uMinLen = minLen;
		}
		else if(card_flag==MNG_OR_INPUT)	//如果是既可刷卡又可输卡号的形式
		{
			strcpy(tradeInfoSend.Contents[0].acTitle, title);
			tradeInfoSend.Contents[0].uCommand = TS_MAG_INPUT_CARD;	//刷卡或输卡号
			tradeInfoSend.Contents[0].uMaxLen = maxLen;
			tradeInfoSend.Contents[0].uMinLen = minLen;
		}
		else	//只刷卡
		{
			strcpy(tradeInfoSend.Contents[0].acTitle, title);
			tradeInfoSend.Contents[0].uCommand = TS_MAG_CARD;	//刷卡
		}
		
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		
		if(iRet != 0)
		{
			wrLog("#TS_TradeControl返回错误[%d]", iRet);
			wrMonitorLog(2, 1, iRet, gbl, pack);	//监控日志
			if(iRet == 1)
				return CANCLE_KEY;
			else
				return iRet;
		}
		
		memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
		strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
		//平台测试整改(不记录磁道信息)
		//wrLog("磁道信息tradeInfoRecv[%d]：[%s]", tradeInfoRecv.Contents[0].uMsgLen, tradeInfoRecv.Contents[0].uMsg);
		
		if(tradeInfoSend.Contents[0].uCommand == TS_MAG_INPUT_CARD)	//刷卡或输卡号
		{
			if(tradeInfoRecv.Contents[0].uMsgLen != 142)	//手输卡号
				strcpy(card_info, (char *)tradeInfoRecv.Contents[0].uMsg);
			else		//刷卡
				memcpy(card_info, tradeInfoRecv.Contents[0].uMsg, tradeInfoRecv.Contents[0].uMsgLen);
		}
		else	//刷卡、手输卡号
		{
			memcpy(card_info, tradeInfoRecv.Contents[0].uMsg, tradeInfoRecv.Contents[0].uMsgLen);
		}
	}
	else
	{
		wrLog("CTrade::mngCard bind_flag error[%d]",bind_flag);
		return -1;
	}	
	//平台测试整改(不记录磁道信息)
	//wrLog("磁道信息：[%s]",card_info);	
	return 0;
}

//通过卡信息取得卡号
//card_flag:
//0，只刷卡(默认)
//1, 只输卡号
//2，刷卡或输卡号(所有卡)
int CTrade::getCardNum(char *card_info, int card_flag )
{
	int iSelect, card_info_len, i;
	int pos, ret, flag;
	
	if( ((card_flag==2) && strlen(card_info) < sizeof(gbl.card_no)) || card_flag==1 )//如果输卡号模式
	{
		bbzero(gbl.track2);
		bbzero(gbl.track3);
		gbl.track2_len = 0;
		gbl.track3_len = 0;
		bbzero(gbl.card_no);
		
		gbl.card_no_len = strlen(card_info);
		if(gbl.card_no_len>sizeof(gbl.card_no)-1)
		{
			wrLog("【gbl.card_no_len】长度过大[%d]",gbl.card_no_len);
			gbl.card_no_len = 0;
			return -1;
		}
		strcpy( gbl.card_no, card_info);		
        wrLog("【gbl.card_no】%s",gbl.card_no);
		ret = isTrack2(gbl.card_no, pos);
		if( ret == 0)	//查找成功
		{
			wrLog("【2磁道查找成功】");
			gbl.key_num = get_key_num(bank_card[pos].bank);
			memcpy(gbl.bank, bank_card[pos].bank, sizeof(gbl.bank));
		}
		else{
			gbl.key_num = 8;	//银联
			strcpy(gbl.bank,"305810");
		}
	}
	else  //刷卡、输卡号
	{
		card_info_len = strlen(card_info);
		flag = 0;
		for(i=0; i<card_info_len; i++)	//把'D'变为'='
		{
			if(card_info[i]=='D')
			{
				card_info[i] = '=';
				flag = 1;
			}
		}
		if(!flag)
		{
			TS_OutPutMsg(gbl.dPosInfo," \n     刷卡出错！\n按【确认】重新刷卡\n按【返回】返回",0,iSelect);
			if(iSelect == 0)
				return RE_MNG_CARD;
			else
				return -1;
		}
		bbzero(gbl.track2);	
		bbzero(gbl.track3);
		memcpy(gbl.track2, card_info, 37);
		memcpy(gbl.track3, card_info+38, 104);
		
		if(!memcmp( gbl.track2, "FF", 2) )	//判断是否有2磁道
			gbl.track2_len = 0;
		else
		{
			gbl.track2_len = strlen(gbl.track2);
			i = gbl.track2_len;
			while(gbl.track2[i-1] == 'F' && i>0)
			{
				gbl.track2[i-1] = '0';
				i--;
			}
		}
		
		if(!memcmp( gbl.track3, "FF", 2) )	//判断是否有3磁道
			gbl.track3_len = 0;
		else
		{
			gbl.track3_len = strlen(gbl.track3);
			i = gbl.track3_len;
			while(gbl.track3[i-1] == 'F' && i>0)
			{
				gbl.track3[i-1] = '0';
				i--;
			}
		}
		/*********************小灵通付费易卡********************/
		if(!memcmp(card_info,"8828",4) || !memcmp(card_info,"2028",4))
		{
			bbzero(gbl.card_no);
			gbl.track2[26] = '\0';	//二磁道信息
			gbl.track2_len = 26;
			i = 0;
			while(gbl.track2[i]!='=')	//卡号以'='号作为结束符
			{
				i++;
				if( i>gbl.track2_len )
					return -1;
			}
			gbl.card_no_len = i;
			if(gbl.card_no_len>sizeof(gbl.card_no)-1)
			{
				wrLog("【gbl.card_no_len】长度过大[%d]",gbl.card_no_len);
				gbl.card_no_len = 0;
				return -1;
			}
			memcpy(gbl.card_no, gbl.track2, gbl.card_no_len);
			gbl.key_num = -1;
			strcpy(gbl.bank,"205810");
		}
		/*************************e卡*************************/
		else if( !memcmp(card_info, "991088", 6) )
		{
			memset( gbl.card_no,0,sizeof(gbl.card_no) );
			i = 0;
			while(gbl.track2[i+2] != '=')	//卡号以'='号作为结束符
			{
				i++;
				if( i>gbl.track2_len )
					return -1;
			}
			gbl.card_no_len = i;
			if(gbl.card_no_len>sizeof(gbl.card_no)-1)
			{
				wrLog("【gbl.card_no_len】长度过大[%d]",gbl.card_no_len);
				gbl.card_no_len = 0;
				return -1;
			}
			memcpy(gbl.card_no, gbl.track2+2, gbl.card_no_len);
			gbl.key_num = get_key_num("105810"); //读卡表取key组号
			strcpy(gbl.bank,"105810");
		}
		/***********************普通银行卡********************/
		else
		{
			ret = 1;
			if( gbl.track2_len ) //2磁道有信息，查找2磁道
			{
				if( CDB::isLock() )
					return -1;
				ret = isTrack2(gbl.track2, pos);
				if( ret == 0)	//查找成功
				{
					wrLog("【2磁道查找成功】");
					gbl.key_num = get_key_num(bank_card[pos].bank);
					memcpy(gbl.bank, bank_card[pos].bank, sizeof(gbl.bank));
					bbzero( gbl.card_no );
					i = 0;
					while(gbl.track2[i] != '=')	//卡号以'='号作为结束符
					{
						i++;
						if( i>gbl.track2_len )
							return -1;
					}
					gbl.card_no_len = i - bank_card[pos].offset; //去除偏移量
					if(gbl.card_no_len>sizeof(gbl.card_no)-1)
					{
						wrLog("【gbl.card_no_len】长度过大[%d]",gbl.card_no_len);
						gbl.card_no_len = 0;
						return -1;
					}
					memcpy(gbl.card_no, gbl.track2 + bank_card[pos].offset, gbl.card_no_len);
				}
			}
			if( ret && gbl.track3_len ) //2磁道查找不到，查找3磁道
			{
				if( CDB::isLock() )
					return -1;
				ret = isTrack3(gbl.track3, pos);
				if( ret == 0)	//查找成功
				{
					wrLog("【3磁道查找成功】");
					gbl.key_num = get_key_num(bank_card[pos].bank);
					memcpy(gbl.bank, bank_card[pos].bank, sizeof(gbl.bank));
					bbzero( gbl.card_no );
					i = 0;
					while(gbl.track3[i] != '=')	//卡号以'='号作为结束符
					{
						i++;
						if( i>gbl.track3_len )
							return -1;
					}
					gbl.card_no_len = i - bank_card[pos].offset; //去除偏移量
					if(gbl.card_no_len>sizeof(gbl.card_no)-1)
					{
						wrLog("【gbl.card_no_len】长度过大[%d]",gbl.card_no_len);
						gbl.card_no_len = 0;
						return -1;
					}
					memcpy(gbl.card_no, gbl.track3 + bank_card[pos].offset, gbl.card_no_len);
				}
			}
			
			if( ret )	//2、3磁道均查找不成功
			{
				wrLog("【2、3磁道查找失败，走银联】");
				gbl.key_num = 8; //走银联
				strcpy(gbl.bank,"305810");
				if( gbl.track2_len ) //有2磁道
				{
					bbzero( gbl.card_no );
					i = 0;
					while(gbl.track2[i] != '=')	//卡号以'='号作为结束符
					{
						i++;
						if( i>gbl.track2_len )
							return -1;
					}
					gbl.card_no_len = i;
					if(gbl.card_no_len>sizeof(gbl.card_no)-1)
					{
						wrLog("【gbl.card_no_len】长度过大[%d]",gbl.card_no_len);
						gbl.card_no_len = 0;
						return -1;
					}
					memcpy(gbl.card_no, gbl.track2, gbl.card_no_len);
				}
				else if( gbl.track3_len ) //有3磁道
				{
					bbzero( gbl.card_no );
					i = 0;
					while(gbl.track3[i] != '=')	//卡号以'='号作为结束符
					{
						i++;
						if( i>gbl.track3_len )
							return -1;
					}
					if(i>19)	//超过19位，取末19位
					{
						gbl.card_no_len = 19;
						memcpy(gbl.card_no, gbl.track3 + i - 19, gbl.card_no_len);
					}
					else
					{
						gbl.card_no_len = i;
						memcpy(gbl.card_no, gbl.track3, gbl.card_no_len);
					}
				}
				else	//2、3磁道均无信息
				{
					TS_OutPutMsg(gbl.dPosInfo,"  \n     刷卡错误！\n按【确认】重新刷卡\n按【返回】返回",0,iSelect);
					if(iSelect == 0)
						return RE_MNG_CARD;
					else
						return ERROR_CODE;
				}
			}//end if( ret )
		}//end else(普通银行卡)
		/**************************************************/
	}//end else  //刷卡、输卡号
	
	////平台测试整改(不记录磁道信息)
	//wrLog("2磁道信息[%d]：[%s]", gbl.track2_len, gbl.track2);
	//wrLog("3磁道信息[%d]：[%s]", gbl.track3_len, gbl.track3);
	//wrLog("卡号[%d]：[%s]", gbl.card_no_len, gbl.card_no);
	//wrLog("key num: [%d]", gbl.key_num);
	//wrLog("bank: [%s]", gbl.bank);
	return 0;
}

//取得卡密码
int CTrade::getCardPwd(const char *type )
{
	int iRet;
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv; 
	
	wrLog("【getCardPwd】");
	
	if(!strcmp(gbl.fee_type, "0184") || !strcmp(gbl.fee_type, "0185")|| !strcmp(gbl.fee_type, "0238"))  //交行转帐与查询余额
	{
		if(TRADE_FLAG){//生产
			gbl.key_num = 17;
			strcpy(gbl.bank,"600001");
		}
		else{
			gbl.key_num = 3;
			strcpy(gbl.bank,"600001");
		}
	}
	if(!strcmp(gbl.fee_type, "0092") || !strcmp(gbl.fee_type, "0210") || !strcmp(gbl.fee_type, "0337") || !strcmp(gbl.fee_type, "0099"))	//全省综合收费，交罚
	{
		if(strcmp(gbl.bank,"105810")!=0){	//非e卡
			gbl.key_num = 8;
			strcpy(gbl.bank,"305810");
		}
	}
	if (strcmp(gbl.fee_type,"0286")==0)
	{
		iRet = TS_SetCardNum(&gbl.dPosInfo, "0000000000000000", (int)gbl.posInfo.inType);
		wrLog("TS_SetCardNum返回值：%d",iRet);
	}
	/*******************输入密码*********************/
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, type); 
    if( !memcmp(gbl.card_no, "8828", 4) )	//小灵通付费易卡，不加密
	{
		tradeInfoSend.uHasTradeID = 1;		//交易流水号标志
		if(!memcmp(gbl.fee_type, "0095", 4))	//付费易卡修改密码
		{
			tradeInfoSend.uTotalContents = 2;
			strcpy(tradeInfoSend.Contents[0].acTitle, "请输入6位原密码：");
		}
		else
		{
			tradeInfoSend.uTotalContents = 1;	//输入总项数
			strcpy(tradeInfoSend.Contents[0].acTitle, "请输入6位密码：");
		}
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_PWD;	//密码
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
		tradeInfoSend.Contents[0].uMinLen = 6;		
		tradeInfoSend.Contents[0].uMaxLen = 6;
		
		if(!memcmp(gbl.fee_type, "0095", 4))
		{
			strcpy(tradeInfoSend.Contents[1].acTitle, "请输入6位新密码：");
			tradeInfoSend.Contents[1].uCommand = TS_INPUT_PWD;	//密码
			tradeInfoSend.Contents[1].uCount = 0x01;
			tradeInfoSend.Contents[1].uTimeOut = EPOS_OVER_TIME;	//超时30秒
			tradeInfoSend.Contents[1].uMinLen = 6;		
			tradeInfoSend.Contents[1].uMaxLen = 6;
		}
	}
	else	//银行卡和e卡
	{
		tradeInfoSend.uHasTradeID = 1;		//交易流水号标志
		tradeInfoSend.uTotalContents = 1;	//输入总项数
		if(!memcmp(gbl.bank, "105810", 4))
		{
			if(atoi(gbl.dPosInfo.prmVer)>=9000)
			{
				strcpy(tradeInfoSend.Contents[0].acTitle, "请输入交易密码：");
			}
			else
			{
				strcpy(tradeInfoSend.Contents[0].acTitle, "请输入e卡密码：");
			}
		}
		else
		{
			strcpy(tradeInfoSend.Contents[0].acTitle, "请输入银行卡密码：");
		}
		
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_PIN;	//密码
		tradeInfoSend.Contents[0].uCardType = CARD_TYPE;	//卡加密
		
		if(!gbl.posInfo.enyFlag)	//加密改造，旧加密体系
		{
			if( gbl.key_num == 8 )//银联流程
			{
				tradeInfoSend.Contents[0].uDesMode = TS_UNION;  
				tradeInfoSend.Contents[0].uKeyIndex = gbl.key_num;			//密钥组号－银联
				memcpy(tradeInfoSend.Contents[0].uKeyRand,logon_random2,8);		//密钥随机数
			}
			else if( gbl.key_num % 2 )	//奇数2次des
			{
				tradeInfoSend.Contents[0].uDesMode = TS_DES_2;	//二次des
				tradeInfoSend.Contents[0].uKeyIndex = gbl.key_num;	//密钥组号
			}
			else	//偶数1次des
			{
				tradeInfoSend.Contents[0].uDesMode = TS_DES_1;	//一次des
				tradeInfoSend.Contents[0].uKeyIndex = gbl.key_num;	
			}
			
			if(!strcmp(gbl.fee_type, "0084"))
			{
				tradeInfoSend.uTotalContents = 2;	//输入总项数
				if(atoi(gbl.dPosInfo.prmVer)>=9000)
				{
					strcpy(tradeInfoSend.Contents[0].acTitle, "请输入原交易密码：");
				}
				else
				{
					strcpy(tradeInfoSend.Contents[0].acTitle, "请输入e卡原密码：");
				}
				strcpy(tradeInfoSend.Contents[1].acTitle, "请输入6位新密码：");
				tradeInfoSend.Contents[1].uCommand = TS_INPUT_PIN;	//密码
				tradeInfoSend.Contents[1].uCardType = CARD_TYPE;	//加密，修改密码标志
				tradeInfoSend.Contents[1].uCount = 1;
				tradeInfoSend.Contents[1].uTimeOut = EPOS_OVER_TIME;	//超时30秒
				tradeInfoSend.Contents[1].uMinLen = 6;		
				tradeInfoSend.Contents[1].uMaxLen = 6;
				tradeInfoSend.Contents[1].uDesMode = TS_DES_2;	//2次des
				tradeInfoSend.Contents[1].uKeyIndex = gbl.key_num;	//密钥组号 
			}
		}
		else	//加密改造，新加密体系
		{

			if(strcmp(gbl.bank,"105810")!=0)
				gbl.key_num = TS_TPK_KEY;//将所有非付费易卡的卡，其密码都用TS_TPK_KEY加密
			else
				gbl.key_num = TS_TEK_KEY;
			tradeInfoSend.Contents[0].uDesMode = TS_DES_3;	//3次des
			tradeInfoSend.Contents[0].uKeyIndex = gbl.key_num;

			if(!strcmp(gbl.fee_type, "0084"))
			{
				tradeInfoSend.uTotalContents = 2;	//输入总项数
				if(atoi(gbl.dPosInfo.prmVer)>=9000)
				{
					strcpy(tradeInfoSend.Contents[0].acTitle, "请输入原交易密码：");
				}
				else
				{
					strcpy(tradeInfoSend.Contents[0].acTitle, "请输入e卡原密码：");
				}
				strcpy(tradeInfoSend.Contents[1].acTitle, "请输入6位新密码：");
				tradeInfoSend.Contents[1].uCommand = TS_INPUT_PIN;	//密码
				tradeInfoSend.Contents[1].uCardType = CARD_TYPE;	//加密，修改密码标志
				tradeInfoSend.Contents[1].uCount = 1;
				tradeInfoSend.Contents[1].uTimeOut = EPOS_OVER_TIME;	//超时30秒
				tradeInfoSend.Contents[1].uMinLen = 6;		
				tradeInfoSend.Contents[1].uMaxLen = 6;
				tradeInfoSend.Contents[1].uDesMode = TS_DES_3;	//3次des
				tradeInfoSend.Contents[1].uKeyIndex = gbl.key_num;	//密钥组号 
			}
		}
		
		wrLog("key num : [%d]",gbl.key_num);
		
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
		tradeInfoSend.Contents[0].uMinLen = 6;		
		tradeInfoSend.Contents[0].uMaxLen = 6;
		
		
	} //end else
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("#TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(2, 1, iRet, gbl, pack);	//监控日志
		if(iRet == 1)
			return CANCLE_KEY;
		else
			return iRet;
	}	
	/*******************end 输入密码***************************/
	bbzero(gbl.pos_serial);	//终端流水
	strcpy(gbl.pos_serial, (char *)tradeInfoRecv.uTradeID);
	bbzero(gbl.password);
	memcpy( gbl.password, (char *)tradeInfoRecv.Contents[0].uMsg, tradeInfoRecv.Contents[0].uMsgLen);	//密码
    wrHex("PASSWORD:" , (BYTE*)gbl.password , 20);
	if(DEBUG_LEVEL<2)
	{
		//平台测试整改(不记录密码信息)
		//wrLog("终端流水: [%s]", gbl.pos_serial);
		//wrHex("密码", (BYTE *)gbl.password, 8);
	}
	//付费易卡和e卡修改密码的新密码
	if(!memcmp(gbl.fee_type, "0095", 4) || !memcmp(gbl.fee_type, "0084", 4))
	{
		bbzero( gbl.new_password );
		memcpy( gbl.new_password,(char *)tradeInfoRecv.Contents[1].uMsg, tradeInfoRecv.Contents[1].uMsgLen );
	}
	if(!gbl.posInfo.enyFlag)	//加密改造，旧加密体系
	{
		if( gbl.key_num % 2 )	//奇数key写随机数
		{
			bbzero(gbl.random_num);
			memcpy(gbl.random_num,(char *)tradeInfoRecv.Contents[0].uKeyRand,8);
		}
	}
	
	////平台测试整改(不记录密码信息)
	//wrLog("-----------------------------------");
	//wrLog("///////////////////////////////////");
	//wrHex("密码",(BYTE *)gbl.password,8);
	//wrHex("返回数据1",tradeInfoRecv.Contents[0].uMsg,tradeInfoRecv.Contents[0].uMsgLen);
	//wrHex("返回数据2",tradeInfoRecv.Contents[1].uMsg,tradeInfoRecv.Contents[1].uMsgLen);
	//wrHex("密匙随机数1",tradeInfoRecv.Contents[0].uKeyRand,8);
	//wrHex("密匙随机数2",tradeInfoRecv.Contents[1].uKeyRand,8);
	//wrLog("///////////////////////////////////");
	//wrLog("-----------------------------------");
	return 0;
}


//一次采集卡号和密码（不加密，目前只有付费易卡）
//card_flag:默认为1，供以后扩充使用
//title: 刷卡提示语，默认为"请刷卡或手动输入卡号"
//minLen: 手输卡号最小长度，默认为12
//maxLen: 手输卡号最大长度，默认为12
int CTrade::getCard_1(const char *type, int card_flag, const char *title, int minLen, int maxLen)
{
	int iRet, i, iSelect;
	char card_info[200];
	
	wrLog("【getCard_1】");
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv; 
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	/******************一次采集************************/
	strcpy(tradeInfoSend.acMainTitle, type);
	tradeInfoSend.uHasTradeID = 1;
	
	if(!memcmp(gbl.fee_type, "0095", 4))	//付费易卡修改密码
		tradeInfoSend.uTotalContents = 3;
	else
		tradeInfoSend.uTotalContents = 2;
	
	/*2006-10-13小灵通付费易卡*/
	strcpy(tradeInfoSend.Contents[0].acTitle, title);
	tradeInfoSend.Contents[0].uCommand = TS_MAG_INPUT_CARD;	//刷卡或手动输入
	tradeInfoSend.Contents[0].uMinLen = minLen;		
	tradeInfoSend.Contents[0].uMaxLen = maxLen;
	tradeInfoSend.Contents[0].uDesMode = TS_NO_ENC;		//不加密
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
	
	if(!memcmp(gbl.fee_type, "0095", 4))	//付费易卡修改密码
		strcpy(tradeInfoSend.Contents[1].acTitle, "请输入6位原密码：");	
	else
		strcpy(tradeInfoSend.Contents[1].acTitle, "请输入6位密码：");
	tradeInfoSend.Contents[1].uCommand = TS_INPUT_PWD;		//明文密码
	tradeInfoSend.Contents[1].uDesMode = TS_NO_ENC;		//不加密
	tradeInfoSend.Contents[1].uTimeOut = EPOS_OVER_TIME;	//超时30秒
	tradeInfoSend.Contents[1].uMinLen = 6;
	tradeInfoSend.Contents[1].uMaxLen = 6;
	
	if(!strcmp(gbl.fee_type, "0095"))
	{
		strcpy(tradeInfoSend.Contents[2].acTitle, "请输入6位新密码：");
		tradeInfoSend.Contents[2].uCommand = TS_INPUT_PWD;	//明文密码
		tradeInfoSend.Contents[2].uDesMode = TS_NO_ENC;
		tradeInfoSend.Contents[2].uCount = 1;	//输入2次
		tradeInfoSend.Contents[2].uTimeOut = EPOS_OVER_TIME;	//超时30秒
		tradeInfoSend.Contents[2].uMinLen = 6;		
		tradeInfoSend.Contents[2].uMaxLen = 6;
	}
	/*******************end一次采集*************************/
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	
	if(iRet != 0)
	{
		wrLog("#TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(2, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	/******************获取卡号和密码***************************/
	bbzero(card_info);
	memcpy(card_info, tradeInfoRecv.Contents[0].uMsg, tradeInfoRecv.Contents[0].uMsgLen);
	
	//平台测试整改(不记录磁道信息)
	//wrLog("磁道信息：%s",card_info);
	
	if(strlen(card_info)<142)	//手动输入
	{
		if(memcmp(card_info,"8828",4) && memcmp(card_info,"2028",4))	
		{
			TS_OutPutMsg(gbl.dPosInfo," \n错误的小灵通付费易卡\n按【确认】重新刷卡\n按【返回】返回",0,iSelect);
			if(iSelect == 0)
				return RE_MNG_CARD;
			else
				return -1;
		}
		bbzero(gbl.track2);
		bbzero(gbl.track3);
		gbl.track2_len = 0;
		gbl.track3_len = 0;
		bbzero( gbl.card_no);
		memcpy(gbl.card_no, card_info, strlen(card_info));
		gbl.card_no_len = strlen(card_info);
	}
	else	//刷卡得到
	{
		if(memcmp(card_info,"8828",4) && memcmp(card_info,"2028",4))	
		{
			TS_OutPutMsg(gbl.dPosInfo," \n错误的小灵通付费易卡\n   按【确认】重新刷卡\n   按【返回】返回",0,iSelect);
			if(iSelect == 0)
				return RE_MNG_CARD;
			else
				return -1;
		}
		bbzero(gbl.track2);	
		bbzero(gbl.track3);
		memcpy(gbl.track2, card_info, 37);
		memcpy(gbl.track3, card_info+38, 104);
		if(!memcmp( gbl.track2, "FF", 2) )	//判断是否有2磁道
			gbl.track2_len = 0;
		else
			gbl.track2_len = strlen(gbl.track2);
		if(!memcmp( gbl.track3, "FF", 2) )	//判断是否有3磁道
			gbl.track3_len = 0;
		else
			gbl.track3_len = strlen(gbl.track3);
		if(!gbl.track2_len && !gbl.track3_len)
		{
			TS_OutPutMsg(gbl.dPosInfo," \n  读取卡信息错误！\n   按【确认】重新刷卡\n   按【返回】返回",0,iSelect);
			if(iSelect == 0)
				return RE_MNG_CARD;
			else
				return -1;
		}
		bbzero(gbl.card_no);
		i = 0;
		if(gbl.track2_len)
		{
			while(gbl.track2[i]!='D' && i<37)	//卡号以D作为结束符
				i++;
			if(i == 37)
				return -1;
			gbl.track2[i] = '=';
			gbl.card_no_len = i;
			memcpy(gbl.card_no, gbl.track2, gbl.card_no_len);
		}
		else if(gbl.track3_len)
		{
			while(gbl.track3[i]!='D' && i<104)	//卡号以D作为结束符
				i++;
			if(i == 104)
				return -1;
			gbl.track3[i] = '=';
			gbl.card_no_len = i;
			memcpy(gbl.card_no, gbl.track3, gbl.card_no_len);
		}
		
	} //end else
	gbl.key_num = -1;
	wrLog("卡号：%s", gbl.card_no);
	bbzero(gbl.pos_serial);	//终端流水
	strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
	bbzero( gbl.password);
	strcpy( gbl.password,(char *)tradeInfoRecv.Contents[1].uMsg );	//密码
																	/*	char pwd[8+1];
																	bbzero(pwd);
																	bbzero(gbl.password);
																	memcpy( pwd, (char *)tradeInfoRecv.Contents[1].uMsg, tradeInfoRecv.Contents[1].uMsgLen);
																	if( getRealPwd(gbl.card_no, pwd, gbl.password) )
																	return -1;
	*/
	//	wrLog("password: [%s]", gbl.password);
	if(!memcmp(gbl.fee_type, "0095", 4))	//修改密码时的新密码
	{
		bbzero(gbl.new_password);
		strcpy( gbl.new_password,(char *)tradeInfoRecv.Contents[2].uMsg );
	}
	
	return 0;
}

//刷卡交易
//card_flag: 采集方式
//			0，二次采集，只能刷卡不能输卡号(默认)
//			1为一次采集，刷卡或输卡号(只限小灵通付费易卡使用，用于小灵通付费易卡的多卡交易中限定不能刷银行卡)
//			2为二次采集，刷卡或输卡号(所有卡)
//pay_flag:	刷卡交费流程标志By:KF 06.11.09
//			MNG_ONE(0默认):一次刷卡输密码连续交费(默认), 取此值时进入函数不需刷卡，只输密码
//		    MNG_MUL(1):每次交费都刷卡, 取此值时进入函数需要刷卡
//			MNG_ONE_BIND(2):一次刷卡输密码连续交费(可用绑定卡号)
//			MNG_MUL_BIND(3):每次交费都刷卡(可以用绑定的卡), 取此值时进入函数需要刷卡
//			MNG_ONE_BIND_E(4):一次刷卡输密码连续交费(用绑定的e卡)
//			MNG_MUL_BIND_E(5):每次交费都刷卡(用绑定的e卡), 取此值时进入函数需要刷卡
//title:  刷卡提示语，默认为“请刷卡”
//minLen: 手输卡号最小长度，默认为12
//maxLen: 手输卡号最大长度，默认为12
int CTrade::mngCard(const char *type, int card_flag, int pay_flag, const char *title, int minLen, int maxLen) //card_flag为卡标识，默认为0
{
	int iRet;
	char card_info[200];
	
	if( pay_flag == MNG_ONE || pay_flag == MNG_ONE_BIND || pay_flag == MNG_ONE_BIND_E)	//不需要刷卡，只需要输密码
	{
		iRet = cardno_fee(gbl.bank, gbl.fee_type, gbl.acc_city_no, atoi(gbl.dPosInfo.prmVer)<9000?1:2);//卡号与业务的支持关系
		if( iRet == 0){
			if (memcmp(gbl.fee_type,"0322",4)!=0)
			{
				iRet = getCardPwd( type);	//取得密码
			}			
		}
		
		if( (iRet == RE_MNG_CARD) )
			return RE_MNG_CARD;
		else if( (iRet == CANCLE_KEY) )
			return CANCLE_KEY;
		else if(iRet != 0 )
			return -1;
	}
	else if( pay_flag == MNG_MUL || pay_flag == MNG_MUL_BIND || pay_flag == MNG_MUL_BIND_E )//需要刷卡输密码
	{
		if(card_flag==1)
		{
			iRet = getCard_1(type, card_flag);
		}
		else
		{
			memset(card_info, 0, sizeof(card_info));
			iRet = getCardInfo( type, card_info, card_flag, pay_flag, title, minLen, maxLen);//刷卡取得卡信息
			if( iRet == 0 )
				iRet = getCardNum(card_info, card_flag);//取得卡号
			if( iRet == 0 )
				iRet = cardno_fee(gbl.bank, gbl.fee_type, gbl.acc_city_no, atoi(gbl.dPosInfo.prmVer)<9000?1:2);//卡号与业务的支持关系
			if( iRet == 0 )
				iRet = getCardPwd(type);	//取得密码
			
			if( (iRet == CANCLE_KEY) )
				return CANCLE_KEY;
			else if( (iRet == RE_MNG_CARD) )
				return RE_MNG_CARD;
			else if(iRet != 0)
				return -1;
		} //end else
	}
	else{
		wrLog("CTrade::mngCard pay_flag error[%d]",pay_flag);
		return -1;
	}
	return iRet;
}

//刷卡处理
int CTrade::mngCard_Hdl(const char *type, const char *title, int card_flag,  int pay_flag, int minLen, int maxLen)
{
	int iRet;
	int mngCard_count = 0;//用于标识一次刷卡时的重刷卡
	if(pay_flag == -1)
		pay_flag = gbl.get_card;
	for(int curTry=0; curTry<MAXTRY; curTry++)	//刷卡错误，重新刷卡
	{
		if( !mngCard_count )  //第一次刷卡
			iRet = mngCard( type, card_flag, pay_flag, title, minLen, maxLen);
		else
		{
			if(pay_flag==MNG_MUL)
				iRet = mngCard( type, 0, MNG_MUL, title, minLen, maxLen);
			else if(pay_flag==MNG_MUL_BIND)
				iRet = mngCard( type, 0, MNG_MUL_BIND, title, minLen, maxLen);
			else if(pay_flag==MNG_MUL_BIND_E)
				iRet = mngCard( type, 0, MNG_MUL_BIND_E, title, minLen, maxLen);
			else if(pay_flag==MNG_ONE)
				iRet = mngCard( type, 2, MNG_MUL, title, minLen, maxLen);
			else if(pay_flag==MNG_ONE_BIND)//如果是一次刷卡，则需要提供可输入卡号形式
				iRet = mngCard( type, 2, MNG_MUL_BIND, title, minLen, maxLen);
			else if(pay_flag==MNG_ONE_BIND_E)
				iRet = mngCard( type, 2, MNG_MUL_BIND_E, title, minLen, maxLen);
			else
				return -1;
		}
		mngCard_count++;	//标志着不是第一次刷卡
		if(iRet == CANCLE_KEY)
			return CANCLE_KEY;
		if(iRet == RE_MNG_CARD)
			continue;
		else if(iRet != 0)
			return -1;
		else
			return 0;
	}
	return -1;
}

int CTrade::merTrade()		//商户交易
{
	int iSelect,iRet=0;
	gbl.init_global();	//初始化全局变量
	iSelect = merInqHdl();
	if(iSelect==0)
		iRet = merPayHdl();
	
	return iRet;
}

int CTrade::merInqHdl()	//查询
{
	int  iRet;
	int  b48_len;
	char len_buff[10];
	struct tm     *tm_now;
	time_t        time_now;
	
	wrLog("商户交易【查询】");
	strcpy(gbl.fee_type,"0123");
	
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, "天天洗衣");
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入8位订单号：");	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
	tradeInfoSend.Contents[0].uCount = 0;		//输入1次		
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
	tradeInfoSend.Contents[0].uMinLen = 8;		
	tradeInfoSend.Contents[0].uMaxLen = 8;	
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	
	memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
	strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
	wrLog("终端流水：%s",gbl.pos_serial);
	memset( gbl.order_no,0,sizeof(gbl.order_no) );
	time_now = time (NULL);
	tm_now = localtime (&time_now);
	sprintf (gbl.order_no, "%04d%02d%02d", tm_now->tm_year + 1900,
		tm_now->tm_mon + 1, tm_now->tm_mday);
	strcat( gbl.order_no,(char *)tradeInfoRecv.Contents[0].uMsg );
	wrLog("商户订单号:[%s]", gbl.order_no);
	
	//写查询域
	pack.wrField(1, gbl);
	/**********************************/
	bbzero(pack.FIELD48);  //bit48
	memcpy((char *)pack.FIELD48,gbl.fee_type,4);	//业务代码
	b48_len = 4;
	memset(len_buff,0,sizeof(len_buff));
	sprintf(len_buff,"%02d",ORDER_LEN);
	strcat((char *)(pack.FIELD48+b48_len),len_buff);
	b48_len += 2;
	strcat((char *)(pack.FIELD48+b48_len),gbl.order_no);
	b48_len += ORDER_LEN;
	pack.Packet_Table[48].Real_Length=b48_len;
	/**********************************/
	//  查询包打包   
	iRet = packHdl(1);
	if(iRet < 0)
		return -1;
	
	//wrLog("bit63:[%s]",pack.FIELD63);
	//wrLog("bit62:[%s]",pack.FIELD62);
	//wrLog("bit48:[%s]",pack.FIELD48);
	//wrLog("bit4:[%x]",pack.FIELD4);
	//返回数据给终端
    iRet =  merInqMsg();
	return iRet;
}

int CTrade::merInqMsg()	//下发商户查询信息
{
	char response_code[3];
	int b63_offset,b48_offset;
	char temp_buff[2048],len_buff[10],mny[20];
	int i,iSelect,order_len;
	
	memset(response_code,0,sizeof(response_code));
	memcpy(response_code,pack.FIELD39,2);
	
	if (!memcmp(response_code,"00",2)) 
	{
		memset(gbl.amount,0,sizeof(gbl.amount));
		CTools::byte_to_hex(pack.FIELD4, (BYTE *)gbl.amount, 6);
		memset(mny,0,sizeof(mny));
		CTools::chgToMny(gbl.amount,mny);
		//bit48
		b48_offset = 4;	//跳过4位业务代码
		memset(len_buff,0,sizeof(len_buff));
		memcpy(len_buff,&pack.FIELD48[b48_offset],2);
		order_len = atoi(len_buff);
		b48_offset += 2;
		memset(gbl.order_no,0,sizeof(gbl.order_no));
		memcpy(gbl.order_no,&pack.FIELD48[b48_offset],order_len);
		//bit63
		memcpy(gbl.user_name,pack.FIELD63,60);
		for (i=0;i<60;i++)
		{
			if (gbl.user_name[i]==0x20) 
			{
				gbl.user_name[i]='\0';
				gbl.user_name_len=i;
				
			}
		}/* end for*/
		b63_offset = 60;
		memset(len_buff,0,sizeof(len_buff));
		memcpy(len_buff,&pack.FIELD63[b63_offset],2);
		b63_offset += 2;
		gbl.phone_len = atoi(len_buff);
		memcpy(gbl.phone_no,&pack.FIELD63[b63_offset],gbl.phone_len);
		
		sprintf(temp_buff,"订单号：\n%s\n金额：%s\n姓名：%s\n电话：%s\n【确认】交费\n【返回】返回",gbl.order_no,mny,gbl.user_name,gbl.phone_no);
		TS_OutPutMsg(gbl.dPosInfo, temp_buff, 0,iSelect);
		return iSelect;
	}
	else
	{
		returnFail(response_code);
		return -1;
	}
}

int CTrade::merPayHdl()	//商户交费
{
	int  iRet,order_len,i,flag;
	int  iSelect;
	int  b48_len;
	char response_code[3];
	char len_buff[10];
	
	wrLog("商户【交费】");
	flag = 0;
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{
		if(!flag)
		{
			iRet = mngCard_Hdl("天天洗衣");
			if(iRet == CANCLE_KEY)
				return CANCLE_KEY;
			else if(iRet != 0)
				return -1;
		}
		pack.wrField(2, gbl);	//写交费域
		/********************************/
		memset(pack.FIELD48,0,sizeof(pack.FIELD48));  //bit48
		memcpy((char *)pack.FIELD48,gbl.fee_type,4);	//业务代码
		b48_len = 4;
		memset(len_buff,0,sizeof(len_buff));
		sprintf(len_buff,"%02d",ORDER_LEN);
		strcat((char *)(pack.FIELD48+b48_len),len_buff);
		b48_len += 2;
		strcat((char *)(pack.FIELD48+b48_len),gbl.order_no);
		b48_len += ORDER_LEN;
		pack.Packet_Table[48].Real_Length=b48_len;
		/********************************/
		
		iRet = packHdl(2);
		if(iRet < 0)
			return -1;
		
		memset(response_code,0,sizeof(response_code));
		memcpy(response_code,pack.FIELD39,2);
		
		//wrLog("bit63:[%s]",pack.FIELD63);
		//wrLog("bit62:[%s]",pack.FIELD62);
		//wrLog("bit48:[%s]",pack.FIELD48);
		//wrLog("bit4 :[%s]",pack.FIELD4);
		
		if (!memcmp(response_code,"00",2)) 
		{
			//bit48
			//跳过4位业务代码
			b48_len = 4;
			memset(len_buff,0,sizeof(len_buff));
			memcpy(len_buff,&pack.FIELD48[b48_len],2);
			order_len = atoi(len_buff);
			b48_len += 2;
			memset(gbl.order_no,0,sizeof(gbl.order_no));
			memcpy(gbl.order_no,&pack.FIELD48[b48_len],order_len);
			//bit63
			memset(gbl.user_name,0,sizeof(gbl.user_name));
			memcpy(gbl.user_name,pack.FIELD63,60);
			for (i=0;i<60;i++)
			{
				if (gbl.user_name[i]==0x20) 
				{
					gbl.user_name[i]='\0';
					gbl.user_name_len=i;
					break;
				}
			}/* end for*/
			iRet = TS_OutPutMsg(gbl.dPosInfo,"     交费成功！\n    谢谢您的使用\n请按【确认】打印发票",0,iSelect);
			if(iRet!=0 || iSelect==0)
			{
				CPrint prt;
				prt.set_in_par(gbl);
				//prt.print_detail(4, "天天洗衣");	 //打印商户明细
				prt.print_mer_detail(pack, "天天洗衣");
			}
			return 0;
		}
		else if(!memcmp(response_code,"55",2))
		{
			flag = 1;
			if(reGetPwd( "天天洗衣") == 0) //密码错误，重新输入密码, 2006-10-25
				continue;
			else
				return CANCLE_KEY;
		}
		else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
			if (iSelect!=0)
			{
				return -1;
			}else
				continue;
		}
		else
		{
			returnFail(response_code);
			return -1;
		}
	}
	return -1;
}

int CTrade::xltTrade(const char *type)	//小灵通付费易卡交易
{
	int iSelect,iRet = 0, inputTel=0, first3mon=1;
	
	for(int i=0; first3mon && i<10; i++)
	{
		iSelect = telInqHdl(type, inputTel, first3mon);
		if(iSelect==0)
		{
			iRet = selectAmount(1);
			if(iRet == CANCLE_KEY)
				return CANCLE_KEY;
			else if(iRet < 0)
				return -1;
			iRet = xltMulCard(type);
		}else
		{
			break;
		}
		inputTel = 1;
	}
	return iRet;
}


//2006-10-13独立出来方便加入电信菜单中
//flag默认为1，0为非付费易卡菜单进入
int CTrade::xltMulCard(const char *type, int flag)	
{
	int  iRet, b48_len;
	int  iSelect, mngCard_count = 1;
	char tmp[512], len_buff[4+1];
	char response_code[3];
	
	int count = 0;  //卡数
	memset(gbl.xlt_card, 0, sizeof(gbl.xlt_card));
	memcpy(gbl.xlt_card, gbl.xlt_type, 2);
	if( !memcmp(gbl.xlt_type, "02", 2) ) //若为按卡内余额交费
		bbzero(gbl.amount);
	
	mngCard_count = 1;//因为需要记录下商户版第一次刷卡是不用刷卡的，所以mngCard_count是用来表示是否为第一次刷卡
	while(count < 21)
	{
		/********************请求刷卡****************/
		if(flag == 1)	//flag=1，小灵通付费易卡菜单进入
		{
			iRet = 1;
			while(iRet > 0)	//刷卡错误，重新刷卡
			{
				if(mngCard_count==1)
					iRet = mngCard( type, 1, gbl.get_card); //1次采集
				else
					iRet = mngCard( type, 1, MNG_MUL);  //1次采集
				mngCard_count = mngCard_count + 1 ;//标志着不是第一次刷卡
				if(iRet == CANCLE_KEY)
					return CANCLE_KEY;
				if(iRet == RE_MNG_CARD)
					continue;
				else if(iRet != 0)
					return -1;
				//付费易卡形式
				if(!memcmp(gbl.card_no,"8828", 4) || !memcmp(gbl.card_no,"2028", 4)) 
					break;
				else
				{
					iRet = 1;
					continue;
				}
			}
		}
		/**********63bit信息******************/
		if( flag != 2)  //flag==2为重输密码操作，下面处理
		{
			count++;
			memset(tmp,0,sizeof(tmp));
			sprintf(tmp,"%02d",count);
			memcpy(gbl.xlt_card+2,tmp,2);
			strcat(gbl.xlt_card,"12");
			strcat(gbl.xlt_card,gbl.card_no);
			strcat(gbl.xlt_card,"06");
			strcat(gbl.xlt_card,gbl.password);
		}
		
		wrLog("小灵通付费易卡【交费】");
		if(DEBUG_LEVEL <= 2)
		{
			wrLog("小灵通付费易卡信息：[%s]\n",gbl.xlt_card);
		}
		pack.wrField(2, gbl);	//写交费域
		/***********修改一些域信息*********/
		switch( atoi(gbl.fee_type) )
		{
		case 71:	//宽带预缴费
			memset(len_buff,0,sizeof(len_buff));
			sprintf(len_buff,"%02d",gbl.phone_len+2);	//电话号码+子业务代码长度（2位）
			memcpy(pack.FIELD48+4, len_buff, 2);	//跳过4位业务代码
			strcat((char *)pack.FIELD48, gbl.sub_code);	//加上2位子业务代码
			pack.Packet_Table[48].Real_Length += 2;
			break;
			
		case 143:  //自由互联业务
			bbzero(pack.FIELD48);
			memcpy(pack.FIELD48,gbl.fee_type,4);	//4位信息码
			b48_len = 4;
			memset(len_buff,0,sizeof(len_buff));
			sprintf(len_buff,"%02d",gbl.phone_len+3);	//电话号码长度
			memcpy(pack.FIELD48+b48_len,len_buff,2);	
			b48_len +=2;
			memcpy(pack.FIELD48+b48_len, gbl.phone_no, gbl.phone_len);	//电话号码
			b48_len += gbl.phone_len;
			pack.Packet_Table[48].Real_Length=b48_len;
			break;
			
		case 76:  //QQ
		case 77:
		case 295:
			memcpy(pack.FIELD63+pack.Packet_Table[63].Real_Length, gbl.QQ_amount, 4);
			pack.Packet_Table[63].Real_Length = pack.Packet_Table[63].Real_Length + 4;
			break;
			
		default:
			break;
		}
		/**********************************/
		
		iRet = packHdl(2);
		if(iRet < 0)
			return -1;
		
		memset(response_code,0,sizeof(response_code));
		memcpy(response_code,pack.FIELD39,2);
		
		if (!memcmp(response_code,"00",2)) 
		{
			if( !memcmp(gbl.xlt_type, "02", 2) ) //若为按卡内余额交费
			{
				bbzero(gbl.amount);
				switch(atoi(gbl.fee_type))
				{
				case 64:	//小灵通预付费
				case 98:	//固话预付费  
				case 140:   //预付费ADSL充值, 2007-02-02
				case 143:   //自由互联, 2007-03-05
					memcpy(gbl.amount, pack.FIELD63 + 30, 12);
					break;
				case 71:	//adsl预缴基本月租
					memcpy(gbl.amount, pack.FIELD63 + 60, 12);
					break;
				case 96:	//小灵通话费预付金
				case 97:	//adsl网费预付金
					memcpy(gbl.amount, pack.FIELD63, 12);
					break;
				default:
					break;
				}
			}
			/************商户打印***************/
			if(gbl.phs_ticket)	//付费易卡是否打印发票标志
			{
				iRet = TS_OutPutMsg(gbl.dPosInfo,"     交费成功！\n    谢谢您的使用\n请按【确认】打印发票",0,iSelect);
				if(iRet!=0 || iSelect==0)
				{
					CPrint prt;
					prt.set_in_par(gbl);
					wrLog("fee_type: %s", gbl.fee_type );
					switch(atoi(gbl.fee_type))
					{
					case 64:
					case 71:
					case 96:
					case 97:
					case 98:
					case 140: //预付费ADSL充值, 2007-02-02
					case 143: //自由互联, 2007-03-05
					//	prt.print_detail(2, type);	 //打印预付费明细
						prt.print_pre_detail(pack,type);
						break;
					default:
					//	prt.print_detail(1, type);	//打印欠费明细
						prt.print_pym_detail(pack,type);
					}
				}
			}
			else
				TS_OutPutMsg(gbl.dPosInfo,"  \n      交费成功！\n	  按【确认】返回",0,iSelect);
			return 0;
		}
		else if(!memcmp(response_code,"51",2))
		{
			TS_OutPutMsg(gbl.dPosInfo,"  \n   卡内余额不足！\n【确认】刷下一张卡\n【返回】返回",0,iSelect);
			flag = 1;
			mngCard_count = mngCard_count + 1;//标志着不是第一次刷卡
			if(iSelect == 0)
				continue;
			else
				return CANCLE_KEY;
		}
		else if(!memcmp(response_code,"55",2))
		{
			if(reGetPwd( type) == 0) //重新输入密码
			{
				flag = 2;
				gbl.xlt_card[4+count*22 - 6] = '\0';
				strcat(gbl.xlt_card,gbl.password);
				continue;
			}
			else
				return CANCLE_KEY;
		}
		else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
			if (iSelect!=0)
			{
				return -1;
			}else
				continue;
		}
		else 
		{
			returnFail((char *)pack.FIELD39);
			return -1;
		}
	} //end while
	return -1;
}

int CTrade::cardInq_yctyp()
{
	int  iRet, flag = 0,nowAmo = 0;
	int  mngCard_count = 1;
	char tmp[256],response_code[3];
	char mny[12+1],date[12+1],yj_amount[1+12+1],yj_buff[12+1];
	BYTE temp_buff[2048];
	
	mngCard_count = 1;
	
	pack.wrField(2, gbl);
	/*******************修改部分包内容****************/
	memset(pack.FIELD3, 0, sizeof(pack.FIELD3));
	CTools::hex_to_byte((BYTE *)"310060", pack.FIELD3, 6);
	//bit48
	memset(pack.FIELD48, 0, sizeof(pack.FIELD48) );
	memcpy(pack.FIELD48, gbl.fee_type, 4);
	strncat((char *)pack.FIELD48, "00", 2);
	pack.Packet_Table[48].Real_Length = 6;
	if(!memcmp(gbl.fee_type, "0094", 4))	//付费易卡
	{		
		//bit63
		memset(pack.FIELD63, 0, sizeof(pack.FIELD63) );
		strcpy((char *)pack.FIELD63, "00000000");
		strncat((char *)pack.FIELD63, "01",2);
		strncat((char *)pack.FIELD63, "12",2);
		strncat((char *)pack.FIELD63, gbl.card_no,12);
		strncat((char *)pack.FIELD63, "06",2);
		strncat((char *)pack.FIELD63, gbl.password,6);
		pack.Packet_Table[63].Real_Length = 32;
	}
	/**************************************************/
	//  查询包打包   
	iRet = packHdl(1);
	if(iRet < 0)
		return -1;
	
	//返回数据给终端
	memset(response_code, 0, sizeof(response_code));
	memcpy(response_code, pack.FIELD39, 2);
	if (!memcmp(response_code,"00",2)) 
	{
		bbzero(gbl.amount);			
		memcpy(gbl.amount, pack.FIELD63+1, 12);
		
		bbzero(tmp);			
		if(!memcmp(gbl.fee_type, "0083", 4))//如果是e卡，e卡比付费易卡多个卡类型字段
		{
			memcpy(tmp, pack.FIELD63+1+12+2, 8);
		}
		else
		{
			memcpy(tmp, pack.FIELD63+1+12, 8);
		}
		
		bbzero(date);			
		memcpy(date, tmp, 4);
		strcat(date,"-");
		strncat(date, tmp+4, 2);
		strcat(date,"-");
		strncat(date, tmp+4+2, 2);			
		wrLog("卡有效期:%s",date);
		
		bbzero(mny);
		//20130105修改-yyx
		CDB::getDayAmo(gbl.dPosInfo.pos_no, &nowAmo);
		//if ((atoi(gbl.amount)==0)&&(gbl.dayAmo!=0)&&(CDB::isSonCard(gbl.mer_ecard)==0))
		//if (CDB::pep_getDayAmo(gbl.pos_no, &nowAmo) < 0) {
		//	wrLog("获取当前日成功交易金额失败");
		//}
		if ((atoi(gbl.amount)==0)&&(gbl.dayAmo!=0)&&(CDB::pep_isSonCard(gbl.dPosInfo.pos_no)==1))
		{
			char bankamo[12+1];
			bbzero(bankamo);
			sprintf(bankamo,"%012d",gbl.dayAmo-nowAmo);
			CTools::chgToMny(bankamo,mny);
		}
		else
		{
			CTools::chgToMny(gbl.amount,mny);
		}
		
		bbzero(yj_amount);
		if(memcmp(gbl.fee_type, "0083", 4)==0 )//如果是e卡，e卡多了酬金
		{
			memcpy(yj_amount, pack.FIELD63+1+12+2+8, 1+12);
		}
		else
		{
			memset(yj_amount, 0x30, 1+12);
		}
		if (memcmp(yj_amount,"D",1)==0)
		{
			memcpy(yj_amount, "-", 1);
		}
		else
		{
			memcpy(yj_amount, "0", 1);
		}
		
		bbzero(yj_buff);			
		CTools::chgToMny(yj_amount,yj_buff);
		
		bbzero(temp_buff);			
		if(atoi(gbl.dPosInfo.prmVer)>=9000)
		{
			getHeadPage(gbl.tgroup, gbl.term_level, new_message, gbl.title_flag, gbl.dPosInfo.pos_no, mny, yj_buff, (char *)temp_buff);
			TS_UpdateHeadPage(gbl.dPosInfo, (char *)temp_buff);
		}
		return 0;
	}
	
	return -1;
}

int CTrade::cardInqHdl(char *amount_out)
{
	int  iRet, flag = 0,nowAmo = 0;
	int  iSelect, mngCard_count = 1;
	char tmp[256],response_code[3];
	char mny[12+1],date[12+1],type[80+1],yj_amount[1+12+1],yj_buff[12+1];
	BYTE temp_buff[2048];
	int iRet2;
	int iSelect2;
	char temp[700];
	
	mngCard_count = 1;
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{
		if(!flag)
		{
			if(!memcmp(gbl.fee_type, "0094", 4))
			{
				//小灵通查询：0094 查询方式：刷卡或输卡号
				iRet = 1;
				while(iRet > 0)	//刷卡错误，重新刷卡
				{
					if(mngCard_count==1)
						iRet = mngCard( "小灵通付费易卡查询", 1, gbl.get_card);//gbl.get_card:0要刷卡；1：不用刷卡
					else
						iRet = mngCard( "小灵通付费易卡查询", 1, MNG_MUL);
					mngCard_count = mngCard_count + 1 ;//标志着不是第一次刷卡
					if(iRet == CANCLE_KEY)
						return CANCLE_KEY;
					if(iRet == RE_MNG_CARD)
						continue;
					else if(iRet != 0)
						return -1;
				}
			}
			else	//E卡查询，查询方式：只有刷卡，没得输卡号
			{
				iRet = 1;
				while(iRet > 0)	//刷卡错误，重新刷卡
				{
					if(atoi(gbl.dPosInfo.prmVer)>=9000)
						sprintf(type, "终端号: %s", gbl.pos_no);
					else
						strcpy(type, "账户余额查询");
					if(mngCard_count==1)
						iRet = mngCard( type, 0, gbl.get_card);//gbl.get_card:0要刷卡；1：不用刷卡
					else
						iRet = mngCard( type, 0, MNG_MUL);
					mngCard_count = mngCard_count + 1 ;//标志着不是第一次刷卡
					if(iRet == CANCLE_KEY)
						return CANCLE_KEY;
					if(iRet == RE_MNG_CARD)
						continue;
					else if(iRet != 0)
						return -1;
				}
			}
		}
		
		//e卡余额查询
		if(!memcmp(gbl.fee_type, "0083", 4)/*&& !memcmp(gbl.pos_no, "6", 1)*/) //暂时只放东莞IPOS
		{
			iRet = ecard_query("ENQ0001");
			if(iRet == 0)
			{
				NULL;
			}
			else if (iRet == -2)
			{
                memcpy(pack.FIELD39, "96", 2);
                pack.Packet_Table[39].Real_Length = 2;
                info("交易密码错误 【Ctrl+H】联系在线客服中心 或致电400-80-11888咨询");
                return -1;
            } else if (iRet == -3) {
				memcpy(pack.FIELD39, "96", 2);
				pack.Packet_Table[39].Real_Length = 2;
				info("交易密码错次数过多，解锁 请联系在线客服中心【Ctrl+H】  400-80-11888");
                return -1;
			} else 
			{
				memcpy(pack.FIELD39, "96", 2);
				pack.Packet_Table[39].Real_Length = 2;
				info("系统故障!\n请稍候再试!\n或按【Ctrl+H】联系在线客服中心 或致电400-80-11888咨询");
                return -1;
			}
		}
		else
		{
			pack.wrField(2, gbl);
			memset(pack.FIELD3, 0, sizeof(pack.FIELD3));
			CTools::hex_to_byte((BYTE *)"310060", pack.FIELD3, 6);
			//bit48
			memset(pack.FIELD48, 0, sizeof(pack.FIELD48) );
			memcpy(pack.FIELD48, gbl.fee_type, 4);
			strncat((char *)pack.FIELD48, "00", 2);
			pack.Packet_Table[48].Real_Length = 6;
			if(!memcmp(gbl.fee_type, "0094", 4))	//付费易卡
			{
				//bit63
				memset(pack.FIELD63, 0, sizeof(pack.FIELD63) );
				strcpy((char *)pack.FIELD63, "00000000");
				strncat((char *)pack.FIELD63, "01",2);
				strncat((char *)pack.FIELD63, "12",2);
				strncat((char *)pack.FIELD63, gbl.card_no,12);
				strncat((char *)pack.FIELD63, "06",2);
				strncat((char *)pack.FIELD63, gbl.password,6);
				pack.Packet_Table[63].Real_Length = 32;
			}
			
			//查询包打包   
			iRet = packHdl(1);
			if(iRet < 0)
				return -1;
		}
		
		//返回数据给终端
		memset(response_code, 0, sizeof(response_code));
		memcpy(response_code, pack.FIELD39, 2);
		if (!memcmp(response_code,"00",2)) 
		{
			bbzero(gbl.amount);			
			memcpy(gbl.amount, pack.FIELD63+1, 12);
			
			bbzero(tmp);			
			if(!memcmp(gbl.fee_type, "0083", 4))//如果是e卡，e卡比付费易卡多个卡类型字段
			{
				memcpy(tmp, pack.FIELD63+1+12+2, 8);
			}
			else
			{
				memcpy(tmp, pack.FIELD63+1+12, 8);
			}
			wrLog("tmp:%s",tmp);
			
			bbzero(date);			
			memcpy(date, tmp, 4);
			strcat(date,"-");
			strncat(date, tmp+4, 2);
			strcat(date,"-");
			strncat(date, tmp+4+2, 2);			
			wrLog("date:%s",date);
			
			bbzero(mny);			
			CDB::getDayAmo(gbl.dPosInfo.pos_no, &nowAmo);
			//if ( (atoi(gbl.amount)==0)&&(gbl.dayAmo!=0)&&(CDB::isSonCard(gbl.mer_ecard)==0))
			//CDB::pep_getDayAmo(gbl.pos_no, &nowAmo);
			if ((atoi(gbl.amount)==0)&&(gbl.dayAmo!=0)&&(CDB::pep_isSonCard(gbl.dPosInfo.pos_no)==1))
			{
				char bankamo[12+1];
				bbzero(bankamo);
				sprintf(bankamo,"%012d",gbl.dayAmo-nowAmo);
				CTools::chgToMny(bankamo,mny);
			}
			else
			{
				CTools::chgToMny(gbl.amount,mny);
			}
			
			bbzero(yj_amount);
			if( memcmp(gbl.fee_type, "0083", 4)==0 )//如果是e卡，e卡多了酬金
			{
				memcpy(yj_amount, pack.FIELD63+1+12+2+8, 1+12);
			}
			else
			{
				memset(yj_amount, 0x30, 1+12);
			}
			if (memcmp(yj_amount,"D",1)==0)
			{
				memcpy(yj_amount, "-", 1);
			}
			else
			{
				memcpy(yj_amount, "0", 1);
			}
			
			bbzero(yj_buff);			
			CTools::chgToMny(yj_amount,yj_buff);
			
			bbzero(temp_buff);			
			if(atoi(gbl.dPosInfo.prmVer)>=9000)
			{
				getHeadPage(gbl.tgroup, gbl.term_level, new_message, gbl.title_flag, gbl.dPosInfo.pos_no, mny, yj_buff, (char *)temp_buff);
				TS_UpdateHeadPage(gbl.dPosInfo, (char *)temp_buff);
			}
			
			bbzero(temp_buff);
			if(amount_out==NULL) 
			{
				if(!memcmp(gbl.fee_type, "0083", 4))//如果是e卡，e卡多了酬金
				{
					if(atoi(gbl.dPosInfo.prmVer)>=9000)
					{
						sprintf((char *)temp_buff, "余额：%s\n有效期：%s\n按【确认】返回",mny,date);
					}
					else
					{
						sprintf((char *)temp_buff, "余额：%s\n酬金：%s\n有效期：%s\n按【确认】酬金结转\n按【返回】返回",mny,yj_buff,date);
					}
				}
				else
				{
					sprintf((char *)temp_buff,"余额：%s\n有效期：%s\n按【确认】返回",mny,date);
				}
				iRet = TS_OutPutMsg(gbl.dPosInfo, (char *)temp_buff, 0,iSelect);
				if(atoi(gbl.dPosInfo.prmVer)>=9000)
				{
					NULL;
				}
				else
				{
					if (iSelect == 0)
					{
						Customer_Trade();
					}
					else
					{
						NULL;
					}
				}
			}
			else if(atoi(amount_out)!=1)
			{
				strcpy(amount_out, gbl.amount);
				iRet = 0;
			}
			
			if(atoi(gbl.dPosInfo.prmVer)>=9000 && gbl.agreeFlag==0)
				
			{
				
				//征求客户建议，只在第一次出现
				
				bbzero(temp);
				wrLog("【显示公告消息】");
				sprintf(temp,"             “交费易”升级  服务更优更便捷  更多新业务即将推出\n\n                           【主体变更通知】\n\n    自2011年12月15日起，由天翼电子商务有限公司广东分公司承接原天讯瑞达通信技术有限公司运营的“交费易”业务。原酬金费率、结转方式等服务内容不变。\n    《交费易业务受理单》合同之权利义务由天翼电子商务有限公司广东分公司享有或承担。\n    合同主体变更后，天讯瑞达通信技术有限公司不再对《交费易业务受理单》合同享有任何权利，也不再履行任何义务。敬请商户知悉。\n    在您充分知悉并同意上述全部内容后，请按回车键（Enter）予以确认并继续进行交易。\n\n\n    确认【Enter】 客服中心【Ctrl+H】");
				iRet = TS_OutPutMsg(gbl.dPosInfo,temp,0,iSelect2);
				if(iRet==0 && iSelect2==0) //按下确认键之后。
				{
					iRet2=CDB::setAgreeFlag(1,gbl.pos_no);
					
					if(iRet2==0)
					{
						gbl.agreeFlag=1;
						
					}
					
				}
			}
			
			
			if (gbl.menu_group_mbl_flag != 1)//移动版修改
			{
				if(atoi(gbl.dPosInfo.prmVer)>=9000&&amount_out!=NULL&&gbl.tgroup!=47&&atoi(amount_out)!=1)
				{
					wrLog("【登录显示最新消息】");
					GetNewMessage(1);
				}
			}
            
		}
		else if(!memcmp(pack.FIELD39,"55",2))
		{
			flag = 1;
			if(!memcmp(gbl.fee_type, "0094", 4))
				iRet = reGetPwd( "小灵通付费易卡查询");
			else
				iRet = reGetPwd( "");
			
			if(iRet == 0) //密码错误，重新输入密码, 2006-10-25
				continue;
			else
				return CANCLE_KEY;
		}
		else
		{
			iRet = returnFail(response_code);
		}
		return iRet;
	}
	return -1;
}



//查询E卡余额 改造 by  liuxiao 20130923
int CTrade::ecardInqHdl()
{
	int  iRet, flag = 0,nowAmo = 0;
	int  mngCard_count = 1;
	char tmp[256],response_code[3];
	char mny[12+1],date[12+1],yj_amount[1+12+1],yj_buff[12+1];
	BYTE temp_buff[2048];
	char acountMny[12+1];
	char pass_16[16+1];

	bbzero(pass_16);
	CTools::byte_to_hex((BYTE *)gbl.password,(BYTE *)pass_16,8);

	//如果出现密码都是0的情况直接退出，不去查询
	if (strcmp(pass_16,"0000000000000000") ==0 ) // 如果密码全部为0，直接退出，不去查询
	{
		return -1;
	}

	bbzero(acountMny); //账户余额
	//e卡余额查询


	iRet = ecard_query("ENQ0001");

		if(iRet == 0)

		{
				NULL;
		}
		
		else if (iRet == -2)
		
		{
                memcpy(pack.FIELD39, "96", 2);
                pack.Packet_Table[39].Real_Length = 2;
                //info("交易密码错误 【Ctrl+H】联系在线客服中心 或致电400-80-11888咨询");
			     return -1;
         } else if (iRet == -3) 

			{
				memcpy(pack.FIELD39, "96", 2);
				pack.Packet_Table[39].Real_Length = 2;
				//info("交易密码错次数过多，解锁 请联系在线客服中心【Ctrl+H】  400-80-11888");
                return -1;
			} else 

			{
				memcpy(pack.FIELD39, "96", 2);
				pack.Packet_Table[39].Real_Length = 2;
				//info("交易密码错误!\n请稍候再试!\n或按【Ctrl+H】联系在线客服中心 或致电400-80-11888咨询");
                return -1;
			}
		
		//返回数据给终端
		memset(response_code, 0, sizeof(response_code));
		memcpy(response_code, pack.FIELD39, 2);
		if (!memcmp(response_code,"00",2)) 
		{
			bbzero(acountMny);			
			memcpy(acountMny, pack.FIELD63+1, 12);
			
			bbzero(tmp);			

			memcpy(tmp, pack.FIELD63+1+12+2, 8);
			wrLog("tmp:%s",tmp);
			bbzero(date);			
			memcpy(date, tmp, 4);
			strcat(date,"-");
			strncat(date, tmp+4, 2);
			strcat(date,"-");
			strncat(date, tmp+4+2, 2);			
			wrLog("date:%s",date);
			
			bbzero(mny);			
			CDB::getDayAmo(gbl.dPosInfo.pos_no, &nowAmo);
			//if ( (atoi(gbl.amount)==0)&&(gbl.dayAmo!=0)&&(CDB::isSonCard(gbl.mer_ecard)==0))
			//CDB::pep_getDayAmo(gbl.pos_no, &nowAmo);
			if ((CDB::pep_isSonCard(gbl.dPosInfo.pos_no)==1))
			{
				char bankamo[12+1];
				bbzero(bankamo);
				sprintf(bankamo,"%012d",gbl.dayAmo-nowAmo);
				CTools::chgToMny(bankamo,mny);
			}
			else
			{
				CTools::chgToMny(acountMny,mny);
			}
			
			bbzero(yj_amount);

			memcpy(yj_amount, pack.FIELD63+1+12+2+8, 1+12);
		
			if (memcmp(yj_amount,"D",1)==0)
			{
				memcpy(yj_amount, "-", 1);
			}
			else
			{
				memcpy(yj_amount, "0", 1);
			}
			
			bbzero(yj_buff);			
			CTools::chgToMny(yj_amount,yj_buff);
			
			bbzero(temp_buff);			
			if(atoi(gbl.dPosInfo.prmVer)>=9000)
			{
				getHeadPage(gbl.tgroup, gbl.term_level, new_message, gbl.title_flag, gbl.dPosInfo.pos_no, mny, yj_buff, (char *)temp_buff);
				TS_UpdateHeadPage(gbl.dPosInfo, (char *)temp_buff);
			}
            
		}
		
		else
		{
			//iRet = returnFail(response_code);
			return -1;
		}

	//}
	return 0;
}

//查询酬金
int CTrade::yj_InqHdl()
{
	int  iRet, flag = 0,nowAmo = 0;
	int  iSelect, mngCard_count = 1;
	char tmp[256],response_code[3];
	char mny[12+1],date[12+1],type[80+1],yj_amount[1+12+1],yj_buff[12+1];
	BYTE temp_buff[2048];
	iRet=pwd_chk(0);
	if (iRet != 0)
    {
		if(iRet==CANCLE_KEY)
		{

			return CANCLE_KEY;
		}
		else
		{

        info("老板密码校验错误，\n如您遗忘您的老板密码，请拨打400-80-11888客服电话咨询!\n");
        return -1;

		}
    }

	mngCard_count = 1;
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{
		if(!flag)
		{
			if(!memcmp(gbl.fee_type, "0094", 4))
			{
				//小灵通查询：0094 查询方式：刷卡或输卡号
				iRet = 1;
				while(iRet > 0)	//刷卡错误，重新刷卡
				{
					if(mngCard_count==1)
						iRet = mngCard( "小灵通付费易卡查询", 1, gbl.get_card);//gbl.get_card:0要刷卡；1：不用刷卡
					else
						iRet = mngCard( "小灵通付费易卡查询", 1, MNG_MUL);
					mngCard_count = mngCard_count + 1 ;//标志着不是第一次刷卡
					if(iRet == CANCLE_KEY)
						return CANCLE_KEY;
					if(iRet == RE_MNG_CARD)
						continue;
					else if(iRet != 0)
						return -1;
				}
			}
			else	//E卡查询，查询方式：只有刷卡，没得输卡号
			{
				iRet = 1;
				while(iRet > 0)	//刷卡错误，重新刷卡
				{
					if(atoi(gbl.dPosInfo.prmVer)>=9000)
						sprintf(type, "终端号: %s", gbl.pos_no);
					else
						strcpy(type, "账户余额查询");
					if(mngCard_count==1)
						iRet = mngCard( type, 0, gbl.get_card);//gbl.get_card:0要刷卡；1：不用刷卡
					else
						iRet = mngCard( type, 0, MNG_MUL);
					mngCard_count = mngCard_count + 1 ;//标志着不是第一次刷卡
					if(iRet == CANCLE_KEY)
						return CANCLE_KEY;
					if(iRet == RE_MNG_CARD)
						continue;
					else if(iRet != 0)
						return -1;
				}
			}
		}
		
		//e卡余额查询
		if(!memcmp(gbl.fee_type, "0083", 4)/*&& !memcmp(gbl.pos_no, "6", 1)*/) //暂时只放东莞IPOS
		{
			iRet = ecard_query("ENQ0001");
			if(iRet == 0)
			{
				NULL;
			}
			else if (iRet == -2)
			{
                memcpy(pack.FIELD39, "96", 2);
                pack.Packet_Table[39].Real_Length = 2;
                info("交易密码错误 【Ctrl+H】联系在线客服中心 或致电400-80-11888咨询");
                return -1;
            } else if (iRet == -3) {
				memcpy(pack.FIELD39, "96", 2);
				pack.Packet_Table[39].Real_Length = 2;
				info("交易密码错次数过多，解锁 请联系在线客服中心【Ctrl+H】  400-80-11888");
                return -1;
			} else 
			{
				memcpy(pack.FIELD39, "96", 2);
				pack.Packet_Table[39].Real_Length = 2;
				info("交易密码错误!\n请稍候再试!\n或按【Ctrl+H】联系在线客服中心 或致电400-80-11888咨询");
                return -1;
			}
		}
		else
		{
			pack.wrField(2, gbl);
			memset(pack.FIELD3, 0, sizeof(pack.FIELD3));
			CTools::hex_to_byte((BYTE *)"310060", pack.FIELD3, 6);
			//bit48
			memset(pack.FIELD48, 0, sizeof(pack.FIELD48) );
			memcpy(pack.FIELD48, gbl.fee_type, 4);
			strncat((char *)pack.FIELD48, "00", 2);
			pack.Packet_Table[48].Real_Length = 6;
			if(!memcmp(gbl.fee_type, "0094", 4))	//付费易卡
			{
				//bit63
				memset(pack.FIELD63, 0, sizeof(pack.FIELD63) );
				strcpy((char *)pack.FIELD63, "00000000");
				strncat((char *)pack.FIELD63, "01",2);
				strncat((char *)pack.FIELD63, "12",2);
				strncat((char *)pack.FIELD63, gbl.card_no,12);
				strncat((char *)pack.FIELD63, "06",2);
				strncat((char *)pack.FIELD63, gbl.password,6);
				pack.Packet_Table[63].Real_Length = 32;
			}
			
			//查询包打包   
			iRet = packHdl(1);
			if(iRet < 0)
				return -1;
		}
		
		//返回数据给终端
		memset(response_code, 0, sizeof(response_code));
		memcpy(response_code, pack.FIELD39, 2);
		if (!memcmp(response_code,"00",2)) 
		{
			bbzero(gbl.amount);			
			memcpy(gbl.amount, pack.FIELD63+1, 12);
			
			bbzero(tmp);			
			if(!memcmp(gbl.fee_type, "0083", 4))//如果是e卡，e卡比付费易卡多个卡类型字段
			{
				memcpy(tmp, pack.FIELD63+1+12+2, 8);
			}
			else
			{
				memcpy(tmp, pack.FIELD63+1+12, 8);
			}
			wrLog("tmp:%s",tmp);
			
			bbzero(date);			
			memcpy(date, tmp, 4);
			strcat(date,"-");
			strncat(date, tmp+4, 2);
			strcat(date,"-");
			strncat(date, tmp+4+2, 2);			
			wrLog("date:%s",date);
			
			bbzero(mny);			
			CDB::getDayAmo(gbl.dPosInfo.pos_no, &nowAmo);
			//if ( (atoi(gbl.amount)==0)&&(gbl.dayAmo!=0)&&(CDB::isSonCard(gbl.mer_ecard)==0))
			//CDB::pep_getDayAmo(gbl.pos_no, &nowAmo);
			if ((atoi(gbl.amount)==0)&&(gbl.dayAmo!=0)&&(CDB::pep_isSonCard(gbl.dPosInfo.pos_no)==1))
			{
				char bankamo[12+1];
				bbzero(bankamo);
				sprintf(bankamo,"%012d",gbl.dayAmo-nowAmo);
				CTools::chgToMny(bankamo,mny);
			}
			else
			{
				CTools::chgToMny(gbl.amount,mny);
			}
			
			bbzero(yj_amount);
			if( memcmp(gbl.fee_type, "0083", 4)==0 )//如果是e卡，e卡多了酬金
			{
				memcpy(yj_amount, pack.FIELD63+1+12+2+8, 1+12);
			}
			else
			{
				memset(yj_amount, 0x30, 1+12);
			}
			if (memcmp(yj_amount,"D",1)==0)
			{
				memcpy(yj_amount, "-", 1);
			}
			else
			{
				memcpy(yj_amount, "0", 1);
			}
			
			bbzero(yj_buff);			
			CTools::chgToMny(yj_amount,yj_buff);
			
			bbzero(temp_buff);			
			if(atoi(gbl.dPosInfo.prmVer)>=9000)
			{
				getHeadPage(gbl.tgroup, gbl.term_level, new_message, gbl.title_flag, gbl.dPosInfo.pos_no, mny, yj_buff, (char *)temp_buff);
				TS_UpdateHeadPage(gbl.dPosInfo, (char *)temp_buff);
			}
			
			bbzero(temp_buff);
			if(!memcmp(gbl.fee_type, "0083", 4))//如果是e卡，e卡多了酬金
				{
						sprintf((char *)temp_buff, "酬金：%s\n有效期：%s\n按【确认】返回",yj_buff,date);
				
				}
				else
				{
					sprintf((char *)temp_buff,"该卡无酬金\n有效期：%s\n按【确认】返回",date);
				}

				iRet = TS_OutPutMsg(gbl.dPosInfo, (char *)temp_buff, 0,iSelect);
			
		}
				
		else if(!memcmp(pack.FIELD39,"55",2))
		{
			flag = 1;
			if(!memcmp(gbl.fee_type, "0094", 4))
				iRet = reGetPwd( "小灵通付费易卡查询");
			else
				iRet = reGetPwd( "");
			
			if(iRet == 0) //密码错误，重新输入密码, 2006-10-25
				continue;
			else
				return CANCLE_KEY;
		}
		else
		{
			iRet = returnFail(response_code);
		}
		return iRet;
	}
	return -1;
}


int CTrade::cardChgPwd( )
{
	int  iRet, flag;
	int  iSelect;
	char new_password_buf[16+1];
	BYTE temp_buff[2048];
	
	if(atoi(gbl.dPosInfo.prmVer)>=9000)
	{
		iRet = checkPEPwd_Hdl("修改交易密码");
		if(iRet!=0)
			if(iRet==CANCLE_KEY)
				return CANCLE_KEY;
			else
			{	
				info("老板密码校验错误\n\n请联系在线客服中心【Ctrl+H】  400-80-11888\n\n按【Enter】确认返回主菜单。");
				return iRet;

			}
		
	}
	
	flag = 0;
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{
		if(!flag)	//初次刷卡和输入密码
		{
			if(!memcmp(gbl.fee_type, "0095", 4))//小灵通修改密码：0095
			{
				iRet = 1;
				while(iRet > 0)	//刷卡错误，重新刷卡
				{
					iRet = mngCard( "修改密码", 1, MNG_MUL);
					if(iRet == CANCLE_KEY)
						return CANCLE_KEY;
					if(iRet == RE_MNG_CARD)
						continue;
					else if(iRet != 0)
						return -1;
				}
			}
			else
			{
				iRet = 1;
				while(iRet > 0)	//刷卡错误，重新刷卡
				{
					if( gbl.get_card==MNG_MUL_BIND || gbl.get_card==MNG_ONE_BIND || gbl.get_card==MNG_MUL_BIND_E || gbl.get_card==MNG_ONE_BIND_E )
						iRet = mngCard( "修改密码", 2, gbl.get_card);
					else if( gbl.get_card==MNG_MUL_BIND_E || gbl.get_card==MNG_ONE_BIND_E )
						return -1;
					else
						iRet = mngCard( "修改密码", 2, MNG_MUL);
					if(iRet == CANCLE_KEY)
						return CANCLE_KEY;
					if(iRet == RE_MNG_CARD)
						continue;
					else if(iRet != 0)
						return -1;
				}
			}
		}
		pack.wrField(2, gbl);
		/*******************修改部分包内容****************/
		memset(pack.FIELD3, 0, sizeof(pack.FIELD3));
		CTools::hex_to_byte((BYTE *)"310060", pack.FIELD3, 6);
		if(!memcmp(gbl.fee_type, "0095", 4))
		{
			//bit48
			memset(pack.FIELD48, 0, sizeof(pack.FIELD48) );
			memcpy(pack.FIELD48, gbl.fee_type, 4);
			strncat((char *)pack.FIELD48, "06", 2);
			strcat((char *)pack.FIELD48,gbl.new_password);
			wrLog("bit48:[%s]",pack.FIELD48);
			pack.Packet_Table[48].Real_Length = 12;
			//bit63
			memset(pack.FIELD63, 0, sizeof(pack.FIELD63) );
			strcpy((char *)pack.FIELD63, "00000000");
			strncat((char *)pack.FIELD63, "01",2);
			strncat((char *)pack.FIELD63, "12",2);
			strncat((char *)pack.FIELD63, gbl.card_no,12);
			strncat((char *)pack.FIELD63, "06",2);
			strncat((char *)pack.FIELD63, gbl.password,6);
			pack.Packet_Table[63].Real_Length = 32;
		}
		else{	//e卡
			if(gbl.posInfo.enyFlag)		//加密改造
			{
				pack.FIELD46[0] = 0x39;
				pack.FIELD46[1] = 0x64;
				pack.Packet_Table[46].Real_Length = 2;
				memcpy((char *)pack.FIELD53, gbl.posInfo.psamNum, 8);
				pack.Packet_Table[53].Real_Length = 8;
			}
			//bit48
			memset(pack.FIELD48, 0, sizeof(pack.FIELD48) );
			memcpy(pack.FIELD48, gbl.fee_type, 4);
			strncat((char *)pack.FIELD48, "16", 2);
			
			memset(new_password_buf, 0, sizeof(new_password_buf));
			CTools::byte_to_hex((BYTE *)gbl.new_password, (BYTE *)new_password_buf, 8);
			new_password_buf[16]=0;
			
			strcat((char *)pack.FIELD48,new_password_buf);
			wrLog("bit48:[%s]",pack.FIELD48);
			pack.Packet_Table[48].Real_Length = 22;
		}
		/*************************************************/
		//  查询包打包   
		iRet = packHdl(1);
		if(iRet < 0)
			return -1;
		
		if(!memcmp(pack.FIELD39,"00",2))
		{
			memset(temp_buff,0,sizeof(temp_buff));
			sprintf((char *)temp_buff," \n    修改密码成功！\n    【确认】返回");
			iRet = TS_OutPutMsg(gbl.dPosInfo, (char *)temp_buff, 0,iSelect);
			memcpy( gbl.password,gbl.new_password,sizeof(gbl.password) );
		}
		else if(!memcmp(pack.FIELD39,"55",2))
		{
			flag = 1;
			if(!memcmp(gbl.fee_type, "0095", 4))
				iRet = reGetPwd( "修改密码");
			else
				iRet = reGetPwd( "修改密码");
			if( iRet == 0) //密码错误，重新输入密码, 2006-10-25,lihk
				continue;
			else
				return CANCLE_KEY;
		}
		
		else
			iRet = returnFail((char *)pack.FIELD39);
		return iRet;
	}
	return -1;
}

//2008-12-16
//返回值：选择的第几项,成功；CANCLE_KEY,取消；其他：错误
int CTrade::selectSubcode()
{
	int iRet, iSelect;
	TSMENULIST menuList;
	memset(&menuList,0,sizeof(menuList));
	switch(atoi(gbl.fee_type))
	{
	case 100://数字电视缴费
		menuList.iTotalNum = 3;
		strcpy(menuList.acTitle, "数字电视缴费");
		strcpy(menuList.menuItem[0], "用户手册号");
		strcpy(menuList.menuItem[1], "身份证号");
		strcpy(menuList.menuItem[2], "IC号");
		
		iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
		if(iRet)
			return -1;
		switch(iSelect)
		{
		case 1:
			strcpy(gbl.sub_code,"01");
			return 1;
		case 2:
			strcpy(gbl.sub_code,"02");
			return 2;
		case 3:
			strcpy(gbl.sub_code,"03");
			return 3;
		default: 
			return CANCLE_KEY;
		}
		break;
		case 114://有线电视缴费
			menuList.iTotalNum = 2;
			strcpy(menuList.acTitle, "模拟电视(无机顶盒)");
			strcpy(menuList.menuItem[0], "用户手册号");
			strcpy(menuList.menuItem[1], "身份证号");
			
			iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
			if(iRet)
				return -1;
			switch(iSelect)
			{
			case 1:
				strcpy(gbl.sub_code,"01");
				return 1;
			case 2:
				strcpy(gbl.sub_code,"02");
				return 2;
			default: 
				return CANCLE_KEY;
			}
			break;
			case 112://珠江宽频缴费
				menuList.iTotalNum = 3;
				strcpy(menuList.acTitle, "珠江宽频缴费");
				strcpy(menuList.menuItem[0], "用户手册号");
				strcpy(menuList.menuItem[1], "身份证号");
				strcpy(menuList.menuItem[2], "MAC地址");
				
				iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
				if(iRet)
					return -1;
				switch(iSelect)
				{
				case 1:
					strcpy(gbl.sub_code,"01");
					return 1;
				case 2:
					strcpy(gbl.sub_code,"02");
					return 2;
				case 3:
					strcpy(gbl.sub_code,"04");
					return 3;
				default: 
					return CANCLE_KEY;
				}
				break;
				case 172://珠江宽频优惠
					menuList.iTotalNum = 1;
					strcpy(menuList.acTitle, "珠江宽频优惠");
					strcpy(menuList.menuItem[0], "续费1000送400");
					
					iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
					if(iRet)
						return -1;
					switch(iSelect)
					{
					case 1:			
						break;
					default: 
						return CANCLE_KEY;
					}
					
					//选择查找类型
					memset(&menuList,0,sizeof(menuList));
					menuList.iTotalNum = 3;
					strcpy(menuList.acTitle, "珠江宽频缴费");
					strcpy(menuList.menuItem[0], "用户手册号");
					strcpy(menuList.menuItem[1], "身份证号");
					strcpy(menuList.menuItem[2], "MAC地址");
					
					iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
					if(iRet)
						return -1;
					switch(iSelect)
					{
					case 1:
						strcpy(gbl.sub_code,"01");
						return 1;
					case 2:
						strcpy(gbl.sub_code,"02");
						return 2;
					case 3:
						strcpy(gbl.sub_code,"04");
						return 3;
					default: 
						return CANCLE_KEY;
					}
					
					break;
					default:
						return 0;
	} //end switch(atoi(gbl.fee_type))
	return 0;
}

//东莞通余额查询菜单
int CTrade::selectDGAmount(int flag, int select)
{
	int iRet, iSelect, count=0,j;
	TSMENULIST menuList;
	memset(&menuList,0,sizeof(menuList));

	menuList.iTotalNum = 4; 
	strcpy(menuList.acTitle, "请选择充值金额");
	for(j=0; j<menuList.iTotalNum; j++)
	{
		memset(menuList.menuItem[j], 0, sizeof(menuList.menuItem[j]));
	}
	strcpy(menuList.menuItem[0], "50元");
	strcpy(menuList.menuItem[1], "100元");
	strcpy(menuList.menuItem[2], "200元");
	strcpy(menuList.menuItem[3], "1分钱");

	iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
	if(iRet)
		return -1;
	switch(iSelect)
	{
	case 1:
		strcpy(gbl.amount,"000000005000");
		return 1;
	case 2:
		strcpy(gbl.amount,"000000010000");
		return 2;
	case 3:
		strcpy(gbl.amount,"000000020000");
		return 3;
	case 4:
		strcpy(gbl.amount,"000000000001");
		return 4;
	default: 
		return CANCLE_KEY;
		
	}


}
//2006-10-13预付费预付金选择菜单
//flag：
//0:默认值，一般选项
//1:付费易卡，多一个“按卡内余额充值”选项
//2:移动选择缴费种类菜单
//返回值：选择的第几项,成功；CANCLE_KEY,取消；其他：错误
int CTrade::selectAmount(int flag, int select)
{
	int iRet, iSelect, count=0,i,j;
	long amo;
	TSMENULIST menuList;
	
	if(flag == 1)   //默认为按金额交费
		strcpy(gbl.xlt_type,"01");
	memset(&menuList,0,sizeof(menuList));
	switch(atoi(gbl.fee_type))
	{
	case 1:		//固话/小灵通话费
	case 13:	//ADSL话费
	case 241:   //CDMA后付费
		break;
		
	case 64:  //小灵通预付费0064
	case 96:  //小灵通预付金
	case 97:  //ADSL话费预付金
	case 98:  //固话预付费0098
	case 138: //ITV预付金
	case 242: //CDMA预付金
		strcpy(menuList.acTitle, "请选择您要充值的金额");
		strcpy(menuList.menuItem[0], "2000元");
		strcpy(menuList.menuItem[1], "1000元");
		strcpy(menuList.menuItem[2], "500元");
		strcpy(menuList.menuItem[3], "200元");
		strcpy(menuList.menuItem[4], "100元");
		strcpy(menuList.menuItem[5], "50元");
		if(flag == 1)
			strcpy(menuList.menuItem[6], "按卡内余额充值");
		count = 0;
		while(strcmp(menuList.menuItem[count++], ""))
			menuList.iTotalNum++;
		if( select==0 )
		{
			iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
		}
		else
		{
			iRet = 0;
			iSelect = select;
		}
		if(iRet)
			return -1;
		switch(iSelect)
		{
		case 1:
			strcpy(gbl.amount,"000000200000");
			return 1;
		case 2:
			strcpy(gbl.amount,"000000100000");
			return 2;
		case 3:
			strcpy(gbl.amount,"000000050000");
			return 3;
		case 4:
			strcpy(gbl.amount,"000000020000");
			return 4;
		case 5:
			strcpy(gbl.amount,"000000010000");
			return 5;
		case 6:
			strcpy(gbl.amount,"000000005000");
			return 6;

		case 7:
			strcpy(gbl.xlt_type,"02");
			return 7;
		default: 
			return CANCLE_KEY;
		}
		break;
		
		case 71: //宽带预缴费0071
			memset(&menuList,0,sizeof(menuList));
			if(flag == 1)
				menuList.iTotalNum = 4;
			else
				menuList.iTotalNum = 3;
			strcpy(menuList.acTitle, "请选择您要预缴的种类");
			strcpy(menuList.menuItem[0], "预存500元赠送100元");
			strcpy(menuList.menuItem[1], "预存1000元赠送300元");
			strcpy(menuList.menuItem[2], "预存1800元赠送600元");
			if(flag == 1)
				strcpy(menuList.menuItem[3], "按卡内余额充值");
			if( select==0 )
			{
				iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
			}
			else
			{
				iRet = 0;
				iSelect = select;
			}
			if(iRet)
				return -1;
			switch(iSelect)
			{
			case 1:
				strcpy(gbl.amount,"000000050000");
				return 1;
			case 2:
				strcpy(gbl.amount,"000000100000");
				return 2;
			case 3:
				strcpy(gbl.amount,"000000180000");
				return 3;
			case 4:
				strcpy(gbl.xlt_type,"02");
				return 4;
			default: 
				return CANCLE_KEY;
			}
			break;
			
			case 46: //电信预缴费0046
				menuList.iTotalNum = 6;
				strcpy(menuList.acTitle, "请选择您要预缴的种类");
				strcpy(menuList.menuItem[0], "预存100元");
				strcpy(menuList.menuItem[1], "预存200元");
				strcpy(menuList.menuItem[2], "预存300元");
				strcpy(menuList.menuItem[3], "预存500元");
				strcpy(menuList.menuItem[4], "预存1000元");
				strcpy(menuList.menuItem[5], "预存2000元");
				if( select==0 )
				{
					iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
				}
				else
				{
					iRet = 0;
					iSelect = select;
				}
				if(iRet)
					return -1;
				switch(iSelect)
				{
				case 1:
					strcpy(gbl.amount,"000000010000");
					return 1;
				case 2:
					strcpy(gbl.amount,"000000020000");
					return 2;
				case 3:
					strcpy(gbl.amount,"000000030000");
					return 3;
				case 4:
					strcpy(gbl.amount,"000000050000");
					return 4;
				case 5:
					strcpy(gbl.amount,"000000100000");
					return 5;
				case 6:
					strcpy(gbl.amount,"000000200000");
					return 6;
				default: 
					return CANCLE_KEY;
				}
				break;
				
				case 140: //预付费ADSL充值 2007-01-29 by lihk
					//	case 143: //自由互联  2007-3-2 by lihk
					if(flag == 1)  //付费易卡
						menuList.iTotalNum = 5;
					else
						menuList.iTotalNum = 4;
					strcpy(menuList.acTitle, "请选择您要充值的金额");
					strcpy(menuList.menuItem[0], "50元");
					strcpy(menuList.menuItem[1], "100元");
					strcpy(menuList.menuItem[2], "200元");
					strcpy(menuList.menuItem[3], "500元");
					if(flag == 1)
						strcpy(menuList.menuItem[4], "按卡内余额充值");
					if( select==0 )
					{
						iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
					}
					else
					{
						iRet = 0;
						iSelect = select;
					}
					if(iRet)
						return -1;
					switch(iSelect)
					{
					case 1:
						strcpy(gbl.amount,"000000005000");
						return 1;
					case 2:
						strcpy(gbl.amount,"000000010000");
						return 2;
					case 3:
						strcpy(gbl.amount,"000000020000");
						return 3;
					case 4:
						strcpy(gbl.amount,"000000050000");
						return 4;
					case 5:
						strcpy(gbl.xlt_type,"02");
						return 5;
					default: 
						return CANCLE_KEY;
					}
					break;
					
					case 143: //自由互联  2007-3-2 by lihk
						//		if(flag == 1)  //付费易卡
						//			menuList.iTotalNum = 6;
						//		else
						menuList.iTotalNum = 5;
						strcpy(menuList.acTitle, "请选择您要充值的金额");
						strcpy(menuList.menuItem[0], "30元");
						strcpy(menuList.menuItem[1], "50元");
						strcpy(menuList.menuItem[2], "100元");
						strcpy(menuList.menuItem[3], "200元");
						strcpy(menuList.menuItem[4], "500元");
						//		if(flag == 1)
						//			strcpy(menuList.menuItem[5], "按卡内余额充值");
						if( select==0 )
						{
							iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
						}
						else
						{
							iRet = 0;
							iSelect = select;
						}
						if(iRet)
							return -1;
						switch(iSelect)
						{
						case 1:
							strcpy(gbl.amount,"000000003000");
							return 1;
						case 2:
							strcpy(gbl.amount,"000000005000");
							return 2;
						case 3:
							strcpy(gbl.amount,"000000010000");
							return 3;
						case 4:
							strcpy(gbl.amount,"000000020000");
							return 4;
						case 5:
							strcpy(gbl.amount,"000000050000");
							return 5;
							//		case 6:
							//			strcpy(gbl.xlt_type,"02");
							//			return 6;
						default: 
							return CANCLE_KEY;
						}
						break;
						
						case 49: //联通预付费0049
						case 3012:	//移动
							if(!memcmp(gbl.fee_type, "3012", 4) && flag == 2)
							{
								menuList.iTotalNum = 2;
								strcpy(menuList.acTitle, "请选择您要缴费的种类");
								strcpy(menuList.menuItem[0], "缴费");
								strcpy(menuList.menuItem[1], "预付费");
								if( select==0 )
								{
									iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
								}
								else
								{
									iRet = 0;
									iSelect = select;
								}
								if(iRet)
									return -1;
								switch(iSelect)
								{
								case 1:
									return 1;
								case 2:
									return 2;
								default:
									return CANCLE_KEY;
								}
							}
							memset(&menuList,0,sizeof(menuList));
							menuList.iTotalNum = 4;
							strcpy(menuList.acTitle, "请选择您要充值的金额");
							strcpy(menuList.menuItem[0], "100元");
							strcpy(menuList.menuItem[1], "150元");
							strcpy(menuList.menuItem[2], "200元");
							strcpy(menuList.menuItem[3], "300元");
							if( select==0 )
							{
								iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
							}
							else
							{
								iRet = 0;
								iSelect = select;
							}
							if(iRet)
								return -1;
							
							char tmp[12+1];
							memset(tmp, 0, sizeof(tmp));
							amo = 0;
							if(!memcmp(gbl.fee_type, "3012", 4))//移动	
								amo = atol(gbl.amount);
							wrLog("移动选择预付费");
							memset(gbl.amount, 0, sizeof(gbl.amount));
							switch(iSelect)
							{
							case 1:
								if(!memcmp(gbl.fee_type, "3012", 4))//移动
								{
									if(amo)	//若有欠费，lihk，2006-10-25 
										memcpy(gbl.tmp_pre_amount, "000000010000", 12);	
									amo += atol("000000010000");
									CTools::longToMny(amo, tmp);
									wrLog("tmp:[%s]",tmp);
									CTools::chg12asc(tmp, gbl.amount);
								}
								else
									strcpy(gbl.amount,"000000010000");
								return 1;
								
							case 2:
								if(!memcmp(gbl.fee_type, "3012", 4))//移动
								{
									if(amo)
										memcpy(gbl.tmp_pre_amount, "000000015000", 12);
									amo += atol("000000015000");
									CTools::longToMny(amo, tmp);
									CTools::chg12asc(tmp, gbl.amount);
								}
								else
									strcpy(gbl.amount,"000000015000");
								return 2;
								
							case 3:
								if(!memcmp(gbl.fee_type, "3012", 4))//移动
								{
									if(amo)
										memcpy(gbl.tmp_pre_amount, "000000020000", 12);
									amo += atol("000000020000");
									CTools::longToMny(amo, tmp);
									CTools::chg12asc(tmp, gbl.amount);
								}
								else
									strcpy(gbl.amount,"000000020000");
								return 3;
							case 4:
								if(!memcmp(gbl.fee_type, "3012", 4))//移动
								{
									if(amo)
										memcpy(gbl.tmp_pre_amount, "000000030000", 12);
									amo += atol("000000030000");
									CTools::longToMny(amo, tmp);
									CTools::chg12asc(tmp, gbl.amount);
								}
								else
									strcpy(gbl.amount,"000000030000");
								return 4;
							default: 
								return CANCLE_KEY;
							}
							break;
							
							case 76: //Q币充值
							case 167:
								if (flag == 2)
								{
									menuList.iTotalNum = 7;
									sprintf(menuList.acTitle, "号码:【%s】  Q币充值",gbl.phone_no);
									strcpy(menuList.menuItem[0], "10个Q币  10元"); 
									strcpy(menuList.menuItem[1], "20个Q币  20元");
									strcpy(menuList.menuItem[2], "30个Q币  30元");
									strcpy(menuList.menuItem[3], "50个Q币  50元");
									strcpy(menuList.menuItem[4], "100个Q币  100元");
									strcpy(menuList.menuItem[5], "200个Q币  200元");
									//strcpy(menuList.menuItem[6], "其它");
									strcpy(menuList.menuItem[6], "交纳固话");
								}else{
									menuList.iTotalNum = 6;
									strcpy(menuList.acTitle, "请选择您要充的Q币个数");
									strcpy(menuList.menuItem[0], "10个Q币  10元");
									strcpy(menuList.menuItem[1], "20个Q币  20元");
									strcpy(menuList.menuItem[2], "30个Q币  30元");
									strcpy(menuList.menuItem[3], "50个Q币  50元");
									strcpy(menuList.menuItem[4], "100个Q币  100元");
									strcpy(menuList.menuItem[5], "200个Q币  200元");
									//strcpy(menuList.menuItem[6], "其它");
								}
								
								if( select==0 )
								{
									iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
								}
								else
								{
									iRet = 0;
									iSelect = select;
								}
								if(iRet)
									return -1;
								switch(iSelect)
								{
								case 1:
									// 			if(atoi(gbl.dPosInfo.prmVer)>=9000)
									// 			{
									// 				bbzero(gbl.QQrate);
									// 				bbzero(gbl.fee_type);
									// 				strcpy(gbl.fee_type,"0295");
									// 				strcpy(gbl.QQrate,"100");
									// 				strcpy(gbl.QQ_amount,"0010");
									// 				sprintf(gbl.amount,"%0.12d",10*atoi(gbl.QQrate));
									// 			}else{
									strcpy(gbl.QQ_amount,"0010");
									sprintf(gbl.amount,"%0.12d",10*atoi(gbl.QQrate)); 
									bbzero(gbl.glQQPayInfo.RECHNUM);
									strcpy(gbl.glQQPayInfo.RECHNUM,"10");
									strcpy(gbl.glQQPayInfo.RECHAMOUNT,"1000");
									bbzero(gbl.glQQPayInfo.PRODUCTCODE);
								//	strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1015");
									strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1027");


									//			}
									return 1;
								case 2:
									// 			if(atoi(gbl.dPosInfo.prmVer)>=9000)
									// 			{
									// 				bbzero(gbl.QQrate);
									// 				bbzero(gbl.fee_type);
									// 				strcpy(gbl.fee_type,"0295");
									// 				strcpy(gbl.QQrate,"100");
									// 				strcpy(gbl.QQ_amount,"0020");
									// 				sprintf(gbl.amount,"%0.12d",20*atoi(gbl.QQrate));
									// 			}else{
									strcpy(gbl.QQ_amount,"0020");
									sprintf(gbl.amount,"%0.12d",20*atoi(gbl.QQrate));
									bbzero(gbl.glQQPayInfo.RECHNUM);
									strcpy(gbl.glQQPayInfo.RECHNUM,"20");
									bbzero(gbl.glQQPayInfo.RECHAMOUNT);
									strcpy(gbl.glQQPayInfo.RECHAMOUNT,"2000");
									bbzero(gbl.glQQPayInfo.PRODUCTCODE);
									//strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1015");
									strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1027");
									//			}
									
									return 2;
								case 3:
									// 			if(atoi(gbl.dPosInfo.prmVer)>=9000)
									// 			{
									// 				bbzero(gbl.QQrate);
									// 				bbzero(gbl.fee_type);
									// 				strcpy(gbl.fee_type,"0295");
									// 				strcpy(gbl.QQrate,"100");
									// 				strcpy(gbl.QQ_amount,"0030");
									// 				sprintf(gbl.amount,"%0.12d",30*atoi(gbl.QQrate));
									// 			}else{
									strcpy(gbl.QQ_amount,"0030");
									sprintf(gbl.amount,"%0.12d",30*atoi(gbl.QQrate));
									bbzero(gbl.glQQPayInfo.RECHNUM);
									strcpy(gbl.glQQPayInfo.RECHNUM,"30");
									bbzero(gbl.glQQPayInfo.RECHAMOUNT);
									strcpy(gbl.glQQPayInfo.RECHAMOUNT,"3000");
									bbzero(gbl.glQQPayInfo.PRODUCTCODE);
								//	strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1015");
									strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1027");
									//			}
									
									return 3;
								case 4:
									strcpy(gbl.QQ_amount,"0050");
									sprintf(gbl.amount,"%0.12d",50*atoi(gbl.QQrate));
									bbzero(gbl.glQQPayInfo.RECHNUM);
									strcpy(gbl.glQQPayInfo.RECHNUM,"50");
									bbzero(gbl.glQQPayInfo.RECHAMOUNT);
									strcpy(gbl.glQQPayInfo.RECHAMOUNT,"5000");
									bbzero(gbl.glQQPayInfo.PRODUCTCODE);
									//strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1015");
									strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1027");

									return 4;
								case 5:
									strcpy(gbl.QQ_amount,"0100");
									sprintf(gbl.amount,"%0.12d",100*atoi(gbl.QQrate));
									bbzero(gbl.glQQPayInfo.RECHNUM);
									strcpy(gbl.glQQPayInfo.RECHNUM,"100");
									bbzero(gbl.glQQPayInfo.RECHAMOUNT);
									strcpy(gbl.glQQPayInfo.RECHAMOUNT,"10000");
									bbzero(gbl.glQQPayInfo.PRODUCTCODE);
									//strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1015");
									strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1027");
									return 5;
								case 6:
									strcpy(gbl.QQ_amount,"0200");
									sprintf(gbl.amount,"%0.12d",200*atoi(gbl.QQrate));
									bbzero(gbl.glQQPayInfo.RECHNUM);
									strcpy(gbl.glQQPayInfo.RECHNUM,"200");
									bbzero(gbl.glQQPayInfo.RECHAMOUNT);
									strcpy(gbl.glQQPayInfo.RECHAMOUNT,"20000");
									bbzero(gbl.glQQPayInfo.PRODUCTCODE);
									//strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1015");
									strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1027");
									return 6;
								case 7:
								/*
								{
										
								
									TSTradeInfoSend tradeInfoSend;
									TSTradeInfoRecv tradeInfoRecv;
									memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
									memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
									strcpy(tradeInfoSend.acMainTitle, "可输入5-200个");
									tradeInfoSend.uHasTradeID = 1; //返回终端流水
									tradeInfoSend.uTotalContents = 1;	//项数
									strcpy(tradeInfoSend.Contents[0].acTitle, "请填写你充值的Q币个数（可输入5-200个）");	
									tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字	
									tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
									tradeInfoSend.Contents[0].uMinLen = 1;		
									tradeInfoSend.Contents[0].uMaxLen = 3;	

									iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
									if(iRet != 0)
									{
										wrLog("TS_TradeControl返回错误[%d]", iRet);
										wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
										return -1;
									}
									
									int iQB = 0;
									iQB = atoi((char *)tradeInfoRecv.Contents[0].uMsg);

									if(iQB < 5 || iQB > 200)
									{
										wrLog("输入Q币[%d]超出范围", iQB);
										wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
										TS_OutPutMsg(gbl.dPosInfo, "输入Q币必须是5-200个",0,iSelect);
										return -1;
									}
									
									sprintf(gbl.QQ_amount,"%04d",iQB);
									sprintf(gbl.amount,"%0.12d",iQB*atoi(gbl.QQrate));
									bbzero(gbl.glQQPayInfo.RECHNUM);
									strcpy(gbl.glQQPayInfo.RECHNUM,(char *)tradeInfoRecv.Contents[0].uMsg);

									char szRECHAMOUNT[5 + 1];
									strcpy(szRECHAMOUNT,(char *)tradeInfoRecv.Contents[0].uMsg);
									strcat(szRECHAMOUNT,"00");
									bbzero(gbl.glQQPayInfo.RECHAMOUNT);
									strcpy(gbl.glQQPayInfo.RECHAMOUNT,szRECHAMOUNT);

									bbzero(gbl.glQQPayInfo.PRODUCTCODE);
								//	strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1015");
									strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1027");

								}
								*/
									return 7;
								case 8:
									return 8;
								default: 
									return CANCLE_KEY;
								}
								break;
								
								case 341:
									menuList.iTotalNum = 6;
									strcpy(menuList.acTitle, "请选择QQ充值金额");
									strcpy(menuList.menuItem[0], "10元");
									strcpy(menuList.menuItem[1], "20元");
									strcpy(menuList.menuItem[2], "50元");
									strcpy(menuList.menuItem[3], "100元");
									strcpy(menuList.menuItem[4], "300元");
									strcpy(menuList.menuItem[5], "500元");
									
									if( select==0 )
									{
										iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
									}
									else
									{
										iRet = 0;
										iSelect = select;
									}
									if(iRet)
										return -1;
									switch(iSelect)
									{
										
									case 1:
										strcpy(gbl.amount,"000000001000");
										return 1;
									case 2:
										strcpy(gbl.amount,"000000002000");
										return 2;
									case 3:
										strcpy(gbl.amount,"000000005000");
										return 3;
									case 4:
										strcpy(gbl.amount,"000000010000");
										return 4;
									case 5:
										strcpy(gbl.amount,"000000030000");
										return 5;
									case 6:
										strcpy(gbl.amount,"000000050000");
										return 6;
									default: 
										return CANCLE_KEY;
									}
									
									break;
									
									case 77: //QQ会员包月
									case 168:
										menuList.iTotalNum = 5;
										strcpy(menuList.acTitle, "QQ会员包月");
										strcpy(menuList.menuItem[0], "1个月  10元");
										strcpy(menuList.menuItem[1], "3个月  30元");
										strcpy(menuList.menuItem[2], "6个月  60元");
										strcpy(menuList.menuItem[3], "9个月  90元");
										strcpy(menuList.menuItem[4], "12个月  120元");
										//strcpy(menuList.menuItem[5], "18个月  180元"); //删除18个月的套餐
										if( select==0 )
										{
											iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
										}
										else
										{
											iRet = 0;
											iSelect = select;
										}
										if(iRet)
											return -1;
										switch(iSelect)
										{
										case 1:
											sprintf(gbl.QQ_amount,"%0.4d",1);
											sprintf(gbl.amount,"%0.12d",1*atoi(gbl.QQrate)*100);
											bbzero(gbl.glQQPayInfo.RECHNUM);
											strcpy(gbl.glQQPayInfo.RECHNUM,"1");
											bbzero(gbl.glQQPayInfo.RECHAMOUNT);
											strcpy(gbl.glQQPayInfo.RECHAMOUNT,"1000");
											bbzero(gbl.glQQPayInfo.PRODUCTCODE);
										//	strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1013");
											strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1026");

											return 1;
										case 2:
											sprintf(gbl.QQ_amount,"%0.4d",3);
											sprintf(gbl.amount,"%0.12d",3*atoi(gbl.QQrate)*100);
											bbzero(gbl.glQQPayInfo.RECHNUM);
											strcpy(gbl.glQQPayInfo.RECHNUM,"3");
											bbzero(gbl.glQQPayInfo.RECHAMOUNT);
											strcpy(gbl.glQQPayInfo.RECHAMOUNT,"3000");
											bbzero(gbl.glQQPayInfo.PRODUCTCODE);
											//strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1013");
											strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1026");

											return 2;
										case 3:
											sprintf(gbl.QQ_amount,"%0.4d",6);
											sprintf(gbl.amount,"%0.12d",6*atoi(gbl.QQrate)*100);
											bbzero(gbl.glQQPayInfo.RECHNUM);
											strcpy(gbl.glQQPayInfo.RECHNUM,"6");
											bbzero(gbl.glQQPayInfo.RECHAMOUNT);
											strcpy(gbl.glQQPayInfo.RECHAMOUNT,"6000");
											bbzero(gbl.glQQPayInfo.PRODUCTCODE);
											//strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1013");
											strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1026");

											return 3;
										case 4:
											sprintf(gbl.QQ_amount,"%0.4d",9);
											sprintf(gbl.amount,"%0.12d",9*atoi(gbl.QQrate)*100);
											bbzero(gbl.glQQPayInfo.RECHNUM);
											strcpy(gbl.glQQPayInfo.RECHNUM,"9");
											bbzero(gbl.glQQPayInfo.RECHAMOUNT);
											strcpy(gbl.glQQPayInfo.RECHAMOUNT,"9000");
											bbzero(gbl.glQQPayInfo.PRODUCTCODE);
											//strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1013");
											strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1026");

											return 4;
										case 5:
											sprintf(gbl.QQ_amount,"%0.4d",12);
											sprintf(gbl.amount,"%0.12d",12*atoi(gbl.QQrate)*100);
											bbzero(gbl.glQQPayInfo.RECHNUM);
											strcpy(gbl.glQQPayInfo.RECHNUM,"12");
											bbzero(gbl.glQQPayInfo.RECHAMOUNT);
											strcpy(gbl.glQQPayInfo.RECHAMOUNT,"12000");
											bbzero(gbl.glQQPayInfo.PRODUCTCODE);
										//	strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1013");
											strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1026");

											return 5;
										/*
										case 6:
											sprintf(gbl.QQ_amount,"%0.4d",18);
											sprintf(gbl.amount,"%0.12d",18*atoi(gbl.QQrate)*100);
											bbzero(gbl.glQQPayInfo.RECHNUM);
											strcpy(gbl.glQQPayInfo.RECHNUM,"18");
											bbzero(gbl.glQQPayInfo.RECHAMOUNT);
											strcpy(gbl.glQQPayInfo.RECHAMOUNT,"18000");
											bbzero(gbl.glQQPayInfo.PRODUCTCODE);
										//	strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1013");
											strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1026");

											return 6;

										*/

										default: 
											return CANCLE_KEY;
										}
										break;
										case 273:
										case 277:
											menuList.iTotalNum = 5;
											strcpy(menuList.acTitle, "QQ堂紫钻包月");
											strcpy(menuList.menuItem[0], "1个月  10元");
											strcpy(menuList.menuItem[1], "3个月  30元");
											strcpy(menuList.menuItem[2], "6个月  60元");
											strcpy(menuList.menuItem[3], "9个月  90元");
											strcpy(menuList.menuItem[4], "12个月  120元");
											//strcpy(menuList.menuItem[5], "18个月  180元");
											if( select==0 )
											{
												iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
											}
											else
											{
												iRet = 0;
												iSelect = select;
											}
											if(iRet)
												return -1;
											switch(iSelect)
											{
											case 1:
												sprintf(gbl.QQ_amount,"%0.4d",1);
												sprintf(gbl.amount,"%0.12d",1*atoi(gbl.QQrate)*100);
												bbzero(gbl.glQQPayInfo.RECHNUM);
												strcpy(gbl.glQQPayInfo.RECHNUM,"1");
												bbzero(gbl.glQQPayInfo.RECHAMOUNT);
												strcpy(gbl.glQQPayInfo.RECHAMOUNT,"1000");
												bbzero(gbl.glQQPayInfo.PRODUCTCODE);
												//strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1012");
												strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1025");

												return 1;
											case 2:
												sprintf(gbl.QQ_amount,"%0.4d",3);
												sprintf(gbl.amount,"%0.12d",3*atoi(gbl.QQrate)*100);
												bbzero(gbl.glQQPayInfo.RECHNUM);
												strcpy(gbl.glQQPayInfo.RECHNUM,"3");
												bbzero(gbl.glQQPayInfo.RECHAMOUNT);
												strcpy(gbl.glQQPayInfo.RECHAMOUNT,"3000");
												bbzero(gbl.glQQPayInfo.PRODUCTCODE);
											//	strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1012");
												strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1025");
												return 2;
											case 3:
												sprintf(gbl.QQ_amount,"%0.4d",6);
												sprintf(gbl.amount,"%0.12d",6*atoi(gbl.QQrate)*100);
												bbzero(gbl.glQQPayInfo.RECHNUM);
												strcpy(gbl.glQQPayInfo.RECHNUM,"6");
												bbzero(gbl.glQQPayInfo.RECHAMOUNT);
												strcpy(gbl.glQQPayInfo.RECHAMOUNT,"6000");
												bbzero(gbl.glQQPayInfo.PRODUCTCODE);
												//strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1012");
												strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1025");

												return 3;
											case 4:
												sprintf(gbl.QQ_amount,"%0.4d",9);
												sprintf(gbl.amount,"%0.12d",9*atoi(gbl.QQrate)*100);
												bbzero(gbl.glQQPayInfo.RECHNUM);
												strcpy(gbl.glQQPayInfo.RECHNUM,"9");
												bbzero(gbl.glQQPayInfo.RECHAMOUNT);
												strcpy(gbl.glQQPayInfo.RECHAMOUNT,"9000");
												bbzero(gbl.glQQPayInfo.PRODUCTCODE);
												//strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1012");
												strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1025");

												return 4;
											case 5:
												sprintf(gbl.QQ_amount,"%0.4d",12);
												sprintf(gbl.amount,"%0.12d",12*atoi(gbl.QQrate)*100);
												bbzero(gbl.glQQPayInfo.RECHNUM);
												strcpy(gbl.glQQPayInfo.RECHNUM,"12");
												bbzero(gbl.glQQPayInfo.RECHAMOUNT);
												strcpy(gbl.glQQPayInfo.RECHAMOUNT,"12000");
												bbzero(gbl.glQQPayInfo.PRODUCTCODE);
												//strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1012");
												strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1025");

												return 5;
											/*
											case 6:
												sprintf(gbl.QQ_amount,"%0.4d",18);
												sprintf(gbl.amount,"%0.12d",18*atoi(gbl.QQrate)*100);
												bbzero(gbl.glQQPayInfo.RECHNUM);
												strcpy(gbl.glQQPayInfo.RECHNUM,"18");
												bbzero(gbl.glQQPayInfo.RECHAMOUNT);
												strcpy(gbl.glQQPayInfo.RECHAMOUNT,"18000");
												bbzero(gbl.glQQPayInfo.PRODUCTCODE);
												//strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1012");
												strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1025");
												return 6;
											*/
											default: 
												return CANCLE_KEY;
											}
											break;
											case 88:
											case 294:
												menuList.iTotalNum = 5;
												strcpy(menuList.acTitle, "蓝钻贵族包月");
												strcpy(menuList.menuItem[0], "1个月  10元");
												strcpy(menuList.menuItem[1], "3个月  30元");
												strcpy(menuList.menuItem[2], "6个月  60元");
												strcpy(menuList.menuItem[3], "9个月  90元");
												strcpy(menuList.menuItem[4], "12个月  120元");
												//strcpy(menuList.menuItem[5], "18个月  180元");
												if( select==0 )
												{
													iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
												}
												else
												{
													iRet = 0;
													iSelect = select;
												}
												if(iRet)
													return -1;
												switch(iSelect)
												{
												case 1:
													sprintf(gbl.QQ_amount,"%0.4d",1);
													sprintf(gbl.amount,"%0.12d",1*atoi(gbl.QQrate)*100);
													bbzero(gbl.glQQPayInfo.RECHNUM);
													strcpy(gbl.glQQPayInfo.RECHNUM,"1");
													bbzero(gbl.glQQPayInfo.RECHAMOUNT);
													strcpy(gbl.glQQPayInfo.RECHAMOUNT,"1000");
													bbzero(gbl.glQQPayInfo.PRODUCTCODE);
													//strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1010");
													strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1023");


													return 1;
												case 2:
													sprintf(gbl.QQ_amount,"%0.4d",3);
													sprintf(gbl.amount,"%0.12d",3*atoi(gbl.QQrate)*100);
													bbzero(gbl.glQQPayInfo.RECHNUM);
													strcpy(gbl.glQQPayInfo.RECHNUM,"3");
													bbzero(gbl.glQQPayInfo.RECHAMOUNT);
													strcpy(gbl.glQQPayInfo.RECHAMOUNT,"3000");
													bbzero(gbl.glQQPayInfo.PRODUCTCODE);
													//strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1010");
													strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1023");


													return 2;
												case 3:
													sprintf(gbl.QQ_amount,"%0.4d",6);
													sprintf(gbl.amount,"%0.12d",6*atoi(gbl.QQrate)*100);
													bbzero(gbl.glQQPayInfo.RECHNUM);
													strcpy(gbl.glQQPayInfo.RECHNUM,"6");
													bbzero(gbl.glQQPayInfo.RECHAMOUNT);
													strcpy(gbl.glQQPayInfo.RECHAMOUNT,"6000");
													bbzero(gbl.glQQPayInfo.PRODUCTCODE);
													//strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1010");
													strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1023");

													return 3;
												case 4:
													sprintf(gbl.QQ_amount,"%0.4d",9);
													sprintf(gbl.amount,"%0.12d",9*atoi(gbl.QQrate)*100);
													bbzero(gbl.glQQPayInfo.RECHNUM);
													strcpy(gbl.glQQPayInfo.RECHNUM,"9");
													bbzero(gbl.glQQPayInfo.RECHAMOUNT);
													strcpy(gbl.glQQPayInfo.RECHAMOUNT,"9000");
													bbzero(gbl.glQQPayInfo.PRODUCTCODE);
													//strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1010");
													strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1023");


													return 4;
												case 5:
													sprintf(gbl.QQ_amount,"%0.4d",12);
													sprintf(gbl.amount,"%0.12d",12*atoi(gbl.QQrate)*100);
													bbzero(gbl.glQQPayInfo.RECHNUM);
													strcpy(gbl.glQQPayInfo.RECHNUM,"12");
													bbzero(gbl.glQQPayInfo.RECHAMOUNT);
													strcpy(gbl.glQQPayInfo.RECHAMOUNT,"12000");
													bbzero(gbl.glQQPayInfo.PRODUCTCODE);
													//strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1010");
													strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1023");

													return 5;

													/*
												case 6:
													sprintf(gbl.QQ_amount,"%0.4d",18);
													sprintf(gbl.amount,"%0.12d",18*atoi(gbl.QQrate)*100);
													bbzero(gbl.glQQPayInfo.RECHNUM);
													strcpy(gbl.glQQPayInfo.RECHNUM,"18");
													bbzero(gbl.glQQPayInfo.RECHAMOUNT);
													strcpy(gbl.glQQPayInfo.RECHAMOUNT,"18000");
													bbzero(gbl.glQQPayInfo.PRODUCTCODE);
													//strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1010");
													strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1023");

													return 6;
													*/

												default: 
													return CANCLE_KEY;
												}
												break;
												case 87:
												case 293:
													menuList.iTotalNum = 5;
													strcpy(menuList.acTitle, "红钻贵族包月");
													strcpy(menuList.menuItem[0], "1个月  10元");
													strcpy(menuList.menuItem[1], "3个月  30元");
													strcpy(menuList.menuItem[2], "6个月  60元");
													strcpy(menuList.menuItem[3], "9个月  90元");
													strcpy(menuList.menuItem[4], "12个月  120元");
													//strcpy(menuList.menuItem[5], "18个月  180元");
													if( select==0 )
													{
														iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
													}
													else
													{
														iRet = 0;
														iSelect = select;
													}
													if(iRet)
														return -1;
													switch(iSelect)
													{
													case 1:
														sprintf(gbl.QQ_amount,"%0.4d",1);
														sprintf(gbl.amount,"%0.12d",1*atoi(gbl.QQrate)*100);
														bbzero(gbl.glQQPayInfo.RECHNUM);
														strcpy(gbl.glQQPayInfo.RECHNUM,"1");
														bbzero(gbl.glQQPayInfo.RECHAMOUNT);
														strcpy(gbl.glQQPayInfo.RECHAMOUNT,"1000");
														bbzero(gbl.glQQPayInfo.PRODUCTCODE);
														//strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1011");
														strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1024");
														return 1;
													case 2:
														sprintf(gbl.QQ_amount,"%0.4d",3);
														sprintf(gbl.amount,"%0.12d",3*atoi(gbl.QQrate)*100);
														bbzero(gbl.glQQPayInfo.RECHNUM);
														strcpy(gbl.glQQPayInfo.RECHNUM,"3");
														bbzero(gbl.glQQPayInfo.RECHAMOUNT);
														strcpy(gbl.glQQPayInfo.RECHAMOUNT,"3000");
														bbzero(gbl.glQQPayInfo.PRODUCTCODE);
														//strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1011");
														strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1024");


														return 2;
													case 3:
														sprintf(gbl.QQ_amount,"%0.4d",6);
														sprintf(gbl.amount,"%0.12d",6*atoi(gbl.QQrate)*100);
														bbzero(gbl.glQQPayInfo.RECHNUM);
														strcpy(gbl.glQQPayInfo.RECHNUM,"6");
														bbzero(gbl.glQQPayInfo.RECHAMOUNT);
														strcpy(gbl.glQQPayInfo.RECHAMOUNT,"6000");
														bbzero(gbl.glQQPayInfo.PRODUCTCODE);
														//strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1011");
														strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1024");

														return 3;
													case 4:
														sprintf(gbl.QQ_amount,"%0.4d",9);
														sprintf(gbl.amount,"%0.12d",9*atoi(gbl.QQrate)*100);
														bbzero(gbl.glQQPayInfo.RECHNUM);
														strcpy(gbl.glQQPayInfo.RECHNUM,"9");
														bbzero(gbl.glQQPayInfo.RECHAMOUNT);
														strcpy(gbl.glQQPayInfo.RECHAMOUNT,"9000");
														bbzero(gbl.glQQPayInfo.PRODUCTCODE);
														//strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1011");
														strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1024");

														return 4;
													case 5:
														sprintf(gbl.QQ_amount,"%0.4d",12);
														sprintf(gbl.amount,"%0.12d",12*atoi(gbl.QQrate)*100);
														bbzero(gbl.glQQPayInfo.RECHNUM);
														strcpy(gbl.glQQPayInfo.RECHNUM,"12");
														bbzero(gbl.glQQPayInfo.RECHAMOUNT);
														strcpy(gbl.glQQPayInfo.RECHAMOUNT,"12000");
														bbzero(gbl.glQQPayInfo.PRODUCTCODE);
														//strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1011");
														strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1024");

														return 5;
													/*
													case 6:
														sprintf(gbl.QQ_amount,"%0.4d",18);
														sprintf(gbl.amount,"%0.12d",18*atoi(gbl.QQrate)*100);
														bbzero(gbl.glQQPayInfo.RECHNUM);
														strcpy(gbl.glQQPayInfo.RECHNUM,"18");
														bbzero(gbl.glQQPayInfo.RECHAMOUNT);
														strcpy(gbl.glQQPayInfo.RECHAMOUNT,"18000");
														bbzero(gbl.glQQPayInfo.PRODUCTCODE);
														//strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1011");
														strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1024");

														return 6;
													*/

													default: 
														return CANCLE_KEY;
													}
													break;
													case 274:
													case 278:
														menuList.iTotalNum = 5;
														strcpy(menuList.acTitle, "黄钻贵族包月");
														strcpy(menuList.menuItem[0], "1个月  10元");
														strcpy(menuList.menuItem[1], "3个月  30元");
														strcpy(menuList.menuItem[2], "6个月  60元");
														strcpy(menuList.menuItem[3], "9个月  90元");
														strcpy(menuList.menuItem[4], "12个月  120元");
														//strcpy(menuList.menuItem[5], "18个月  180元");
														if( select==0 )
														{
															iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
														}
														else
														{
															iRet = 0;
															iSelect = select;
														}
														if(iRet)
															return -1;
														switch(iSelect)
														{
														case 1:
															sprintf(gbl.QQ_amount,"%0.4d",1);
															sprintf(gbl.amount,"%0.12d",1*atoi(gbl.QQrate)*100);
															bbzero(gbl.glQQPayInfo.RECHNUM);
															strcpy(gbl.glQQPayInfo.RECHNUM,"1");
															bbzero(gbl.glQQPayInfo.RECHAMOUNT);
															strcpy(gbl.glQQPayInfo.RECHAMOUNT,"1000");
															bbzero(gbl.glQQPayInfo.PRODUCTCODE);
															//strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1014");
															strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1022");

															return 1;
														case 2:
															sprintf(gbl.QQ_amount,"%0.4d",3);
															sprintf(gbl.amount,"%0.12d",3*atoi(gbl.QQrate)*100);
															bbzero(gbl.glQQPayInfo.RECHNUM);
															strcpy(gbl.glQQPayInfo.RECHNUM,"3");
															bbzero(gbl.glQQPayInfo.RECHAMOUNT);
															strcpy(gbl.glQQPayInfo.RECHAMOUNT,"3000");
															bbzero(gbl.glQQPayInfo.PRODUCTCODE);
															//strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1014");
															strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1022");

															return 2;
														case 3:
															sprintf(gbl.QQ_amount,"%0.4d",6);
															sprintf(gbl.amount,"%0.12d",6*atoi(gbl.QQrate)*100);
															bbzero(gbl.glQQPayInfo.RECHNUM);
															strcpy(gbl.glQQPayInfo.RECHNUM,"6");
															bbzero(gbl.glQQPayInfo.RECHAMOUNT);
															strcpy(gbl.glQQPayInfo.RECHAMOUNT,"6000");
															bbzero(gbl.glQQPayInfo.PRODUCTCODE);
															//strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1014");
															strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1022");

															return 3;
														case 4:
															sprintf(gbl.QQ_amount,"%0.4d",9);
															sprintf(gbl.amount,"%0.12d",9*atoi(gbl.QQrate)*100);
															bbzero(gbl.glQQPayInfo.RECHNUM);
															strcpy(gbl.glQQPayInfo.RECHNUM,"9");
															bbzero(gbl.glQQPayInfo.RECHAMOUNT);
															strcpy(gbl.glQQPayInfo.RECHAMOUNT,"9000");
															bbzero(gbl.glQQPayInfo.PRODUCTCODE);
															//strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1014");
															strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1022");
															return 4;
														case 5:
															sprintf(gbl.QQ_amount,"%0.4d",12);
															sprintf(gbl.amount,"%0.12d",12*atoi(gbl.QQrate)*100);
															bbzero(gbl.glQQPayInfo.RECHNUM);
															strcpy(gbl.glQQPayInfo.RECHNUM,"12");
															bbzero(gbl.glQQPayInfo.RECHAMOUNT);
															strcpy(gbl.glQQPayInfo.RECHAMOUNT,"12000");
															bbzero(gbl.glQQPayInfo.PRODUCTCODE);
															//strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1014");
															strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1022");

															return 5;
														/*
														case 6:
															sprintf(gbl.QQ_amount,"%0.4d",18);
															sprintf(gbl.amount,"%0.12d",18*atoi(gbl.QQrate)*100);
															bbzero(gbl.glQQPayInfo.RECHNUM);
															strcpy(gbl.glQQPayInfo.RECHNUM,"18");
															bbzero(gbl.glQQPayInfo.RECHAMOUNT);
															strcpy(gbl.glQQPayInfo.RECHAMOUNT,"18000");
															bbzero(gbl.glQQPayInfo.PRODUCTCODE);
															//strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1014");
															strcpy(gbl.glQQPayInfo.PRODUCTCODE,"1022");
															return 6;
														*/

														default: 
															return CANCLE_KEY;
														}
														break;
														
														//售卡业务
														case 89:
														case 153:
															memset(&menuList,0,sizeof(menuList));
															if ( atoi(gbl.sell_card_type) == 40)
																menuList.iTotalNum = 7;
															else if(atoi(gbl.sell_card_type) == 30 || atoi(gbl.sell_card_type) == 20)  //联通加入30元，20070817
																menuList.iTotalNum = 3;
															else if(atoi(gbl.sell_card_type) == 900)
																menuList.iTotalNum = 1;	
															else if (memcmp(gbl.sell_card_type,"10",2)==0)//卡类型为0501 为翼支付卡
																menuList.iTotalNum=5;
															else
																menuList.iTotalNum = 2;
															strcpy(menuList.acTitle, "请选择售卡面值");
															if ( atoi(gbl.sell_card_type) == 40)
															{
																strcpy(menuList.menuItem[0], "20元");
																strcpy(menuList.menuItem[1], "30元");
																strcpy(menuList.menuItem[2], "50元");
																strcpy(menuList.menuItem[3], "100元");
																strcpy(menuList.menuItem[4], "200元");
																strcpy(menuList.menuItem[5], "300元");
																strcpy(menuList.menuItem[6], "500元");
															}
															else if(atoi(gbl.sell_card_type) == 30 || atoi(gbl.sell_card_type) == 20)
															{
																strcpy(menuList.menuItem[0], "30元");
																strcpy(menuList.menuItem[1], "50元");
																strcpy(menuList.menuItem[2], "100元");
															}
															else if(atoi(gbl.sell_card_type) == 900)
															{
																strcpy(menuList.menuItem[1], "50元");
															}
															else if(memcmp(gbl.sell_card_type,"10",2)==0)  //翼支付卡销售
															{
															
																strcpy(menuList.menuItem[0],"10元");
																strcpy(menuList.menuItem[1],"30元");
																strcpy(menuList.menuItem[2],"50元");
																strcpy(menuList.menuItem[3],"100元");
																strcpy(menuList.menuItem[4],"300元");


															}
															else
															{
																strcpy(menuList.menuItem[0], "50元");
																strcpy(menuList.menuItem[1], "100元");
															}
															if( select==0 )
															{
																iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
															}
															else
															{
																iRet = 0;
																iSelect = select;
															}
															if(iRet)
																return -1;
															switch(iSelect)
															{
															case 1:
																if(atoi(gbl.sell_card_type) == 30)
																{
																	strcpy(gbl.card_amount,"000000003000");
																	strcpy(gbl.amount,"000000003000");
																	strcpy(gbl.sell_card_type, "0311");
																}else if (atoi(gbl.sell_card_type) == 40)
																{
																	strcpy(gbl.card_amount,"000000002000");
																	strcpy(gbl.amount,"000000002000");
																	strcpy(gbl.sell_card_type, "0137");
																}
																else if (atoi(gbl.sell_card_type) == 20)
																{
																	strcpy(gbl.card_amount,"000000003000");
																	strcpy(gbl.amount,"000000003000");
																	strcpy(gbl.sell_card_type, "0207");
																}
																else if (atoi(gbl.sell_card_type) == 900)
																{
																	strcpy(gbl.card_amount,"000000005000");
																	strcpy(gbl.amount,"000000005000");
																	strcpy(gbl.sell_card_type, "0900");
																}
																else if (memcmp(gbl.sell_card_type,"10",2)==0) //天翼翼支付卡
																{
																	bbzero(gbl.sell_card_type);
																	strcpy(gbl.sell_card_type,"1001");//10元翼支付卡
																	strcpy(gbl.card_amount,"000000001000");
																	strcpy(gbl.amount,"000000001000");
								
																}
																else
																{
																	strcpy(gbl.card_amount,"000000005000");
																	strcpy(gbl.amount,"000000005000");
																	if(!memcmp(gbl.sell_card_type, "010", 3))
																		strcpy(gbl.sell_card_type, "0109");
																	else if(!memcmp(gbl.sell_card_type, "011", 3))
																		strcpy(gbl.sell_card_type, "0112");
																	// 				else if(!memcmp(gbl.sell_card_type, "020", 3))
																	// 					strcpy(gbl.sell_card_type, "0200");
																	// 				else if(!memcmp(gbl.sell_card_type, "040", 3))
																	// 					strcpy(gbl.sell_card_type, "0136");
																}
																return 1;
																
															case 2:
																if(atoi(gbl.sell_card_type) == 30)
																{
																	strcpy(gbl.card_amount,"000000005000");
																	strcpy(gbl.amount,"000000005000");
																	strcpy(gbl.sell_card_type, "0300");
																}else if (atoi(gbl.sell_card_type) == 40)
																{
																	strcpy(gbl.card_amount,"000000003000");
																	strcpy(gbl.amount,"000000003000");
																	strcpy(gbl.sell_card_type, "0135");
																}
																else if (atoi(gbl.sell_card_type) == 20)
																{
																	strcpy(gbl.card_amount,"000000005000");
																	strcpy(gbl.amount,"000000005000");
																	strcpy(gbl.sell_card_type, "0200");
																}
																else if (memcmp(gbl.sell_card_type,"10",2)==0) //翼支付卡充值30元

																{
																	bbzero(gbl.sell_card_type);
																	strcpy(gbl.sell_card_type,"1003");//30元翼支付卡
																	strcpy(gbl.card_amount,"000000003000");
																	strcpy(gbl.amount,"000000003000");
																}
																else
																{
																	strcpy(gbl.card_amount,"000000010000");
																	strcpy(gbl.amount,"000000010000");
																	if(!memcmp(gbl.sell_card_type, "010", 3))
																		strcpy(gbl.sell_card_type, "0110");
																	else if(!memcmp(gbl.sell_card_type, "011", 3))
																		strcpy(gbl.sell_card_type, "0113");
																	// 				else if(!memcmp(gbl.sell_card_type, "020", 3))
																	// 					strcpy(gbl.sell_card_type, "0201");
																	// 				else if(!memcmp(gbl.sell_card_type, "040", 3))
																	// 					strcpy(gbl.sell_card_type, "0139");
																}
																return 2;
																
															case 3:
																if(atoi(gbl.sell_card_type) == 30)
																{
																	strcpy(gbl.card_amount, "000000010000");
																	strcpy(gbl.amount, "000000010000");
																	strcpy(gbl.sell_card_type, "0301");
																}else if (atoi(gbl.sell_card_type) == 40)
																{
																	strcpy(gbl.card_amount,"000000005000");
																	strcpy(gbl.amount,"000000005000");
																	strcpy(gbl.sell_card_type, "0136");
																}
																else if (atoi(gbl.sell_card_type) == 20)
																{
																	strcpy(gbl.card_amount,"000000010000");
																	strcpy(gbl.amount,"000000010000");
																	strcpy(gbl.sell_card_type, "0201");
																}
																else if(memcmp(gbl.sell_card_type,"10",2)==0) //翼支付卡50元充值
																{
																	bbzero(gbl.sell_card_type);
																	strcpy(gbl.sell_card_type,"1005");
																	strcpy(gbl.card_amount,"000000005000"); 
																	strcpy(gbl.amount,"000000005000");
																}
																else
																	return CANCLE_KEY;
																return 3;
															case 4:
																if (atoi(gbl.sell_card_type) == 40)
																{
																	strcpy(gbl.card_amount,"000000010000");
																	strcpy(gbl.amount,"000000010000");
																	strcpy(gbl.sell_card_type, "0139");			
																}
																else if(memcmp(gbl.sell_card_type,"10",2)==0) //翼支付卡100元
																{
																	
																	bbzero(gbl.sell_card_type);
																	strcpy(gbl.sell_card_type,"1011");
																	strcpy(gbl.card_amount,"000000010000");
																	strcpy(gbl.amount,"000000010000");
																}
																else
																	return CANCLE_KEY;
																return 4;
																
															case 5:
																if (atoi(gbl.sell_card_type) == 40)
																{
																	strcpy(gbl.card_amount, "000000020000");
																	strcpy(gbl.amount, "000000020000");
																	strcpy(gbl.sell_card_type, "0142");				
																}
																else if(memcmp(gbl.sell_card_type,"10",2)==0)
																{
																	bbzero(gbl.sell_card_type);
																	strcpy(gbl.sell_card_type,"1013"); //翼支付卡300元
																	strcpy(gbl.card_amount, "000000030000");
																	strcpy(gbl.amount, "000000030000");

																}
																else
																	return CANCLE_KEY;
																return 5;
															case 6:
																if (atoi(gbl.sell_card_type) == 40)
																{
																	strcpy(gbl.card_amount, "000000030000");
																	strcpy(gbl.amount, "000000030000");
																	strcpy(gbl.sell_card_type, "0143");				
																}else
																	return CANCLE_KEY;
																return 6;
															case 7:
																if (atoi(gbl.sell_card_type) == 40)
																{
																	strcpy(gbl.card_amount, "000000050000");
																	strcpy(gbl.amount, "000000050000");
																	strcpy(gbl.sell_card_type, "0144");					
																}else
																	return CANCLE_KEY;
																return 7;
															default:
																return CANCLE_KEY;
		}
		break;		
		
	case 112: 
		if (atoi(gbl.amount)==0)
		{
			menuList.iTotalNum = 5;
			strcpy(menuList.acTitle, "请选择您要预存的金额");
			strcpy(menuList.menuItem[0], "预存100元");
			strcpy(menuList.menuItem[1], "预存200元");
			strcpy(menuList.menuItem[2], "预存300元");
			strcpy(menuList.menuItem[3], "预存500元");
			strcpy(menuList.menuItem[4], "预存800元");
		}else{
			menuList.iTotalNum = 6;
			strcpy(menuList.acTitle, "请选择您要预存的金额");
			strcpy(menuList.menuItem[0], "预存100元");
			strcpy(menuList.menuItem[1], "预存200元");
			strcpy(menuList.menuItem[2], "预存300元");
			strcpy(menuList.menuItem[3], "预存500元");
			strcpy(menuList.menuItem[4], "预存800元");
			strcpy(menuList.menuItem[5], "全额交费");
		}
		if( select==0 )
		{
			iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
		}
		else
		{
			iRet = 0;
			iSelect = select;
		}
		if(iRet)
			return -1;
		switch(iSelect)
		{
		case 1:
			strcpy(gbl.amount,"000000010000");
			return 1;
		case 2:
			strcpy(gbl.amount,"000000020000");
			return 2;
		case 3:
			strcpy(gbl.amount,"000000030000");
			return 3;
		case 4:
			strcpy(gbl.amount,"000000050000");
			return 4;
		case 5:
			strcpy(gbl.amount,"000000080000");
			return 5;
		case 6:
			return 6;
		default: 
			return CANCLE_KEY;
		}
		break;
		case 100: //有线电视预付费
			if (atoi(gbl.amount)==0)
			{
				menuList.iTotalNum = 6;
				strcpy(menuList.acTitle, "请选择您要预存的金额");
				strcpy(menuList.menuItem[0], "任意金额");
				strcpy(menuList.menuItem[1], "预存100元");
				strcpy(menuList.menuItem[2], "预存300元");
				strcpy(menuList.menuItem[3], "预存500元");
				strcpy(menuList.menuItem[4], "预存800元");
				strcpy(menuList.menuItem[5], "预存1000元");
			}else{
				menuList.iTotalNum = 7;
				strcpy(menuList.acTitle, "请选择您要预存的金额");
				strcpy(menuList.menuItem[0], "任意金额");
				strcpy(menuList.menuItem[1], "预存100元");
				strcpy(menuList.menuItem[2], "预存300元");
				strcpy(menuList.menuItem[3], "预存500元");
				strcpy(menuList.menuItem[4], "预存800元");
				strcpy(menuList.menuItem[5], "预存1000元");
				strcpy(menuList.menuItem[6], "全额交费");
			}
			if( select==0 )
			{
				iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
			}
			else
			{
				iRet = 0;
				iSelect = select;
			}
			if(iRet)
				return -1;
			switch(iSelect)
			{
			case 1:
				int ii;
				for (ii=0;ii<MAXTRY;ii++)
				{
					TSTradeInfoSend tradeInfoSend;
					TSTradeInfoRecv tradeInfoRecv;
					memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
					memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
					
					strcpy(tradeInfoSend.acMainTitle, "珠江数码(数字电视)");
					tradeInfoSend.uHasTradeID = 1;
					tradeInfoSend.uTotalContents = 1;
					
					strcpy(tradeInfoSend.Contents[0].acTitle, "请输入金额：");	
					tradeInfoSend.Contents[0].uCommand = TS_INPUT_MONEY;	//全字符
					tradeInfoSend.Contents[0].uCount = 0;		//输入1次
					tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
					tradeInfoSend.Contents[0].uMinLen = 1;	
					tradeInfoSend.Contents[0].uMaxLen = 12;	
					
					iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
					if(iRet != 0)
					{
						wrLog("TS_TradeControl返回错误[%d]", iRet);
						wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
						return iRet;
					}
					
					bbzero(gbl.pos_serial);
					strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
					bbzero(gbl.amount);
					strcpy(gbl.amount,(char *)tradeInfoRecv.Contents[0].uMsg );
					
					if ((atoi(gbl.amount)>=400) && (atoi(gbl.amount)<10000))
					{
						return 1;
					}else{
						iRet = TS_OutPutMsg(gbl.dPosInfo,"输入的金额必须大于等于4元且小于100元\n请重新输入！",0,iSelect);
						if (iSelect == 0)
						{
							continue;
						}else
							return CANCLE_KEY;
						
					}
				}
				
				return CANCLE_KEY;
			case 2:
				strcpy(gbl.amount,"000000010000");
				return 2;
			case 3:
				strcpy(gbl.amount,"000000030000");
				return 3;
			case 4:
				strcpy(gbl.amount,"000000050000");
				return 4;
			case 5:
				strcpy(gbl.amount,"000000080000");
				return 5;
			case 6:
				strcpy(gbl.amount,"000000100000");
				return 6;
			case 7:
				return 7;
			default: 
				return CANCLE_KEY;
			}
			break;
			case 114: 
				if (atoi(gbl.amount)==0)
				{
					menuList.iTotalNum = 5;
					strcpy(menuList.acTitle, "请选择您要预存的金额");
					strcpy(menuList.menuItem[0], "预存100元");
					strcpy(menuList.menuItem[1], "预存300元");
					strcpy(menuList.menuItem[2], "预存500元");
					strcpy(menuList.menuItem[3], "预存800元");
					strcpy(menuList.menuItem[4], "预存1000元");
				}else{
					menuList.iTotalNum = 6;
					strcpy(menuList.acTitle, "请选择您要预存的金额");
					strcpy(menuList.menuItem[0], "预存100元");
					strcpy(menuList.menuItem[1], "预存300元");
					strcpy(menuList.menuItem[2], "预存500元");
					strcpy(menuList.menuItem[3], "预存800元");
					strcpy(menuList.menuItem[4], "预存1000元");
					strcpy(menuList.menuItem[5], "全额交费");
				}
				if( select==0 )
				{
					iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
				}
				else
				{
					iRet = 0;
					iSelect = select;
				}
				if(iRet)
					return -1;
				switch(iSelect)
				{
				case 1:
					strcpy(gbl.amount,"000000010000");
					return 1;
				case 2:
					strcpy(gbl.amount,"000000030000");
					return 2;
				case 3:
					strcpy(gbl.amount,"000000050000");
					return 3;
				case 4:
					strcpy(gbl.amount,"000000080000");
					return 4;
				case 5:
					strcpy(gbl.amount,"000000100000");
					return 5;
				case 6:
					return 6;
				default: 
					return CANCLE_KEY;
				}
				break;
				
				case 81: //家用车交通车强险
					memset(&menuList,0,sizeof(menuList));
					menuList.iTotalNum = 2;
					strcpy(menuList.acTitle, "交费易--PICC车强险");
					strcpy(menuList.menuItem[0], "6座以下保费950元");
					strcpy(menuList.menuItem[1], "6座及以上保费1,100元");
					if( select==0 )
					{
						iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
					}
					else
					{
						iRet = 0;
						iSelect = select;
					}
					if(iRet)
						return -1;
					switch(iSelect)
					{
					case 1:
						return 1;
					case 2:
						return 2;
					default: 
						return CANCLE_KEY;
					}
					break;
					case 164: //付费易卡充值  2007-6-26 by lihk
						menuList.iTotalNum = 5;
						strcpy(menuList.acTitle, "请选择您要充值的金额");
						strcpy(menuList.menuItem[0], "30元");
						strcpy(menuList.menuItem[1], "50元");
						strcpy(menuList.menuItem[2], "100元");
						strcpy(menuList.menuItem[3], "200元");
						strcpy(menuList.menuItem[4], "500元");
						
						if( select==0 )
						{
							iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
						}
						else
						{
							iRet = 0;
							iSelect = select;
						}
						if(iRet)
							return -1;
						switch(iSelect)
						{
						case 1:
							strcpy(gbl.amount,"000000003000");
							return 1;
						case 2:
							strcpy(gbl.amount,"000000005000");
							return 2;
						case 3:
							strcpy(gbl.amount,"000000010000");
							return 3;
						case 4:
							strcpy(gbl.amount,"000000020000");
							return 4;
						case 5:
							strcpy(gbl.amount,"000000050000");
							return 5;
						default: 
							return CANCLE_KEY;
						}
						break;
						case 169: //连连空中充值  移动
						case 180: //华鸿空中充值
						case 174: //连连空中充值  移动
						case 305: //联动空中充值  移动
						case 243: //体彩账户充值
						case 323://拉卡拉移动直充
						case 327:
						case 325:
						case 328:
						case 343: //飞跃 移动
							menuList.iTotalNum = 6;
							strcpy(menuList.acTitle, "请选择您要充值的金额");
							strcpy(menuList.menuItem[0], "30元");
							strcpy(menuList.menuItem[1], "50元");
							strcpy(menuList.menuItem[2], "100元");
							strcpy(menuList.menuItem[3], "300元");
							strcpy(menuList.menuItem[4], "400元(未开通)");
							strcpy(menuList.menuItem[5], "500元");
							
							if( select==0 )
							{
								iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
							}
							else
							{
								iRet = 0;
								iSelect = select;
							}
							if(iRet)
								return -1;
							switch(iSelect)
							{
							case 1:
								strcpy(gbl.amount,"000000003000");
								return 1;
							case 2:
								strcpy(gbl.amount,"000000005000");
								return 2;
							case 3:
								strcpy(gbl.amount,"000000010000");
								return 3;
							case 4:
								strcpy(gbl.amount,"000000030000");
								return 4;
							case 5:
								TS_OutPutMsg(gbl.dPosInfo,"暂未开通400元充值，请使用100元+300元进行充值",0,iSelect);
								return CANCLE_KEY;
							case 6:
								strcpy(gbl.amount,"000000050000");
								return 6;
							default: 
								return CANCLE_KEY;
							}
							break;
							case 265: //连欣空中充值  联通
							case 300: //连欣空中充值  联通  东莞
							case 342: //联通空中充值
							case 356: //省联通
								menuList.iTotalNum = 7;
								strcpy(menuList.acTitle, "请选择您要充值的金额");
								strcpy(menuList.menuItem[0], "30元");
								strcpy(menuList.menuItem[1], "50元");
								strcpy(menuList.menuItem[2], "100元");
								strcpy(menuList.menuItem[3], "200元");
								strcpy(menuList.menuItem[4], "300元");
								strcpy(menuList.menuItem[5], "400元");
								strcpy(menuList.menuItem[6], "500元");
								
								if( select==0 )
								{
									iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
								}
								else
								{
									iRet = 0;
									iSelect = select;
								}
								if(iRet)
									return -1;
								switch(iSelect)
								{
								case 1:
									strcpy(gbl.amount,"000000003000");
									return 1;
								case 2:
									strcpy(gbl.amount,"000000005000");
									return 2;
								case 3:
									strcpy(gbl.amount,"000000010000");
									return 3;
								case 4:
									strcpy(gbl.amount,"000000020000");
									return 4;
								case 5:
									strcpy(gbl.amount,"000000030000");
									return 5;
								case 6:
									TS_OutPutMsg(gbl.dPosInfo,"暂未开通400元充值，请使用100元+300元进行充值",0,iSelect);
									return CANCLE_KEY;
								case 7:
									strcpy(gbl.amount,"000000050000");
									return 7;
								default: 
									return CANCLE_KEY;
								}
								break;
								
								case 361://翼支付充值
									
									menuList.iTotalNum = 8; 
									strcpy(menuList.acTitle, "请选择您要充值的金额");
									strcpy(menuList.menuItem[0], "10元");
									strcpy(menuList.menuItem[1], "30元");
									strcpy(menuList.menuItem[2], "50元");
									strcpy(menuList.menuItem[3], "100元");
									strcpy(menuList.menuItem[4], "200元");
									strcpy(menuList.menuItem[5], "300元");
									strcpy(menuList.menuItem[6], "500元");
									strcpy(menuList.menuItem[7], "1000元");
									if( select==0 )
									{
										iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
									}
									else
									{
										iRet = 0;
										iSelect = select;
									}
									if(iRet)
										return -1;
									
									switch(iSelect)
									{
									case 1:
										strcpy(gbl.amount,"000000001000");
										return 1;
									case 2:
										strcpy(gbl.amount,"000000003000");
										return 2;
									case 3:
										strcpy(gbl.amount,"000000005000");
										return 3;
									case 4:
										strcpy(gbl.amount,"000000010000");
										return 4;
									case 5:
										strcpy(gbl.amount,"000000020000");
										return 5;
									case 6:
										strcpy(gbl.amount,"000000030000");
										return 6;
									case 7:
										strcpy(gbl.amount,"000000050000");
										return 7;
									case 8:
										strcpy(gbl.amount,"000000100000");
										return 8;
									default: 
										return CANCLE_KEY;
									}
									break;

									case 367://全国电信话费充值
										
										menuList.iTotalNum = 4; 
										strcpy(menuList.acTitle, "请选择您要充值的金额");
										strcpy(menuList.menuItem[0], "10元");
										strcpy(menuList.menuItem[1], "30元");
										strcpy(menuList.menuItem[2], "50元");
										strcpy(menuList.menuItem[3], "100元");
										
										if( select==0 )
										{
											iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
										}
										else
										{
											iRet = 0;
											iSelect = select;
										}
										if(iRet)
											return -1;

											switch(iSelect)
											{
											case 1:

												bbzero(gbl.origAmount);
												strcpy(gbl.origAmount,"000000001000");
												bbzero(gbl.amount);
												strcpy(gbl.amount,"000000001000");
												return 1;
											case 2:

												bbzero(gbl.origAmount);
												strcpy(gbl.origAmount,"000000003000");
												bbzero(gbl.amount);
												strcpy(gbl.amount,"000000003000");
												return 2;
											case 3:

												bbzero(gbl.origAmount);
												strcpy(gbl.origAmount,"000000005000");
												bbzero(gbl.amount);
												strcpy(gbl.amount,"000000005000");
												return 3;
											case 4:
												bbzero(gbl.origAmount);
												strcpy(gbl.origAmount,"000000010000");
												bbzero(gbl.amount);
												strcpy(gbl.amount,"000000010000");
												return 4;
											default: 
												return CANCLE_KEY;
											}
										

									break;

									case 370://全国联通话费充值
											
											menuList.iTotalNum = 3; 
											strcpy(menuList.acTitle, "请选择您要充值的金额");
											//strcpy(menuList.menuItem[0], "10元"); //溢价问题先不上
											//strcpy(menuList.menuItem[1], "20元"); ///溢价问题先不上
											//strcpy(menuList.menuItem[2], "30元");///溢价问题先不上
											strcpy(menuList.menuItem[0], "50元"); 
											strcpy(menuList.menuItem[1], "100元");
											strcpy(menuList.menuItem[2], "200元");
											
											if( select==0 )
											{
												iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
											}
											else
											{
												iRet = 0;
												iSelect = select;
											}
											if(iRet)
												return -1;
											
												switch(iSelect)
												{
													
													/*
												case 1:
													bbzero(gbl.origAmount);
													strcpy(gbl.origAmount,"000000001000");

													bbzero(gbl.amount);
													strcpy(gbl.amount,"000000001050");
													return 1;
												case 2:
													bbzero(gbl.origAmount);
													strcpy(gbl.origAmount,"000000002000");
													bbzero(gbl.amount);
													strcpy(gbl.amount,"000000002050");
													return 2;
													
												case 3:
													bbzero(gbl.origAmount);
													strcpy(gbl.origAmount,"000000003000");
													bbzero(gbl.amount);
													strcpy(gbl.amount,"000000003050");
													return 3;
													*/
												case 1:

													bbzero(gbl.origAmount);
													strcpy(gbl.origAmount,"000000005000");
													bbzero(gbl.amount);
													strcpy(gbl.amount,"000000005000");
													return 1;
												case 2:
													bbzero(gbl.origAmount);
													strcpy(gbl.origAmount,"000000010000");
													bbzero(gbl.amount);
													strcpy(gbl.amount,"000000010000");
													return 2;
												case 3:
													bbzero(gbl.origAmount);
													strcpy(gbl.origAmount,"000000020000");
													bbzero(gbl.amount);
													strcpy(gbl.amount,"000000020000");
													return 3;

												default: 
													return CANCLE_KEY;
													
												}


									break;

									case 369://全国移动话费充值
												
													menuList.iTotalNum = 3; 
													strcpy(menuList.acTitle, "请选择您要充值的金额");
													//strcpy(menuList.menuItem[0], "10元");
												//	strcpy(menuList.menuItem[1], "20元");
													//strcpy(menuList.menuItem[2], "30元");
													strcpy(menuList.menuItem[0], "50元");
													strcpy(menuList.menuItem[1], "100元");
													strcpy(menuList.menuItem[2], "200元");
							
												if( select==0 )
												{
													iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
												}
												else
												{
													iRet = 0;
													iSelect = select;
												}
												if(iRet)
													return -1;

													switch(iSelect)
													{
														
														/*
													case 1:

														bbzero(gbl.origAmount);
														strcpy(gbl.origAmount,"000000001000");
														bbzero(gbl.amount);
														strcpy(gbl.amount,"000000001050");
														return 1;
													case 2:
														bbzero(gbl.origAmount);
														strcpy(gbl.origAmount,"000000002000");
														bbzero(gbl.amount);
														strcpy(gbl.amount,"000000002050");
														return 2;
													case 3:
														bbzero(gbl.origAmount);
														strcpy(gbl.origAmount,"000000003000");
														bbzero(gbl.amount);
														strcpy(gbl.amount,"000000003050");
														return 3;
														*/
													case 1:

														bbzero(gbl.origAmount);
														strcpy(gbl.origAmount,"000000005000");
														bbzero(gbl.amount);
														strcpy(gbl.amount,"000000005000");
														return 1;
													case 2:
														bbzero(gbl.origAmount);
														strcpy(gbl.origAmount,"000000010000");
														bbzero(gbl.amount);
														strcpy(gbl.amount,"000000010000");
														return 2;
													case 3:
														bbzero(gbl.origAmount);
														strcpy(gbl.origAmount,"000000020000");
														bbzero(gbl.amount);
														strcpy(gbl.amount,"000000020000");
														return 3;

													default: 
														return CANCLE_KEY;
													}
					

									break;

									case 255: //连连空中充值  广州电信
									case 257: //华鸿空中充值  全省电信
									case 321:
									case 344:
										menuList.iTotalNum = 6;
										if (flag == 2)
										{
											char amomny[12+1];
											bbzero(amomny);
											CTools::chgToMny(gbl.overdraft_amount,amomny);
											sprintf(menuList.acTitle, "欠费%s  选金额",amomny);
										}else
											strcpy(menuList.acTitle, "请选择您要充值的金额");
										
										strcpy(menuList.menuItem[0], "30元");
										strcpy(menuList.menuItem[1], "50元");
										strcpy(menuList.menuItem[2], "100元");
										strcpy(menuList.menuItem[3], "200元");
										strcpy(menuList.menuItem[4], "300元");
										strcpy(menuList.menuItem[5], "500元");
										// 		strcpy(menuList.menuItem[6], "10元");
										// 		strcpy(menuList.menuItem[7], "20元");
										if( select==0 )
										{
											iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
										}
										else
										{
											iRet = 0;
											iSelect = select;
										}
										if(iRet)
											return -1;
										switch(iSelect)
										{		
										case 1:
											strcpy(gbl.amount,"000000003000");
											return 1;
										case 2:
											strcpy(gbl.amount,"000000005000");
											return 2;
										case 3:
											strcpy(gbl.amount,"000000010000");
											return 3;
										case 4:
											strcpy(gbl.amount,"000000020000");
											return 4;
										case 5:
											strcpy(gbl.amount,"000000030000");
											return 5;
										case 6:
											strcpy(gbl.amount,"000000050000");
											return 6;
											// 		case 7:
											// 			strcpy(gbl.amount,"000000001000");
											// 			return 7;
											// 		case 8:
											// 			strcpy(gbl.amount,"000000002000");
											// 			return 8;
										default: 
											return CANCLE_KEY;
										}
										break;
										case 256: //华鸿空中充值  东莞电信
											menuList.iTotalNum = 6;
											strcpy(menuList.acTitle, "请选择您要充值的金额");
											
											strcpy(menuList.menuItem[0], "30元");
											strcpy(menuList.menuItem[1], "50元");
											strcpy(menuList.menuItem[2], "100元");
											strcpy(menuList.menuItem[3], "200元");
											strcpy(menuList.menuItem[4], "300元");
											strcpy(menuList.menuItem[5], "500元");
											if( select==0 )
											{
												iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
											}
											else
											{
												iRet = 0;
												iSelect = select;
											}
											if(iRet)
												return -1;
											switch(iSelect)
											{		
											case 1:
												strcpy(gbl.amount,"000000003000");
												return 1;
											case 2:
												strcpy(gbl.amount,"000000005000");
												return 2;
											case 3:
												strcpy(gbl.amount,"000000010000");
												return 3;
											case 4:
												strcpy(gbl.amount,"000000020000");
												return 4;
											case 5:
												strcpy(gbl.amount,"000000030000");
												return 5;
											case 6:
												strcpy(gbl.amount,"000000050000");
												return 6;
											default: 
												return CANCLE_KEY;
											}
											break;
											case 213: //华鸿空中充值  东莞移动
											case 316: //东莞联动空充
												menuList.iTotalNum = 5;
												strcpy(menuList.acTitle, "请选择您要充值的金额");
												
												strcpy(menuList.menuItem[0], "30元");
												strcpy(menuList.menuItem[1], "50元");
												strcpy(menuList.menuItem[2], "100元");
												strcpy(menuList.menuItem[3], "300元");
												strcpy(menuList.menuItem[4], "500元");
												if( select==0 )
												{
													iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
												}
												else
												{
													iRet = 0;
													iSelect = select;
												}
												if(iRet)
													return -1;
												switch(iSelect)
												{		
												case 1:
													strcpy(gbl.amount,"000000003000");
													return 1;
												case 2:
													strcpy(gbl.amount,"000000005000");
													return 2;
												case 3:
													strcpy(gbl.amount,"000000010000");
													return 3;
												case 4:
													strcpy(gbl.amount,"000000030000");
													return 4;
												case 5:
													strcpy(gbl.amount,"000000050000");
													return 5;
												default: 
													return CANCLE_KEY;
												}
												break;
												case 170: //e卡充值
													menuList.iTotalNum = 2;
													strcpy(menuList.acTitle, "请选择您要充值的金额");
													strcpy(menuList.menuItem[0], "1000元");
													strcpy(menuList.menuItem[1], "2000元");
													
													if( select==0 )
													{
														iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
													}
													else
													{
														iRet = 0;
														iSelect = select;
													}
													if(iRet)
														return -1;
													switch(iSelect)
													{
													case 1:
														strcpy(gbl.amount,"000000100000");
														return 1;
													case 2:
														strcpy(gbl.amount,"000000200000");
														return 2;
													default: 
														return CANCLE_KEY;
													}
													break;
													case 12:
														menuList.iTotalNum = 6;
														strcpy(menuList.acTitle, "请选择罚单文书类型");
														strcpy(menuList.menuItem[0], "1001 现场执法");
														strcpy(menuList.menuItem[1], "6001 电子警察");
														strcpy(menuList.menuItem[2], "8001 行政复议");
														strcpy(menuList.menuItem[3], "1002 行政处罚通告");
														strcpy(menuList.menuItem[4], "1004 行人非机动车");
														strcpy(menuList.menuItem[5], "2006 道路交通安全");
														
														if( select==0 )
														{
															iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
														}
														else
														{
															iRet = 0;
															iSelect = select;
														}
														if(iRet)
															return -1;
														switch(iSelect)
														{
														case 1:
															return 1;
														case 2:
															return 2;
														case 3:
															return 3;
														case 4:
															return 4;
														case 5:
															return 5;
														case 6:
															return 6;
														default: 
															return CANCLE_KEY;
														}
														break;
														case 99: //交罚文书类型
															menuList.iTotalNum = 5;
															strcpy(menuList.acTitle, "请选择罚单文书类型");
															//strcpy(menuList.menuItem[0], "1001 现场执法");
															strcpy(menuList.menuItem[0], "6001 电子警察");
															strcpy(menuList.menuItem[1], "8001 行政复议");
															strcpy(menuList.menuItem[2], "1002 行政处罚通告");
															strcpy(menuList.menuItem[3], "1004 行人非机动车");
															strcpy(menuList.menuItem[4], "2006 道路交通安全");
															
															if( select==0 )
															{
																iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
															}
															else
															{
																iRet = 0;
																iSelect = select;
															}
															if(iRet)
																return -1;
															switch(iSelect)
															{
															case 1:
																return 1;
															case 2:
																return 2;
															case 3:
																return 3;
															case 4:
																return 4;
															case 5:
																return 5;
															default: 
																return CANCLE_KEY;
															}
															break;
															case 232: //东莞广州交罚
																menuList.iTotalNum = 6;
																strcpy(menuList.acTitle, "请选择罚单文书类型");
																strcpy(menuList.menuItem[0], "1001 现场执法");
																strcpy(menuList.menuItem[1], "6001 电子警察");
																strcpy(menuList.menuItem[2], "8001 行政复议");
																strcpy(menuList.menuItem[3], "1002 行政处罚通告");
																strcpy(menuList.menuItem[4], "1004 行人非机动车");
																strcpy(menuList.menuItem[5], "2006 道路交通安全");
																
																if( select==0 )
																{
																	iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
																}
																else
																{
																	iRet = 0;
																	iSelect = select;
																}
																if(iRet)
																	return -1;
																switch(iSelect)
																{
																case 1:
																	return 1;
																case 2:
																	return 2;
																case 3:
																	return 3;
																case 4:
																	return 4;
																case 5:
																	return 5;
																case 6:
																	return 6;
																default: 
																	return CANCLE_KEY;
																}
																break;
																case 233: //交罚车辆类型
																	menuList.iTotalNum = 2;
																	strcpy(menuList.acTitle, "请选择车辆类型");
																	strcpy(menuList.menuItem[0], "小型汽车(蓝牌)");
																	strcpy(menuList.menuItem[1], "大型汽车(黄牌)");
																	// 		strcpy(menuList.menuItem[2], "摩托车");
																	// 		strcpy(menuList.menuItem[3], "外籍汽车(黑牌)");
																	// 		strcpy(menuList.menuItem[4], "外籍摩托车(黑牌)");
																	
																	if( select==0 )
																	{
																		iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
																	}
																	else
																	{
																		iRet = 0;
																		iSelect = select;
																	}
																	if(iRet)
																		return -1;
																	switch(iSelect)
																	{
																	case 1:
																		return 1;
																	case 2:
																		return 2;
																		// 		case 3:
																		// 			return 3;
																		// 		case 4:
																		// 			return 4;
																		// 		case 5:
																		// 			return 5;
																	default: 
																		return CANCLE_KEY;
																	}
																	break;
																	case 245:
																		// 		menuList.iTotalNum = CDB::get_pcardnum();
																		// 		strcpy(menuList.acTitle, "请选择点卡类型");
																		// 		for (i=0;i<menuList.iTotalNum;i++)
																		// 		{
																		// 			strcpy(menuList.menuItem[i],pcard_conf[i].card_name);
																		// 		}
																		// 		
																		// 		if( select==0 )
																		// 		{
																		// 			iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
																		// 		}
																		// 		else
																		// 		{
																		// 			iRet = 0;
																		// 			iSelect = select;
																		// 		}
																		// 		if(iRet)
																		// 			return -1;
																		// 		if (iSelect>0&&iSelect<=menuList.iTotalNum)
																		// 		{
																		// 			strcpy(gbl.amount,pcard_conf[iSelect-1].card_price);
																		// 			strcpy(gbl.card_amount,pcard_conf[iSelect-1].card_price);
																		// 			strcpy(gbl.xmcard_type,pcard_conf[iSelect-1].card_type);
																		// 			strcpy(gbl.xmcard_name,pcard_conf[iSelect-1].card_name);
																		// 			return iSelect;
																		// 		}else
																		return CANCLE_KEY;
																		//		break;
																	case 248: //终端销售
																		if (flag ==1 )
																		{
																			menuList.iTotalNum = 2;
																			strcpy(menuList.acTitle, "请选择数量(含运费)");
																			strcpy(menuList.menuItem[0], "5份―1440元");
																			strcpy(menuList.menuItem[1], "10份―2880元");
																			if( select==0 )
																			{
																				iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
																			}
																			else
																			{
																				iRet = 0;
																				iSelect = select;
																			}
																			if(iRet)
																				return -1;
																			switch(iSelect)
																			{
																			case 1:
																				return 1;
																			case 2:
																				return 2;
																			default: 
																				return CANCLE_KEY;
																			}
																			break;
																		}else if (flag ==2 )
																		{
																			menuList.iTotalNum = 2;
																			strcpy(menuList.acTitle, "请选择产品");
																			strcpy(menuList.menuItem[0], "交费易发票");
																			strcpy(menuList.menuItem[1], "交费易凭条(热敏纸)");
																			if( select==0 )
																			{
																				iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
																			}
																			else
																			{
																				iRet = 0;
																				iSelect = select;
																			}
																			if(iRet)
																				return -1;
																			switch(iSelect)
																			{
																			case 1:
																				return 1;
																			case 2:
																				return 2;
																			default: 
																				return CANCLE_KEY;
																			}
																			break;
																		}else if (flag ==8 )
																		{
																			menuList.iTotalNum = 2;
																			strcpy(menuList.acTitle, "请选择产品");
																			strcpy(menuList.menuItem[0], "发票打印机");
																			strcpy(menuList.menuItem[1], "凭条打印机(热敏)");
																			if( select==0 )
																			{
																				iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
																			}
																			else
																			{
																				iRet = 0;
																				iSelect = select;
																			}
																			if(iRet)
																				return -1;
																			switch(iSelect)
																			{
																			case 1:
																				return 1;
																			case 2:
																				return 2;
																			default: 
																				return CANCLE_KEY;
																			}
																			break;
																		}else
																			return CANCLE_KEY;
																			case 261: //肇庆 电信预受理业务
																				menuList.iTotalNum = 5;
																				strcpy(menuList.acTitle, "请选择预受理业务类型");
																				strcpy(menuList.menuItem[0], "固话新装");
																				strcpy(menuList.menuItem[1], "宽带新装");
																				strcpy(menuList.menuItem[2], "互联网视听新装");
																				strcpy(menuList.menuItem[3], "套餐新装");
																				strcpy(menuList.menuItem[4], "CDMA移动手机新装");
																				
																				if( select==0 )
																				{
																					iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
																				}
																				else
																				{
																					iRet = 0;
																					iSelect = select;
																				}
																				if(iRet)
																					return -1;
																				switch(iSelect)
																				{
																				case 1:
																					return 1;
																				case 2:
																					return 2;
																				case 3:
																					return 3;
																				case 4:
																					return 4;
																				case 5:
																					return 5;
																				default: 
																					return CANCLE_KEY;
																				}
																				break;
																				case 176:  //全球通充值，20070902
																					memset(&menuList,0,sizeof(menuList));
																					menuList.iTotalNum = 5;
																					strcpy(menuList.acTitle, "请选择充值金额");
																					for(i=0; i<menuList.iTotalNum; i++)
																					{
																						memset(menuList.menuItem[i], 0, sizeof(menuList.menuItem[i]));
																					}
																					//		strcpy(menuList.menuItem[0], "按建议充值金额缴纳");
																					strcpy(menuList.menuItem[0], "50元");
																					strcpy(menuList.menuItem[1], "100元");
																					strcpy(menuList.menuItem[2], "200元");
																					strcpy(menuList.menuItem[3], "300元");
																					strcpy(menuList.menuItem[4], "500元");
																					iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
																					if(iRet)
																						return -1;
																					switch(iSelect)
																					{
																					case 1:
																						strcpy(gbl.amount,"000000005000");
																						return 1;
																					case 2:
																						strcpy(gbl.amount,"000000010000");
																						return 2;
																					case 3:
																						strcpy(gbl.amount,"000000020000");
																						return 3;
																					case 4:
																						strcpy(gbl.amount,"000000030000");
																						return 4;
																					case 5:
																						strcpy(gbl.amount,"000000050000");
																						return 5;
																					default: 
																						return CANCLE_KEY;
																					}
																					break;
																					case 211:  //莞城通充值
																						memset(&menuList,0,sizeof(menuList));
																						menuList.iTotalNum = 3; 
																						strcpy(menuList.acTitle, "请选择充值金额");
																						for(j=0; j<menuList.iTotalNum; j++)
																						{
																							memset(menuList.menuItem[j], 0, sizeof(menuList.menuItem[j]));
																						}
																						strcpy(menuList.menuItem[0], "50元");
																						strcpy(menuList.menuItem[1], "100元");
																						strcpy(menuList.menuItem[2], "200元");
																						iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
																						if(iRet)
																							return -1;
																						switch(iSelect)
																						{
																						case 1:
																							strcpy(gbl.amount,"000000005000");
																							strcpy(gbl.bus_selltype,"0");
																							return 1;
																						case 2:
																							strcpy(gbl.amount,"000000010000");
																							strcpy(gbl.bus_selltype,"0");
																							return 2;
																						case 3:
																							strcpy(gbl.amount,"000000020000");
																							strcpy(gbl.bus_selltype,"0");
																						return 3;
											
																						default: 
																							return CANCLE_KEY;
																						}
																						break;
																						case 214:  //莞城通开卡
																							memset(&menuList,0,sizeof(menuList));
																							menuList.iTotalNum = 1;
																							strcpy(menuList.acTitle, "请选择开卡类型");
																							for(j=0; j<menuList.iTotalNum; j++)
																							{
																								memset(menuList.menuItem[j], 0, sizeof(menuList.menuItem[j]));
																							}
																							strcpy(menuList.menuItem[0], "出售:15+30=45元");
																							// 		strcpy(menuList.menuItem[1], "租金:18+30=48元");
																							// 		strcpy(menuList.menuItem[2], "押金:25+30=55元");
																							iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
																							if(iRet)
																								return -1;
																							switch(iSelect)
																							{
																							case 1:
																								strcpy(gbl.amount,"000000004500");
																								strcpy(gbl.bus_selltype,"1");
																								return 1;
																								// 		case 2:
																								// 			strcpy(gbl.amount,"000000004800");
																								// 			strcpy(gbl.bus_selltype,"2");
																								// 			return 2;
																								// 		case 3:
																								// 			strcpy(gbl.amount,"000000005500");
																								// 			strcpy(gbl.bus_selltype,"3");
																								// 			return 3;
																							default: 
																								return CANCLE_KEY;
																							}
																							break;
																							case 283:  //联通直充-全省接口
																								menuList.iTotalNum = 5;
																								strcpy(menuList.acTitle, "请选择您要充值的金额");
																								strcpy(menuList.menuItem[0], "30元");
																								strcpy(menuList.menuItem[1], "50元");
																								strcpy(menuList.menuItem[2], "100元");
																								strcpy(menuList.menuItem[3], "200元");
																								strcpy(menuList.menuItem[4], "500元");
																								
																								if( select==0 )
																								{
																									iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
																								}
																								else
																								{
																									iRet = 0;
																									iSelect = select;
																								}
																								if(iRet)
																									return -1;
																								switch(iSelect)
																								{
																								case 1:
																									strcpy(gbl.amount,"000000003000");
																									return 1;
																								case 2:
																									strcpy(gbl.amount,"000000005000");
																									return 2;
																								case 3:
																									strcpy(gbl.amount,"000000010000");
																									return 3;
																								case 4:
																									strcpy(gbl.amount,"000000020000");
																									return 4;
																								case 5:
																									strcpy(gbl.amount,"000000050000");
																									return 5;
																								default: 
																									return CANCLE_KEY;
																								}
																								break;
																								case 334:  //卡充移动充值-华鸿
																								case 335:  //卡充移动充值-拉卡拉
																									menuList.iTotalNum = 4;
																									strcpy(menuList.acTitle, "请选择您要充值的金额");
																									strcpy(menuList.menuItem[1], "50元");
																									strcpy(menuList.menuItem[2], "100元");
																									strcpy(menuList.menuItem[3], "300元");
																									strcpy(menuList.menuItem[4], "500元");
																									
																									if( select==0 )
																									{
																										iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
																									}
																									else
																									{
																										iRet = 0;
																										iSelect = select;
																									}
																									if(iRet)
																										return -1;
																									switch(iSelect)
																									{
																									case 1:
																										strcpy(gbl.amount,"000000005000");
																										return 1;
																									case 2:
																										strcpy(gbl.amount,"000000010000");
																										return 2;
																									case 3:
																										strcpy(gbl.amount,"000000030000");
																										return 3;
																									case 4:
																										strcpy(gbl.amount,"000000050000");
																										return 4;
																									default: 
																										return CANCLE_KEY;
																									}
																									break;
																									default:
																										return 0;
	} //end switch(atoi(gbl.fee_type))
	return 0;
}

//普通签到（旧加密体系）
int CTrade::logonHdl()
{
	int  iRet;
	
	//签到包打包 
	wrLog("**********签到************");
	
	strcpy(gbl.pos_serial, "999999");
	
	pack.wrField(3, gbl);
	
	
	iRet = packHdl(3);	
	if(iRet == -1)
	{
		wrLog("【签到】8583包打包错误！");
		return -1;
	}
	if(iRet == -2)
	{
		wrLog("【签到】连接超时！");
		return -2;
	}
	
	memset(logon_random2,0,sizeof(logon_random2) );
	memcpy(logon_random2,pack.FIELD63+8,8);
	
	return 0;
}

//签到（新加密体）
//1-TPK签到, 加密改造
//2-TAK签到
//3-TEK签到
//4-完整签到
//5-普通签到
//9-TMK更新
int CTrade::logonHdl(int type)
{
	int  iRet, bit63Len, logonType, i;
	char PSAMNum[8+1], ranNum[4+1];		//PSAM卡号和随机数
	TSPSAMKey psamKey;
	
	bbzero(PSAMNum);
	bbzero(ranNum);
	iRet = TS_GetPSAMNum(gbl.dPosInfo, CARD_TYPE, PSAMNum, ranNum);
	if(iRet)
	{
		wrLog("获取PSAM卡号错误");
		return -3;
	}else{
		wrHex("PSAM卡号",(unsigned char *)PSAMNum,8);
		wrHex("随机数",(unsigned char *)ranNum,4);
	}
	
	strcpy(gbl.pos_serial, "999999");
	pack.wrField(3, gbl);
	/*-----------修改包体域----------*/
	pack.FIELD46[0] = 0x39;
	pack.FIELD46[1] = 0x64;
	pack.Packet_Table[46].Real_Length = 2;
	memcpy(pack.FIELD53, PSAMNum, 8);
	pack.FIELD63[0] = type;
	bit63Len = 1;
	if(type != 5)	//新加密体系
	{
		memcpy(pack.FIELD63+bit63Len, ranNum, 4);
		bit63Len += 4;
		memset(pack.FIELD63+bit63Len, 0x00, 4);
		bit63Len += 4;
	}
	pack.Packet_Table[63].Real_Length = bit63Len;
	/*-------------------------------*/
	//签到包打包 
	wrLog("**********签到************");
	iRet = packHdl(3);	
	if(iRet == -1)
	{
		wrLog("【签到】8583包打包错误！");
		return -1;
	}
	if(iRet == -2)
	{
		wrLog("【签到】连接超时！");
		return -2;
	}
	if (memcmp(pack.FIELD39,"00",2)) 
	{
		returnFail((char *)pack.FIELD39);
		return -4;
	}
	//获取密匙信息
	memset(&psamKey, 0, sizeof(psamKey));
	logonType = pack.FIELD63[0];
	bit63Len = 1;
	switch(logonType)
	{
	case 1:	//TPK
	case 2:	//TAK
	case 3:	//TEK
		psamKey.num = 1;
		psamKey.keyCont[0].keyIndex = logonType+1;
		memcpy(psamKey.keyCont[0].keyInfo, pack.FIELD63+bit63Len, 24);
		bit63Len+=24;
		memcpy(psamKey.keyCont[0].macData, pack.FIELD63+bit63Len, 4);
		bit63Len+=4;
		break;
	case 9:	//TMK
		psamKey.num = 1;
		psamKey.keyCont[0].keyIndex = 1;
		memcpy(psamKey.keyCont[0].keyInfo, pack.FIELD63+bit63Len, 24);
		bit63Len+=24;
		memcpy(psamKey.keyCont[0].macData, pack.FIELD63+bit63Len, 4);
		bit63Len+=4;
		break;
	case 4:	//完整签到
		psamKey.num = 3;
		for(i=0; i<psamKey.num; i++)
		{
			psamKey.keyCont[i].keyIndex = i+2;
			memcpy(psamKey.keyCont[i].keyInfo, pack.FIELD63+bit63Len, 24);	//密匙信息
			bit63Len+=24;
			memcpy(psamKey.keyCont[i].macData, pack.FIELD63+bit63Len, 4);	//macData
			bit63Len+=4;
		}
		break;
	default:
		return -1;
	}
	//更新密匙
	if( TS_UpdatePSAMKey(gbl.dPosInfo, &psamKey, CARD_TYPE) )
	{
		wrLog("更新密匙失败");
		return -3;
	}
	if(type == 9){
		return logonHdl(4);
	}
	
	return 0;
}

int CTrade::getBit46(char *bit46)
{
	BYTE bit46_byte[3+1];
	bbzero(bit46_byte);
	
	CTools::hex_to_byte((BYTE *)bit46, bit46_byte, 5);
	//stop_flag
	if((bit46_byte[1]&0x04) == 0x04)
		return 7;
	//update_tmk
	if((bit46_byte[2]&0x80) == 0x80)
		return 2;
	//update_all_work_key
	if((bit46_byte[2]&0x08) == 0x08)
		return 3;
	//update_tpk
	if((bit46_byte[2]&0x04) == 0x04)
		return 4;
	//update_tak
	if((bit46_byte[2]&0x02) == 0x02)
		return 5;
	//update_tek
	if((bit46_byte[2]&0x01) == 0x01)
		return 6;
	return 1;
}

/******************取卡密匙组号***************
int CTrade::get_key_num(char *card_no)	
{
int i;
for(i = 0; i < ECARD_TABLE_MAX; i++)	//e卡
{
if(!memcmp(CARD_TABLE_ECARD[i], card_no, strlen(CARD_TABLE_ECARD[i])) )
return 1;	//第1组密匙
}

  for(i = 0; i < ABC_TABLE_MAX; i++)	//农行
  {
		if(!memcmp(CARD_TABLE_ABC[i], card_no, strlen(CARD_TABLE_ABC[i])) )
		return 3;	//第3组密匙
		}
		
		  for(i = 0; i < CMB_TABLE_MAX; i++)	//招行
		  {
		  if(!memcmp(CARD_TABLE_CMB[i], card_no, strlen(CARD_TABLE_CMB[i])) )
		  return 4;	//第4组密匙
		  }
		  
			for(i = 0; i < GCB_TABLE_MAX; i++)	//广州商业银行
			{
			if(!memcmp(CARD_TABLE_GCB[i], card_no, strlen(CARD_TABLE_GCB[i])) )
			return 6;	//第6组密匙
			}
			
			  for(i = 0; i < CCB_TABLE_MAX; i++)	//建行
			  {
			  if(!memcmp(CARD_TABLE_CCB[i], card_no, strlen(CARD_TABLE_CCB[i])) )
			  return 7;	//第7组密匙
			  }
			  
				for(i = 0; i < CIT_TABLE_MAX; i++)	//交行
				{
				if(!memcmp(CARD_TABLE_CIT[i], card_no, strlen(CARD_TABLE_CIT[i])) )
				return 17;	//第17组密匙
				}
				
				  /*	for(i = 0; i < ICBC_TABLE_MAX; i++)	//工行
				  {
				  if(!memcmp(CARD_TABLE_ICBC[i], card_no, strlen(CARD_TABLE_ICBC[i])) )
				  return 2;	//第2组密匙
				  }
				  
					
					  for(i = 0; i < BOC_TABLE_MAX; i++)	//中行
					  {
					  if(!memcmp(CARD_TABLE_BOC[i], card_no, strlen(CARD_TABLE_BOC[i])) )
					  return 11;	//第11组密匙
					  }
					  
						for(i = 0; i < PSD_TABLE_MAX; i++)	//邮储
						{
						if(!memcmp(CARD_TABLE_PSD[i], card_no, strlen(CARD_TABLE_PSD[i])) )
						return 5;	//第5组密匙
						}
						
						  for(i = 0; i < GDB_TABLE_MAX; i++)	//广发
						  {
						  if(!memcmp(CARD_TABLE_GDB[i], card_no, strlen(CARD_TABLE_GDB[i])) )
						  return 9;	//第9组密匙
						  }
						  
							for(i = 0; i < NXB_TABLE_MAX; i++)	//农信
							{
							if(!memcmp(CARD_TABLE_NXB[i], card_no, strlen(CARD_TABLE_NXB[i])) )
							return 13;	//第13组密匙
							}
							
							  
								for(i = 0; i < MSB_TABLE_MAX; i++)	//民生
								{
								if(!memcmp(CARD_TABLE_MSB[i], card_no, strlen(CARD_TABLE_MSB[i])) )
								return 19;	//第19组密匙
								}
								
								  for(i = 0; i < ZXB_TABLE_MAX; i++)	//中信
								  {
								  if(!memcmp(CARD_TABLE_ZXB[i], card_no, strlen(CARD_TABLE_ZXB[i])) )
								  return 15;	//第15组密匙
	} */
	/*
	return 8; //银联
	}
	*/
	
	//flag:1-通讯资费，2-车船税
	int CTrade::rePrintHdl(int flag)
	{
		int iRet, iSelect, b48_len;
		char tmp[256], type[20], card_info[200];
		char response_code[3];
		BYTE temp_buff[2048];
		TSMENULIST menuList;
		TSTradeInfoSend tradeInfoSend;
		TSTradeInfoRecv tradeInfoRecv; 
		
		wrLog("【补打发票】");
		if(flag == 1){
			strcpy(gbl.fee_type, "0012");
			/**************取得卡号*******************/
			for(int curTry=0; curTry<MAXTRY; curTry++)
			{
				bbzero(card_info);
				iRet = getCardInfo("补打发票", card_info, MNG_OR_INPUT, gbl.get_card, "", 6, 19);
				if( iRet == 0 )
					iRet = getCardNum(card_info, MNG_OR_INPUT);//取得卡号
				if( (iRet == CANCLE_KEY) )
					return CANCLE_KEY;
				else if( (iRet == RE_MNG_CARD) )
					continue;
				else if(iRet != 0)
					return -1;
				else
					break;
			}
			if( !memcmp( gbl.card_no, "991088", 6) )
			{
				char tmp_card[20];
				bbzero(tmp_card);
				gbl.card_no_len -= 2;
				memcpy(tmp_card, gbl.card_no+2, gbl.card_no_len);
				bbzero(gbl.card_no);
				strcpy(gbl.card_no, tmp_card);
			}
		}
		else	//车船税
		{
			strcpy(gbl.fee_type, "3065");
			memset(&menuList,0,sizeof(menuList));
			menuList.iTotalNum = 9;
			strcpy(menuList.acTitle, "请选择车船类型：");
			strcpy(menuList.menuItem[0], "小型汽车");
			strcpy(menuList.menuItem[1], "大型汽车");
			strcpy(menuList.menuItem[2], "两、三轮摩托车");
			strcpy(menuList.menuItem[3], "轻便摩托车");
			strcpy(menuList.menuItem[4], "挂车");
			strcpy(menuList.menuItem[5], "拖拉机");
			strcpy(menuList.menuItem[6], "农用运输车");
			strcpy(menuList.menuItem[7], "外籍汽车");
			strcpy(menuList.menuItem[8], "外籍摩托车");
			iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
			if(iRet)
				return -1;
			memset(gbl.car_type, 0, sizeof(gbl.car_type));
			switch(iSelect)
			{
			case 1:
				wrLog("小型汽车");
				memcpy(gbl.car_type, "A2", 2);
				break;
			case 2:
				wrLog("大型汽车");
				memcpy(gbl.car_type, "A1", 2);
				break;
			case 3:
				wrLog("两、三轮摩托车");
				memcpy(gbl.car_type, "A3", 2);
				break;
			case 4:
				wrLog("轻便摩托车");
				memcpy(gbl.car_type, "A4", 2);
				break;
			case 5:
				wrLog("挂车");
				memcpy(gbl.car_type, "A5", 2);
				break;
			case 6:
				wrLog("拖拉机");
				memcpy(gbl.car_type, "A6", 2);
				break;
			case 7:
				wrLog("农用运输车");
				memcpy(gbl.car_type, "A7", 2);
				break;
			case 8:
				wrLog("外籍汽车");
				memcpy(gbl.car_type, "C1", 2);
				break;
			case 9:
				wrLog("外籍摩托车");
				memcpy(gbl.car_type, "C2", 2);
				break;
			default :
				return -1;
			}
			
			/**************取得卡号*******************/
			if(atoi(gbl.dPosInfo.prmVer)>=9000){
				for(int curTry=0; curTry<MAXTRY; curTry++)
				{
					bbzero(card_info);
					if( gbl.get_card == MNG_ONE_BIND_E || gbl.get_card == MNG_MUL_BIND_E )
						iRet = getCardInfo( "补打发票", card_info, ONLY_MNG, MNG_MUL, "请刷卡");//只能刷卡，多次刷卡模式
					else
						iRet = getCardInfo( "补打发票", card_info, ONLY_MNG, gbl.get_card, "请刷卡");//刷卡取得卡信息
					
					if(iRet==0)
						iRet = getCardNum(card_info);
					
					if( (iRet == CANCLE_KEY) )
						return CANCLE_KEY;
					else if( (iRet == RE_MNG_CARD) )
						return RE_MNG_CARD;
					else if(iRet != 0)
						return -1;
					else
						break;
				}
			}else{
				for(int curTry=0; curTry<MAXTRY; curTry++)
				{
					bbzero(card_info);
					iRet = getCardInfo("补打发票", card_info, MNG_OR_INPUT, gbl.get_card, "", 6, 19);
					if( iRet == 0 )
						iRet = getCardNum(card_info, MNG_OR_INPUT);//取得卡号
					if( (iRet == CANCLE_KEY) )
						return CANCLE_KEY;
					else if( (iRet == RE_MNG_CARD) )
						continue;
					else if(iRet != 0)
						return -1;
					else
						break;
				}
			}
			
			if( !memcmp( gbl.card_no, "991088", 6) )
			{
				char tmp_card[20];
				bbzero(tmp_card);
				gbl.card_no_len -= 2;
				memcpy(tmp_card, gbl.card_no+2, gbl.card_no_len);
				bbzero(gbl.card_no);
				strcpy(gbl.card_no, tmp_card);
			}
			
			
	}
	wrLog("卡号[%d]：[%s]",gbl.card_no_len,gbl.card_no);
	/************输入查询号码****************/
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	tradeInfoSend.uTotalContents = 1;	
	tradeInfoSend.uHasTradeID = 1;
	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//全字符
	if(!memcmp(gbl.fee_type, "0012", 4))
	{
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入电话号码或上网帐号");
		tradeInfoSend.Contents[0].uMinLen = 1;
		tradeInfoSend.Contents[0].uMaxLen = 12;
	}
	if(!memcmp(gbl.fee_type, "3065", 4))
	{
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入末5位车牌号码:");
		tradeInfoSend.Contents[0].uMinLen = 5;
		tradeInfoSend.Contents[0].uMaxLen = 5;
	}
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));	//终端流水
	strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
	
	pack.wrField(1, gbl);
	/*************修改部分包信息*******/
	memset(pack.FIELD2, 0, sizeof(pack.FIELD2));
	memset(pack.FIELD3, 0, sizeof(pack.FIELD3));
	memset(pack.FIELD48, 0, sizeof(pack.FIELD48));
	//bit2
	memset((char *)temp_buff,0,sizeof(temp_buff));
	strcpy((char *)temp_buff,gbl.card_no);
	if(gbl.card_no_len%2)		//卡号是奇数，后补"F"
	{
		strcat((char *)temp_buff,"F");
	}
	CTools::hex_to_byte((BYTE *)temp_buff, pack.FIELD2, gbl.card_no_len, 1);	//变为bcd码（后补0）
	pack.Packet_Table[2].Real_Length=gbl.card_no_len;
	//bit3
	CTools::hex_to_byte((BYTE *)"310040", pack.FIELD3, 6);
	//bit48
	if(!memcmp(gbl.fee_type, "0012", 4))
	{
		memset(gbl.phone_no, 0, sizeof(gbl.phone_no));
		memcpy(gbl.phone_no, tradeInfoRecv.Contents[0].uMsg, tradeInfoRecv.Contents[0].uMsgLen);
		CTools::lowerToUpper(gbl.phone_no);
		gbl.phone_len = tradeInfoRecv.Contents[0].uMsgLen;
		memcpy(pack.FIELD48, gbl.fee_type, 4);
		b48_len = 4;
		memset(tmp, 0, sizeof(tmp));
		sprintf(tmp, "%02d", gbl.phone_len);
		memcpy(pack.FIELD48 + b48_len, tmp, 2);
		b48_len += 2;
		memcpy(pack.FIELD48 + b48_len, gbl.phone_no, gbl.phone_len);
		b48_len += gbl.phone_len;
		memcpy(pack.FIELD48 + b48_len, "03", 2);
		b48_len += 2;
		pack.Packet_Table[48].Real_Length = b48_len;
	}
	else if(!memcmp(gbl.fee_type, "3065", 4))
	{
		bbzero(gbl.car_no);
		strcpy(gbl.car_no, "01A");
		memcpy(gbl.car_no+3, tradeInfoRecv.Contents[0].uMsg, 5);
		for(int i = 3; i < 8; i++)	//小写转换成大写
		{
			if((gbl.car_no[i] >= 97) && (gbl.car_no[i] <= 122) )
				gbl.car_no[i] = gbl.car_no[i] - 32; 
		}
		memcpy(pack.FIELD48,gbl.fee_type,4);	//4位信息码
		b48_len =4;
		memcpy(pack.FIELD48+b48_len, "10", 2);	//后面的长度:车类型(2) + 车牌号(8)
		b48_len +=2;
		memcpy(pack.FIELD48+b48_len, gbl.car_type, 2);
		b48_len +=2;
		memcpy(pack.FIELD48+b48_len, gbl.car_no, 8);
		b48_len +=8;
		memcpy(pack.FIELD48 + b48_len, "03", 2);
		b48_len += 2;
		pack.Packet_Table[48].Real_Length = b48_len;
	}
	/**********************************************/
	//查询包打包   
	iRet = packHdl(1);
	if(iRet < 0)
		return -1;
	
	//返回数据给终端
	memset(response_code, 0, sizeof(response_code));
	memcpy(response_code, pack.FIELD39, 2);
	if(!atoi(response_code))	//成功
	{
		memset(type, 0, sizeof(type));
		switch(atoi(gbl.fee_type))
		{
		case 1:
			strcpy(type, "长市话费");
			break;
		case 13:
			strcpy(type, "ADSL话费");
			break;
		case 241:
			strcpy(type, "CDMA话费");
			break;
		case 3002:
			strcpy(type, "移动话费");
			break;
		case 0065:
			strcpy(type, "车船税");
			break;
		}
		CPrint prt;
		prt.set_in_par(gbl);
		//prt.print_detail(1, type);	//打印欠费明细
		prt.print_pym_detail(pack,type);
	}
	else
		returnFail(response_code);
	return -1;
}

int CTrade::newrePrtTrade(int flag)
{
	int iRet, iSelect, biz_flag;
	char tmp[256], type[20];
	char response_code[3];
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv; 
	
	wrLog("【东莞补打发票及直充补打】");
	if(flag == 1)//按交费号码补打
	{
		strcpy(gbl.fee_type, "0149");
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));	
		tradeInfoSend.uTotalContents = 1;	
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入缴费号码：");	
		tradeInfoSend.Contents[0].uMinLen = 1;
		tradeInfoSend.Contents[0].uMaxLen = 12;
        tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		if(iRet != 0)
		{
			wrLog("TS_TradeControl返回错误[%d]", iRet);
			wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
			return iRet;
		}
		memset(gbl.phone_no, 0, sizeof(gbl.phone_no));
		memcpy(gbl.phone_no, tradeInfoRecv.Contents[0].uMsg, tradeInfoRecv.Contents[0].uMsgLen);
		gbl.phone_len = tradeInfoRecv.Contents[0].uMsgLen;
		wrLog("输入的缴费号码为:[%s]", gbl.phone_no);
		
		
		for (int i = 0; i < epos_mobile.size(); i++)
		{
			if (memcmp(gbl.phone_no,epos_mobile[i].mobile_field,3)==0)
				break;
		}
		if (i == epos_mobile.size())
		{
			biz_flag = 4;
		}
		else
		{
			biz_flag = epos_mobile[i].mobile_owner;
		}
		
		if (biz_flag == 2 && gbl.menu_group_mbl_flag==2)
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n\n请使用ipos_m进行补打",0,iSelect);
			return -1;
		}else if (biz_flag != 2 && gbl.menu_group_mbl_flag == 1 )
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n\n请使用ipos进行补打",0,iSelect);
			return -1;
		}
		
		if (gbl.phone_len == 10)
		{   
			bbzero(gbl.card_num);
			memcpy(gbl.card_num, gbl.phone_no, strlen(gbl.phone_no));
			char change[10];
			int i;
			bbzero(change);
			for(i=0; i<10; i++)
			{
				if(gbl.phone_no[i]>='5')
					change[i] = gbl.phone_no[i] - 5;
				else
					change[i] = gbl.phone_no[i] + 5;
			}
			for(i=0; i<2; i++)
			{
				char temp;
				temp = change[i*2];
				change[i*2] = change[(4-i)*2];
				change[(4-i)*2] = temp;
				temp = change[i*2+1];
				change[i*2+1] = change[(4-i)*2+1];
				change[(4-i)*2+1] = temp;
			}
			memset(gbl.phone_no,0,sizeof(gbl.phone_no));			
			char arr[16]={'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'}; 
			unsigned int num1,k=16; 
			num1 = atoi(change);
			char p[10]; 
			int count=0; 
			while(num1>0) 
			{ 
				p[count]=num1 % k ; 
				num1=num1 / k ; 
				count ++ ; 
			} 
			for (i=count-1;i>=0;i--)
			{
				memcpy(gbl.phone_no+7-i,&arr[p[i]],sizeof(arr[p[i]]));
			}
			wrLog("转换后的公交卡号是:[%s]", gbl.phone_no);
		}
		memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));	//终端流水
		strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
		
		pack.wrField(1, gbl);
		/*************修改部分包信息*******/
		memset(pack.FIELD3, 0, sizeof(pack.FIELD3));
		CTools::hex_to_byte((BYTE *)"310050", pack.FIELD3, 6);
		/**********************************************/
		//查询包打包   
		iRet = packHdl(1);
		if(iRet < 0)
			return -1;
		
		//返回数据给终端
		memset(response_code, 0, sizeof(response_code));
		memcpy(response_code, pack.FIELD39, 2);
		if(!atoi(response_code))	//成功
		{   
			int count=0,len=0;
			
			bbzero(gbl.fee_type2);
			memcpy(gbl.fee_type2, pack.FIELD48, 4);
			
			
			bbzero( tmp );
			memcpy(tmp, pack.FIELD63, 2);
			count += 2;
			len = atoi(tmp);
			bbzero(gbl.card_no);
			memcpy(gbl.card_no, pack.FIELD63 + count, len);
			count += len;
			
			bbzero(gbl.fee_type);
			memcpy(gbl.fee_type, pack.FIELD63 + count, 4);
			count += 4;
			
			bbzero( tmp );
			memcpy(tmp, pack.FIELD63 + count, 2);
			count += 2;
			len = atoi(tmp);
			bbzero(gbl.pay_no);
			memcpy(gbl.pay_no, pack.FIELD63 + count, len);
			count += len;
			
			bbzero(gbl.amount);
			memcpy(gbl.amount, pack.FIELD63 + count, 12);
			count += 12;
			
			bbzero(gbl.stan_no);
			memcpy(gbl.stan_no, pack.FIELD63 + count, 12);
			count += 12;
			
			bbzero( tmp );
			memcpy(tmp, pack.FIELD63 + count, 3);
			count += 3;		
			len = atoi(tmp);
			gbl.num = count;
			
			bbzero(type);
			getFeeType(gbl.fee_type, type);
			CPrint prt;
			prt.set_in_par(gbl);
			if( atoi(gbl.fee_type) == 131)
				//prt.print_detail(1, type);	//打印欠费明细
				prt.print_pym_detail(pack,type);
			else if (atoi(gbl.fee_type) == 214)//东莞公交开卡
			{   
			//	prt.print_detail(15, "东莞公交开卡"); 
				prt.reprint_bus_detail(pack,"东莞公交开卡");
			}
			else
				//prt.print_detail(2, type); 
				prt.print_pre_detail(pack,type);

			return 0;
		}
		else
		{		
			returnFail(response_code);
		}
		return 1;
	}
	else if(flag == 2)	//按stan号补打售卡
	{
        strcpy(gbl.fee_type, "0182");
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));	
		tradeInfoSend.uTotalContents = 1;	
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//全字符
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入系统参考号：");
		tradeInfoSend.Contents[0].uMinLen = 12;
		tradeInfoSend.Contents[0].uMaxLen = 12;
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		if(iRet != 0)
		{
			wrLog("TS_TradeControl返回错误[%d]", iRet);
			wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
			return iRet;
		}
		memset(gbl.phone_no, 0, sizeof(gbl.phone_no));
		memcpy(gbl.phone_no, tradeInfoRecv.Contents[0].uMsg, tradeInfoRecv.Contents[0].uMsgLen);
		gbl.phone_len = tradeInfoRecv.Contents[0].uMsgLen;
		wrLog("输入的系统参考号为:[%s]", gbl.phone_no);
        int flag2=0;
		for(int curTry=0; curTry<MAXTRY; curTry++)
		{	
			if(!flag2)
			{   
				iRet = 1;
				while(iRet)	//刷卡错误，重新刷卡
				{
					iRet = mngCard_Hdl("按系统参考号补打发票");
					if(iRet == CANCLE_KEY)
						return CANCLE_KEY;
					else if(iRet != 0)
						return -1;
				}
			}
			
            memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));	//终端流水
			strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
			
			pack.wrField(2, gbl);
			/*************修改部分包信息*******/
			memset(pack.FIELD3, 0, sizeof(pack.FIELD3));
			CTools::hex_to_byte((BYTE *)"310050", pack.FIELD3, 6);
			
			/**********************************************/
			//查询包打包   
			iRet = packHdl(1);
			if(iRet < 0)
				return -1;
			
			//返回数据给终端
			memset(response_code, 0, sizeof(response_code));
			memcpy(response_code, pack.FIELD39, 2);
			if (!memcmp(response_code,"00",2)) 
			{   
				bbzero(gbl.fee_type2);
				memcpy(gbl.fee_type2, pack.FIELD48, 4);
				wrLog("东莞售卡补打，准备打印!");
				CPrint prt;
				prt.set_in_par(gbl);
				//prt.print_detail(3, "按系统参考号补打");	 //打印售卡明细
				prt.print_card_detail(pack,"按系统参考号补打");
				return 0;
			}
			else if(!memcmp(response_code,"80",2) && !memcmp(pack.FIELD62, "P20003755", 9))
			{
				flag2 = 1;
				if(reGetPwd("按系统参考号补打") == 0) //密码错误，重新输入密码, 2006-10-25
					continue;
				else
					return CANCLE_KEY;
			}			
			else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
			{
				TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
				if (iSelect!=0)
				{
					return -1;
				}else
					continue;
			}
			else
			{		
				returnFail(response_code);
			}
			return 1;
        }
	}
	else
		return -1;
	return 1;
}

//重新输入密码
int CTrade::reGetPwd(const char *type)
{
	int iSelect, iRet;
	TS_OutPutMsg(gbl.dPosInfo,"  \n     密码错误！\n【确认】重新输入\n【返回】返回",0,iSelect);
	if(iSelect == 0)
	{
		iRet = getCardPwd(type);		
		if(iRet == CANCLE_KEY)
			return CANCLE_KEY;
		else if(iRet != 0)
			return -1;
		return 0;
	}
	else
		return CANCLE_KEY;
}

//售卡业务，2006-10-31，lihk 添加翼支付卡销售 by liuxiao 30131121
int CTrade::sellCardTrade(const char *type, int select,int input_flag)
{
	int  iRet=0, flag = 0;
	int  iSelect;
	int returnflag;
	int  b48_len;
	char len_tmp[2+1];
	char response_code[3];
	//	char correct_code[3],party_code[7];
	char amoMny[15], msg[200];
	//	char temp[1024];
	/*
	char dest_list[1+1], phone_no[20], formData[1024], getData[1024], tmp[1024], cardpwdEnc[20+1], password[18+1];
	TSMENULIST menuList;
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv; 
	*/
	
	//院线通获取手机号
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	char strPhoneNo[12];
	
	wrLog("售卡业务");
	if(atoi(gbl.dPosInfo.prmVer)>=9000 && memcmp(gbl.sell_card_type,"10",2)==0 ) //如果是IPOS的话，直接
	{
		//界面上面显示信息
		TS_OutPutMsg(gbl.dPosInfo,"\n\n1、翼支付卡（电子卡）是中国电信天翼电子商务有限公司推出的一种电子消费卡。该卡不记名、不挂失、不计息、不透支、不可兑换现金。\n2、持卡用户可用该卡为电信翼支付帐户充值，并可通过翼支付门户网站和翼支付手机客户端进行消费。\n3、持卡用户可以登陆天翼积分商城jf.ct10000.com进行消费。\n\n【Enter】 进入业务 　【Del】返上一级",1,iSelect);
		if (iSelect!=0)
		{
			return CANCLE_KEY;
		}

	}
	else{
		switch(atoi(gbl.sell_card_type)){
		case 10:
			TS_OutPutMsg(gbl.dPosInfo,"本充值卡为广州市小灵通充值卡，只适用于广州市预付费小灵通用户话费充值",1,iSelect);
			break;
		case 20:
			TS_OutPutMsg(gbl.dPosInfo,"本充值卡为广东省移动充值卡，只适用广东省移动用户（动感地带、神州行、大众卡、全球通）话费充值。",1,iSelect);
			break;
		case 30:
			TS_OutPutMsg(gbl.dPosInfo,"本充值卡适用于全国联通号码充值（130~132、155、156）。",1,iSelect);
			break;
		case 40:
			TS_OutPutMsg(gbl.dPosInfo,"本业务为广东省电信充值付费卡，只适用广东省电信用户（固话、ADSL、小灵通、CDMA）充值付费。",1,iSelect);
			break;
		case 802:
			TS_OutPutMsg(gbl.dPosInfo,"你购买的是搜狐畅游一卡通300点点卡，面值15元",1,iSelect);
			break;
		case 803:
			TS_OutPutMsg(gbl.dPosInfo,"你购买的是搜狐畅游一卡通600点点卡，面值30元",1,iSelect);
			break;
		case 801:
			TS_OutPutMsg(gbl.dPosInfo,"你购买的是魔兽世界600点游戏卡，面值30元",1,iSelect);
			break;
		}
	}
	
	
	if(atoi(gbl.sell_card_type) == 802)
	{
		wrLog("进入游戏点卡业务搜狐300点，取得金额");
		strcpy(gbl.card_amount, "000000001500");
		strcpy(gbl.amount, "000000001500");
		strcpy(gbl.sell_card_type, "0800");
	}
	else	if(atoi(gbl.sell_card_type) == 803)
	{
		wrLog("进入游戏点卡业务搜狐600点，取得金额");
		strcpy(gbl.card_amount, "000000003000");
		strcpy(gbl.amount, "000000003000");
		strcpy(gbl.sell_card_type, "0801");
	}
	else	if(atoi(gbl.sell_card_type) == 801)
	{
		wrLog("进入游戏点卡业务魔兽600点，取得金额");
		strcpy(gbl.card_amount, "000000003000");
		strcpy(gbl.amount, "000000003000");
		strcpy(gbl.sell_card_type, "0810");
	}
	else{
		iRet = selectAmount(0, select);
		returnflag = iRet;
	}
    
	if((iRet < 0) || (iRet == CANCLE_KEY))
		return -1;
	
	if (input_flag == 0)
	{
		if(atoi(gbl.dPosInfo.prmVer)>=9000)
		{
			bbzero(amoMny);
			CTools::chgToMny(gbl.amount,amoMny);
			bbzero(msg);
			if(atoi(gbl.sell_card_type) == 900)
				sprintf(msg, "%s\n\n%s\n\n【是 Enter】  【否 Esc】", type, amoMny);
			else
			{
				sprintf(msg, "%s\n\n%s\n\n【是 Enter】  【否 Esc】\n【请认真核对售卡类型及金额】", type, amoMny);
			}
			iRet = TS_OutPutMsg(gbl.dPosInfo, msg, 0, iSelect);
			if(iSelect)
			{
				return -1;
			}
		}
	}
	
	
	//院线通输入手机号
	if(atoi(gbl.sell_card_type) == 900)
	{
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
		
		strcpy(tradeInfoSend.acMainTitle, "院线通");
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents = 1;		
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入手机号：(用于接收密码短信)");	
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	
		tradeInfoSend.Contents[0].uCount = 1;	//输入2次	
		tradeInfoSend.Contents[0].uTimeOut = 30;
		tradeInfoSend.Contents[0].uMinLen = 11;	
		tradeInfoSend.Contents[0].uMaxLen = 11;
		
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		
		if(iRet != 0)
		{
			wrLog("TS_TradeControl返回错误[%d]", iRet);
			wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
			return iRet;
		}
		
		bbzero(strPhoneNo);
		memcpy(strPhoneNo, (char *)tradeInfoRecv.Contents[0].uMsg, tradeInfoRecv.Contents[0].uMsgLen);
		
		bbzero(msg);
		sprintf(msg, "%s\n\n%s\n\n手机号：%s\n\n【确认 Enter】  【退出 Esc】", type, amoMny, strPhoneNo);
		
		iRet = TS_OutPutMsg(gbl.dPosInfo, msg, 0, iSelect);
		if(iSelect)
		{
			return -1;
		}
	}
	
	// 交费
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{	
		if(!flag)
		{   
			iRet = 1;
			while(iRet)	//刷卡错误，重新刷卡
			{
				iRet = mngCard_Hdl(type);
				if(iRet == CANCLE_KEY)
					return CANCLE_KEY;
				else if(iRet != 0)
					return -1;
				
			}
		}
        
		pack.wrField(2, gbl);	//写交费域
		/*************48bit****************/
		b48_len = 0;
		bbzero(pack.FIELD48);
		memcpy(pack.FIELD48, gbl.fee_type, 4);
		b48_len += 4;
		bbzero(len_tmp);
		memcpy(len_tmp, "04", 2);
		memcpy(pack.FIELD48 + b48_len, len_tmp, 2);
		b48_len += 2;
		memcpy(pack.FIELD48+b48_len, gbl.sell_card_type, 4);
		b48_len += 4;
		pack.Packet_Table[48].Real_Length=b48_len;
		
		//院线通手机号
		if(atoi(gbl.sell_card_type) == 900)
		{
			memcpy(pack.FIELD48+4, "15", 2);
			memcpy(pack.FIELD48+b48_len, strPhoneNo, 11);
			b48_len += 11;
			pack.Packet_Table[48].Real_Length=b48_len;
		}
		
		/*************end 48bit****************/
		
		iRet = packHdl(2);
		if(iRet < 0)
			return -1;
		
		memset(response_code,0,sizeof(response_code));
		memcpy(response_code,pack.FIELD39,2);
		if (!memcmp(response_code,"00",2)) 
		{   
	

			if(atoi(gbl.fee_type)==153){//东莞售卡
				TS_OutPutMsg(gbl.dPosInfo," \n     交易成功！\n   请连接好打印机\n   按【确认】打印",0,iSelect);
			}
			else
				TS_OutPutMsg(gbl.dPosInfo,"     售卡成功！\n按【确认】打印卡数据\n如无法正常获得卡数据，请立即致电400-80-11888（最好于3小时以内），我们将为您优先处理",0,iSelect);
			wrLog("售卡成功，准备打印!");
			CPrint prt;
			prt.set_in_par(gbl);
			//prt.print_detail(3, type);	 //打印售卡明细
			prt.print_card_detail(pack,type);
			

										 /*if( atoi(gbl.dPosInfo.prmVer)>=9000 && ( strstr(CT10000_TERM, "00000000")!=NULL || strstr(CT10000_TERM, gbl.pos_no)!=NULL ) )
										 {
										 if( ( memcmp(gbl.fee_type, "0089", 4)==0 && (memcmp(gbl.sell_card_type, "0135", 4)==0 || memcmp(gbl.sell_card_type, "0136", 4)==0 || memcmp(gbl.sell_card_type, "0139", 4)==0) ) || ( memcmp(gbl.fee_type, "0153", 4)==0 && (memcmp(gbl.sell_card_type, "0128", 4)==0 || memcmp(gbl.sell_card_type, "0129", 4)==0 || memcmp(gbl.sell_card_type, "0130", 4)==0) ) )
										 {
										 char acTitle[80+1];
										 
										   bbzero(dest_list);
										   bbzero(phone_no);
										   bbzero(formData);
										   bbzero(getData);
										   bbzero(tmp);
										   
											 bbzero(acTitle);
											 
											   bbzero(cardpwdEnc);
											   bbzero(password);
											   memcpy(cardpwdEnc, pack.FIELD63+4, 18);
											   CTools::Encrypt(cardpwdEnc, password, 1);
											   
												 memset(&menuList,0,sizeof(menuList));
												 strcpy(menuList.acTitle, "如需直接充值，请选择号码类型");
												 strcpy(menuList.menuItem[0], "固话");
												 strcpy(menuList.menuItem[1], "小灵通");
												 strcpy(menuList.menuItem[2], "天翼手机(无线宽带)");
												 strcpy(menuList.menuItem[3], "ADSL");
												 menuList.iTotalNum = 4;
												 iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
												 if(iRet != 0)
												 {
												 return 0;
												 }
												 else
												 {
												 NULL;
												 }
												 
												   bbzero(dest_list);
												   memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
												   memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
												   tradeInfoSend.uTotalContents = 1;	
												   tradeInfoSend.uHasTradeID = 1;
												   
													 switch(iSelect)
													 {
													 case 1:
													 strcpy(dest_list,"0");
													 tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//全字符
													 strcpy(tradeInfoSend.Contents[0].acTitle, "固话:区号+固话号码");
													 tradeInfoSend.Contents[0].uMinLen = 11;
													 tradeInfoSend.Contents[0].uMaxLen = 12;
													 tradeInfoSend.Contents[0].uCount = 1;//输入2次
													 tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
													 break;
													 case 2:
													 strcpy(dest_list,"1");
													 tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//全字符
													 strcpy(tradeInfoSend.Contents[0].acTitle, "小灵通:区号+小灵通号码");
													 tradeInfoSend.Contents[0].uMinLen = 11;
													 tradeInfoSend.Contents[0].uMaxLen = 12;
													 tradeInfoSend.Contents[0].uCount = 1;//输入2次
													 tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
													 break;
													 case 3:
													 strcpy(dest_list,"2");
													 tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//全字符
													 strcpy(tradeInfoSend.Contents[0].acTitle, "天翼手机(无线宽带):手机号码(11位)");
													 tradeInfoSend.Contents[0].uMinLen = 11;
													 tradeInfoSend.Contents[0].uMaxLen = 11;
													 tradeInfoSend.Contents[0].uCount = 1;//输入2次
													 tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
													 break;
													 case 4:
													 strcpy(dest_list,"3");
													 tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//全字符
													 strcpy(tradeInfoSend.Contents[0].acTitle, "宽带:区号+捆绑的固话号码");
													 tradeInfoSend.Contents[0].uMinLen = 11;
													 tradeInfoSend.Contents[0].uMaxLen = 12;
													 tradeInfoSend.Contents[0].uCount = 1;//输入2次
													 tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
													 break;
													 default:
													 wrLog("TS_Menu返回错误[%d]", iSelect);
													 return 0;
													 break;
													 }
													 
													   for(int i=0; i<MAXTRY; i++)
													   {									
													   iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
													   if(iRet != 0)
													   {
													   wrLog("TS_TradeControl返回错误[%d]", iRet);
													   return iRet;
													   }
													   else
													   {
													   NULL;
													   }
													   bbzero(phone_no);
													   if(memcmp(dest_list, "2", 1)==0)
													   {
													   strcpy( phone_no, gbl.city_no );
													   strcat( phone_no,(char *)tradeInfoRecv.Contents[0].uMsg );
													   }
													   else
													   {
													   strcpy( phone_no,(char *)tradeInfoRecv.Contents[0].uMsg );
													   }					
													   
														 if(memcmp(phone_no, "0", 1)==0)
														 {
														 break;
														 }
														 else
														 {
														 bbzero(tmp);
														 sprintf(tmp,"您输入的号码没带区号\n\n请重新输入 %s ", acTitle);
														 TS_OutPutMsg(gbl.dPosInfo, tmp, 0,iSelect);
														 }
														 }
														 
														   bbzero(getData);
														   bbzero(formData);
														   strcpy(formData, "charge_type=dz&card_pwd_num=1&charge_num_total=1&card_pwd=");
														   strcat(formData, password);
														   strcat(formData, "&dest_list=");
														   strcat(formData, dest_list);
														   strcat(formData, "&latn_id_list=");
														   if(memcmp(phone_no, "020", 3)==0)//如果输入广州区号
														   {
														   strcat(formData, "020");
														   strcat(formData, "&charge_num_list=");
														   strcat(formData, phone_no+3);
														   }
														   else//如果输入非广州区号
														   {
														   memcpy(formData+strlen(formData), phone_no, 4);
														   strcat(formData, "&charge_num_list=");
														   strcat(formData, phone_no+4);
														   }
														   strcat(formData, "&charge_amount_list=0&objType=5BC");
														   iRet=TS_FillCt10000(gbl.dPosInfo, "gd.ct10000.com", "/webChargeAction.do", formData, getData);
														   if(iRet==0)
														   {
														   if(strstr(getData, "充值成功")!=NULL)
														   {
														   bbzero(amoMny);
														   CTools::chgToMny(gbl.amount,amoMny);
														   bbzero(tmp);
														   sprintf(tmp,"充值付费卡[%s]充值成功！\n电话[%s]已充值%s", password, phone_no, amoMny);
														   TS_OutPutMsg(gbl.dPosInfo, tmp, 0,iSelect);
														   }
														   else
														   {
														   wrLog("gd.ct10000.com getData[%s]", getData);
														   bbzero(tmp);
														   sprintf(tmp,"充值付费卡[%s]充值超时，结果待确认\n请拨打400-80-11888客服电话进行充值结果查询，需要提供充值付费卡的卡序列号进行查询", password);
														   TS_OutPutMsg(gbl.dPosInfo, tmp, 0,iSelect);
														   }
														   }
														   else
														   {
														   wrLog("gd.ct10000.com getData[%s]", getData);
														   bbzero(tmp);
														   sprintf(tmp,"充值付费卡[%s]充值超时，结果待确认\n请拨打400-80-11888客服电话进行充值结果查询，需要提供充值付费卡的卡序列号进行查询", password);
														   TS_OutPutMsg(gbl.dPosInfo, tmp, 0,iSelect);
														   }
														   }
														   }
														   else
														   {
														   NULL;
			}*/

		}
		else if(!memcmp(response_code,"55",2))
		{
			flag = 1;
			if(reGetPwd( type) == 0) //密码错误，重新输入密码, 2006-10-25，lihk
				continue;
			else
				return CANCLE_KEY;
		}
		else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
			if (iSelect!=0)
			{
				return -1;
			}else
				continue;
		}
		else
		{		
			// 			memset(party_code,0,sizeof(party_code));
			// 			memset(correct_code,0,sizeof(correct_code));
			// 			
			// 			memcpy(party_code,&pack.FIELD62[1],6);
			// 			memcpy(correct_code,&pack.FIELD62[1+6],2);
			// 			if ((returnflag==1)&&(atoi(response_code)==80)&&(atoi(correct_code)==82)&&(!memcmp(gbl.sell_card_type, "020", 3))&&atoi(gbl.fee_type)!=153)
			// 			{
			// 				wrLog("返回失败,返回码[%s]",response_code);
			// 				wrLog("62域correct_code返回码[%s]",correct_code);
			// 				bbzero(temp);
			// 				sprintf(temp,"        您好！\n    充值卡已售完\n请按【确认】用“移动话费直充”进行充值");
			// 				iRet = TS_OutPutMsg(gbl.dPosInfo,temp,0,iSelect);
			// 				if (iRet == 0)
			// 				{
			// 					mblAirPay("移动话费直充", 2);
			// 				}else
			// 					return -1;
			// 			}else			
			returnFail(response_code);
		}

		return 1;
	}
	return -1;
}


//售卡业务，2006-10-31，lihk
//flag==1则为网易游戏卡（网易无15元游戏卡充值）
//修改天下通卡无15元游戏卡充值
int CTrade::sellZWgameCard(const char *type, int select,int input_flag)
{
	int  iRet=0, flag = 0;
	int  iSelect;
	int  b48_len;
	char len_tmp[2+1];
	char amoMny[15], msg[200];
	char response_code[3];
	TSMENULIST menuList;
	
	wrLog("天下通卡售卡业务");
	memset(&menuList,0,sizeof(menuList));
	if(input_flag==0){
		menuList.iTotalNum = 5;
		strcpy(menuList.acTitle, "请选择游戏卡的面值");
		for(int j=0; j<menuList.iTotalNum; j++)
		{
			memset(menuList.menuItem[j], 0, sizeof(menuList.menuItem[j]));
		}
		strcpy(menuList.menuItem[0], "10元");
		strcpy(menuList.menuItem[1], "15元");
		strcpy(menuList.menuItem[2], "30元");
		strcpy(menuList.menuItem[3], "50元");
		strcpy(menuList.menuItem[4], "100元");
		if(select==0){
			iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
		}
		else
		{
			iRet = 0;
			iSelect = select;
		}
		if(iRet)
			return -1;
		wrLog("充值卡选择项：[%d]", iSelect);
		bbzero(gbl.amount);
		bbzero(gbl.sell_card_type);
		
		switch(iSelect)
		{
		case 1:
			strcpy(gbl.card_amount,"000000001000");
			strcpy(gbl.amount,"000000001000");
			strcpy(gbl.sell_card_type,"0810");
			break;
		case 2:	
			strcpy(gbl.card_amount,"000000001500");
			strcpy(gbl.amount,"000000001500");
			strcpy(gbl.sell_card_type,"0811");
			break;
		case 3:
			strcpy(gbl.card_amount,"000000003000");
			strcpy(gbl.amount,"000000003000");
			strcpy(gbl.sell_card_type,"0812");
			break;
		case 4:
			strcpy(gbl.card_amount,"000000005000");
			strcpy(gbl.amount,"000000005000");
			strcpy(gbl.sell_card_type,"0813");
			break;
		case 5:
			strcpy(gbl.card_amount,"000000010000");
			strcpy(gbl.amount,"000000010000");
			strcpy(gbl.sell_card_type,"0814");
			break;
		default: 
			return CANCLE_KEY;
		}
    }else{
		menuList.iTotalNum = 4;
		strcpy(menuList.acTitle, "请选择游戏卡的面值");
		for(int j=0; j<menuList.iTotalNum; j++)
		{
			memset(menuList.menuItem[j], 0, sizeof(menuList.menuItem[j]));
		}
		strcpy(menuList.menuItem[0], "10元");
		strcpy(menuList.menuItem[1], "30元");
		strcpy(menuList.menuItem[2], "50元");
		strcpy(menuList.menuItem[3], "100元");
		if(select==0){
			iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
		}
		else
		{
			iRet = 0;
			iSelect = select;
		}
		if(iRet)
			return -1;
		wrLog("充值卡选择项：[%d]", iSelect);
		bbzero(gbl.amount);
		bbzero(gbl.sell_card_type);
		
		switch(iSelect)
		{
		case 1:
			strcpy(gbl.card_amount,"000000001000");
			strcpy(gbl.amount,"000000001000");
			strcpy(gbl.sell_card_type,"0810");
			break;
		case 2:
			strcpy(gbl.card_amount,"000000003000");
			strcpy(gbl.amount,"000000003000");
			strcpy(gbl.sell_card_type,"0812");
			break;
		case 3:
			strcpy(gbl.card_amount,"000000005000");
			strcpy(gbl.amount,"000000005000");
			strcpy(gbl.sell_card_type,"0813");
			break;
		case 4:
			strcpy(gbl.card_amount,"000000010000");
			strcpy(gbl.amount,"000000010000");
			strcpy(gbl.sell_card_type,"0814");
			break;
		default: 
			return CANCLE_KEY;
		}
		
	}
	if(atoi(gbl.dPosInfo.prmVer)>=9000)
	{
		bbzero(amoMny);
		CTools::chgToMny(gbl.amount,amoMny);
		bbzero(msg);
		sprintf(msg, "%s\n\n%s\n\n【是 Enter】  【否 Esc】", type, amoMny);
		iRet = TS_OutPutMsg(gbl.dPosInfo, msg, 0, iSelect);
		if(iSelect)
		{
			return -1;
		}
	}
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{	
		if(!flag)
		{
			iRet = mngCard_Hdl(type);
			if(iRet == CANCLE_KEY)
				return CANCLE_KEY;
			else if(iRet != 0)
				return -1;
		}
        
		pack.wrField(2, gbl);	//写交费域
		/*************48bit****************/
		b48_len = 0;
		bbzero(pack.FIELD48);
		memcpy(pack.FIELD48, gbl.fee_type, 4);
		b48_len += 4;
		bbzero(len_tmp);
		memcpy(len_tmp, "04", 2);
		memcpy(pack.FIELD48 + b48_len, len_tmp, 2);
		b48_len += 2;
		memcpy(pack.FIELD48+b48_len, gbl.sell_card_type, 4);
		b48_len += 4;
		pack.Packet_Table[48].Real_Length=b48_len;
		/*************end 48bit****************/
		
		iRet = packHdl(2);
		if(iRet < 0)
			return -1;
		
		memset(response_code,0,sizeof(response_code));
		memcpy(response_code,pack.FIELD39,2);
		if (!memcmp(response_code,"00",2)) 
		{   
			if(atoi(gbl.fee_type)==153){
				TS_OutPutMsg(gbl.dPosInfo," \n     交易成功！\n   请连接好打印机\n   按【确认】打印",0,iSelect);
			}
			else
				TS_OutPutMsg(gbl.dPosInfo,"     售卡成功！\n按【确认】打印卡数据\n如无法正常获得卡数据，请立即致电400-80-11888（最好于3小时以内），我们将为您优先处理",0,iSelect);
			wrLog("售卡成功，准备打印!");
			CPrint prt;
			prt.set_in_par(gbl);
			//prt.print_detail(3, type);	 //打印售卡明细
			prt.print_card_detail(pack,type);
			return 0;
		}
		else if(!memcmp(response_code,"55",2))
		{
			flag = 1;
			if(reGetPwd( type) == 0) //密码错误，重新输入密码, 2006-10-25，lihk
				continue;
			else
				return CANCLE_KEY;
		}
		else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
			if (iSelect!=0)
			{
				return -1;
			}else
				continue;
		}
		else
		{					
			returnFail(response_code);
		}
		return 1;
	}
	return -1;
}

//包处理函数，包括打包、发包、收包和解包一条龙
//flag参数:
//1, 查询包
//2, 交费包
//3, 签到包
//4, 确认包
//5, 冲正包
int CTrade::packHdl(int flag)
{
	BYTE temp_buff[1024];
	char send_buff[1024], rev_buff[1024+1], len_buff[4+1], serial[6+1], bankamo[12+1], mny[12+1], msg[1024],yjamo[1+12+1],yjmny[12+1];
	char seq[10+1]; //数据库操作时产生的序列号
	int send_len, iRet, rev_len, iSelect, nowAmo=0;
	int i, stat;
	CConnect con;	//连接类
	
	//if(flag==2 && memcmp(gbl.fee_type, "0301", 4)&& memcmp(gbl.fee_type, "0302", 4)&& memcmp(gbl.fee_type, "0075", 4)&& memcmp(gbl.fee_type, "0074", 4) && memcmp(gbl.fee_type, "0083", 4) && memcmp(gbl.fee_type, "0221", 4) && memcmp(gbl.fee_type, "0109", 4) && memcmp(gbl.fee_type, "0268", 4))
	if(flag == 2 && strstr(ECARDTRADE, gbl.fee_type) == NULL)
	{
		if(CDB::getDayAmo(gbl.dPosInfo.pos_no, &nowAmo)==0)
		//20130105修改-yyx
		//if (CDB::pep_getDayAmo(gbl.pos_no, &nowAmo) == 0)
		{
			if( gbl.dayAmo!=0 && nowAmo+atoi(gbl.amount)>gbl.dayAmo)
			{
				TS_OutPutMsg(gbl.dPosInfo, "已超出当天的最大消费金额，交易取消", 1, iSelect);
				return -1;
			}
		}
		else
		{
			TS_OutPutMsg(gbl.dPosInfo, "数据库操作出错，交易取消\n请稍候再试!\n 如果交易结果不明确请做 最后一笔交易查询", 1, iSelect);
			return -1;
		}
	}	
	
	//打包   
	memset(temp_buff,0,sizeof(temp_buff));
    pack.set_gbl(gbl);
	send_len = pack.Comm_Pack(flag, temp_buff);
	
	sprintf(len_buff,"%04d",send_len);
	if (send_len <=0 || send_len>1024)
	{
		wrLog("8583包打包错误\n");
		if(flag != 3)
			TS_OutPutMsg(gbl.dPosInfo,"  \n\n  8583包打包错误！\n请稍候再试!\n 如果交易结果不明确请做 最后一笔交易查询\n   按【确认】返回",0,iSelect);
		return -1;
	}
	memset(send_buff,0,sizeof(send_buff));
	CTools::hex_to_byte((BYTE *)len_buff, (BYTE *)send_buff, 4);
	memcpy(send_buff+2,temp_buff,send_len);
	send_len +=2;
	
	//插入记录
	bbzero(seq);
	i = 0;
	if(flag < 4)  //确认和冲正不写数据库，2007-3-15
	{
		CDB::setEposTxn(flag, gbl, pack, seq);
	}
	if(flag==2)
	{
	
		bbzero(gbl.order_time);
		CDB::getDBtime(gbl.order_time);
		wrLog("订单发起的时间为:%s",gbl.order_time);
	}
	wrPosLog(0, flag, gbl, pack);
	
	//上送数据包
	memset(rev_buff,0,sizeof(rev_buff));
	if(flag==2 && atoi(gbl.dPosInfo.prmVer)>=9000)
	{
		TSPosPar tsposPar;
		tsposPar.num=1;
		tsposPar.parCont[0].parId=38;
		tsposPar.parCont[0].parLen=1;
		tsposPar.parCont[0].parCont[0]=0x01;
		TS_UpdatePosPar(gbl.dPosInfo, &tsposPar);
		iRet = con.HostSendRecvData(send_buff,send_len,rev_buff,1024);
		tsposPar.parCont[0].parCont[0]=0x00;
		TS_UpdatePosPar(gbl.dPosInfo, &tsposPar);
	}
	else
	{
		if(gbl.timeout>0){
			iRet = con.HostSendRecvData(send_buff,send_len,rev_buff,1024,gbl.timeout);
			gbl.mycoolpayeasy_return=1;//为了不显示“连接超时”
		}
		else
			iRet = con.HostSendRecvData(send_buff,send_len,rev_buff,1024);
	}
	if (iRet )
	{
		if(flag != 3)
		{
			if (gbl.mycoolpayeasy_return == 0)
			{		
				
				if(flag == 2)
				{
					if(atoi(gbl.dPosInfo.prmVer)>=9000)
						
					{
						
						TS_OutPutMsg(gbl.dPosInfo,"\n连接超时！\n请使用【821】进行最后一笔交易结果查询，确认交易是否成功\n 如果成功请收费\n按【确认】返回",0,iSelect);
						
					}
					
					else
						
					{
						TS_OutPutMsg(gbl.dPosInfo,"\n连接超时,请稍后再试!",0,iSelect);
						
					}
				}
				
				else
				{
					if(atoi(gbl.dPosInfo.prmVer)>9000)
					{
						
						TS_OutPutMsg(gbl.dPosInfo,"  \n连接超时！\n\n请稍候再试!\n如果交易结果不明确请做 最后一笔交易查询\n 按【确认】返回",0,iSelect);
						
					}
					else
					{
						
						TS_OutPutMsg(gbl.dPosInfo,"\n连接超时!\n\n请稍后再试",0,iSelect);
						
					}
				}
			}			
		}
		//监控日志
		if(flag == 1 || flag == 2)	//查询、交费
			wrMonitorLog(flag, 2, iRet, gbl, pack);
		else if(flag == 3)	//签到
			wrMonitorLog(5, 2, iRet, gbl, pack);
		else if(flag == 5)	//冲正
			wrMonitorLog(3, 2, iRet, gbl, pack);
		return -2;
	}
	
	bbzero(len_buff);
	CTools::byte_to_hex((BYTE *)rev_buff, (BYTE *)len_buff, 2);
	rev_len =atol(len_buff);
	
	//解包
	if( pack.unpackFunc((BYTE *)rev_buff,rev_len) != TRUE){
		TS_OutPutMsg(gbl.dPosInfo,"  \n系统解包错误!\n请致电客服400-80-11888\n按【确认】继续\n",1,iSelect);
		return -3;
	}		
	//更新记录
	if( strcmp(seq, "") )
	{
		wrPosLog(1, flag, gbl, pack);
		if(flag == 1)
			CDB::setEposTxn(11, gbl, pack, seq);
		if(flag == 2)
		{
			CDB::setEposTxn(22, gbl, pack, seq);
			if((!memcmp((char *)pack.FIELD39, "00", 2))&& memcmp(gbl.fee_type, "0301", 4)&& memcmp(gbl.fee_type, "0302", 4)&&memcmp(gbl.fee_type, "0074", 4)&&memcmp(gbl.fee_type, "0075", 4)&&memcmp(gbl.fee_type, "0301", 4) &&memcmp(gbl.fee_type, "0302", 4) &&memcmp(gbl.fee_type, "0170", 4) &&memcmp(gbl.fee_type, "0184", 4) && memcmp(gbl.fee_type, "0083", 4) && memcmp(gbl.fee_type, "0221", 4) && memcmp(gbl.fee_type, "0109", 4) && memcmp(gbl.fee_type, "0268", 4) && memcmp(gbl.fee_type, "0339", 4) && memcmp(gbl.fee_type, "0340", 4)) 
				//如果是当日的交易则累计交易额。edit by liuxiao  订单发起的时间是当天的
				//获取这笔订单的发起时间。
			{
				char DBTime[14+1];
				bbzero(DBTime);
				CDB::getDBtime(DBTime);
				wrLog("gbl.order_time:%s",gbl.order_time);
				wrLog("DBTime:%s",DBTime);
				if(memcmp(gbl.order_time,DBTime,8)==0) //如果订单时间和数据库时间是同一天
				{
					CDB::setSumDayAmo(atoi(gbl.amount),gbl.pos_no);
					
				}
			}
		
		
		}
		if(flag == 3)
			CDB::setEposTxn(33, gbl, pack, seq);
	}
	//监控日志
	if(atoi((char *)pack.FIELD39))
		stat = 3;
	else
		stat = 0;
	if(stat == 0){
		if(pack.FIELD46[0]!=0 && pack.FIELD46[2]!=0){
			wrLog("pack.FIELD46:[%s]",pack.FIELD46);
			if(gbl.posInfo.enyFlag && pack.FIELD46[0]=='9'){
				int logonBit = getBit46((char *)pack.FIELD46);
				wrLog("logonBit:[%d]",logonBit);
				if(logonBit!=1)
					CDB::setEposLogonStatus(logonBit, gbl.pos_no);
			}
		}
	}
	
	//流水号校对
	bbzero(serial);
	CTools::byte_to_hex(pack.FIELD11, (BYTE *)serial, 3);
	if(!memcmp(gbl.pos_serial, "-", 1))	//终端流水前面为"-"号
		gbl.pos_serial[0] = '0';
	//薪加薪业务不需要校对流水号
	if (strcmp(gbl.fee_type,"0368") != 0 && strcmp(gbl.fee_type,"0056") != 0) //暂时不比较流水号
	{
		if(memcmp(gbl.pos_serial, serial, 6))
		{
			wrLog("返回流水号不匹配！");
			wrLog("serial: [%s]", serial);
			wrLog("gbl.pos_serial: [%s]", gbl.pos_serial);
			
			if(flag == 1 || flag == 2){	//查询、交费
				if(memcmp(gbl.fee_type,"0221",4))//0221:e卡农信转帐
					wrMonitorLog(flag, 2, 7, gbl, pack);
				else
					wrMonitorLog(15, 2, 7, gbl, pack);//15:e卡农信转帐
			}
			else if(flag == 3)	//签到
				wrMonitorLog(5, 2, 7, gbl, pack);
			else if(flag == 5)	//冲正
				wrMonitorLog(3, 2, 7, gbl, pack);
			
			TS_OutPutMsg(gbl.dPosInfo,"\n交易超时\n请查询最后一笔交易以确认是否成功\n   按【确认】返回",1,iSelect);
			return -1;
		}
	else{
		if(flag == 1 || flag == 2)//查询、交费
		{
			if(memcmp(gbl.fee_type,"0221",4))//0221:e卡农信转帐
			{
				wrMonitorLog(flag, stat, atoi((char *)pack.FIELD39), gbl, pack);
			}
			else
			{
				wrMonitorLog(15, stat, atoi((char *)pack.FIELD39), gbl, pack);//15:e卡农信转帐
			}
			if( atoi(gbl.dPosInfo.prmVer)>=9000 && flag == 2 && memcmp(pack.FIELD39, "00", 2)==0 )
			{
				if( gbl.posInfo.inType==(unsigned char)0x0C )
				{
					TS_OpenMnyBox(gbl.dPosInfo, "\x1B\x70\x00\x19\xFF", 5);
				}
				else
				{
					NULL;
				}
				if( memcmp(gbl.bank, "105810", 2)==0 && memcmp(gbl.fee_type, "0074", 4)!=0&& memcmp(gbl.fee_type, "0075", 4)!=0&& memcmp(gbl.fee_type, "0322", 4)!=0)
				{
					bbzero(bankamo);
					memcpy(bankamo, pack.FIELD54+1, 12);//取E卡余额
					
					
					bbzero(yjamo);
					memcpy(yjamo, pack.FIELD54+1+12, 1+12);					
					if (memcmp(yjamo,"D",1)==0)
					{
						memcpy(yjamo, "-", 1);
					}
					else
					{
						memcpy(yjamo, "0", 1);
					}
					bbzero(yjmny);					
					CTools::chgToMny(yjamo,yjmny);//取酬金
					
					char theTamo[12+1];
					bbzero(theTamo);
					memcpy(theTamo, pack.FIELD54+1+12+1+12+1, 12);
					/*
					if ( (atoi(bankamo)==0)&&(gbl.dayAmo!=0)&&(atoi(theTamo)==0)&&(atoi(yjamo)==0) )//如果三个金额全部为0则判断为子卡
					{
						bbzero(bankamo);
						sprintf(bankamo,"%012d",gbl.dayAmo-(nowAmo+atoi(gbl.amount)));
					}
					*/

                    //修改判断子卡的条件：
					if((CDB::pep_isSonCard(gbl.dPosInfo.pos_no))==1) //如果是资金池子卡
					{
	    	         	bbzero(bankamo);
						sprintf(bankamo,"%012d",gbl.dayAmo-(nowAmo+atoi(gbl.amount)));
					}
				
					else
					{
						NULL;
					}
					bbzero(mny);					
					CTools::chgToMny(bankamo,mny);
					
					bbzero(msg);
					getHeadPage(gbl.tgroup, gbl.term_level, new_message, gbl.title_flag, gbl.dPosInfo.pos_no, mny, yjmny, (char *)msg);
					TS_UpdateHeadPage(gbl.dPosInfo, msg);
				}
				else
				{
					NULL;
				}
			}
			else
			{
				NULL;
			}
		}
		else if(flag == 3)	//签到
		{
			wrMonitorLog(5, stat, atoi((char *)pack.FIELD39), gbl, pack);
		}
		else if(flag == 5)	//冲正
		{
			wrMonitorLog(3, stat, atoi((char *)pack.FIELD39), gbl, pack);
		}
		else
		{
			NULL;
		}
		return 0;
	}
}
	return 0;
}

//安全下发信息函数，2006-11-07 by lihk
int CTrade::safeOutPutMsg(char *msg, int flag)
{
	int  iRet, iSelect;
	int msgLen = strlen(msg);
	TSOutPutMsg_S outPutMsg;
	
	memset(&outPutMsg, 0, sizeof(outPutMsg));
	outPutMsg.uCardType = CARD_TYPE;	
	if(!gbl.posInfo.enyFlag){
		outPutMsg.uKeyIndex = 12;				//密钥组号12
		outPutMsg.uDesMode = TS_DES_2_DOWN;		//下发随机数加密
	}else{
		outPutMsg.uKeyIndex = TS_TEK_KEY;		//密钥TEK
		outPutMsg.uDesMode = TS_DES_3_TEK_DEC;	//加密算法
	}
	memcpy(outPutMsg.uMsgData, msg, msgLen);
	outPutMsg.uMsgDataLen = msgLen;
	iRet = TS_OutPutMsg_S(gbl.dPosInfo, &outPutMsg, flag, iSelect);
	return iSelect;
}

//有线电视，2006-11-20 by lihk
int CTrade::CATVTrade(const char *type)
{
	int iRet = selectSubcode();
	if(iRet == CANCLE_KEY)
		return CANCLE_KEY;
	else if(iRet < 0)
		return -1;
	
	iRet = CATVInqHdl(type);
	
	if(iRet==0)
	{
		iRet = CATVPayHdl(type);
	}
	return iRet;
}

//有线电视查询
//flag:默认为0，即用户手动输入查询号码
//flag为1时，先身份证，后用户手册号
int CTrade::CATVInqHdl(const char *type, int flag)
{
	int  iRet;
	int  b48_len;
	char len_buff[10];
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	
	wrLog("有线电视【查询】");
	if(!flag)
	{
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
		
		strcpy(tradeInfoSend.acMainTitle, type);
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents = 1;
		
		if(!memcmp(gbl.sub_code, "01", 2))	//用户手册 
		{
			strcpy(tradeInfoSend.Contents[0].acTitle, "请输入您的用户手册号");	
			tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
			tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
			tradeInfoSend.Contents[0].uMinLen = 8;		
			tradeInfoSend.Contents[0].uMaxLen = 11;	
			
		}
		else if(!memcmp(gbl.sub_code, "02", 2))	//身份证 
		{
			strcpy(tradeInfoSend.Contents[0].acTitle, "请输入您的身份证号码");
			tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//全字符(因身份证末尾可能有字母)
			tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME + 10;	//超时40秒
			tradeInfoSend.Contents[0].uMinLen = 15;		
			tradeInfoSend.Contents[0].uMaxLen = 18;
			
		}else if(!memcmp(gbl.sub_code, "03", 2))	//IC 
		{
			strcpy(tradeInfoSend.Contents[0].acTitle, "请输入您的IC卡号");	
			tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//数字
			tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME + 10;	//超时30秒
			tradeInfoSend.Contents[0].uMinLen = 8;		
			tradeInfoSend.Contents[0].uMaxLen = 20;	
			
		}else	//MAC
		{
			strcpy(tradeInfoSend.Contents[0].acTitle, "请输入您的MAC地址");
			tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//全字符(因身份证末尾可能有字母)
			tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME + 10;	//超时40秒
			tradeInfoSend.Contents[0].uMinLen = 12;		
			tradeInfoSend.Contents[0].uMaxLen = 12;
		}
		
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		if(iRet != 0)
		{
			wrLog("TS_TradeControl返回错误[%d]", iRet);
			wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
			return iRet;
		}
		memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));	//取得终端流水
		strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
		wrLog("终端流水：%s",gbl.pos_serial);
		
		bbzero(gbl.CATV_id_card);
		bbzero(gbl.CATV_manual_num);
		bbzero(gbl.CATV_IC_NUM);
		bbzero(gbl.CATV_MAC_NUM);
		
		if(!memcmp(gbl.sub_code, "01", 2))
			strcpy( gbl.CATV_manual_num,(char *)tradeInfoRecv.Contents[0].uMsg );
		else if(!memcmp(gbl.sub_code, "02", 2))
			strcpy( gbl.CATV_id_card,(char *)tradeInfoRecv.Contents[0].uMsg );
		else if(!memcmp(gbl.sub_code, "03", 2))
			strcpy( gbl.CATV_IC_NUM,(char *)tradeInfoRecv.Contents[0].uMsg );
		else
			strcpy( gbl.CATV_MAC_NUM,(char *)tradeInfoRecv.Contents[0].uMsg );
		wrLog("有线手册号:[%s]", gbl.CATV_manual_num);
		wrLog("有线身份证号:[%s]", gbl.CATV_id_card);
		wrLog("IC号:[%s]", gbl.CATV_IC_NUM);
		wrLog("MAC地址:[%s]", gbl.CATV_MAC_NUM);
	}
	//写查询域
	pack.wrField(1, gbl);
	/***************补充域信息*******************/
	bbzero(pack.FIELD48);  //bit48
	memcpy(pack.FIELD48, gbl.fee_type, 4);
	b48_len = 4;
	if(!flag)	//第一次直接查
	{
		bbzero(len_buff);
		sprintf(len_buff, "%02d", tradeInfoRecv.Contents[0].uMsgLen + 2);	//号码长度(2位)
		memcpy(pack.FIELD48 + b48_len, len_buff, 2);
		b48_len += 2;
		memcpy(pack.FIELD48 + b48_len, gbl.sub_code, 2);
		b48_len += 2;
		if(!memcmp(gbl.sub_code, "01", 2))
			memcpy(pack.FIELD48 + b48_len, gbl.CATV_manual_num, tradeInfoRecv.Contents[0].uMsgLen);
		else if(!memcmp(gbl.sub_code, "02", 2))
			memcpy(pack.FIELD48 + b48_len, gbl.CATV_id_card, tradeInfoRecv.Contents[0].uMsgLen);
		else if(!memcmp(gbl.sub_code, "03", 2))
			memcpy(pack.FIELD48 + b48_len, gbl.CATV_IC_NUM, tradeInfoRecv.Contents[0].uMsgLen);
		else
			memcpy(pack.FIELD48 + b48_len, gbl.CATV_MAC_NUM, tradeInfoRecv.Contents[0].uMsgLen);
		b48_len += tradeInfoRecv.Contents[0].uMsgLen;
	}
	else	//查了身份证再查手册号
	{
		bbzero(gbl.CATV_manual_num);	//用户选择的手册号
		memcpy( gbl.CATV_manual_num, gbl.Id_Detail.cnt[gbl.CATV_choice].manual_num, gbl.Id_Detail.cnt[gbl.CATV_choice].manual_num_len );
		char temp_buff[20];
		bbzero(temp_buff);
		sprintf(temp_buff,"%d",gbl.Id_Detail.cnt[gbl.CATV_choice].manual_num_len+2);
		memcpy(pack.FIELD48 + b48_len, temp_buff, 2);//号码长度
		b48_len += 2;
		bbzero(gbl.sub_code);
		strcpy(gbl.sub_code, "01");
		memcpy(pack.FIELD48 + b48_len, gbl.sub_code, 2);
		b48_len += 2;
		memcpy(pack.FIELD48 + b48_len, gbl.CATV_manual_num, gbl.Id_Detail.cnt[gbl.CATV_choice].manual_num_len);
		b48_len += gbl.Id_Detail.cnt[gbl.CATV_choice].manual_num_len;
	}
	pack.Packet_Table[48].Real_Length=b48_len;
	/*********************************************/
	//  查询包打包   
	iRet = packHdl(1);
	if(iRet < 0)
		return -1;
	//返回数据给终端
	if(!memcmp(gbl.sub_code, "01", 2)||!memcmp(gbl.sub_code, "03", 2)||!memcmp(gbl.sub_code, "04", 2))
		iRet = CATVInqMsg1();
	else
		iRet = CATVInqMsg2(type);
	return iRet;
}


//用户手册号返回结果
int CTrade::CATVInqMsg1()
{
	char response_code[3];
	int b63_len;
	char temp_buff[512],len_buff[10],mny[20],mny_r[20], total_mny[20];
	int i,j,iSelect, stat;
	char name[15], mny_type[11];
	
	memset(response_code,0,sizeof(response_code));
	memcpy(response_code,pack.FIELD39,2);
	wrLog("业务代码:[%s]",gbl.fee_type);
	b63_len = 0;
	if (!memcmp(response_code,"00",2)) 
	{
		memset(&gbl.Manual_Detail,0,sizeof(gbl.Manual_Detail) );	//初始化返回明细
		//用户地址
		bbzero(len_buff);
		memcpy(len_buff, pack.FIELD63, 2);
		b63_len += 2;
		gbl.Manual_Detail.add_len = atoi(len_buff);
		memcpy(gbl.Manual_Detail.address, pack.FIELD63 + b63_len, gbl.Manual_Detail.add_len);
		b63_len += gbl.Manual_Detail.add_len;
		wrLog("地址：%s", gbl.Manual_Detail.address);
		//卡号数
		bbzero(len_buff);	
		memcpy(len_buff, pack.FIELD63 + b63_len, 2);
		b63_len += 2;
		gbl.Manual_Detail.nCnt = atoi(len_buff);
		
		for(i = 0; i<gbl.Manual_Detail.nCnt; i++)	//取得用户卡号信息
		{
			bbzero(len_buff);	//交费卡号
			memcpy(len_buff, pack.FIELD63 + b63_len, 2);
			gbl.Manual_Detail.cnt[i].card1_len = atoi(len_buff);
			b63_len += 2;
			memcpy(gbl.Manual_Detail.cnt[i].card1, pack.FIELD63 + b63_len, gbl.Manual_Detail.cnt[i].card1_len);
			b63_len += gbl.Manual_Detail.cnt[i].card1_len;
			wrLog("卡号1[%d]：[%s]", gbl.Manual_Detail.cnt[i].card1_len, gbl.Manual_Detail.cnt[i].card1);
			
			bbzero(len_buff);	//接入号
			memcpy(len_buff, pack.FIELD63 + b63_len, 2);
			b63_len += 2;
			gbl.Manual_Detail.cnt[i].card2_len = atoi(len_buff);
			memcpy(gbl.Manual_Detail.cnt[i].card2, pack.FIELD63 + b63_len, gbl.Manual_Detail.cnt[i].card2_len);
			b63_len += gbl.Manual_Detail.cnt[i].card2_len;
			wrLog("卡号2[%d]：[%s]", gbl.Manual_Detail.cnt[i].card2_len, gbl.Manual_Detail.cnt[i].card2);
			//用户名
			memcpy(gbl.Manual_Detail.cnt[i].user_name, pack.FIELD63 + b63_len, 60);
			for (j=0;j<60;j++)
			{   
				if (gbl.Manual_Detail.cnt[i].user_name[j] == 0x20) 
				{
					gbl.Manual_Detail.cnt[i].user_name[j]='\0';
					gbl.Manual_Detail.cnt[i].user_name_len=j;
					break;
				}
			}/* end for*/
			//gbl.Manual_Detail.cnt[i].user_name_len=60;
			b63_len += 60;
			
			wrLog("用户名[%d]：%s", gbl.Manual_Detail.cnt[i].user_name_len,gbl.Manual_Detail.cnt[i].user_name);
			//应收金额
			memcpy(gbl.Manual_Detail.cnt[i].amount, pack.FIELD63 + b63_len, 12);
			b63_len += 12;
			wrLog("应收金额：%s", gbl.Manual_Detail.cnt[i].amount);
			//
			if (atoi(gbl.fee_type) != 172)
			{
				memcpy(gbl.Manual_Detail.cnt[i].remain_amount, pack.FIELD63 + b63_len, 12);
				b63_len += 12;
				wrLog("剩余预存：%s", gbl.Manual_Detail.cnt[i].remain_amount);
			}			
			// 			memcpy(gbl.Manual_Detail.cnt[i].stat, pack.FIELD63 + b63_len, 3);
			// 			b63_len += 3;
			// 			bbzero(len_buff);
			// 			memcpy(len_buff, pack.FIELD63 + b63_len, 2);
			// 			b63_len += 2;
			// 			if(atoi(len_buff))
			// 			{
			// 				memcpy(gbl.Manual_Detail.cnt[i].remark, pack.FIELD63 + b63_len, atoi(len_buff));
			// 				b63_len += atoi(len_buff);
			// 			}
			
			//珠江宽频优惠
			if(atoi(gbl.fee_type) == 172)
			{
				char remark_len[3];
				memcpy(gbl.Manual_Detail.cnt[i].stat, pack.FIELD63 + b63_len, 3);
				b63_len += 3;
				bbzero(remark_len);
				memcpy(remark_len, pack.FIELD63 + b63_len, 2);
				b63_len += 2;
				if(atoi(remark_len))
				{
					memcpy(gbl.Manual_Detail.cnt[i].remark, pack.FIELD63 + b63_len, atoi(remark_len));
					b63_len += atoi(remark_len);
				}
				wrLog("stat: [%s]", gbl.Manual_Detail.cnt[i].stat);
				wrLog("remark[%d]: [%s]", atoi(remark_len), gbl.Manual_Detail.cnt[i].remark);
			}
		}//end for
		
		bbzero(name);
		bbzero(mny_type);
		switch(atoi(gbl.fee_type))	//显示提示信息
		{
		case 100:	//月租费
			strcpy(name, "智能卡号");
			strcpy(mny_type, "待缴金额");
			break;
		case 112:
			strcpy(name, "Modem MAC地址");
			strcpy(mny_type, "待缴金额");
			break;
		case 114:
			strcpy(name, "手册号");
			strcpy(mny_type, "待缴金额");
			break;
		case 111:	//预付费
			strcpy(name, "智能卡号");
			strcpy(mny_type, "预付余额");
			break;
		case 113:
			strcpy(name, "Modem MAC地址");
			strcpy(mny_type, "预付余额");
			break;
		case 115:
			strcpy(name, "手册号");
			strcpy(mny_type, "预付余额");
			break;
        case 172:	//珠江宽频优惠
			strcpy(name, "用户手册号");
			strcpy(mny_type, "");
			break;
		}
		if(atoi(gbl.fee_type) == 172)	//珠江宽频
		{
			if( gbl.Manual_Detail.nCnt == 1 ) //只有一个卡号
			{
				j = 0;
				gbl.CATV_choice=0;
			}
			else
			{
				gbl.CATV_choice = CATVMenu(0) - 1;
				if(gbl.CATV_choice < gbl.Manual_Detail.nCnt && gbl.CATV_choice >= 0)
					j = gbl.CATV_choice;
				else
					return CANCLE_KEY;
			}
			bbzero(temp_buff);
			stat = atoi(gbl.Manual_Detail.cnt[j].stat);
			wrLog("状态号：%d,业务代码：%d",stat,atoi(gbl.fee_type));
			switch(stat)
			{
				trim(gbl.Manual_Detail.cnt[j].user_name,gbl.Manual_Detail.cnt[j].user_name_len);
			case 0:		//开通用户有欠费有优惠
			case 100:	//欠费停机有欠费有优惠
			case 110:	//欠费停机无欠费有优惠
				sprintf(temp_buff, "对不起，您不符合办理该优惠的条件，详情请咨询有线电视客服电话：969368");
				break;
			case 1:		//开通用户有欠费无优惠
				bbzero(mny);		//欠费
				bbzero(total_mny);	//缴费总额
				bbzero(gbl.amount);	//缴费总额
				CTools::chgToMny(gbl.Manual_Detail.cnt[j].amount, mny, 0);
				sprintf(gbl.amount, "%012d", atoi(gbl.Manual_Detail.cnt[j].amount)+100000);
				CTools::chgToMny(gbl.amount, total_mny, 0);
				wrLog("mny: [%s]", mny);
				wrLog("total_mny: [%s]", total_mny);
				wrLog("gbl.amount: [%s]", gbl.amount);
				sprintf(temp_buff, "用户名：%s\n用户手册号：%s\n欠费金额：%s元\n优惠包年金额：1000元\n优惠时间段：%s\n请确认缴费金额：\n欠费金额+优惠包年金额：%s元\n【确认】交费\n【返回】返回", gbl.Manual_Detail.cnt[j].user_name, gbl.Manual_Detail.cnt[j].card2, mny, gbl.Manual_Detail.cnt[j].remark, total_mny);
				break;
			case 10:	//开通用户无欠费有优惠
				bbzero(gbl.amount);
				sprintf(gbl.amount, "%012d", 100000);
				sprintf(temp_buff, "用户名：%s\n用户手册号：%s\n优惠包年金额：1000元\n优惠时间段：%s\n提示：您之前优惠还未到期，本优惠开始日期将顺延\n请确认缴费金额：\n欠费金额+优惠包年金额：1000元\n【确认】交费\n【返回】返回", gbl.Manual_Detail.cnt[j].user_name, gbl.Manual_Detail.cnt[j].card2, gbl.Manual_Detail.cnt[j].remark);
				break;
			case 11:	//开通用户无欠费无优惠
				bbzero(gbl.amount);
				sprintf(gbl.amount, "%012d", 100000);
				sprintf(temp_buff, "用户名：%s\n用户手册号：%s\n优惠包年金额：1000元\n优惠时间段：%s\n请确认缴费金额：\n欠费金额+优惠包年金额：1000元\n【确认】交费\n【返回】返回", gbl.Manual_Detail.cnt[j].user_name, gbl.Manual_Detail.cnt[j].card2, gbl.Manual_Detail.cnt[j].remark);
				break;
			case 101:	//欠费停机有欠费无优惠
				bbzero(mny);		//欠费
				bbzero(total_mny);	//缴费总额
				bbzero(gbl.amount);	//缴费总额
				CTools::chgToMny(gbl.Manual_Detail.cnt[j].amount, mny, 0);
				sprintf(gbl.amount, "%012d", atoi(gbl.Manual_Detail.cnt[j].amount)+100000);
				CTools::chgToMny(gbl.amount, total_mny, 0);
				sprintf(temp_buff, "用户名：%s\n用户手册号：%s\n优惠包年金额：1000元\n优惠时间段：%s\n提示：优惠期从欠费当月开始计算\n请确认缴费金额：\n欠费金额+优惠包年金额：%s元\n【确认】交费\n【返回】返回", gbl.Manual_Detail.cnt[j].user_name, gbl.Manual_Detail.cnt[j].card2, gbl.Manual_Detail.cnt[j].remark, total_mny);
				break;
			case 111:	//欠费停机无欠费无优惠
				bbzero(gbl.amount);
				sprintf(gbl.amount, "%012d", 100000);
				sprintf(temp_buff, "用户名：%s\n用户手册号：%s\n优惠包年金额：1000元\n优惠时间段：%s\n提示：优惠期从欠费当月开始计算\n请确认缴费金额：\n欠费金额+优惠包年金额：1000元\n【确认】交费\n【返回】返回", gbl.Manual_Detail.cnt[j].user_name, gbl.Manual_Detail.cnt[j].card2, gbl.Manual_Detail.cnt[j].remark);
				break;
			}
			TS_OutPutMsg(gbl.dPosInfo, temp_buff, 0,iSelect);
			if(stat == 0 || stat == 100 || stat == 110)
				return CANCLE_KEY;
			else
				return iSelect;
		}
		else
		{
			if( gbl.Manual_Detail.nCnt == 1 ) //只有一个卡号
			{	
				j = 0;
                gbl.CATV_choice=0;
			}
			else
			{
				gbl.CATV_choice = CATVMenu(0) - 1;
				if(gbl.CATV_choice < gbl.Manual_Detail.nCnt && gbl.CATV_choice >= 0)
					j = gbl.CATV_choice;
				else
					return CANCLE_KEY;
			}
			bbzero(gbl.amount);
			memcpy(gbl.amount, gbl.Manual_Detail.cnt[j].amount, 12);
			bbzero(mny);
			bbzero(mny_r);
			CTools::chgToMny(gbl.amount,mny);
			CTools::chgToMny(gbl.Manual_Detail.cnt[j].remain_amount,mny_r);
			bbzero(temp_buff);
			sprintf(temp_buff,"用户名：%s\n%s：%s\n地址：%s\n%s：%s\n剩余预存：%s\n【确认】交费\n【返回】返回",gbl.Manual_Detail.cnt[j].user_name, name, gbl.Manual_Detail.cnt[j].card2, gbl.Manual_Detail.address, mny_type, mny,mny_r);
			if(atoi(gbl.fee_type) == 100)
				strcat(temp_buff, "\n主机智能卡帐户已含所属副机智能卡各项费用，副机无需单独交费");
			else if(atoi(gbl.fee_type) == 112)
				strcat(temp_buff, "\n主机智能卡帐号余额已包含主机及所属副机智能卡所能使用的最大额度");				
			TS_OutPutMsg(gbl.dPosInfo, temp_buff, 0,iSelect);
			return iSelect;
		}
	}//end if(!memcmp(response_code,"00",2)) 
	else
	{
		returnFail(response_code);
		return -1;
	}
}

//用户身份证号返回结果
int CTrade::CATVInqMsg2(const char *type)
{
	char response_code[3];
	int b63_len;
	char len_buff[10];
	int i,iRet;
	
	memset(response_code,0,sizeof(response_code));
	memcpy(response_code,pack.FIELD39,2);
	wrLog("业务代码:[%s]",gbl.fee_type);
	b63_len = 0;
	if (!memcmp(response_code,"00",2)) 
	{
		memset(&gbl.Id_Detail,0,sizeof(gbl.Id_Detail) );	//初始化返回明细
		//手册号数
		bbzero(len_buff);	
		memcpy(len_buff, pack.FIELD63 + b63_len, 2);
		b63_len += 2;
		gbl.Id_Detail.nCnt = atoi(len_buff);
		
		for(i = 0; i<gbl.Id_Detail.nCnt; i++)	//取得手册号信息
		{
			//手册号
			bbzero(len_buff);	
			memcpy(len_buff, pack.FIELD63 + b63_len, 2);
			b63_len += 2;
			gbl.Id_Detail.cnt[i].manual_num_len = atoi(len_buff);
			memcpy(gbl.Id_Detail.cnt[i].manual_num, pack.FIELD63 + b63_len, gbl.Id_Detail.cnt[i].manual_num_len);
			b63_len += gbl.Id_Detail.cnt[i].manual_num_len;
			//地址长度
			bbzero(len_buff);	
			memcpy(len_buff, pack.FIELD63 + b63_len, 2);
			b63_len += 2;
			gbl.Id_Detail.cnt[i].add_len = atoi(len_buff);
			//地址
			memcpy(gbl.Id_Detail.cnt[i].address, pack.FIELD63 + b63_len, gbl.Id_Detail.cnt[i].add_len);
			b63_len += gbl.Id_Detail.cnt[i].add_len;
		}//end for
		
		gbl.CATV_choice = CATVMenu(1) - 1;
		if(gbl.CATV_choice < gbl.Id_Detail.nCnt && gbl.CATV_choice >= 0)	//用户选择其中一个手册号
		{
			iRet = CATVInqHdl(type, 1);
			return iRet;
		}
		else
			return CANCLE_KEY;
	}//end if(!memcmp(response_code,"00",2)) 
	else
	{
		returnFail(response_code);
		return -1;
	}
}


int CTrade::CATVPayHdl(const char *type)
{
	int  iRet = 0,flag;
	int  iSelect;
	int  b48_len;
	char response_code[3];
	char len_buff[10];
	int amount;
	amount = atoi(gbl.amount);
	
	wrLog("有线电视【交费】");
	//预存费
	iRet = selectAmount();
	if(iRet == CANCLE_KEY)
		return 0;
	else if(iRet < 0)
		return -1;
	if (atoi(gbl.amount)<amount)
	{
		TS_OutPutMsg(gbl.dPosInfo,"\n\n您所选择的金额不能小于欠费金额！",1,iSelect);
		return -1;
	}
	
	flag = 0;
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{
		if(!flag)
		{
			iRet = mngCard_Hdl(type);
			if(iRet == CANCLE_KEY)
				return CANCLE_KEY;
			else if(iRet != 0)
				return -1;
		}
		pack.wrField(2, gbl);	//写交费域
		/********************************/
		memset(pack.FIELD48,0,sizeof(pack.FIELD48));  //bit48
		memcpy(pack.FIELD48,gbl.fee_type,4);	//业务代码
		b48_len = 4;
		memset(len_buff,0,sizeof(len_buff));
		sprintf(len_buff,"%02d",gbl.Manual_Detail.cnt[gbl.CATV_choice].card1_len);
		memcpy(pack.FIELD48+b48_len, len_buff, 2);
		b48_len += 2;
		memcpy(pack.FIELD48+b48_len, gbl.Manual_Detail.cnt[gbl.CATV_choice].card1, gbl.Manual_Detail.cnt[gbl.CATV_choice].card1_len);
		b48_len += gbl.Manual_Detail.cnt[gbl.CATV_choice].card1_len;
		pack.Packet_Table[48].Real_Length=b48_len;
		/********************************/
		
		iRet = packHdl(2);
		if(iRet < 0)
			return -1;
		
		memset(response_code,0,sizeof(response_code));
		memcpy(response_code,pack.FIELD39,2);
		
		if (!memcmp(response_code,"00",2)) 
		{
			iRet = TS_OutPutMsg(gbl.dPosInfo,"     交费成功！\n    谢谢您的使用\n请按【确认】打印凭条",0,iSelect);
			if(iRet!=0 || iSelect==0)
			{
				CPrint prt;
				prt.set_in_par(gbl);
				switch(atoi(gbl.fee_type))
				{
				case 100:
				case 112:
				case 114:
					//prt.print_detail(5, type); //打印有线欠费明细
					prt.print_CATV_detail(pack,type);

					if( atoi(gbl.fee_type) != 112)
						TS_OutPutMsg(gbl.dPosInfo," \n如果您已办理珠江宽频宽带上网业务并已欠费，可返回继续缴费",0,iSelect);
					break;
					
					// 				case 111:
					// 				case 113:
					// 				case 115:
					// 					prt.print_detail(2, type);	 //打印预付费明细
					// 					if( atoi(gbl.fee_type) == 113)
					// 						TS_OutPutMsg(gbl.dPosInfo," \n如果您的有线电视（或珠江数码）帐户欠费，您将无法正常使用珠江宽频业务，可返回继续预存有线电视（或珠江数码）的费用",0,iSelect);
					// 					break;
                case 172:	//珠江宽频优惠
					//prt.print_detail(11, type);
					prt.print_CATVDiscount_detail(pack,type);
					break;
				}
			}
			return 0;
			//return ysqHdl();//预授权入口
		}
		else if(!memcmp(response_code,"55",2))
		{
			flag = 1;
			if(reGetPwd( type) == 0) //密码错误，重新输入密码, 2006-10-25
				continue;
			else
				return CANCLE_KEY;
		}
		else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
			if (iSelect!=0)
			{
				return -1;
			}else
				continue;
		}
		else
		{
			returnFail(response_code);
			return -1;
		}
	}
	return -1;
}

//根据返回的手册号或卡号显示菜单
int CTrade::CATVMenu(int flag)
{
	int j,iSelect, iRet;
	TSMENULIST menuList;
	memset(&menuList, 0, sizeof(menuList));
	if(flag == 0)
	{
		menuList.iTotalNum = gbl.Manual_Detail.nCnt;
		strcpy(menuList.acTitle, "请选择卡号:");
		for(j=0; j<menuList.iTotalNum; j++)
			strcpy(menuList.menuItem[j], gbl.Manual_Detail.cnt[j].card2);
		iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
		if(iRet)
			return -1;
		if( (iSelect > 0) && (iSelect < menuList.iTotalNum +1) )
			return iSelect;
		else
			return CANCLE_KEY;
	}
	else
	{
		menuList.iTotalNum = gbl.Id_Detail.nCnt;
		strcpy(menuList.acTitle, "请选择手册号:");
		for(j=0; j<menuList.iTotalNum; j++)
			strcpy(menuList.menuItem[j], gbl.Id_Detail.cnt[j].manual_num);
		iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
		
		if(iRet)
			return -1;
		if( (iSelect > 0) && (iSelect < menuList.iTotalNum +1) )
			return iSelect;
		else
			return CANCLE_KEY;
	}
	
}


//2007-4-23，picc业务
int CTrade::piccTrade()
{
	int  iRet, iSelect, flag = 0;
	int  b48_len, b63_len;
	char tmp[512], car_info[25], type[20], rsp_code[3];
	char car_type[5], id_card[19], car_no[9], phone[12];
	
	wrLog("【PICC家用车车强险】");
	strcpy(gbl.fee_type, "0081");
	strcpy(type, "PICC家用车车强险");
	
	iRet = selectAmount();
	if(iRet == CANCLE_KEY)
		return CANCLE_KEY;
	else if(iRet < 0)
		return -1;
	else if(iRet == 1)
	{
		strcpy(car_type, "0101");
		strcpy(car_info, "6座以下保费950元");
		strcpy(gbl.amount, "000000095000");
	}
	else if(iRet == 2)
	{
		strcpy(car_type, "0102");
		strcpy(car_info, "6座及以上保费1,100元");
		strcpy(gbl.amount, "000000110000");
	}
	
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, "投保信息,参照行驶证");
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 3;
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "输入被保险人(车主)身份证号码");	
	tradeInfoSend.Contents[0].uMinLen = 15;		
	tradeInfoSend.Contents[0].uMaxLen = 18;
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//数字
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME + 10;	//超时40秒
	
	strcpy(tradeInfoSend.Contents[1].acTitle, "输入车牌号码(粤A)");	
	tradeInfoSend.Contents[1].uMinLen = 5;		
	tradeInfoSend.Contents[1].uMaxLen = 5;
	tradeInfoSend.Contents[1].uCommand = TS_INPUT_ALL_CHAR;	//全字符
	tradeInfoSend.Contents[1].uTimeOut = EPOS_OVER_TIME+20;	//超时30秒
	
	strcpy(tradeInfoSend.Contents[2].acTitle, "输入小灵通或手机号码");	
	tradeInfoSend.Contents[2].uMinLen = 8;		
	tradeInfoSend.Contents[2].uMaxLen = 11;
	tradeInfoSend.Contents[2].uCommand = TS_INPUT_MATH;	//数字
	tradeInfoSend.Contents[2].uTimeOut = EPOS_OVER_TIME;	//超时30秒
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
	strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
	strcpy(car_no, "粤A");
	strcpy(id_card, (char *)tradeInfoRecv.Contents[0].uMsg);
	strcat(car_no, (char *)tradeInfoRecv.Contents[1].uMsg);
	strcpy(phone, (char *)tradeInfoRecv.Contents[2].uMsg);
	
	for(int i = 3; i < 8; i++)	//小写转换成大写
	{
		if((car_no[i] >= 97) && (car_no[i] <= 122) )
			car_no[i] = car_no[i] - 32; 
	}
	wrLog("car no: [%s]", car_no);
	bbzero(tmp);
	sprintf(tmp, "   请确认投保信息\n%s\n被保险人(车主)身份证号码：\n%s\n车牌号码：%s\n小灵通或手机号码：\n%s\n按【确认】交费", car_info, id_card, car_no, phone);
	TS_OutPutMsg(gbl.dPosInfo, tmp, 0, iSelect);
	if( iSelect )
		return -1;
	flag = 0;
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{
		if(!flag)
		{
			iRet = mngCard_Hdl(type);
			if(iRet == CANCLE_KEY)
				return CANCLE_KEY;
			else if(iRet != 0)
				return -1;
		}
		pack.wrField(2, gbl);	//写交费域
		/***************修改一些域****************/
		bbzero(pack.FIELD48);
		memcpy(pack.FIELD48,gbl.fee_type,4);
		b48_len = 4;
		sprintf((char *)pack.FIELD48 + b48_len, "%02d", strlen(id_card));	//身份证号长度
		b48_len += 2;
		memcpy(pack.FIELD48 + b48_len, id_card, strlen(id_card));
		b48_len += strlen(id_card);
		pack.Packet_Table[48].Real_Length=b48_len;
		
		bbzero(pack.FIELD63);
		if( gbl.key_num % 2 )	//奇数key
			memcpy(pack.FIELD63, gbl.random_num, 8);
		else
			memcpy(pack.FIELD63, "00000000", 8);
		b63_len = 8;
		memcpy(pack.FIELD63+b63_len, car_type, 4);
		b63_len += 4;
		sprintf((char *)pack.FIELD63+b63_len, "%02d", strlen(phone));
		b63_len += 2;
		memcpy(pack.FIELD63+b63_len, phone, strlen(phone));
		b63_len += strlen(phone);
		sprintf((char *)pack.FIELD63+b63_len, "%02d", strlen(car_no));
		b63_len += 2;
		memcpy(pack.FIELD63+b63_len, car_no, strlen(car_no));
		b63_len += strlen(car_no);
		pack.Packet_Table[63].Real_Length=b63_len;
		/*****************************************/
		
		iRet = packHdl(2);
		if(iRet < 0)
			return -1;
		
		bbzero(rsp_code);
		memcpy(rsp_code,pack.FIELD39,2);
		if (!atoi(rsp_code) ) 
		{
			iRet = TS_OutPutMsg(gbl.dPosInfo,"     交费成功！\n    谢谢您的使用\n请按【确认】打印发票",0,iSelect);
			if(iRet!=0 || iSelect==0)
			{
				strcpy(gbl.CATV_id_card, id_card);
				strcpy(gbl.phone_no, phone);
				strcpy(gbl.car_no, car_no);
				CPrint prt;
				prt.set_in_par(gbl);
				if( atoi(car_type) == 101 )
					//prt.print_detail(6, "PICC保险（家用车车强险6座以下）");	//打印picc明细
					prt.print_PICC_detail(pack,"PICC保险（家用车车强险6座以下）");
				else
				//	prt.print_detail(6, "PICC保险（家用车车强险6座及以上）");	//打印picc明细
					prt.print_PICC_detail(pack,"PICC保险（家用车车强险6座及以上）");
			}
			return 0;
		}
		else if(atoi(rsp_code)==55)
		{
			flag = 1;
			if(reGetPwd( type) == 0) //密码错误，重新输入密码, 2006-10-25
				continue;
			else
				return CANCLE_KEY;
		}
		else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
			if (iSelect!=0)
			{
				return -1;
			}else
				continue;
		}
		else{
			returnFail(rsp_code);
			return -1;
		}
	}
	return -1;
}


//全省综合收费交易
int CTrade::foshanTrade(const char *title, const char* city_no)		
{
	wrLog("gbl.city_no:%s", gbl.city_no);
	wrLog("city_no:%s", city_no);
	int iRet=0;
	
	if(strlen(city_no) < 3)
		iRet = get_area_biz(BIZ_AREA_BIZ_INTEGRATED, gbl.city_no, gbl.acc_city_no, gbl.fee_type);
	else
		iRet = get_area_biz(BIZ_AREA_BIZ_INTEGRATED, (char*)city_no, gbl.acc_city_no, gbl.fee_type);
	
	if( iRet==0 )
	{
		wrLog("gbl.fee_type = [%s]", gbl.fee_type);
	}
	else
	{
		return -1;
	}
	
	iRet = foshanInqHdl(title, city_no);
	if(iRet==0)
		iRet = foshanPayHdl(title);
	return iRet;
}

//全省综合收费查询
int CTrade::foshanInqHdl(const char *title, const char *city_no)	
{
	int  iRet=0, iSelect=0;
	int  b48_len;
	char  phone_no[20+1];	
	
	wrLog("全省综合收费【查询】");	
	
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	bbzero(phone_no);
	
	strcpy(tradeInfoSend.acMainTitle, title);
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入电话或ADSL号码");	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//全字符
	tradeInfoSend.Contents[0].uCount = 0;		//输入1次		
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
	tradeInfoSend.Contents[0].uMinLen = 7;		
	tradeInfoSend.Contents[0].uMaxLen = 20;
	//tradeInfoSend.Contents[0].uMaxLen = 16;
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	} 
	
	bbzero( gbl.pos_serial );
	strcpy( gbl.pos_serial, (char *)tradeInfoRecv.uTradeID );
	bbzero( gbl.phone_no );
	strcpy( gbl.phone_no, (char *)tradeInfoRecv.Contents[0].uMsg );
	CTools::lowerToUpper( gbl.phone_no );
	
	wrLog("该地区固话区号【%s】",gbl.city_no);
	
	if(gbl.phone_no[0]=='0' && strlen(gbl.phone_no) > 9)//如果输了区号，暂时屏蔽：不允许跨区交费
	{
		TS_OutPutMsg(gbl.dPosInfo, "\n输入有误，请不要输入区号", 1, iSelect);
		return -1;
	}
	
	if(!strcmp(gbl.city_no, "0756"))	//珠海后付费
	{
		bbzero(phone_no);
		strcpy(phone_no, gbl.phone_no);
		bbzero(gbl.phone_no);
		strcpy(gbl.phone_no, gbl.city_no);
		strcat(gbl.phone_no, phone_no);
		strcpy(gbl.fee_type,"0310");
	}
	else if(strcmp(gbl.city_no, "0757")==0)//如果是佛山的终端
	{
		strcpy(gbl.fee_type,"0092");//佛山
		bbzero(phone_no);
		strcpy(phone_no, gbl.phone_no);
		bbzero(gbl.phone_no);
		strcpy(gbl.phone_no, gbl.city_no);
		strcat(gbl.phone_no, phone_no);
	}
	else if(strcmp(gbl.city_no, "020")==0)//如果是广州的终端
	{
		gbl.phone_len = strlen(gbl.phone_no);
		strcpy(gbl.fee_type,"0047");
		telTrade("固话+ADSL网费", 1);//走广州
		return CANCLE_KEY;
	}
	else
	{
		bbzero(phone_no);
		strcpy(phone_no, gbl.phone_no);
		bbzero(gbl.phone_no);
		if(strlen(city_no) < 3)
		{
			strcpy(gbl.phone_no, gbl.city_no);
		}
		else 
		{
			strcpy(gbl.phone_no, gbl.city_no);
		}
		strcat(gbl.phone_no, phone_no);
		if(strcmp(gbl.city_no, "0756")==0)
			strcpy(gbl.fee_type,"0310");//珠海电信后付费
		//else
		//strcpy(gbl.fee_type,"0210");//全省
	}
	/*	
	if(memcmp(gbl.phone_no, "0757", 4)==0)//如果输入佛山的区号
	{
	bbzero(phone_no);
	strcpy(phone_no, gbl.phone_no+4);//去除区号
	strcpy(gbl.phone_no, phone_no);
	strcpy(gbl.fee_type,"0092");//佛山
	}
	else if(memcmp(gbl.phone_no, "020", 3)==0)//如果输入广州的区号
	{
	bbzero(phone_no);
	strcpy(phone_no, gbl.phone_no+3);//去除区号
	strcpy(gbl.phone_no, phone_no);
	gbl.phone_len = strlen(gbl.phone_no);
	strcpy(gbl.fee_type,"0047");
	telTrade("固话+ADSL网费", 1);//走广州
	return CANCLE_KEY;
	}
	else if(gbl.phone_no[0]!='0')//如果没输入区号
	{
	if(strcmp(gbl.city_no, "0757")==0)//如果是佛山的终端
	{
	strcpy(gbl.fee_type,"0092");//佛山
	}
	else if(strcmp(gbl.city_no, "020")==0)//如果是广州的终端
	{
	gbl.phone_len = strlen(gbl.phone_no);
	strcpy(gbl.fee_type,"0047");
	telTrade("固话+ADSL网费", 1);//走广州
	return CANCLE_KEY;
	}
	else//否则补上区号
	{
	bbzero(phone_no);
	strcpy(phone_no, gbl.phone_no);
	bbzero(gbl.phone_no);
	strcpy(gbl.phone_no, gbl.city_no);
	strcat(gbl.phone_no, phone_no);
	if(strcmp(gbl.city_no, "0756")==0)
	strcpy(gbl.fee_type,"0310");//珠海电信后付费
	else
	strcpy(gbl.fee_type,"0210");//全省
	}
	}else if(strcmp(gbl.city_no, "0756")==0){
	strcpy(gbl.fee_type,"0310");//珠海电信后付费
	}
	else//输了区号，但不是佛山、珠海或广州的
	{
	strcpy(gbl.fee_type,"0210");//全省
	}
	*/
	gbl.phone_len = strlen(gbl.phone_no);
	wrLog("phone[%d]: [%s]", gbl.phone_len, gbl.phone_no);
	
	/*---------------------------------------*/
	
	//写查询域
	pack.wrField(1, gbl);
	/************修改一些域*********/
	bbzero(pack.FIELD48);
	b48_len = 0;
	memcpy(pack.FIELD48+b48_len, gbl.fee_type, 4);
	b48_len += 4;
	sprintf((char *)pack.FIELD48+b48_len, "%02d", gbl.phone_len);
	b48_len += 2;
	memcpy(pack.FIELD48+b48_len, gbl.phone_no, gbl.phone_len);
	b48_len += gbl.phone_len;
	pack.Packet_Table[48].Real_Length = b48_len;
	/*******************************/
	
	//  查询包打包   
	iRet = packHdl(1);
	if(iRet < 0)
		return -1;
	//返回终端数据
	iRet =  foshanInqMsg();
	return iRet;
}

//全省综合收费下传信息
int CTrade::foshanInqMsg()	
{
	char temp_buff[512], amoMny[13];
	char response_code[3], mny[20][MAXAMOLEN], tal[6][20];
	int iSelect, k, j;
	
	memset(response_code,0,sizeof(response_code));
	memcpy(response_code,pack.FIELD39,2);
	
	if (!memcmp(response_code,"00",2)) 
	{
		if( foshanRdField63() )	//保留查询返回信息供打印和显示信息用
		{
			TS_OutPutMsg(gbl.dPosInfo,"您输入的号码欠费月过多！",1,iSelect);
			return -1;
		}
		memset(gbl.amount,0,sizeof(gbl.amount));
		CTools::byte_to_hex(pack.FIELD4, (BYTE *)gbl.amount, 6);
		memset(amoMny,0,sizeof(amoMny));
		CTools::chgToMny(gbl.amount,amoMny);	
		
		//获取合计金额
		memset(tal,0,sizeof(tal));
		for(j=0; j<gbl.detail.nMonCnt; j++)
		{
			memset(mny,0,sizeof(mny));
			for(k=0; k<gbl.detail.monDetail[j].nCnt; k++)
				strcpy(mny[k], gbl.detail.monDetail[j].cnt[k].amo);
			CTools::getTalAmo(mny, tal[j], gbl.detail.monDetail[j].nCnt);	
			strcat(tal[j], "元");
			wrLog("tal[%d]: [%s]", j, tal[j]);
		}
		
		sprintf(temp_buff,"用户名：%s\n电话号码：%s\n总交费金额：%s\n", gbl.user_name, gbl.phone_no, amoMny);
		
		for(j=0; j<gbl.detail.nMonCnt; j++)
		{
			// 			strcat(temp_buff, gbl.detail.monDetail[j].tmFrom);
			// 			strcat(temp_buff, "到");
			// 			strcat(temp_buff, gbl.detail.monDetail[j].tmTo);
			strcat(temp_buff, gbl.detail.monDetail[j].month);
			strcat(temp_buff, "：");
			strcat(temp_buff, tal[j]);
			strcat(temp_buff, "\n");
		}
		
		strcat(temp_buff, "【确认】交费\n【返回】返回");
		if(TS_OutPutMsg(gbl.dPosInfo, temp_buff, 0, iSelect) == -2)
		{
			sprintf(temp_buff,"用户名：%s\n电话号码：%s\n总交费金额：%s\n", gbl.user_name, gbl.phone_no, amoMny);
			TS_OutPutMsg(gbl.dPosInfo, temp_buff, 0, iSelect);
			return -1;
		}
		return iSelect;
	}//end if (!memcmp(response_code,"00",2)) 
	else
	{
		returnFail(response_code);
		return -1;
	}
}

//全省综合收费交费
int CTrade::foshanPayHdl(const char *title)	
{
	int  iRet, iSelect, flag;
	int  b48_len;
	char response_code[3];
	
	//////////////////////////////////////////////////////////////////////////
	if( atoi(gbl.dPosInfo.prmVer)>=9000 && ( strstr(CT10000_TERM, "00000000")!=NULL || strstr(CT10000_TERM, gbl.pos_no)!=NULL ) )
	{
		iRet = payModeSelect(title, gbl.fee_type, gbl.amount, gbl.city_no, gbl.phone_no);
		if(iRet==0)
		{
			NULL;
		}
		else
		{
			return 0;
		}
	}
	// 	else if( atoi(gbl.dPosInfo.prmVer)>=9000 && strcmp(gbl.city_no, "020")!=0 && strcmp(gbl.city_no, "0756")!=0)//如果不是广州且不是EPOS		
	// 	{
	// 		TS_OutPutMsg(gbl.dPosInfo, "暂未开通直接方式缴费\n\n请使用电信充值付费卡", 1, iSelect);
	// 		strcpy(gbl.fee_type,"0089");
	// 		strcpy(gbl.sell_card_type, "040");
	// 		sellCardTrade("电信充值付费业务");
	// 		return -1;
	// 	}
	//////////////////////////////////////////////////////////////////////////
	
	wrLog("全省综合收费【交费】");
	/************刷卡****************/
	flag = 0;
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{
		if(!flag)
		{
			iRet = mngCard_Hdl(title);
			if(iRet == CANCLE_KEY)
				return CANCLE_KEY;
			else if(iRet != 0)
				return -1;
		}
		pack.wrField(2, gbl);	//写交费域
		/**************修改一些域**************/
		bbzero(pack.FIELD48);
		memcpy(pack.FIELD48,gbl.fee_type,4);
		b48_len =4;
		sprintf((char *)pack.FIELD48+b48_len, "%02d", gbl.phone_len);
		b48_len +=2;
		memcpy(pack.FIELD48+b48_len,gbl.phone_no, gbl.phone_len);
		b48_len +=gbl.phone_len;
		pack.Packet_Table[48].Real_Length=b48_len;
		/**************************************/
		//交费包
		iRet = packHdl(2);
		if(iRet < 0)
			return -1;
		
		memset(response_code,0,sizeof(response_code));
		memcpy(response_code,pack.FIELD39,2);
		if (!memcmp(response_code,"00",2)) 
		{
			iRet = TS_OutPutMsg(gbl.dPosInfo,"     交费成功！\n    谢谢您的使用\n请按【确认】打印发票",0,iSelect);
			if(iRet!=0 || iSelect==0)
			{
				CPrint prt;
				prt.set_in_par(gbl,pack);
				prt.print_detail(1, title);
				//prt.print_pym_detail(pack,title);
			}
			return 0;
		}
		else if(!memcmp(response_code,"55",2))
		{
			flag = 1;
			if(reGetPwd( title) == 0) //密码错误，重新输入密码, 2006-10-25
				continue;
			else
				return CANCLE_KEY;
		}
		else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
			if (iSelect!=0)
			{
				return -1;
			}else
				continue;
		}
		else
			returnFail(response_code);
		return 1;	
	}
	return -1;
}

int CTrade::foshanRdField63()
{
	char temp[20];
	int count=0, len, i, j;
	
	//wrLog("BIT63:[%s]", pack.FIELD63);
	memset(&gbl.detail,0,sizeof(gbl.detail) );	//准备写入明细
	//用户名
	sscanf((char *)pack.FIELD63, "%02d", &gbl.user_name_len);
	count += 2;
	bbzero(gbl.user_name);
	memcpy(gbl.user_name, (char *)pack.FIELD63 + count, gbl.user_name_len);
	count += gbl.user_name_len;
	//交费月数
	sscanf((char *)pack.FIELD63+count, "%01d", &gbl.detail.nMonCnt);
	count+=1;
	wrLog("交费月份数：%d", gbl.detail.nMonCnt);
	if(gbl.detail.nMonCnt > 6)
	{
		//欠费月过多
		return -1;
	}
	for(i=0; i<gbl.detail.nMonCnt; i++)		
	{
		memcpy(gbl.detail.monDetail[i].tmFrom, (char *)(pack.FIELD63+count), 4);
		memcpy(gbl.detail.monDetail[i].month,gbl.detail.monDetail[i].tmFrom, 4);
		count+=4;
		strcat(gbl.detail.monDetail[i].tmFrom,"年");
		strncat(gbl.detail.monDetail[i].tmFrom,(char *)(pack.FIELD63+count),2);
		strncat(gbl.detail.monDetail[i].month,(char *)(pack.FIELD63+count), 2);
		count+=2;
		strcat(gbl.detail.monDetail[i].tmFrom,"月");
		strncat(gbl.detail.monDetail[i].tmFrom,(char *)(pack.FIELD63+count),2);
		count+=2;
		strcat(gbl.detail.monDetail[i].tmFrom,"日");
		memcpy(gbl.detail.monDetail[i].tmTo,(char *)(pack.FIELD63+count),4);
		count+=4;
		strcat(gbl.detail.monDetail[i].tmTo,"年");
		strncat(gbl.detail.monDetail[i].tmTo,(char *)(pack.FIELD63+count),2);
		count+=2;
		strcat(gbl.detail.monDetail[i].tmTo,"月");
		strncat(gbl.detail.monDetail[i].tmTo,(char *)(pack.FIELD63+count),2);
		count+=2;
		strcat(gbl.detail.monDetail[i].tmTo,"日");
		
		wrLog("交费月：[%s - %s]",gbl.detail.monDetail[i].tmFrom,gbl.detail.monDetail[i].tmTo);
		//获取当前交费时段明细长度（3位）
		sscanf((char *)(pack.FIELD63+count), "%03d", &len);
		count += 3;
		j=0;	//明细计数器
		while(len>0)
		{
			if(len > 512)
				return -1;
			memset(temp,0,sizeof(temp));
			memcpy(temp,(char *)(pack.FIELD63+count),2);	//明细标识码
			count+=2;
			len-=2;
			if( !strncmp(temp,"99",2) )		//获得交费条目名
			{
				memcpy(gbl.detail.monDetail[i].cnt[j].type,(char *)(pack.FIELD63+count),12);
				count+=12;
				len-=12;
			}
			else
				foshanCkCode(atoi(temp), gbl.detail.monDetail[i].cnt[j].type);
			
			memset(temp,0,sizeof(temp));
			memcpy(temp,(char *)(pack.FIELD63+count),6);	//明细金额（6位）
			CTools::chgToMny(temp,gbl.detail.monDetail[i].cnt[j].amo , 0);		//转换为浮点数字符串
			count+=6;
			len-=6;
			
			//		wrLog("条目%d：%s",j, gbl.detail.monDetail[i].cnt[j].type);
			//		wrLog("金额：%s",temp);
			
			j++;
		}
		gbl.detail.monDetail[i].nCnt = j;
	}
	return 0;
}

int CTrade::DZDBRdField63()
{
	char temp[20];
	int count=0, len, i, j;
	
	//wrLog("BIT63:[%s]", pack.FIELD63);
	memset(&gbl.detail,0,sizeof(gbl.detail) );	//准备写入明细
	//用户名
	sscanf((char *)pack.FIELD63, "%02d", &gbl.user_name_len);
	count += 2;
	bbzero(gbl.user_name);
	memcpy(gbl.user_name, (char *)pack.FIELD63 + count, gbl.user_name_len);
	count += gbl.user_name_len;
	//交费月数
	sscanf((char *)pack.FIELD63+count, "%01d", &gbl.detail.nMonCnt);
	count+=1;
	wrLog("交费月份数：%d", gbl.detail.nMonCnt);
	if(gbl.detail.nMonCnt > 6)
	{
		//欠费过多
		return -1;
	}
	for(i=0; i<gbl.detail.nMonCnt; i++)		
	{
		memcpy(gbl.detail.monDetail[i].tmFrom, (char *)(pack.FIELD63+count), 4);
		count+=4;
		strcat(gbl.detail.monDetail[i].tmFrom,"年");
		strncat(gbl.detail.monDetail[i].tmFrom,(char *)(pack.FIELD63+count),2);
		count+=2;
		strcat(gbl.detail.monDetail[i].tmFrom,"月");
		strncat(gbl.detail.monDetail[i].tmFrom,(char *)(pack.FIELD63+count),2);
		count+=2;
		strcat(gbl.detail.monDetail[i].tmFrom,"日");
		
		memcpy(gbl.detail.monDetail[i].tmTo,(char *)(pack.FIELD63+count),4);
		count+=4;
		strcat(gbl.detail.monDetail[i].tmTo,"年");
		strncat(gbl.detail.monDetail[i].tmTo,(char *)(pack.FIELD63+count),2);
		count+=2;
		strcat(gbl.detail.monDetail[i].tmTo,"月");
		strncat(gbl.detail.monDetail[i].tmTo,(char *)(pack.FIELD63+count),2);
		count+=2;
		strcat(gbl.detail.monDetail[i].tmTo,"日");
		
		wrLog("交费月：[%s - %s]",gbl.detail.monDetail[i].tmFrom,gbl.detail.monDetail[i].tmTo);
		//获取当前交费时段明细长度（3位）
		sscanf((char *)(pack.FIELD63+count), "%03d", &len);
		count += 3;
		j=0;	//明细计数器
		while(len>0)
		{
			if(len > 512)
				return -1;
			memset(temp,0,sizeof(temp));
			memcpy(temp,(char *)(pack.FIELD63+count),2);	//明细标识码
			count+=2;
			len-=2;
			if( !strncmp(temp,"99",2) )		//获得交费条目名
			{
				memcpy(gbl.detail.monDetail[i].cnt[j].type,(char *)(pack.FIELD63+count),12);
				count+=12;
				len-=12;
			}
			else
				foshanCkCode(atoi(temp), gbl.detail.monDetail[i].cnt[j].type);
			
			memset(temp,0,sizeof(temp));
			memcpy(temp,(char *)(pack.FIELD63+count),8);	//明细金额（6位）
			CTools::chgToMny(temp,gbl.detail.monDetail[i].cnt[j].amo , 0);		//转换为浮点数字符串
			count+=8;
			len-=8;
			
			//		wrLog("条目%d：%s",j, gbl.detail.monDetail[i].cnt[j].type);
			//		wrLog("金额：%s",temp);
			
			j++;
		}
		gbl.detail.monDetail[i].nCnt = j;
	}
	return 0;
}

//获取佛山明细项名
void CTrade::foshanCkCode(int code, char *type)
{
	switch(code)
	{
	case 1:
		strcpy(type, "基本月租");
		break;
	case 2:
		strcpy(type, "功能月租");
		break;
	case 3:
		strcpy(type, "短信费");
		break;
	case 4:
		strcpy(type, "本地话费");
		break;
	case 5:
		strcpy(type, "电信IP长途费");
		break;
	case 6:
		strcpy(type, "96688长话费");
		break;
	case 9:
		strcpy(type, "家家乐补退");
		break;
	case 11:
		strcpy(type, "区内通话费");
		break;
	case 12:
		strcpy(type, "区间通话费");
		break;
	case 13:
		strcpy(type, "特号通话费");
		break;
	case 21:
		strcpy(type, "国内长话费");
		break;
	case 22:
		strcpy(type, "国际港澳台话费");
		break;
	case 23:
		strcpy(type, "手机IP长话费");
		break;
	case 28:
		strcpy(type, "非电信IP本地话费");
		break;
	case 31:
		strcpy(type, "电报业务费");
		break;
	case 32:
		strcpy(type, "分组交换业务费");
		break;
	case 33:
		strcpy(type, "DDN业务费");
		break;
	case 41:
		strcpy(type, "因特网网络使用费");
		break;
	case 42:
		strcpy(type, "拨号上网通信费");
		break;
	case 43:
		strcpy(type, "宽带业务费");
		break;
	case 44:
		strcpy(type, "电路月租");
		break;
	case 45:
		strcpy(type, "中继线月租");
		break;
	case 46:
		strcpy(type, "帧中继月租");
		break;
	case 47:
		strcpy(type, "ATM使用费");
		break;
	case 51:
		strcpy(type, "代维费");
		break;
	case 52:
		strcpy(type, "800业务费");
		break;
	case 53:
		strcpy(type, "信息费");
		break;
	case 54:
		strcpy(type, "补收补退费");
		break;
	case 55:
		strcpy(type, "公话代办费");
		break;
	case 61:
		strcpy(type, "公话税金");
		break;
	case 62:
		strcpy(type, "鸿联信息费");
		break;
	case 63:
		strcpy(type, "南方信息费");
		break;
	case 64:
		strcpy(type, "诚立信息费");
		break;
	case 65:
		strcpy(type, "神州在线网络使用费");
		break;
	case 71:
		strcpy(type, "小灵通套餐实际话费");
		break;
	case 72:
		strcpy(type, "小灵通套餐优惠");
		break;
	case 73:
		strcpy(type, "小灵通套餐封顶费");
		break;
	case 74:
		strcpy(type, "小灵通套餐超封顶费");
		break;
	case 75:
		strcpy(type, "小灵通套餐包月费");
		break;
	case 76:
		strcpy(type, "合家欢包月费");
		break;
	case 81:
		strcpy(type, "租金");
		break;
	case 82:
		strcpy(type, "分期付款");
		break;
	case 85:
		strcpy(type, "开户调测工料费");
		break;
	case 86:
		strcpy(type, "下月退费");
		break;
	case 87:
		strcpy(type, "预付金");
		break;
	case 88:
		strcpy(type, "退现");
		break;
	case 89:
		strcpy(type, "本次零头");
		break;
	case 90:
		strcpy(type, "其他费");
		break;
	case 91:
		strcpy(type, "折扣补退");
		break;
	case 92:
		strcpy(type, "违约金");
		break;
	case 93:
		strcpy(type, "预付金存取");
		break;
	case 94:
		strcpy(type, "减免话费");
		break;
	case 95:
		strcpy(type, "上次零头");
		break;
	case 96:
		strcpy(type, "减免违约金");
		break;
	case 97:
		strcpy(type, "使用退费预付金");
		break;
	case 98:
		strcpy(type, "合家欢包月补退");
		break;
	default:
		strcpy(type, "其他");
		break;
	}
}


//商户查询交易
//inqFlag: 1, 日交易查询
//         2, 上月交易查询
//         3, 最后一笔交易查询(不含移动)
//         4, 本月交易查询
//         5, 东莞交罚日查询
//         6, 东莞交罚月查询
//         7, 东莞日交易查询
//         8, 东莞月交易查询
//         9, 移动版最后一笔交易查询
int CTrade::merInqTrade(int inqFlag)
{
	int iRet=0;
	
	wrLog("【商户交易查询：%d】", inqFlag);
	
	if(inqFlag==2 || inqFlag==4)
	{
		if(atoi(gbl.dPosInfo.prmVer)>=9000)
		{
			iRet = checkPEPwd_Hdl("修改交易密码");
			if(iRet!=0)
				if(iRet==CANCLE_KEY)
					return CANCLE_KEY;
				else
				{	
					info("老板密码校验错误\n\n请联系在线客服中心【Ctrl+H】  400-80-11888\n\n按【Enter】确认返回主菜单。");
					return iRet;
					
				}
		}
	}
	else
	{
		NULL;
	}
	
	iRet = merInqTrade_inq(inqFlag);

	wrLog("iRet = %d",iRet);
	//返回数据给终端
	if(iRet==0)
		
		iRet = merInqTrade_msg(inqFlag);
	
	return iRet;
}

//inqFlag: 1, 日交易查询
//         2, 月交易查询
//         3, 最后一笔交易查询
//         4, 本月交易查询
//         5, 东莞交罚日查询
//         6, 东莞交罚月查询
//         7, 东莞日交易查询
//         8, 东莞月交易查询
//         9, 移动版最后一笔交易查询
int CTrade::merInqTrade_inq(int inqFlag)
{
	int iRet, flag, b48_len, b63_len;
	char title[30], date8[9];
	
	bbzero(title);
	if(inqFlag == 1)
	{
		strcpy(gbl.fee_type, "0145");
		strcpy(title, "日交易查询");
	}
	else if(inqFlag == 2)
	{
		strcpy(gbl.fee_type, "0146");
		strcpy(title, "上月交易查询");
	}
	else if(inqFlag == 3)
	{//无限制版最后一笔交易查询
		strcpy(gbl.fee_type, "0144");
		strcpy(title, "最后一笔交易查询");
	}
	else if(inqFlag == 4)
	{
		strcpy(gbl.fee_type, "0146");
		strcpy(title, "本月交易查询");
	}
	else if(inqFlag == 5)
	{
		strcpy(gbl.fee_type, "0235");
		strcpy(title, "东莞交罚日查询");
	}
	else if(inqFlag == 6)
	{
		strcpy(gbl.fee_type, "0236");
		strcpy(title, "东莞交罚月查询");
	}
	else if(inqFlag == 7)
	{
		strcpy(gbl.fee_type, "0145");
		strcpy(title, "东莞日交易查询");
	}
	else if(inqFlag == 8)
	{
		strcpy(gbl.fee_type, "0146");
		strcpy(title, "东莞月交易查询");
	}
	else  if(inqFlag == 9)
	{//移动版最后一笔交易查询
		strcpy(gbl.fee_type, "0314");
		strcpy(title, "最后一笔交易查询");
	}
	else  if(inqFlag == 10)
	{//非移动版最后一笔交易查询
		strcpy(gbl.fee_type, "0315");
		strcpy(title, "最后一笔交易查询");
	}
	else
		return -1;
	
	flag = 0;
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{
		if(inqFlag != 3 && inqFlag!=9 && inqFlag!=10)
		{
			if(!flag)  
			{
				iRet = mngCard_Hdl(title);
				if(iRet == CANCLE_KEY)
					return CANCLE_KEY;
				else if(iRet != 0)
					return -1;
			}
		}
		else //最后一笔交易
		{
			strcpy(gbl.pos_serial, "999999");
			strcpy(gbl.card_no, "000000000000000000");
			gbl.card_no_len = 18;
		}
		
		gbl.track2_len = 0;
		gbl.track3_len = 0;
		pack.wrField(2, gbl);
		/*******************修改部分包内容****************/
		memset(pack.FIELD3, 0, sizeof(pack.FIELD3));
		CTools::hex_to_byte((BYTE *)"310050", pack.FIELD3, 6);
		//bit48
		memset(pack.FIELD48, 0, sizeof(pack.FIELD48) );
		memcpy(pack.FIELD48, gbl.fee_type, 4);
		b48_len = 4;
		memcpy(pack.FIELD48 + b48_len, "10", 2);
		b48_len += 2;
		memcpy(pack.FIELD48 + b48_len, "03", 2);
		b48_len += 2;
		memcpy(pack.FIELD48 + b48_len,  gbl.pos_no, 8);
		b48_len += 8;
		pack.Packet_Table[48].Real_Length = b48_len;
		//bit63
		bbzero(date8);		
		memset(pack.FIELD63, 0, sizeof(pack.FIELD63) );
		memcpy(pack.FIELD63, gbl.random_num, 8);	
		b63_len = 8;
		if( atoi(gbl.fee_type) == 145 && (inqFlag == 1) )	//广州日查询
		{	
			CTools::getYesterday(date8);	
			memcpy(pack.FIELD63+b63_len, date8, 8);
			b63_len += 8;
			pack.Packet_Table[63].Real_Length = b63_len;
		}
		else if( (atoi(gbl.fee_type) == 146) && (inqFlag == 2))	//上月查询
		{
			CTools::getLastMonth(date8);
			memcpy(pack.FIELD63+b63_len, date8, 6);
			b63_len += 6;
			pack.Packet_Table[63].Real_Length = b63_len;
		}
		else if( ((atoi(gbl.fee_type) == 146) && (inqFlag == 4) ) || atoi(gbl.fee_type) == 236 ||  inqFlag == 8)	//本月查询，东莞交罚月查询，东莞月交易查询
		{
			CTools::getTheMonth(date8);
			memcpy(pack.FIELD63+b63_len, date8, 6);
			b63_len += 6;
			pack.Packet_Table[63].Real_Length = b63_len;
		}
		else if(atoi(gbl.fee_type) == 235 ||  inqFlag == 7 )//东莞交罚日查询,东莞日交易查询
		{
			CTools::getDate(date8);
			memcpy(pack.FIELD63+b63_len, date8, 8);
			b63_len += 8;
			pack.Packet_Table[63].Real_Length = b63_len;
		}
		else	//最后一笔交易查询
			NULL;
		pack.Packet_Table[63].Real_Length = b63_len;
		/**************************************************/
		//  查询包打包   
		iRet = packHdl(1);
		wrLog("packHdl iRet = %d",iRet);
		if(iRet < 0)
			return -1;
		
		if(atoi((char *)pack.FIELD39) == 80 && !memcmp(pack.FIELD62, "P20003755", 9))
		{
			flag = 1;
			if(reGetPwd( title ) == 0) //密码错误，重新输入密码, 2006-10-25
				continue;
			else
				return CANCLE_KEY;
		}
		return iRet;
	}
	return -1;
}

//inqFlag: 1, 日交易查询
//         2, 月交易查询
//         3, 最后一笔交易查询
//         4, 本月交易查询
//         5, 东莞交罚日查询
//         6, 东莞交罚月查询
//         7, 东莞日交易查询
//         8, 东莞月交易查询
//         9, 移动版最后一笔交易查询
int CTrade::merInqTrade_msg(int inqFlag)
{
	char response_code[3];
	char tmp[512], date8[9], date[15],date2[15];
	char tra_num[6][6+1], amo[7][13], mny[7][13];
	char stan[12+1], amount[13], pay_no[60], tim[9], result[5],rsp_code[3],amount2[13],seq[11];//最后一笔交易用到的
	char fee_type[4+1], fee_name[30];
	int i,iSelect, len, num;
	char dgtra_num[6+1], dgamo[13], dgmny[13];
	int  index = -1,ret;
	_bstr_t vSQL;
	_RecordsetPtr record;
	
	bbzero(response_code);
	memcpy(response_code, pack.FIELD39, 2);
	
	if (!memcmp(response_code,"00",2)) 
	{
		if(inqFlag == 3 || inqFlag == 9|| inqFlag == 10)	//3：非移动版最后一笔交易 9：移动版最后一笔交易
		{
			bbzero(fee_name); //业务名称
			bbzero(date);    //交易日期
			bbzero(date2);    //交易日期
			bbzero(tim);    //交易时间
			bbzero(stan);    //交易系统参考号
			bbzero(fee_type); //交易业务
			bbzero(pay_no);  //交易号码
			bbzero(amount);	 //交易金额
			bbzero(amount2);	 //交易金额
			bbzero(result);  //交易结果
			len = 0;
			memcpy(date8, pack.FIELD63, 8);
			len += 8;
			memcpy(date, date8, 4);
			strcat(date, "/");
			memcpy(date+5, date8+4, 2);
			strcat(date, "/");
			memcpy(date+8, date8+6, 2);
			memcpy(tim, pack.FIELD63+len, 2);
			len += 2;
			strcat(tim, ":");
			memcpy(tim+3, pack.FIELD63+len, 2);
			len += 2;
			strcat(tim, ":");
			memcpy(tim+6, pack.FIELD63+len, 2);
			len += 2;
			memcpy(stan, pack.FIELD63+len, 12);
			len += 12;
			memcpy(fee_type, pack.FIELD63+len, 4);
			len += 4;
			memcpy(tmp, pack.FIELD63+len, 2);
			len += 2;
			memcpy(pay_no, pack.FIELD63+len, atoi(tmp));
			len += atoi(tmp);
			bbzero(tmp);
			memcpy(tmp, pack.FIELD63+len, 12);
			memcpy(amount2, pack.FIELD63+len, 12);
			len += 12;
			CTools::chgToMny(tmp, amount);
			bbzero(rsp_code);
			memcpy(rsp_code, pack.FIELD63+len, 2);
			//	rsp_code ：
			switch(atoi(rsp_code))
			{
			case 0: 
				strcpy(result, "成功");
				break;
			case 1: 
				strcpy(result, "失败");
				break;
			case 2: 
				strcpy(result, "订单超时");
				break;
			case 3:
				strcpy(result, "申请成功");
				break;
			case 4:
				strcpy(result, "订单生成，处理中");
				break;
			case 5:
				strcpy(result, "订单取消");
				break;
			case 6:
				strcpy(result, "已撤销");
				break;
			case 7:
				strcpy(result, "已退款");
				break;
			default:
				strcpy(result, "失败");
			}

			getFeeType(fee_type, fee_name);
			memcpy(date2, pack.FIELD63, 14);
			bbzero(tmp);
			sprintf(tmp, "交易日期：%s\n交易时间：%s\n系统参考号：%s\n交易业务：%s\n交易号码：%s\n交易金额：%s\n交易结果：%s", date, tim, stan, fee_name, pay_no, amount, result);
			TS_OutPutMsg(gbl.dPosInfo, tmp, 0, iSelect);
			
			if(atoi(gbl.dPosInfo.prmVer)>=9000){
				index = CDB::getConnStat();  //获取可用连接
				if( index<0 )
					return -1;
				wrLog("【连接数据库通道 %d】", index);
				
				if( index<0 )
					return -1;
				bbzero(tmp);
				sprintf(tmp, "select epos_seq from epos_txn WHERE txn_time=to_date('%s','yyyymmddhh24miss') and amount=%d and biz_type='%s' and pay_no='%s' and stan is null and rsp_code is null ",date2,atoi(amount2),fee_type,pay_no);
                vSQL = tmp;
				record = g_adoConnInfo[index].adoConn.GetRecordSet(vSQL, ret);
				if(ret)
				{
					g_adoConnInfo[index].connStat = 2;
					return -2;
				}
				if(record->adoEOF)
				{
					g_adoConnInfo[index].connStat = 0;
					return -3;
				}
				bbzero(seq);
				strcpy( seq, (LPCSTR)(_bstr_t)(record->GetCollect("epos_seq")));
				wrLog("查询到的序列号：[%s]", seq);
				
				if(strlen(seq)!=0){
					if(memcmp(rsp_code,"00",2)==0)
						CDB::setSumDayAmo(atoi(amount2),gbl.pos_no);
					bbzero(tmp);
					sprintf(tmp, "UPDATE epos_txn SET stan = '%s', rsp_code ='%s' WHERE epos_seq='%s' ",stan, rsp_code,seq);
					vSQL = tmp;
					wrLog("SQL语句：[%s]", tmp);
					if( g_adoConnInfo[index].adoConn.ExecuteSQL(vSQL) )
					{
						wrLog("插入或更新数据库失败");
						g_adoConnInfo[index].connStat = 2;
						return -4;
					}
				}
				g_adoConnInfo[index].connStat = 0;
            }
		}
		else if(inqFlag == 5 || inqFlag == 6)//东莞交罚日月查询
		{
			bbzero(dgtra_num); //交易数目
			bbzero(dgamo);     //交易金额(12位)
			bbzero(dgmny);	 //交易金额"xx.xx元"形式
            len = 0;
			memcpy(dgtra_num, pack.FIELD63+len, 6 );
			len += 6;
            memcpy(dgamo, pack.FIELD63+len, 12 );
			len += 12;
			CTools::chgToMny(dgamo, dgmny);
			
			if (inqFlag == 5)
			{
				bbzero(tmp);
				sprintf(tmp, "    您本日当前共成功进行交罚业务共%d笔，交易金额为%s\n    【确认】返回", atoi(dgtra_num), dgmny );
			}else if (inqFlag == 6 )
			{
				bbzero(tmp);
				sprintf(tmp, "    您本月当前共成功进行交罚业务共%d笔，交易金额为%s\n    【确认】返回", atoi(dgtra_num), dgmny );
			}else
				return -1;
			
			TS_OutPutMsg(gbl.dPosInfo, tmp, 0, iSelect);
		}
		else
		{
			bbzero(tra_num); //交易数目
			bbzero(amo);     //交易金额(12位)
			bbzero(mny);	 //交易金额"xx.xx元"形式
			
			num = 7;
			len = 0;
			for(i=0; i<num; i++)
			{
				if( i < 6 )
				{
					memcpy(tra_num[i], pack.FIELD63+len, 6 );
					len += 6;
				}
				if(i >= 6 && inqFlag == 1)
					break;
				memcpy(amo[i], pack.FIELD63+len, 12 );
				len += 12;
				CTools::chgToMny(amo[i], mny[i]);
			}
			
			if(inqFlag == 1 || inqFlag == 7)	//日交易
			{
				bbzero(date);
				bbzero(date8);
				if(inqFlag == 7)
                    CTools::getDate(date8);
				else
					CTools::getYesterday(date8);
				wrLog("date: [%s]", date8);
				memcpy(date, date8, 4);
				strcat(date,"-");
				strncat(date, date8+4, 2);
				strcat(date,"-");
				strncat(date, date8+4+2, 2);
				bbzero(tmp);
				sprintf(tmp, "查询日期：%s\n1.电信充值卡%d笔\n销售总额：%s\n2.移动充值卡%d笔\n销售总额：%s\n3.联通充值卡%d笔\n销售总额：%s", date, atoi(tra_num[0]), mny[0], atoi(tra_num[1]), mny[1], atoi(tra_num[2]), mny[2]);
				TS_OutPutMsg(gbl.dPosInfo, tmp, 0, iSelect);
				bbzero(tmp);
				sprintf(tmp, "4.商户代缴费%d笔\n代缴总额：%s\n5.商户合计缴费%d笔\n缴费总额：%s\n6.e卡代缴费%d笔\n代缴总额：%s\n【确认】返回", atoi(tra_num[3]), mny[3], atoi(tra_num[4]), mny[4], atoi(tra_num[5]), mny[5]);
				TS_OutPutMsg(gbl.dPosInfo, tmp, 0, iSelect);
			}
			else if(inqFlag == 2)	//月交易
			{
				bbzero(date);
				bbzero(date8);
				CTools::getLastMonth(date8);
				wrLog("month: [%s]", date8);
				memcpy(date, date8, 4);
				strcat(date,"-");
				strncat(date, date8+4, 2);
				bbzero(tmp);
				sprintf(tmp, "查询月份：%s\n1.电信充值卡%d笔\n销售总额：%s\n2.移动充值卡%d笔\n销售总额：%s\n", date, atoi(tra_num[0]), mny[0], atoi(tra_num[1]), mny[1]);
				TS_OutPutMsg(gbl.dPosInfo, tmp, 0, iSelect);
				bbzero(tmp);
				sprintf(tmp, "3.联通充值卡%d笔\n销售总额：%s\n4.商户代缴费%d笔\n代缴总额：%s\n5.商户合计缴费%d笔\n缴费总额：%s\n", atoi(tra_num[2]), mny[2], atoi(tra_num[3]), mny[3], atoi(tra_num[4]), mny[4]);
				TS_OutPutMsg(gbl.dPosInfo, tmp, 0, iSelect);
				bbzero(tmp);
				sprintf(tmp, "6.e卡代缴费%d笔\n代缴总额：%s\n7.e卡充值金额：%s\n【确认】返回", atoi(tra_num[5]), mny[5], mny[6]);
				TS_OutPutMsg(gbl.dPosInfo, tmp, 0, iSelect);
			}else if(inqFlag == 4 || inqFlag == 8)	//月交易
			{
				bbzero(date);
				bbzero(date8);
				CTools::getTheMonth(date8);
				wrLog("month: [%s]", date8);
				memcpy(date, date8, 4);
				strcat(date,"-");
				strncat(date, date8+4, 2);
				bbzero(tmp);
				sprintf(tmp, "查询月份：%s\n1.电信充值卡%d笔\n销售总额：%s\n2.移动充值卡%d笔\n销售总额：%s\n", date, atoi(tra_num[0]), mny[0], atoi(tra_num[1]), mny[1]);
				TS_OutPutMsg(gbl.dPosInfo, tmp, 0, iSelect);
				bbzero(tmp);
				sprintf(tmp, "3.联通充值卡%d笔\n销售总额：%s\n4.商户代缴费%d笔\n代缴总额：%s\n5.商户合计缴费%d笔\n缴费总额：%s\n", atoi(tra_num[2]), mny[2], atoi(tra_num[3]), mny[3], atoi(tra_num[4]), mny[4]);
				TS_OutPutMsg(gbl.dPosInfo, tmp, 0, iSelect);
				bbzero(tmp);
				sprintf(tmp, "6.e卡代缴费%d笔\n代缴总额：%s\n7.e卡充值金额：%s\n【确认】返回", atoi(tra_num[5]), mny[5], mny[6]);
				TS_OutPutMsg(gbl.dPosInfo, tmp, 0, iSelect);
			}
		}		
		return iSelect;
	}
	else
	{
		returnFail(response_code);
		return -1;
	}
}


//付费易卡2期查询,20070625
int CTrade::xltInqTrade(const char *title)
{
	int  iRet;
	
	iRet = xltInqHdl(title);
	if(iRet == 0)
		iRet = xltInqMsg(title);
	return iRet;
}


//付费易卡2期查询,20070625
int CTrade::xltInqHdl(const char *title)
{
	int  iRet, flag = 0;
	int  mngCard_count = 1;
	char response_code[3];
	
	wrLog("【付费易卡2期查询】");
	strcpy(gbl.fee_type, "0094");
	mngCard_count = 1;
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{
		if(!flag)
		{
			//小灵通查询：0094 查询方式：刷卡或输卡号
			iRet = 1;
			for(int curTry=0; curTry<MAXTRY; curTry++)	//刷卡错误，重新刷卡
			{
				if(mngCard_count==1)
					iRet = mngCard(title, 1, gbl.get_card);
				else
					iRet = mngCard(title, 1, MNG_MUL);
				mngCard_count = mngCard_count + 1 ;//标志着不是第一次刷卡
				if(iRet == CANCLE_KEY)
					return CANCLE_KEY;
				if(iRet == RE_MNG_CARD)
					continue;
				else if(iRet != 0)
					return -1;
				//非付费易卡
				if(memcmp(gbl.card_no,"8828", 4) && memcmp(gbl.card_no,"2028", 4)) 
					continue;
				break;
			}
		}
		pack.wrField(2, gbl);
		/*******************修改部分包内容****************/
		memset(pack.FIELD3, 0, sizeof(pack.FIELD3));
		CTools::hex_to_byte((BYTE *)"310060", pack.FIELD3, 6);
		//bit48
		bbzero(pack.FIELD48);
		memcpy(pack.FIELD48, gbl.fee_type, 4);
		strncat((char *)pack.FIELD48, "00", 2);
		pack.Packet_Table[48].Real_Length = 6;
		//bit63
		memset(pack.FIELD63, 0, sizeof(pack.FIELD63) );
		strcpy((char *)pack.FIELD63, "00000000");
		strncat((char *)pack.FIELD63, "01",2);
		strncat((char *)pack.FIELD63, "12",2);
		strncat((char *)pack.FIELD63, gbl.card_no,12);
		strncat((char *)pack.FIELD63, "06",2);
		strncat((char *)pack.FIELD63, gbl.password,6);
		pack.Packet_Table[63].Real_Length = 32;
		/**************************************************/
		//  查询包打包   
		iRet = packHdl(1);
		if(iRet < 0)
			return -1;
		
		strcpy(response_code, (char *)pack.FIELD39);
		if(!memcmp(response_code, "55", 2))
		{
			flag = 1;
			
			iRet = reGetPwd(title);
			if(iRet == 0) //密码错误，重新输入密码, 2006-10-25
				continue;
			else
				return CANCLE_KEY;
		}
		else if( atoi(response_code) )
		{
			iRet = returnFail((char *)pack.FIELD39);
		}
		return iRet;
	}
	return -1;
}

//付费易卡2期查询下发信息,20070625
int CTrade::xltInqMsg(const char *title)
{
	int  iSelect, len;
	char tmp[512],rsp_code[3], tmp_len[2+1];
	char amo[12+1], mny[12+1],date[12+1];
	char card_type[11], stat[20], pwd_time[3+1], usage_type[7];
	char if_tran[15], card_level[7], if_usage[9], if_reg[15], if_tied[15];
	char hav_integral[8+1], his_integral[10+1];
	
	bbzero(rsp_code);
	memcpy(rsp_code, pack.FIELD39, 2);
	
	if(atoi(rsp_code) == 0)
	{
		len = 0;
		//跳过卡号长＋卡号＋密码长＋密码
		bbzero(tmp_len);
		memcpy(tmp_len, pack.FIELD63, 2);
		len += 2;
		len += atoi(tmp_len);  //卡号长
		bbzero(tmp_len);
		memcpy(tmp_len, pack.FIELD63+len, 2);
		len += 2;
		len += atoi(tmp_len);  //密码长
		//卡类型
		bbzero(card_type);
		if( !memcmp(pack.FIELD63+len, "001", 3) )
			strcpy(card_type, "普通磁卡");
		else if( !memcmp(pack.FIELD63+len, "002", 3) )
			strcpy(card_type, "IC芯片卡");
		else if( !memcmp(pack.FIELD63+len, "003", 3) )
			strcpy(card_type, "帐号PVC卡");
		else if( !memcmp(pack.FIELD63+len, "004", 3) )
			strcpy(card_type, "帐号纸质卡");
		else
			return -1;
		len += 3;
		//余额
		bbzero(amo);
		bbzero(mny);
		memcpy(amo, pack.FIELD63+len, 12);
		len += 12;
		CTools::chgToMny(amo, mny, 1);
		//状态
		bbzero(stat);
		if( !memcmp(pack.FIELD63+len, "00", 2) )
			strcpy(stat, "正常");
		else if( !memcmp(pack.FIELD63+len, "01", 2) )
			strcpy(stat, "冻结");
		else if( !memcmp(pack.FIELD63+len, "02", 2) )
			strcpy(stat, "挂失");
		else if( !memcmp(pack.FIELD63+len, "03", 2) )
			strcpy(stat, "锁定");
		else if( !memcmp(pack.FIELD63+len, "04", 2) )
			strcpy(stat, "黑名单");
		else if( !memcmp(pack.FIELD63+len, "05", 2) )
			strcpy(stat, "卡被锁，错误多次");
		else if( !memcmp(pack.FIELD63+len, "98", 2) )
			strcpy(stat, "未激活");
		else if( !memcmp(pack.FIELD63+len, "99", 2) )
			strcpy(stat, "注销");
		else
			return -1;
		len += 2;
		//有效期
		bbzero(date);
		memcpy(date, pack.FIELD63+len, 4);
		len += 4;
		strcat(date, "-");
		strncat(date, (char *)pack.FIELD63+len, 2);
		len += 2;
		strcat(date, "-");
		strncat(date, (char *)pack.FIELD63+len, 2);
		len += 2;
		
		//累计密码错误次数
		bbzero(pwd_time);
		memcpy(pwd_time, pack.FIELD63+len, 3);
		len += 3;
		//卡使用类型
		bbzero(usage_type);
		if( !memcmp(pack.FIELD63+len, "0", 1) )
			strcpy(usage_type, "现金卡");
		else if( !memcmp(pack.FIELD63+len, "1", 1) )
			strcpy(usage_type, "记名卡");
		else
			return -1;
		len += 1;
		//是否允许转帐时将资金转出
		bbzero(if_tran);
		if( !memcmp(pack.FIELD63+len, "0", 1) )
			strcpy(if_tran, "资金不能转出");
		else if( !memcmp(pack.FIELD63+len, "1", 1) )
			strcpy(if_tran, "资金可以转出");
		else
			return -1;
		len += 1;
		//卡级别
		bbzero(card_level);
		if( !memcmp(pack.FIELD63+len, "0", 1) )
			strcpy(card_level, "普通卡");
		else if( !memcmp(pack.FIELD63+len, "1", 1) )
			strcpy(card_level, "银卡");
		else if( !memcmp(pack.FIELD63+len, "2", 1) )
			strcpy(card_level, "金卡");
		else if( !memcmp(pack.FIELD63+len, "3", 1) )
			strcpy(card_level, "钻石卡");
		else
			return -1;
		len += 1;
		//是否使用过
		bbzero(if_usage);
		if( !memcmp(pack.FIELD63+len, "0", 1) )
			strcpy(if_usage, "未使用过");
		else if( !memcmp(pack.FIELD63+len, "1", 1) )
			strcpy(if_usage, "已使用过");
		else
			return -1;
		len += 1;
		//是否登记身份证信息
		bbzero(if_reg);
		if( !memcmp(pack.FIELD63+len, "0", 1) )
			strcpy(if_reg, "未登记身份信息");
		else if( !memcmp(pack.FIELD63+len, "1", 1) )
			strcpy(if_reg, "已登记身份信息");
		else
			return -1;
		len += 1;
		//是否登记身份证信息
		bbzero(if_tied);
		if( !memcmp(pack.FIELD63+len, "0", 1) )
			strcpy(if_tied, "未支付绑定");
		else if( !memcmp(pack.FIELD63+len, "1", 1) )
			strcpy(if_tied, "已设置支付绑定");
		else
			return -1;
		len += 1;
		//已有积分
		bbzero(hav_integral);
		memcpy(hav_integral, pack.FIELD63+len, 8);
		len += 8;
		//历史积分
		bbzero(his_integral);
		memcpy(his_integral, pack.FIELD63+len, 10);
		len += 10;
		
		bbzero(tmp);
		if( !strcmp(usage_type, "现金卡") )
			sprintf(tmp, "余额：%s\n有效期：%s\n按【确认】返回", mny, date);
		else
			sprintf(tmp, "卡状态：%s\n卡级别：%s\n余额：%s\n有效期：%s\n已有积分：%d\n历史积分：%d\n按【确认】返回", stat, card_level, mny, date, atoi(hav_integral), atoi(his_integral));
		TS_OutPutMsg(gbl.dPosInfo, tmp, 0,iSelect);
		return iSelect;	
	}
	else
	{
		returnFail(rsp_code);
		return -1;
	}
}



//小灵通2期业务，20070625
//0164: 充值
int CTrade::xltMnyIn(const char *title)
{
	int  iRet, b48_len, flag, curTry=0;
	int  iSelect, mngCard_count = 1;
	char tmp[512], len_buff[4+1], mny[12];
	char card_info[200], phscard[20];
	
	wrLog("【付费易卡充值】");
	strcpy(gbl.fee_type, "0164");
	
	for(curTry=0; curTry<MAXTRY; curTry++)
	{
		bbzero(card_info);
		iRet = getCardInfo( title, card_info, MNG_OR_INPUT, gbl.get_card, "请刷或输入待充值卡号");//刷卡取得卡信息
		if(iRet==0)
			iRet = getCardNum(card_info, 2);
		if(iRet == RE_MNG_CARD)
			continue;
		else if(iRet != 0)
			return -1;
		if( memcmp(gbl.card_no, "2028", 4) )  //非记名卡不能转入
		{
			TS_OutPutMsg(gbl.dPosInfo, "  只能为记名卡充值\n按【确定】重刷\n按【返回】退出", 0, iSelect);
			if(iSelect==0)
				continue;
			else
				return 0;
		}
		//取得待转入卡卡号
		bbzero(phscard);
		strcpy(phscard, gbl.card_no);
		//选取充值金额		
		iRet = selectAmount();
		if(iRet == CANCLE_KEY)
			return CANCLE_KEY;
		else if(iRet < 0)
			return -1;
		//下发提示
		bbzero(mny);
		CTools::chgToMny(gbl.amount, mny);
		bbzero(tmp);
		sprintf(tmp, "您要充值的卡号为：\n%s\n您要充值的金额为：\n%s\n按【确认】继续\n按【返回】修改", phscard, mny);
		TS_OutPutMsg(gbl.dPosInfo, tmp, 0, iSelect);
		if( iSelect )
			continue;
		else
			break;
	}
	
	flag = 0;
	for(curTry=0; curTry<MAXTRY; curTry++)
	{
		if(!flag) 
		{
			iRet = mngCard_Hdl(title, "请刷银行卡");
			if(iRet == CANCLE_KEY)
				return CANCLE_KEY;
			else if(iRet != 0)
				return -1;
		}
		pack.wrField(2, gbl);	//写交费域
		/***********修改一些域信息*********/
		//bit48
		bbzero(pack.FIELD48);
		memcpy(pack.FIELD48, gbl.fee_type,4);	//4位信息码
		b48_len = 4;
		bbzero(len_buff);
		sprintf(len_buff,"%02d", strlen(phscard));	//卡长度
		memcpy(pack.FIELD48+b48_len, len_buff, 2);	
		b48_len +=2;
		memcpy(pack.FIELD48+b48_len, phscard, strlen(phscard));	//卡号
		b48_len += strlen(phscard);
		pack.Packet_Table[48].Real_Length=b48_len;
		/**********************************/
		//交费包处理
		iRet = packHdl(2);
		if(iRet < 0)
			return -1;
		
		if (!memcmp(pack.FIELD39,"00",2)) 
		{
			iRet = TS_OutPutMsg(gbl.dPosInfo," \n     充值成功！\n	按【确认】打印票据",0,iSelect);
			if(iRet!=0 || iSelect==0)
			{
				CPrint prt;
				prt.set_in_par(gbl);
			//	prt.print_detail(2, title);	 //打印预付费明细
				prt.print_pre_detail(pack,title);
			}
			return 0;
		}// end if (!memcmp(pack.FIELD39,"00",2))
		else if(!memcmp(pack.FIELD39,"55",2))
		{
			flag = 1;
			if(reGetPwd( title) == 0) //密码错误，重新输入密码, 2006-10-25
				continue;
			else
				return CANCLE_KEY;
		}
		else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
			if (iSelect!=0)
			{
				return -1;
			}else
				continue;
		}
		returnFail((char *)pack.FIELD39);
		return -1;
	}// for(int curTry=0; curTry<MAXTRY; curTry++)
	return -1;
}


//小灵通2期业务，20070620
//0163: 转帐
int CTrade::xltAccTrans(const char *title)
{
	int  iRet, b48_len, flag=0;
	int  iSelect, mngCard_count = 1;
	char tmp[512], len_buff[4+1];
	char rsp_code[3], card_info[200], phscard[20];
	
	wrLog("小灵通付费易卡2期【转帐】");
	strcpy(gbl.fee_type, "0163");
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{
		bbzero(card_info);
		iRet = getCardInfo( title, card_info, MNG_OR_INPUT, gbl.get_card, "请刷或输入待转帐卡号");//刷卡取得卡信息
		if(iRet==0)
			iRet = getCardNum(card_info, MNG_OR_INPUT);
		if(iRet == RE_MNG_CARD)
			continue;
		else if(iRet != 0)
			return -1;
		if( memcmp(gbl.card_no, "2028", 4) )  //非记名卡不能转入
		{
			TS_OutPutMsg(gbl.dPosInfo, "   只能转入记名卡\n按【确定】重刷\n按【返回】退出", 0, iSelect);
			if(iSelect==0)
				continue;
			else
				return 0;
		}
		
		//取得待转入卡卡号
		bbzero(phscard);
		strcpy(phscard, gbl.card_no);
		//下发确认信息
		bbzero(tmp);
		sprintf(tmp, "您要转入的卡号为：\n%s\n按【确认】继续\n按【返回】修改", phscard);
		TS_OutPutMsg(gbl.dPosInfo, tmp, 0, iSelect);
		if(iSelect == 0)
			break;
		else
			continue;
	}
	
	int count = 0;  //卡数
	strcpy(gbl.xlt_type, "02");  //按卡内余额
	bbzero(gbl.xlt_card);
	memcpy(gbl.xlt_card, gbl.xlt_type, 2);
	bbzero(gbl.amount);		//按卡内余额交费
	
	while(count < 20)
	{
		if(count >= 20)
		{
			TS_OutPutMsg(gbl.dPosInfo,"  \n已达到能刷卡数的上限\n按【确认】转帐\n按【返回】退出",0,iSelect);
			if(iSelect)
				return 0;
		}
		else
		{
			/********************请求刷卡****************/
			iRet = 1;
			while(iRet > 0)	//刷卡错误，重新刷卡
			{
				iRet = mngCard( title, 1, MNG_MUL, ""); //1次采集
				if(iRet == CANCLE_KEY)
					return CANCLE_KEY;
				if(iRet == RE_MNG_CARD)
					continue;
				else if(iRet != 0)
					return -1;
			}
			/**********要写入63bit的信息***********/
			count++;
			memset(tmp,0,sizeof(tmp));
			sprintf(tmp,"%02d",count);
			memcpy(gbl.xlt_card+2,tmp,2);
			strcat(gbl.xlt_card,"12");
			strcat(gbl.xlt_card,gbl.card_no);
			strcat(gbl.xlt_card,"06");
			strcat(gbl.xlt_card,gbl.password);
			/**************************************/
			if(DEBUG_LEVEL <= 2)
			{
				wrLog("小灵通付费易卡信息：[%s]\n",gbl.xlt_card);
			}
			//是否继续刷卡
			TSMENULIST menuList;
			memset(&menuList,0,sizeof(menuList));
			menuList.iTotalNum = 2;
			strcpy(menuList.acTitle, title);
			strcpy(menuList.menuItem[0], "继续刷卡");
			strcpy(menuList.menuItem[1], "确认转帐");
			iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
			if(iRet)
				return -1;
			switch(iSelect)
			{
			case 1:
				continue;
			case 2:
				break;
			default: 
				return CANCLE_KEY;
			}
		}
		
		pack.wrField(2, gbl);	//写交费域
		/***********修改一些域信息*********/
		//bit48
		bbzero(pack.FIELD48);
		memcpy(pack.FIELD48, gbl.fee_type,4);	//4位信息码
		b48_len = 4;
		bbzero(len_buff);
		sprintf(len_buff,"%02d", strlen(phscard));	//卡长度
		memcpy(pack.FIELD48+b48_len,len_buff,2);	
		b48_len +=2;
		memcpy(pack.FIELD48+b48_len, phscard, strlen(phscard));	//卡号
		b48_len += strlen(phscard);
		pack.Packet_Table[48].Real_Length=b48_len;
		/**********************************/
		
		iRet = packHdl(2);
		if(iRet < 0)
			return -1;
		
		bbzero(rsp_code);
		memcpy(rsp_code,pack.FIELD39,2);
		
		if (!memcmp(rsp_code,"00",2)) 
		{
			xltInqMsg(title);
			/************商户打印***************/
			if(gbl.phs_ticket)	//付费易卡是否打印发票标志
			{
				iRet = TS_OutPutMsg(gbl.dPosInfo,"  \n      转入成功！\n	按【确认】打印",0,iSelect);
				if(iRet!=0 || iSelect==0)
				{
					CPrint prt;
					prt.set_in_par(gbl);
				//	prt.print_detail(2, title);	
					prt.print_pre_detail(pack,title);
				}
			}
			else
				TS_OutPutMsg(gbl.dPosInfo,"  \n      转入成功！\n	  按【确认】返回",0,iSelect);
			return 0;
		}
		else if(!memcmp(rsp_code,"55",2))
		{
			TS_OutPutMsg(gbl.dPosInfo,"  \n\n      密码错误！", 1, iSelect);
			return 0;
		}
		else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
			if (iSelect!=0)
			{
				return -1;
			}else
				continue;
		}
		else 
		{
			returnFail((char *)pack.FIELD39);
			return -1;
		}
	} //end while
	return 0;
}

//移动空中充值
//biz_flag:1:电信空充（定额无查询）;2:移动空充;3:联通空充（联欣）;4:联通空充（全省）
//input_flag:0:普通直充;1:超爽交费易;2:优惠直充;
int CTrade::mblAirPayForGDYD(const char *title, int select, int input_flag,int mbl_input_flag)
{
	int iRet, iSelect;
	//char response_code[3];
	char amoMny[15], msg[200];
//	char party_code[10];
	char phone_buff[15], phone_area[10];
	int phone_owner=0,check_flag=0,i=0,t_menu_cnt=0;
	int menu[10];
	int iSelect2;
	char showPhoneNo[11+1];
	bbzero(showPhoneNo);

	bbzero(gbl.fee_type);
	strcpy(gbl.fee_type,"0180");
	
	wrLog("【mblAirPayForGDYD】title[%s] select[%d] input_flag[%d]", title, select, input_flag);

	if(input_flag==2) //移动优惠直充
		
	{
		
		t_menu_cnt=get_favorable_menu(gbl.city_no,gbl.fee_type,menu);
		if(t_menu_cnt>0){
			int iRet, iSelect;
			TSMENULIST menuList;
			memset(&menuList,0,sizeof(menuList));
			strcpy(menuList.acTitle, "请选择您要充值的金额");
			for(i=0;i<t_menu_cnt;i++){
				strcpy(menuList.menuItem[i], favorable_air_pay[menu[i]].name);
			}
			menuList.iTotalNum=t_menu_cnt;
			iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
            if(strlen(favorable_air_pay[menu[iSelect-1]].info)>0){
				TS_OutPutMsg(gbl.dPosInfo,favorable_air_pay[menu[iSelect-1]].info,0,iSelect2);
				if(iSelect2!=0){
					return -1;
				}
			}
			sprintf(gbl.amount,"%12d",favorable_air_pay[menu[iSelect-1]].amount);
		}else{
            return -1;
		}
	}
	
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	if (input_flag == 0||input_flag == 2)
	{
		strcpy(tradeInfoSend.acMainTitle, title);
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents = 1;
		
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入手机号码：");
		
		if(atoi(gbl.dPosInfo.prmVer)>=9000)
		{
			strcat(tradeInfoSend.Contents[0].acTitle, "(可通过854修改输入次数)");
		}
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
		if (mbl_input_flag == 1)
		{
			tradeInfoSend.Contents[0].uCount = 0;		//输入1次
		}
		else
		{	
			tradeInfoSend.Contents[0].uCount = gbl.input_times;
		}

		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
		tradeInfoSend.Contents[0].uMinLen = 11;		
		tradeInfoSend.Contents[0].uMaxLen = 11;	

		
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		if(iRet != 0)
		{
			wrLog("TS_TradeControl返回错误[%d]", iRet);
			wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
			return iRet;
		}
		
		memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
		bbzero(gbl.phone_no);
		strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);	
		strcpy(gbl.phone_no,(char *)tradeInfoRecv.Contents[0].uMsg );
		gbl.phone_len = tradeInfoRecv.Contents[0].uMsgLen;
	}
	
	bbzero(phone_area);
	
	if(gbl.phone_no[0]=='1')//如果是手机
	{
		CTools::shildWords(gbl.phone_no,3,4,showPhoneNo);
		wrLog("充值号码:[%s]", showPhoneNo);

		iRet=CDB::phone_district_qry(gbl.phone_no,gbl.phone_province,gbl.phone_city,&gbl.phone_owner);
			
		if(iRet !=0) 
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n\n该号码不属于广东地区\n   请更换号码再试",0,iSelect);
			return -1;
		}

		strcpy(phone_area, gbl.phone_city);
	}

	if (gbl.phone_owner!=2)

	{
		TS_OutPutMsg(gbl.dPosInfo,"\n   输入的手机号错误！\n为移动号码充值",1,iSelect);
		return -1;
	}
		
	
	if (input_flag == 1)
	{
		if(select == 0)
		{
			iRet = selectAmount(2, select);
		}
		else
		{
			sprintf(gbl.amount,"%012d", select * 100);
		}
		
	}
	else if (input_flag == 2)
	{
		NULL;
	}
	else
	{
		if(select == 0)
		{
			iRet = selectAmount(0, select);
		}
		else
		{
			sprintf(gbl.amount,"%012d", select * 100);
		}
		
	}
	
	if(CDB::chKChinaUnicom(gbl.fee_type, gbl.phone_no, atoi(gbl.amount))==0)
	{
		NULL;
	}
	else
	{
		bbzero(msg);
		sprintf(msg, "业务运营商规定：\n同一号码%s\n同一金额%d元\n%d分钟内不能连续充值\n请稍后再试", gbl.phone_no, atoi(gbl.amount)/100,FORBID_TIME);
		TS_OutPutMsg(gbl.dPosInfo, msg, 1, iSelect);
		return -1;
	}
	
	if (input_flag == 0 ||input_flag == 2)
	{
		if(atoi(gbl.dPosInfo.prmVer)>=9000)
		{
			bbzero(amoMny);
			CTools::chgToMny(gbl.amount,amoMny);
			bbzero(msg);
			if (memcmp(gbl.phone_no,"1",1)==0)
			{
				bbzero(phone_buff);
				memcpy(phone_buff,gbl.phone_no,3);
				strcat(phone_buff,"-");
				memcpy(phone_buff+4,gbl.phone_no+3,4);
				strcat(phone_buff,"-");
				memcpy(phone_buff+9,gbl.phone_no+7,4);
				sprintf(msg, "%s\n\n%s\t%s\n\n%s\n\n【是 Enter】  【否 Esc】", title, phone_buff, phone_area, amoMny);
			}else
				sprintf(msg, "%s\n\n%s\t%s\n\n%s\n\n【是 Enter】  【否 Esc】", title, gbl.phone_no, phone_area, amoMny);
			iRet = TS_OutPutMsg(gbl.dPosInfo, msg, 0, iSelect);
			if(iSelect)
			{
				return -1;
			}
		}
	}
	else if (input_flag == 1)
	{
		if(atoi(gbl.dPosInfo.prmVer)>=9000)
		{

			bbzero(amoMny);
			CTools::chgToMny(gbl.amount,amoMny);
			bbzero(msg);
			
			bbzero(phone_buff);
			memcpy(phone_buff,gbl.phone_no,3);
			strcat(phone_buff,"-");
			memcpy(phone_buff+4,gbl.phone_no+3,4);
			strcat(phone_buff,"-");
			memcpy(phone_buff+9,gbl.phone_no+7,4);
			
			sprintf(msg, "%s\n\n%s\t%s\n\n%s\n\n【是 Enter】  【否 Esc】", title, phone_buff, phone_area, amoMny);
			iRet = TS_OutPutMsg(gbl.dPosInfo, msg, 0, iSelect);
			if(iSelect)
			{
				return -1;
			}
		}
	}
	
	
	char errMsg[500];
	char showMsg[500];
	bbzero(errMsg);
	bbzero(showMsg);


	iRet=pay(title,errMsg);

	if (iRet!=0)
	{
		if (iRet==-5) 
		{

			bbzero(showMsg);
			sprintf(showMsg,"\n%s系统繁忙，请稍后再试!\n如果交易结果不明确请使用[821]查询最后一笔交易","移动"); //界面提示，如果交易结果不明确，请做最后一笔交易查询
			TS_OutPutMsg(gbl.dPosInfo,showMsg,0,iSelect);
			return CANCLE_KEY;

		}
		else
		{
			
			bbzero(showMsg);
			sprintf(showMsg,"%s",errMsg); //界面提示，如果交易结果不明确，请做最后一笔交易查询
			TS_OutPutMsg(gbl.dPosInfo,showMsg,0,iSelect);
			return CANCLE_KEY;
		}
		
	}
	
	bbzero(showMsg);
	sprintf(showMsg,"业务受理成功!\n\n系统参考号:%s\n手机号码:%s\n充值金额:%.2f元\n实收金额:%.2f元\n\n按确认打印凭证 【Enter】是 【Esc】否\n\n 【注意】由于移动账务系统话费信息暂未实现实时更新，充值成功后话费明细可能与实际不一致，建议充值成功10分钟后再查询明细"
		,gbl.stan_no,gbl.phone_no,atof(gbl.origAmount)/100,atof(gbl.amount)/100);
	iRet=TS_OutPutMsg(gbl.dPosInfo,showMsg,0,iSelect);
	
	if (iSelect!=0)
	{
		return 0;
	}
	
	//打印信息
	CPrint print;
	print.set_in_par(gbl);
//	print.print_phonePay_detail(title);
	print.print_phonePay_detailForGDYD(title);

	return 0;
}

//移动空中充值
//biz_flag:1:电信空充（定额无查询）;2:移动空充;3:联通空充（联欣）;4:联通空充（全省）
//input_flag:0:普通直充;1:超爽交费易;2:优惠直充;
int CTrade::mblAirPay(const char *title, int biz_flag, int select, int input_flag,int mbl_input_flag)
{
	int iRet, flag, iSelect;
	char response_code[3];
	char overdraft_mny[15+1],amoMny[15], msg[200],phone_no_buff[30+1],phone_mny[12+1],len_buff[2+1];
	char party_code[10];
	char phone_buff[15], phone_area[10];
	int phone_owner=0,check_flag=0,i=0,t_menu_cnt=0;
	int menu[10];
	int iSelect2;
	char showPhoneNo[11+1];
	bbzero(showPhoneNo);
	
	wrLog("【mblAirPay】title[%s] biz_flag[%d] select[%d] input_flag[%d]", title, biz_flag, select, input_flag);
	
	iRet = get_area_biz(biz_flag, gbl.city_no, gbl.acc_city_no, gbl.fee_type); //
	if( iRet==0 )
	{
		//for test
		//strcpy(gbl.fee_type,"0323"); 
		wrLog("gbl.fee_type = [%s]", gbl.fee_type);
	}
	else
	{
		return -1;
	}
	
	if(input_flag==2) //移动优惠直充
		
	{
		
		t_menu_cnt=get_favorable_menu(gbl.city_no,gbl.fee_type,menu);
		if(t_menu_cnt>0){
			int iRet, iSelect;
			TSMENULIST menuList;
			memset(&menuList,0,sizeof(menuList));
			strcpy(menuList.acTitle, "请选择您要充值的金额");
			for(i=0;i<t_menu_cnt;i++){
				strcpy(menuList.menuItem[i], favorable_air_pay[menu[i]].name);
			}
			menuList.iTotalNum=t_menu_cnt;
			iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
            if(strlen(favorable_air_pay[menu[iSelect-1]].info)>0){
				TS_OutPutMsg(gbl.dPosInfo,favorable_air_pay[menu[iSelect-1]].info,0,iSelect2);
				if(iSelect2!=0){
					return -1;
				}
			}
			sprintf(gbl.amount,"%12d",favorable_air_pay[menu[iSelect-1]].amount);
		}else{
            return -1;
		}
	}
	
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	if (input_flag == 0||input_flag == 2)
	{
		strcpy(tradeInfoSend.acMainTitle, title);
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents = 1;
		
		if (biz_flag==2 || biz_flag==3 || biz_flag==4 || biz_flag==10)//移动或联通
		{
			strcpy(tradeInfoSend.Contents[0].acTitle, "请输入手机号码：");	
			if(atoi(gbl.dPosInfo.prmVer)>=9000)
			{
				strcat(tradeInfoSend.Contents[0].acTitle, "(可通过854修改输入次数)");
			}
			tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
			if (mbl_input_flag == 1)
			{
				tradeInfoSend.Contents[0].uCount = 0;		//输入1次
			}else
				
				tradeInfoSend.Contents[0].uCount = gbl.input_times;
			tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
			tradeInfoSend.Contents[0].uMinLen = 11;		
			tradeInfoSend.Contents[0].uMaxLen = 11;	
		}else if ( biz_flag==1 )//电信
		{
			strcpy(tradeInfoSend.Contents[0].acTitle, "请输入手机号码：");
			if(atoi(gbl.dPosInfo.prmVer)>=9000)
			{
				strcat(tradeInfoSend.Contents[0].acTitle, "(可通过854修改输入次数)");
			}
			tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
			tradeInfoSend.Contents[0].uCount = gbl.input_times;
			tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
			tradeInfoSend.Contents[0].uMinLen = 7;		
			tradeInfoSend.Contents[0].uMaxLen = 12;	
		}
		
		else
		{
			iRet = TS_OutPutMsg(gbl.dPosInfo, "非法调用，操作出错", 0, iSelect);
			return -1;
		}
		
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		if(iRet != 0)
		{
			wrLog("TS_TradeControl返回错误[%d]", iRet);
			wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
			return iRet;
		}
		
		memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
		bbzero(gbl.phone_no);
		strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);	
		strcpy(gbl.phone_no,(char *)tradeInfoRecv.Contents[0].uMsg );
		gbl.phone_len = tradeInfoRecv.Contents[0].uMsgLen;
	}
	
	bbzero(phone_area);
	
	if(gbl.phone_no[0]=='1')//如果是手机
	{
		CTools::shildWords(gbl.phone_no,3,4,showPhoneNo);
		wrLog("充值号码:[%s]", showPhoneNo);

		iRet=CDB::phone_district_qry(gbl.phone_no,gbl.phone_province,gbl.phone_city,&gbl.phone_owner);
			
		if(iRet !=0) 
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n\n该号码不属于广东地区\n   请更换号码再试",0,iSelect);
			return -1;
		}

		strcpy(phone_area, gbl.phone_city);

		/*
		if(!strcmp(gbl.fee_type, "0342")) 
		{
		if(!strcmp(phone_area, "汕头") || !strcmp(phone_area, "揭阳") || !strcmp(phone_area, "潮州")
		|| !strcmp(phone_area, "清远") || !strcmp(phone_area, "韶关") ||!strcmp(phone_area, "河源"))
		{
		strcpy(gbl.fee_type, "0356");
		wrLog("高酬金号码源fee_type change [%s]", gbl.fee_type);
		}
		}
		*/
		//待优化，使用MAP对应
		if(!strcmp(gbl.fee_type, "0342"))
		{
			switch(atoi(gbl.city_no))
			{
			case 754://汕头
				if(!strcmp(phone_area, "汕头"))
				{
					strcpy(gbl.fee_type, "0356");
					wrLog("高酬金号码源fee_type change [%s]", gbl.fee_type);
				}
				break;
			case 663://揭阳
				if(!strcmp(phone_area, "揭阳"))
				{
					strcpy(gbl.fee_type, "0356");
					wrLog("高酬金号码源fee_type change [%s]", gbl.fee_type);
				}
				break;
			case 768://潮州
				if(!strcmp(phone_area, "潮州"))
				{
					strcpy(gbl.fee_type, "0356");
					wrLog("高酬金号码源fee_type change [%s]", gbl.fee_type);
				}
				break;
			case 763://清远
				if(!strcmp(phone_area, "清远"))
				{
					strcpy(gbl.fee_type, "0356");
					wrLog("高酬金号码源fee_type change [%s]", gbl.fee_type);
				}
				break;
			case 751://韶关
				if(!strcmp(phone_area, "韶关"))
				{
					strcpy(gbl.fee_type, "0356");
					wrLog("高酬金号码源fee_type change [%s]", gbl.fee_type);
				}
				break;
			case 762://河源
				if(!strcmp(phone_area, "河源"))
				{
					strcpy(gbl.fee_type, "0356");
					wrLog("高酬金号码源fee_type change [%s]", gbl.fee_type);
				}
				break;
			case 757:
				if(!strcmp(phone_area, "佛山"))
				{
					strcpy(gbl.fee_type, "0356");
					wrLog("高酬金号码源fee_type change [%s]", gbl.fee_type);
				}
			default:
				break;
			}
		}
	}
	iRet = 0;
	
	if ( biz_flag==1 )//如果是电信话费直充 电信
	{
		if(gbl.phone_no[0]=='1')//如果是手机
		{
		
			if (gbl.phone_owner != 1)
			{
				TS_OutPutMsg(gbl.dPosInfo,"\n   输入的手机号错误\n 请确认输入的手机号码\n   为电信手机号码！",1,iSelect);
				return -1;
			}

		}
		else if (gbl.phone_no[0]!='0')//如果不是手机且没输区号 //加终端地区对应的区号
		{
			char phone_no[20];
			bbzero(phone_no);
			strcpy(phone_no, gbl.phone_no);
			bbzero(gbl.phone_no);
			strcpy(gbl.phone_no, gbl.city_no);
			strcat(gbl.phone_no, phone_no);
			gbl.phone_len = strlen(gbl.phone_no);
		}
		else
		{
			NULL;
		}
	}else //如果不是电信直充
	{
			if ( biz_flag==2 || biz_flag==10)//移动话费直充
			{
				if (gbl.phone_owner!=2)

				{
					TS_OutPutMsg(gbl.dPosInfo,"\n   输入的手机号错误！\n为移动号码充值",1,iSelect);
					return -1;
				}
			}else if ( biz_flag==3 || biz_flag==4 )//联通话费直充
			{
				if (gbl.phone_owner != 3)
				{
					TS_OutPutMsg(gbl.dPosInfo,"\n   输入的手机号错误！\n为联通号码充值",1,iSelect);
					return -1;
				
				}
			}
			else
			{
				TS_OutPutMsg(gbl.dPosInfo,"\n   输入的手机号错误！\n请查证后输入",1,iSelect);
					return -1;

			}

	}
		
	
	if (input_flag == 1)
	{
		if(select == 0)
		{
			iRet = selectAmount(2, select);
		}
		else
		{
			sprintf(gbl.amount,"%012d", select * 100);
		}
		
	}else if (input_flag == 2)
	{
		NULL;
	}else
	{
		if(select == 0)
		{
			iRet = selectAmount(0, select);
		}
		else
		{
			sprintf(gbl.amount,"%012d", select * 100);
		}
		
	}
	
	if(CDB::chKChinaUnicom(gbl.fee_type, gbl.phone_no, atoi(gbl.amount))==0)
	{
		NULL;
	}
	else
	{
		bbzero(msg);
		sprintf(msg, "业务运营商规定：\n同一号码%s\n同一金额%d元\n%d分钟内不能连续充值\n请稍后再试", gbl.phone_no, atoi(gbl.amount)/100,FORBID_TIME);
		TS_OutPutMsg(gbl.dPosInfo, msg, 1, iSelect);
		return -1;
	}
	
	if (input_flag == 0 ||input_flag == 2)
	{
		if(atoi(gbl.dPosInfo.prmVer)>=9000)
		{
			bbzero(amoMny);
			CTools::chgToMny(gbl.amount,amoMny);
			bbzero(msg);
			if (memcmp(gbl.phone_no,"1",1)==0)
			{
				bbzero(phone_buff);
				memcpy(phone_buff,gbl.phone_no,3);
				strcat(phone_buff,"-");
				memcpy(phone_buff+4,gbl.phone_no+3,4);
				strcat(phone_buff,"-");
				memcpy(phone_buff+9,gbl.phone_no+7,4);
				sprintf(msg, "%s\n\n%s\t%s\n\n%s\n\n【是 Enter】  【否 Esc】", title, phone_buff, phone_area, amoMny);
			}else
				sprintf(msg, "%s\n\n%s\t%s\n\n%s\n\n【是 Enter】  【否 Esc】", title, gbl.phone_no, phone_area, amoMny);
			iRet = TS_OutPutMsg(gbl.dPosInfo, msg, 0, iSelect);
			if(iSelect)
			{
				return -1;
			}
		}
	}
	else if (input_flag == 1)
	{
		if(atoi(gbl.dPosInfo.prmVer)>=9000)
		{
			if(memcmp(gbl.phone_no,"0",1)==0)
			{
				if ((memcmp(gbl.phone_no,"02",2)==0) || (memcmp(gbl.phone_no,"01",2)==0))
				{
					bbzero(phone_no_buff);
					memcpy(phone_no_buff,gbl.phone_no,3);
					memcpy(phone_no_buff+3,"-",1);
					memcpy(phone_no_buff+4,gbl.phone_no+3,gbl.phone_len-3);
					
				}else{
					bbzero(phone_no_buff);
					memcpy(phone_no_buff,gbl.phone_no,4);
					memcpy(phone_no_buff+4,"-",1);
					memcpy(phone_no_buff+5,gbl.phone_no+4,gbl.phone_len-4);
				}
				bbzero(amoMny);
				bbzero(overdraft_mny);
				CTools::chgToMny(gbl.overdraft_amount,overdraft_mny);
				CTools::chgToMny(gbl.amount,amoMny);
				bbzero(msg);
				sprintf(msg,"号码：%s \t%s 户名：%s\n推荐业务：电信直充\n\n欠费金额：%s\n充值金额：%s\n【是 Enter】  【否 Esc】\n【请认真核对交费号码及金额】",phone_no_buff,phone_area,gbl.user_name,overdraft_mny,amoMny);
				TS_OutPutMsg(gbl.dPosInfo, msg, 0,iSelect);
				if (iSelect != 0)
				{
					return -1;
				}
			}else{
				bbzero(amoMny);
				CTools::chgToMny(gbl.amount,amoMny);
				bbzero(msg);
				
				bbzero(phone_buff);
				memcpy(phone_buff,gbl.phone_no,3);
				strcat(phone_buff,"-");
				memcpy(phone_buff+4,gbl.phone_no+3,4);
				strcat(phone_buff,"-");
				memcpy(phone_buff+9,gbl.phone_no+7,4);
				
				sprintf(msg, "%s\n\n%s\t%s\n\n%s\n\n【是 Enter】  【否 Esc】", title, phone_buff, phone_area, amoMny);
				iRet = TS_OutPutMsg(gbl.dPosInfo, msg, 0, iSelect);
				if(iSelect)
				{
					return -1;
				}
			}
		}
	}
	
	//省联通手机充值 0342:低费率 0356:高费率
	if(biz_flag == 3 && (!memcmp(gbl.fee_type, "0342", 4) || !memcmp(gbl.fee_type, "0356", 4)))
	{
		if(atoi(gbl.amount) == 3000 && !memcmp(gbl.fee_type, "0356", 4))
		{
			memcpy(gbl.fee_type, "0342", 4);
			wrLog("高酬金号码源fee_type change [%s]", gbl.fee_type);
		}
		iRet = unicom_direct_recharge(title);
		return iRet;
	}
	
	/************刷卡****************/
	flag = 0;
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{
		if(!flag)
		{
			wrLog("title before mngCard_Hdl [%s]", title);
			iRet = mngCard_Hdl(title);
			if(iRet == CANCLE_KEY)
				return CANCLE_KEY;
			else if(iRet != 0)
				return -1;
		}
		pack.wrField(2, gbl);	//写交费域
		//交费包
		iRet = packHdl(2);
		if(iRet < 0)
			return -1;
		
		memset(response_code,0,sizeof(response_code));
		memcpy(response_code,pack.FIELD39,2);
		if (!memcmp(response_code,"00",2)) 
		{
			bbzero(gbl.phone_amount);
			bbzero(phone_mny);
			bbzero(len_buff);
			memcpy(len_buff,pack.FIELD63,2);
			memcpy(gbl.phone_amount,pack.FIELD63+2+atoi(len_buff),12);
			
			bbzero(msg);
			if (atoi(gbl.phone_amount)>0)
			{
				CTools::chgToMny(gbl.phone_amount,phone_mny);					
				sprintf(msg, "      充值成功！\n号码余额：%s\n 按【确认】打印凭证",phone_mny);
			}else
			{
				strcpy(msg, "      充值成功！\n 按【确认】打印凭证");
			}
			if( biz_flag==1 )//如果是电信空充
			{
				if( strcmp(gbl.city_no, "020")==0 )//广州地区
				{
					NULL;//打凭证
				}
				else if( strcmp(gbl.city_no, "0769")==0 )//东莞地区
				{
					strcat(msg,"\n充值查询请拨11888\n【返回】退出");
				}
				else//其它地区
				{
					if( gbl.phone_no[0]!='1' )//如果是手机
					{
						NULL;//打凭证
					}
					else
					{
						strcpy(msg, "");//不打印
					}
				}
			}
			else if( biz_flag==2 || biz_flag==3 || biz_flag==4 || biz_flag==10 )//如果是移动,联通
			{
				NULL;//打凭证
			}
			else
			{
				TS_OutPutMsg(gbl.dPosInfo," \n\n      充值成功！\n请留意短信提醒或拨打11888查询",0,iSelect);
				strcpy(msg, "");//不打印
			}
			
			if( strcmp(msg, "")==0 )
			{
				NULL;//不打印
			}
			else
			{
				iRet = TS_OutPutMsg(gbl.dPosInfo,msg,0,iSelect);
				if(iRet!=0 || iSelect==0)
				{
					CPrint prt;
					prt.set_in_par(gbl);
					wrLog("title before print_detail [%s]", title);
					//prt.print_detail(2, title);
					prt.print_pre_detail(pack,title);
				}
			}
			
			return 0;
		}
		else if ( !memcmp(response_code,"80",2) && strcmp(gbl.acc_city_no, "0769")==0 && ( biz_flag==1 || biz_flag==2 ) )//东莞移动电信返回80
		{
			bbzero(party_code);
			memcpy(party_code,&pack.FIELD62[1],8);
			if(!strcmp(party_code, "20004172")||!strcmp(party_code, "P20004199")){
				if( biz_flag==1 )//电信
					iRet = TS_OutPutMsg(gbl.dPosInfo,"\n     充值待定！\n【确认】打印票据\n充值查询请拨11888\n【返回】退出",0,iSelect);
				else
					iRet = TS_OutPutMsg(gbl.dPosInfo,"\n      充值待定！\n 按【确认】打印凭证",0,iSelect);
				if(iRet!=0 || iSelect==0)
				{
					CPrint prt;
					prt.set_in_par(gbl);
				//	prt.print_detail(2, title);
					prt.print_pre_detail(pack,title);
				}
			}
			else
				returnFail(response_code);
			return 1;
		} 
		else if(!memcmp(response_code,"55",2))
		{
			flag = 1;
			if(reGetPwd(title) == 0) //密码错误，重新输入密码, 2006-10-25
				continue;
			else
				return CANCLE_KEY;
		}
		else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
			if (iSelect!=0)
			{
				return -1;
			}else
				continue;
		}
		else
			returnFail(response_code);
		return 1;	
	}
	return -1;
}

//e卡充值
int CTrade::ecardMnyIn(const char *title, int area_flag)
{
	int iRet=0, iRetB=0, iSelect=0;	
	char enqFIELD48[42+1], enqFIELD63[999+1], mark_card[30+1];
	bbzero(enqFIELD48);
	bbzero(enqFIELD63);
	bbzero(mark_card);
	strncpy(mark_card, gbl.card_no, sizeof(mark_card)-1);
	
	iRet = ecardMnyIn_Hdl(title,area_flag);
	if( gbl.get_card == MNG_ONE_BIND_E || gbl.get_card == MNG_MUL_BIND_E )//还原原先刷的卡
	{
		iRetB = bindcard(mark_card, gbl.card_no, &gbl.card_no_len);
		if(iRetB != 0)
		{
			TS_OutPutMsg(gbl.dPosInfo,"绑定原卡号出错!请挂机重连!",0,iSelect);
			TS_HangUp(gbl.dPosInfo);
		}
	}
	return iRet;
}


//e卡充值
int CTrade::ecardMnyIn_Hdl(const char *title, int area_flag)		
{
	int  iRet=0 , flag = 1 ,select_flag;
	int  iSelect=0, mngCard_count = 1;
	char money[20],tmp_amount[13], fee_type_bak[10];
	char card_info[200];
	char respone_info[1024];
	char pwd[7],oldpwd[7];
	char tips_info[1024],check_buff[10+1],keynum_buff[2+1],yj_amount[1+12+1],yj_mny[12+1],sxf_amount[1+12+1],sxf_mny[12+1];
	BYTE temp_buff[2048];
	bool isCommission = FALSE;
	char e_card[20];
    char bank_id[8] = { 0 };    //2012-11-18 , 不在通过银行编码判断扣费渠道。
	int e_card_no_len=0;
	
	wrLog("【e卡充值】");
	
	if(strcmp(gbl.mer_ecard,"")==0)
	{
		TS_OutPutMsg(gbl.dPosInfo,"本终端机未绑定e卡\n不能转账\n请联系在线客服中心【Ctrl+H】  400-80-11888\n按【确认】返回",0,iSelect);
		return 0;
	}
	else
	{
		NULL;
	}
	
	while( strcmp(gbl.mer_ecard,gbl.card_no)!=0 || strcmp(gbl.card_no,"")==0 )
	{
		if( strcmp(gbl.card_no,"")!=0 )
		{
			TS_OutPutMsg(gbl.dPosInfo,"e卡卡号与终端机绑定的卡号不一致，请重新刷e卡。\n按【确认】继续",0,iSelect);
		}
		else
		{
			NULL;
		}
		
		/**************取得卡号*******************/
		for(int curTry=0; curTry<MAXTRY; curTry++)
		{
			bbzero(card_info);
			iRet = getCardInfo(title, card_info, MNG_OR_INPUT, gbl.get_card, "请刷或输入e卡卡号", 6, 19);
			if( iRet == 0 )
				iRet = getCardNum(card_info, MNG_OR_INPUT);//取得卡号
			if( (iRet == CANCLE_KEY) )
				return CANCLE_KEY;
			else if( (iRet == RE_MNG_CARD) )
				continue;
			else if(iRet != 0)
				return -1;
			else
				break;
		}	 
	}

	//if((CDB::isSonCard(gbl.mer_ecard))==0)
	//20130105修改-yyx
	if((CDB::pep_isSonCard(gbl.dPosInfo.pos_no))==1)
	{
		TS_OutPutMsg(gbl.dPosInfo,"该e卡为资金池的子卡\n不能转账\n按【确认】返回",0,iSelect);
		return 0;
	}
	
	bbzero(e_card);
	wrLog("gbl.card_no_len:%d",gbl.card_no_len);
	memcpy(e_card, gbl.card_no, gbl.card_no_len);
	bbzero(gbl.card_no);
	strcpy(gbl.card_no, e_card);
	e_card_no_len=gbl.card_no_len;
	wrLog("e卡号[%d]：[%s]",e_card_no_len,e_card);

	flag = 0;
	/********************请求刷卡****************/
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{
		if(!flag) 
		{
			bbzero(card_info);
			if( gbl.get_card == MNG_ONE_BIND_E || gbl.get_card == MNG_MUL_BIND_E )
				iRet = getCardInfo( title, card_info, ONLY_MNG, MNG_MUL, "请刷卡");//只能刷卡，多次刷卡模式
			else
				iRet = getCardInfo( title, card_info, ONLY_MNG, gbl.get_card, "请刷卡");//刷卡取得卡信息
			
			if(iRet==0)
				iRet = getCardNum(card_info);
			
			if( (iRet == CANCLE_KEY) )
				return CANCLE_KEY;
			else if( (iRet == RE_MNG_CARD) )
				return RE_MNG_CARD;
			else if(iRet != 0)
				return -1;
		}
		
		bbzero(gbl.fee_type);
		strcpy(gbl.fee_type,"0264");
		pack.wrField(1, gbl);	//写查询域
		/*----------------------------------*/
		bbzero(pack.FIELD3);
		CTools::hex_to_byte((BYTE *)"310000", pack.FIELD3, 6);
		//CTools::hex_to_byte((BYTE *)"310060", pack.FIELD3, 6);
		bbzero(pack.FIELD48);
		memcpy(pack.FIELD48, gbl.fee_type, 4);
		pack.Packet_Table[48].Real_Length = 4;
		memcpy(pack.FIELD48+4, "00", 2);
		pack.Packet_Table[48].Real_Length += 2;
		
		bbzero(pack.FIELD2);
		memset((char *)temp_buff,0,sizeof(temp_buff));
		strcpy((char *)temp_buff,gbl.card_no);
		if(gbl.card_no_len%2)		//卡号是奇数，后补"F"
		{
			strcat((char *)temp_buff,"F");
		}
		CTools::hex_to_byte((BYTE *)temp_buff, pack.FIELD2, gbl.card_no_len, 1);	//变为bcd码（后补0）
		pack.Packet_Table[2].Real_Length=gbl.card_no_len;
		
		/*----------------------------------*/
		//打查询包
		iRet = packHdl(1);
		if(iRet < 0)
			return -1;
		
		if (!memcmp(pack.FIELD39,"00",2)) {
			bbzero(check_buff);
			memcpy(check_buff, (char *)pack.FIELD63, 2);
			bbzero(gbl.bank);
			memcpy(gbl.bank,(char *)pack.FIELD63+2,6);
            memcpy(bank_id , (char*)pack.FIELD63+8 , 2);
			bbzero(keynum_buff);
			memcpy(keynum_buff,(char *)pack.FIELD63+8,2);
			gbl.key_num = atoi(keynum_buff);
			wrLog("银行代码：【%s】  密钥号：【%d】",gbl.bank,gbl.key_num);
			if (memcpy(bank_id, "18", 2) == 0) {
				gbl.key_num = 8; //走银联
				bbzero(gbl.bank);
				strcpy(gbl.bank,"305810");
				
				//TS_OutPutMsg(gbl.dPosInfo,"提示：您的签约银行卡属于非优惠银行\n\n银行转账手续费按照转账金额的0.4%收取\n在酬金结算中统一扣除\n确认转账请按【确认】",0,iSelect);				
				//	if (iSelect!=0)
				//	{
				//		return -1;
				//	}
			}

			if (memcmp(check_buff,"00",2)==0)
			{
				select_flag = 2;
			} 
			else if (memcmp(check_buff,"01",2)==0)
			{
				select_flag = 1;
			}else if(memcmp(check_buff, "03", 2) == 0)		//-----------添加的新内容(免费银行)
			{
				select_flag = 4;
			}
			else
			{
				select_flag = 3;
			}

		} else if (!memcmp(pack.FIELD39,"40",2)) {
			select_flag = 1;
			gbl.key_num = 8; //走银联
			bbzero(gbl.bank);
			strcpy(gbl.bank,"305810");
			
			TS_OutPutMsg(gbl.dPosInfo,"提示：您的签约银行卡属于非优惠银行\n\n银行转账手续费按照转账金额的0.4%收取\n在酬金结算中统一扣除\n确认转账请按【确认】",0,iSelect);
			
			if (iSelect!=0)
			{
				return -1;
			}
		} else{
			TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
			if (iSelect!=0)
			{
				return -1;
			}else
				continue;
		}
		
		
		TSTradeInfoSend tradeInfoSend;
		TSTradeInfoRecv tradeInfoRecv;
		
		for(int curTry1=0; curTry1<MAXTRY; curTry1++)
		{
			
			memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
			memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
			
			strcpy(tradeInfoSend.acMainTitle, title);
			tradeInfoSend.uHasTradeID = 1;
			tradeInfoSend.uTotalContents = 1;
			
			
			strcpy(tradeInfoSend.Contents[0].acTitle, "请输入转账金额(转账金额请大于3元)");	
			tradeInfoSend.Contents[0].uMinLen = 1;		
			tradeInfoSend.Contents[0].uMaxLen = 5;
			tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
			tradeInfoSend.Contents[0].uCount = 0;		//输入1次		
			tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
			
			memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
			iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
			if(iRet != 0)
			{
				if(iRet == 1 || iRet ==2)
					wrLog("【e卡充值】输入金额用户取消或超时");
				else
					wrLog("【e卡充值】输入金额失败");
				wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
				return -1;
			}
			bbzero(gbl.amount);
			bbzero(tmp_amount);
			strcpy(tmp_amount, (char *)tradeInfoRecv.Contents[0].uMsg);	//读入金额
			sprintf(gbl.amount,"%010s00",tmp_amount);
			
			if(atoi(gbl.amount)>2000000)
			{
				TS_OutPutMsg(gbl.dPosInfo, "超过最大转账金额(2万元)\n【确认】重新输入\n【返回】退出", 0, iSelect);
				if(iSelect)
					return CANCLE_KEY;
				else
					continue;
			} else {
				bbzero(tips_info);
				bbzero(money);
				CTools::chgToMny(gbl.amount,money);
				
				wrLog("select_flag [%d]",select_flag);

				if (atoi(gbl.amount)<=300)
				{
					continue;
				}
				else if ((select_flag == 2) && (atoi(gbl.amount)<200000))
				{
					sprintf(tips_info,"转账金额：%s\n\n提示：该笔转账金额小于2000元，需缴纳银行转账手续费2元\n\n建议：转账2000元以上，可免手续费。\n使用建设银行卡，任意金额都可以免手续费。\n如有疑问请联系在线客服【861】。\n\n【确认】转账\n【返回】重新输入",money);
					isCommission = TRUE;
				}else if(select_flag == 2)
				{
					sprintf(tips_info,"转账金额：%s\n\n提示：该笔转账金额大于等于2000元，手续费为0元\n\n【确认】转账\n【返回】重新输入",money);
				}else if ((select_flag == 3))
				{
					sprintf(tips_info,"转账金额：%s\n\n提示：建设银行卡   手续费为0元\n\n【确认】转账\n【返回】重新输入",money);
					
				}else if(select_flag == 4 && (atoi(gbl.amount) < 50000))
				{
					sprintf(tips_info, "转账金额：%s\n\n提示：该笔转账金额小于500元，需缴纳银行转账手续费2元\n\n建议：转账500元以上，可免手续费。\n使用建设银行卡，任意金额都可以免手续费。\n如有疑问请联系在线客服【861】。\n\n【确认】转账\n【返回】重新输入",money);
					isCommission = TRUE;
				}else if(select_flag == 4)
				{
					sprintf(tips_info, "转账金额：%s\n\n提示：该笔转账金额大于等于500元，手续费为0元\n\n【确认】转账\n【返回】重新输入",money);
				}else
				{
					sprintf(tips_info,"转账金额：%s\n\n提示：建议您使用建设银行等优惠银行借记卡进行签约转账。详情请见【862】\n\n【确认】转账\n【返回】重新输入",money);
					isCommission = TRUE;
				}
				
				iRet = TS_OutPutMsg(gbl.dPosInfo, tips_info, 0, iSelect);
				
				if(iSelect)
					continue;
				else{
					memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
					strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
					break;
				}
			}
		}
		
		
		wrLog("gbl.amount: [%s]", gbl.amount);
		
		if((iRet < 0) || (iRet == CANCLE_KEY))
			return -1;
		
		if (memcmp(bank_id ,"17",2)==0 || memcmp(bank_id ,"18",2)==0)	//资金归集
		{
			wrLog("走资金归集");
			iRet=checkPwdNotNull();//检测转账密码是否为空，若为空则返回非0
			if(atoi(gbl.dPosInfo.prmVer)<9000)			//EPOS不使用转账密码的修改
			{
				wrLog("Epos不检查转账密码");
				iRet = 0;
			}
			
			wrLog("checkPwdNotNull() iRet: [%d]", iRet);
			if(iRet==-1){
				TS_OutPutMsg(gbl.dPosInfo, "连接转账密码服务器错误!\n请稍候再试!\n或联系在线客服中心【Ctrl+H】  400-80-11888", 0, iSelect);
				return -1;		   
			}else if(iRet==14||iRet==91){
				wrLog("卡号[%d]：[%s]",gbl.card_no_len,gbl.card_no);
				int flag = 0;
				for(int curTry=0; curTry<MAXTRY; curTry++)
				{
					bbzero(gbl.fee_type);
					strcpy(gbl.fee_type,"0177");
					if(flag==0){
						iRet = getCardPwd(title);	//取得密码
						if( (iRet == CANCLE_KEY) )
							return CANCLE_KEY;
						else if( (iRet == RE_MNG_CARD) )
							return RE_MNG_CARD;
						else if(iRet != 0)
							return -1;
					}
					bbzero(tmp_amount);
					strcpy(tmp_amount,gbl.amount);
					bbzero(gbl.amount);
					strcpy(gbl.amount,"000000000001");
					pack.wrField(2, gbl);	//写交费域
					/*----------------------------------*/
					
					bbzero(pack.FIELD48);
					memcpy(pack.FIELD48, gbl.fee_type, 4);
					strncat((char *)pack.FIELD48, "00", 2);
					pack.Packet_Table[48].Real_Length = 6;
					
					bbzero(pack.FIELD63);
					memcpy(pack.FIELD63,gbl.random_num,8);
					pack.Packet_Table[63].Real_Length = 8;
					/*----------------------------------*/
					//打查询包
					iRet = packHdl(2);
					if(iRet < 0)
						return -1;
					
					if (!memcmp(pack.FIELD39,"00",2)) 
					{  
						TS_OutPutMsg(gbl.dPosInfo, "【提示】接银行方通知，实时转帐到交费易需使用转帐密码。\n\n请设置您的转帐密码并保管好转帐密码。\n\n按【确认】继续", 0, iSelect);
						break;
					}
					else if(!memcmp(pack.FIELD39,"55",2) || !memcmp(pack.FIELD62, "P20004855", 9))
					{
						flag = 1;
						if(reGetPwd(title) == 0) //密码错误，重新输入密码
							continue;
						else
							return CANCLE_KEY;
					}
					else
					{
						iRet = banReturnFail((char *)pack.FIELD39);
						return -1;
					}
				}
				
				memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
				memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
				
				strcpy(tradeInfoSend.acMainTitle, "e卡充值");
				tradeInfoSend.uHasTradeID = 1;
				tradeInfoSend.uTotalContents = 1;				   
				strcpy(tradeInfoSend.Contents[0].acTitle, "请设置转账密码");
				tradeInfoSend.Contents[0].uCommand = TS_INPUT_PWD;	//密码
				tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME + 10;	//超时40秒
				tradeInfoSend.Contents[0].uCount = 1;		//输入2次
				tradeInfoSend.Contents[0].uMinLen = 6;		
				tradeInfoSend.Contents[0].uMaxLen = 6;
				
				iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
				if(iRet != 0)
				{
					wrLog("TS_TradeControl返回错误[%d]", iRet);
					wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
					return iRet;
				}
				memset(pwd,0,sizeof(pwd) );
				memcpy(pwd,(char *)tradeInfoRecv.Contents[0].uMsg,tradeInfoRecv.Contents[0].uMsgLen);  
				memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
				strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
				bbzero(oldpwd);
				iRet=setTransferPwd(pwd,oldpwd);
				wrLog("初次设置转账密码setTransferPwd(pwd,oldpwd) iRet: [%d]", iRet);
				if(iRet != 0)
				{
					switch(iRet)
					{
					case 94:
						TS_OutPutMsg(gbl.dPosInfo, "设置转账密码过程中，网络不稳定，包格式错误!\n请稍候再试!\n或联系在线客服中心【Ctrl+H】  400-80-11888", 0, iSelect);
						break;
					case 96:
						TS_OutPutMsg(gbl.dPosInfo, "设置转账密码过程中，网络不稳定，数据库操作出错!\n请稍候再试!\n或联系在线客服中心【Ctrl+H】  400-80-11888", 0, iSelect);
						break;
					case -1:
						TS_OutPutMsg(gbl.dPosInfo, "连接转账密码服务器错误!\n请稍候再试!\n或联系在线客服中心【Ctrl+H】  400-80-11888", 0, iSelect);
						break;
					default:
						TS_OutPutMsg(gbl.dPosInfo, "网络繁忙，操作出错!\n请稍候再试!\n或联系在线客服中心【Ctrl+H】  400-80-11888", 0, iSelect);
						break;
					}
					return -1;
				}
				bbzero(gbl.amount);
				strcpy(gbl.amount,tmp_amount);
				bbzero(gbl.fee_type);
				if (select_flag == 3){
					if (area_flag == 0)
					{
						strcpy(gbl.fee_type,"0301");
					}else
						strcpy(gbl.fee_type,"0302");
				}else if(select_flag == 4){
					if(area_flag == 0){
						strcpy(gbl.fee_type, "0339");
					}else{
						strcpy(gbl.fee_type, "0340");
					}
				}else{
					if (area_flag == 0)
					{
						strcpy(gbl.fee_type,"0221");
					}else
						strcpy(gbl.fee_type,"0268");
				}
		   } else if(iRet==0){	   
			   //	iRet=checkTransferPwd_Hdl("e卡充值"); 
			   //	if (iRet!=0)
			   //	{
			   //		return -1;
			   //	}
			   bbzero(gbl.fee_type);
			   if (select_flag == 3){
				   if (area_flag == 0)
				   {
					   strcpy(gbl.fee_type,"0301");
				   }else
					   strcpy(gbl.fee_type,"0302");
			   }else if(select_flag == 4){
				   if(area_flag == 0){
					   strcpy(gbl.fee_type, "0339");
				   }else{
					   strcpy(gbl.fee_type, "0340");
				   }
			   }else{
				   if (area_flag == 0)
				   {
					   strcpy(gbl.fee_type,"0221");
				   }else
					   strcpy(gbl.fee_type,"0268");
			   }
			   
			   if(atoi(gbl.dPosInfo.prmVer)>=9000)	//IPOS检查转帐密码
			   {
				   iRet=checkTransferPwd_Hdl("e卡充值"); 
				   if (iRet!=0)
				   {
					   if(iRet==CANCLE_KEY)
					   {
					    return CANCLE_KEY;
					   }
					   else
					   {
				
						info("转账密码校验失败\n如您遗忘您的转账密码，请拨打400-80-11888客服电话咨询!\n");
						 return -1;

					   }
					   
					
				   }
			   }
			   else
			   {
				   bbzero(fee_type_bak);
				   strcpy(fee_type_bak, gbl.fee_type);

				  // strcpy(gbl.fee_type, "0238");
				   wrLog("资金归集EPOS不检验转帐密码，银行卡余额查询");
				   iRet = getCardPwd(title);	//取得密码
				   if( (iRet == CANCLE_KEY) )
					   return CANCLE_KEY;
				   else if( (iRet == RE_MNG_CARD) )
					   return RE_MNG_CARD;
				   else if(iRet != 0)
					   return -1;
#if 0				   
				   //银行卡余额查询
				   bbzero(gbl.phone_no);
				   strcpy(gbl.phone_no,"00000000");
				   gbl.phone_len = strlen(gbl.phone_no);
				   pack.wrField(2, gbl);	//写交费域
				   //----------------------------------
				   bbzero(pack.FIELD3);
				   CTools::hex_to_byte((BYTE *)"310060", pack.FIELD3, 6);
				   bbzero(pack.FIELD48);
				   memcpy(pack.FIELD48, gbl.fee_type, 4);
				   pack.Packet_Table[48].Real_Length = 4;
				   //----------------------------------
				   //打查询包
				   iRet = packHdl(1);
				   if(iRet < 0)
					   return -1;
				   
				   if (!memcmp(pack.FIELD39,"00",2)) 
				   {
					   bbzero(tmp_amount);
					   memcpy(tmp_amount, (char *)pack.FIELD63, 12);
					   wrLog("银行卡余额:%s", tmp_amount);
					   if(atoi(tmp_amount) < atoi(gbl.amount))
					   {
						   TS_OutPutMsg(gbl.dPosInfo, "银行卡余额不足，转帐失败\n   按【确认】返回\n", 0, iSelect);
						   return -1;
					   }
				   }
				   else
				   {
					   TS_OutPutMsg(gbl.dPosInfo, "银行卡余额查询失败，转帐失败\n   按【确认】返回\n", 0, iSelect);
					   return -1;
				   }
#endif
				   strcpy(gbl.fee_type, fee_type_bak);
			   }
			   
		   } else{
			   TS_OutPutMsg(gbl.dPosInfo, "检测转账密码出错!\n请稍候再试!\n或联系在线客服中心【Ctrl+H】  400-80-11888", 0, iSelect);
			   return -1;		   
		   }
		}else if (select_flag == 2)
		{
			bbzero(gbl.fee_type);
			if (area_flag == 0)
			{
				strcpy(gbl.fee_type,"0221");
			}else
				strcpy(gbl.fee_type,"0268");
			iRet = getCardPwd(title);	//取得密码
			if( (iRet == CANCLE_KEY) )
				return CANCLE_KEY;
			else if( (iRet == RE_MNG_CARD) )
				return RE_MNG_CARD;
			else if(iRet != 0)
				return -1;
		}else if (select_flag == 1)
		{
			bbzero(gbl.fee_type);
			if (area_flag == 0)
			{
				strcpy(gbl.fee_type,"0083");
			}else
				strcpy(gbl.fee_type,"0109");
			iRet = getCardPwd(title);	//取得密码
			if( (iRet == CANCLE_KEY) )
				return CANCLE_KEY;
			else if( (iRet == RE_MNG_CARD) )
				return RE_MNG_CARD;
			else if(iRet != 0)
				return -1;
		}else if (select_flag == 3)
		{
			bbzero(gbl.fee_type);
			if (area_flag == 0)
			{
				strcpy(gbl.fee_type,"0301");
			}else
				strcpy(gbl.fee_type,"0302");
			iRet = getCardPwd(title);	//取得密码
			if( (iRet == CANCLE_KEY) )
				return CANCLE_KEY;
			else if( (iRet == RE_MNG_CARD) )
				return RE_MNG_CARD;
			else if(iRet != 0)
				return -1;
		}else if(select_flag == 4){
			bbzero(gbl.fee_type);
			if (area_flag == 0)
			{
				strcpy(gbl.fee_type,"0339");
			}else
				strcpy(gbl.fee_type,"0340");
			iRet = getCardPwd(title);	//取得密码
			if( (iRet == CANCLE_KEY) )
				return CANCLE_KEY;
			else if( (iRet == RE_MNG_CARD) )
				return RE_MNG_CARD;
			else if(iRet != 0)
				return -1;
		}else
			return -1;
		
		if(isCommission && gbl.commission_free > 0)
		{
			gbl.commission_free--;
			CDB::update_commission_free(gbl.pos_no,gbl.commission_free);
			if (area_flag == 0)
				strcpy(gbl.fee_type,"0301");
			else
				strcpy(gbl.fee_type,"0302");
		}
		
		bbzero(gbl.phone_no);   //e卡卡号
		strcpy(gbl.phone_no, e_card);
		gbl.phone_len = e_card_no_len;
		pack.wrField(2, gbl);	//写交费域
		if(gbl.posInfo.enyFlag)		//加密改造
		{
			if (strcmp(gbl.bank,"647810")==0)	//人行
			{
				bbzero(pack.FIELD46);
				memcpy(pack.FIELD46, "AF01", 4);
				pack.Packet_Table[46].Real_Length = 4;
			}
			else if(strcmp(gbl.bank,"777810")==0)		//ChinaPay
			{
				bbzero(pack.FIELD46);
				memcpy(pack.FIELD46, "AF03", 4);
				pack.Packet_Table[46].Real_Length = 4;
			}
			else if (strcmp(gbl.bank,"305810")==0)		//银联
			{
				bbzero(pack.FIELD46);
				pack.FIELD46[0] = 0x39;
				pack.FIELD46[1] = 0x66;
				pack.Packet_Table[46].Real_Length = 2;
			}

			else if (strcmp(gbl.bank,"327810")==0)		
			{
				bbzero(pack.FIELD46);
				memcpy(pack.FIELD46, "AF08", 4);
				pack.Packet_Table[46].Real_Length = 4;
			}


		}
		
		/*-打8583包-*/
		iRet = packHdl(2);
		if(iRet < 0)
			return -1;
		
		if (!memcmp(pack.FIELD39,"00",2)) 
		{ 
			char eAmount[20];
			char eBalance[20];
			char eMnyBuf[13];
			
			bbzero(eMnyBuf);
			memcpy(eMnyBuf,pack.FIELD63,12);
			bbzero(eAmount);			
            CTools::chgToMny(eMnyBuf,eAmount);
			wrLog("充值金额:%s",eAmount);
			
			bbzero(eMnyBuf);
			memcpy(eMnyBuf,pack.FIELD63+13,12);
			bbzero(eBalance);			
            CTools::chgToMny(eMnyBuf,eBalance);
			wrLog("卡内余额:%s",eBalance);
			
			bbzero(yj_amount);
			memcpy(yj_amount,pack.FIELD63+13+12+8,1+12);			
			if (memcmp(yj_amount,"D",1)==0)
			{
				memcpy(yj_amount, "-", 1);
			}
			else
			{
				memcpy(yj_amount, "0", 1);
			}
			
			bbzero(yj_mny);
			CTools::chgToMny(yj_amount,yj_mny,0);
			
			bbzero(sxf_amount);
			memcpy(sxf_amount,pack.FIELD63+13+12+8+13,1+12);			
			if (memcmp(sxf_amount,"D",1)==0)
			{
				memcpy(sxf_amount, "-", 1);
			}
			else
			{
				memcpy(sxf_amount, "0", 1);
			}
			
			bbzero(sxf_mny);
			CTools::chgToMny(sxf_amount,sxf_mny,0);
			
			bbzero(respone_info);
			if(atoi(gbl.dPosInfo.prmVer)>=9000)
			{
				getHeadPage(gbl.tgroup, gbl.term_level, new_message, gbl.title_flag, gbl.dPosInfo.pos_no, eBalance, yj_mny, (char *)respone_info);
				TS_UpdateHeadPage(gbl.dPosInfo, respone_info);
			}
			
			bbzero(respone_info);
			sprintf(respone_info,"     转账成功！\n转账金额：%s\n银行手续费：%s\ne卡余额：%s\n酬金：%s\n按【确认】退出",eAmount,sxf_mny,eBalance,yj_mny);	
			TS_OutPutMsg(gbl.dPosInfo,respone_info, 0, iSelect);
			
			return 0;
		}
		else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
			if (iSelect!=0)
			{
				return -1;
			}else
				continue;
		}
		else
			iRet = returnFail((char *)pack.FIELD39);
		return -1;
	}
	return -1;
}


//e卡充值申请
int CTrade::ecardAppli(const char *title)
{
	int iRet=0, iRetB=0, iSelect=0;
	char mark_card[30+1];
    
	//if((CDB::isSonCard(gbl.mer_ecard))==0)
	//20130105修改-yyx
	if(CDB::pep_isSonCard(gbl.dPosInfo.pos_no)==1)
	{
		TS_OutPutMsg(gbl.dPosInfo,"该e卡为资金池的子卡\n不能充值\n按【确认】返回",0,iSelect);
		return -1;
	}
	
	if(atoi(gbl.dPosInfo.prmVer)>=9000)
	{
		iRet = checkPEPwd_Hdl("修改交易密码");
		if(iRet!=0)
			if(iRet==CANCLE_KEY)
				return CANCLE_KEY;
			else
			{	
				info("老板密码校验错误\n\n请联系在线客服中心【Ctrl+H】  400-80-11888\n\n按【Enter】确认返回主菜单。");
				return iRet;
				
			}
	}
	
	bbzero(mark_card);
	strncpy(mark_card, gbl.card_no, sizeof(mark_card)-1);
	iRet = ecardAppli_Hdl(title);
	iRetB = bindcard(mark_card, gbl.card_no, &gbl.card_no_len);
	if(iRetB != 0)
	{
		TS_OutPutMsg(gbl.dPosInfo,"绑定原卡号出错!请挂机重连!",0,iSelect);
		TS_HangUp(gbl.dPosInfo);
	}
	return iRet;
}

int CTrade::ecardAppli_Hdl(const char *title)
{
	int iSelect, iRet, j, pay_flag, b63_len=0;
	char bank[7], date[13], account[31], amount[13];
	char tmp_len[5], rsp_code[3];
	
	wrLog("e卡充值登记");
	strcpy(gbl.fee_type, "0171");
	
	if( gbl.group_type == 0 ){
		TS_OutPutMsg(gbl.dPosInfo, "公司帐户名称更改为<天讯瑞达通信技术有限公司>，请您在银行或网银进行E卡转帐时使用此帐户名称，谢谢！", 0, iSelect);
	}
	
	/*---------------------------*/
	TSMENULIST menuList;
	for(int i=0; i<2; i++)   //先选择银行，后选择充值方式
	{
		memset(&menuList,0,sizeof(menuList));
		menuList.iTotalNum = 2;
		strcpy(menuList.acTitle, title);
		for(j=0; j<menuList.iTotalNum; j++)
			bbzero(menuList.menuItem[j]);
		if(i == 0)
		{
			strcpy(menuList.menuItem[0], "农业银行(天讯帐户)");
			strcpy(menuList.menuItem[1], "工商银行(天讯帐户)");
			bbzero(bank);
		}
		else
		{
			strcpy(menuList.menuItem[0], "现金");
			strcpy(menuList.menuItem[1], "转帐(商户帐户)");
			bbzero(account);
		}
		iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
		if(iRet)
			return -1;
		switch(iSelect)
		{
		case 1:
			if(i == 0)
				strcpy(bank, "635810");
			else
			{
				pay_flag = 2;
				strcpy(account, "0000");
			}
			break;			
		case 2:
			if(i == 0)
				strcpy(bank, "625810");
			else
				pay_flag = 1;
			break;
		default: 
			return CANCLE_KEY;
		}
	}
	/******************数据采集************************/
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv; 
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	strcpy(tradeInfoSend.acMainTitle, title);
	tradeInfoSend.uHasTradeID = 1;
	
	if(pay_flag == 1)	//转帐
		tradeInfoSend.uTotalContents = 3;
	else
		tradeInfoSend.uTotalContents = 2;
	
	gbl.key_num = 1;
	if(pay_flag == 1)  //转帐
	{
		strcpy(tradeInfoSend.Contents[0].acTitle, "转帐时间(年/月/日/时/分,例:200707091023)");
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;
		tradeInfoSend.Contents[0].uMinLen = 12;		
		tradeInfoSend.Contents[0].uMaxLen = 12;
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
		
		strcpy(tradeInfoSend.Contents[1].acTitle, "转帐金额：");	
		tradeInfoSend.Contents[1].uCommand = TS_INPUT_MONEY;
		tradeInfoSend.Contents[1].uTimeOut = EPOS_OVER_TIME;	//超时30秒
		tradeInfoSend.Contents[1].uMinLen = 3;		
		tradeInfoSend.Contents[1].uMaxLen = 9;
		
		strcpy(tradeInfoSend.Contents[2].acTitle, "请输入付款人帐号：");
		tradeInfoSend.Contents[2].uCommand = TS_INPUT_MATH;
		tradeInfoSend.Contents[2].uDesMode = TS_NO_ENC;
		tradeInfoSend.Contents[2].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
		tradeInfoSend.Contents[2].uMinLen = 10;		
		tradeInfoSend.Contents[2].uMaxLen = 30;
		
	}
	else //现金
	{
		strcpy(tradeInfoSend.Contents[0].acTitle, "存款时间(年/月/日/时/分,例:200707091023)");
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;
		tradeInfoSend.Contents[0].uMinLen = 12;		
		tradeInfoSend.Contents[0].uMaxLen = 12;
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
		
		strcpy(tradeInfoSend.Contents[1].acTitle, "存款金额：");	
		tradeInfoSend.Contents[1].uCommand = TS_INPUT_MONEY;
		tradeInfoSend.Contents[1].uTimeOut = EPOS_OVER_TIME;	//超时30秒
		tradeInfoSend.Contents[1].uMinLen = 3;		
		tradeInfoSend.Contents[1].uMaxLen = 9;
	}
	/*******************end一次采集*************************/
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	bbzero(date);
	strcpy(date, (char *)tradeInfoRecv.Contents[0].uMsg);
	bbzero(amount);
	memcpy(amount, "000000000000", 12-tradeInfoRecv.Contents[1].uMsgLen);
	strcat(amount, (char *)tradeInfoRecv.Contents[1].uMsg);
	if(pay_flag==1)
	{
		bbzero(account);
		strcpy(account, (char *)tradeInfoRecv.Contents[2].uMsg);
	}
	
	int flag = 0;
	int get_card = 0;
	switch(gbl.get_card)
	{
	case MNG_ONE:
		get_card=MNG_MUL;
		break;
	case MNG_ONE_BIND:
		get_card=MNG_MUL_BIND;
		break;
	case MNG_ONE_BIND_E:
		get_card=MNG_MUL_BIND_E;
		break;
	}
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{
		if(!flag)
		{
			iRet = mngCard_Hdl(title, "", 0, get_card);
			if(iRet == CANCLE_KEY)
				return CANCLE_KEY;
			else if(iRet != 0)
				return -1;
		}
		pack.wrField(2, gbl);
		/*******************修改部分包内容****************/
		bbzero(pack.FIELD3);
		CTools::hex_to_byte((BYTE *)"310060", pack.FIELD3, 6);
		//bit48
		bbzero(pack.FIELD48);
		memcpy(pack.FIELD48, gbl.fee_type, 4);
		strncat((char *)pack.FIELD48, "00", 2);
		pack.Packet_Table[48].Real_Length = 6;
		//bit63
		bbzero(pack.FIELD63);
		memcpy((char *)pack.FIELD63, gbl.random_num, 8);
		b63_len = 8;
		memcpy((char *)pack.FIELD63+b63_len, bank, 6);
		b63_len += 6;
		bbzero(tmp_len);
		sprintf(tmp_len, "%02d", strlen(account));
		memcpy((char *)pack.FIELD63+b63_len, tmp_len, 2);
		b63_len += 2;
		memcpy((char *)pack.FIELD63+b63_len, account, atoi(tmp_len));
		b63_len += atoi(tmp_len);
		memcpy((char *)pack.FIELD63+b63_len, amount, 12);
		b63_len += 12;
		memcpy((char *)pack.FIELD63+b63_len, date, 12);
		b63_len += 12;
		pack.Packet_Table[63].Real_Length = b63_len;
		wrLog("BIT63: [%s]", (char *)pack.FIELD63);
		/**************************************************/
		//  查询包打包   
		iRet = packHdl(1);
		if(iRet < 0)
			return -1;
		//返回数据给终端
		bbzero(rsp_code);
		memcpy(rsp_code, pack.FIELD39, 2);
		if (!memcmp(rsp_code,"00",2)) 
		{
			iRet = TS_OutPutMsg(gbl.dPosInfo, " \n\n 该笔申请提交成功！\n注意：请勿重复提交！", 0,iSelect);
		}
		else if(!memcmp(rsp_code,"55",2))
		{
			flag = 1;
			iRet = reGetPwd(title);
			if(iRet == 0) //密码错误，重新输入密码, 2006-10-25
				continue;
			else
				return CANCLE_KEY;
		}
		else
		{
			iRet = returnFail(rsp_code);
		}
		
		return iRet;
	}
	return -1;
}

//最新电影折扣票，2007-08-06
int CTrade::filmPay(const char *title)
{
	int iRet, iSelect, flag, b48_len, b63_len;
	char tmp[512], response_code[3];
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv; 
	
	wrLog("【最新电影折扣票】");
	strcpy(gbl.fee_type, "0173");
	bbzero(tmp);
	strcpy(tmp, "三个月内看青宫影院任一场次，凭短信票号到青宫领票或凭打印票据领票\n按【确认】键继续");
	iRet = TS_OutPutMsg(gbl.dPosInfo, tmp, 0,iSelect);
	if(iSelect)
		return CANCLE_KEY;
	
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	strcpy(tradeInfoSend.acMainTitle, title);
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 3;
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入购票张数(票价40元)");
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
	tradeInfoSend.Contents[0].uMinLen = 1;
	tradeInfoSend.Contents[0].uMaxLen = 1;
	
	strcpy(tradeInfoSend.Contents[1].acTitle, "请输入证件号码：");
	tradeInfoSend.Contents[1].uCommand = TS_INPUT_MATH;
	tradeInfoSend.Contents[1].uTimeOut = EPOS_OVER_TIME + 10;	//超时40秒
	tradeInfoSend.Contents[1].uMinLen = 1;
	tradeInfoSend.Contents[1].uMaxLen = 25;
	
	strcpy(tradeInfoSend.Contents[2].acTitle, "输入手机号码(小灵通加区号)");
	tradeInfoSend.Contents[2].uCommand = TS_INPUT_MATH;
	tradeInfoSend.Contents[2].uTimeOut = EPOS_OVER_TIME;	//超时30秒
	tradeInfoSend.Contents[2].uMinLen = 11;
	tradeInfoSend.Contents[2].uMaxLen = 11;
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	
	gbl.num = atoi((char *)tradeInfoRecv.Contents[0].uMsg);
	bbzero(gbl.id_num);
	strcpy(gbl.id_num, (char *)tradeInfoRecv.Contents[1].uMsg);
	bbzero(gbl.phone_no);
	strcpy(gbl.phone_no, (char *)tradeInfoRecv.Contents[2].uMsg);
	gbl.phone_len = strlen(gbl.phone_no);
	bbzero(gbl.pos_serial);
	strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
	bbzero(tmp);
	sprintf(tmp, "%d", gbl.num*40);
	CTools::chg12asc(tmp, gbl.amount);
	
	/*--------------------*/
	wrLog("证件号码：[%s]", gbl.id_num);
	wrLog("电话号码：[%s]", gbl.phone_no);
	wrLog("金额：[%s]", gbl.amount);
	/*--------------------*/
	
	bbzero(tmp);
	sprintf(tmp, "请确认以下信息：\n证件号码：%s\n手机号码：%s\n购票数量：%d张\n总价：%d元", gbl.id_num, gbl.phone_no, gbl.num, gbl.num*40);
	iRet = TS_OutPutMsg(gbl.dPosInfo, tmp, 0,iSelect);
	if(iSelect)
		return CANCLE_KEY;
	//刷卡
	flag = 0;
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{
		if(!flag)
		{
			iRet = mngCard_Hdl(title);
			if(iRet == CANCLE_KEY)
				return CANCLE_KEY;
			else if(iRet != 0)
				return -1;
		}
		pack.wrField(2, gbl);	//写交费域
		/********************************/
		memset(pack.FIELD48,0,sizeof(pack.FIELD48));  //bit48
		memcpy((char *)pack.FIELD48,gbl.fee_type,4);	//业务代码
		b48_len = 4;
		strcat((char *)pack.FIELD48, "04");  //电影院编码长度
		b48_len += 2;
		strcat((char *)pack.FIELD48, "0001");
		b48_len += 4;
		pack.Packet_Table[48].Real_Length = b48_len;
		//bit63
		memset(pack.FIELD63,0,sizeof(pack.FIELD63));  //bit63
		memcpy((char *)pack.FIELD63, gbl.random_num, 8);
		b63_len = 8;
		sprintf((char *)pack.FIELD63 + b63_len, "%03d", gbl.num);
		b63_len += 3;
		sprintf((char *)pack.FIELD63 + b63_len, "%02d", gbl.phone_len);  //电话号码长度
		b63_len += 2;
		strcat((char *)pack.FIELD63, gbl.phone_no);
		b63_len += gbl.phone_len;
		sprintf((char *)pack.FIELD63 + b63_len, "%02d", strlen(gbl.id_num));  //证件长度
		b63_len += 2;
		strcat((char *)pack.FIELD63, gbl.id_num);
		b63_len += strlen(gbl.id_num);
		strcat((char *)pack.FIELD63, "00"); //姓名为空
		b63_len += 2;
		pack.Packet_Table[63].Real_Length = b63_len;
		/********************************/
		
		iRet = packHdl(2);
		if(iRet < 0)
			return -1;
		memset(response_code,0,sizeof(response_code));
		memcpy(response_code,pack.FIELD39,2);
		if (!memcmp(response_code,"00",2)) 
		{
			iRet = TS_OutPutMsg(gbl.dPosInfo,"     购票成功！\n   请留意短信提醒\n如有疑问请拨打400-80-11888\n 按【确认】打印票据",0,iSelect);
			if(iRet!=0 || iSelect==0)
			{
				CPrint prt;
				prt.set_in_par(gbl);
				//prt.print_detail(7, title);	 //打印电影票明细
				prt.print_film_detail(pack,title);
			}
			
			return 0;
		}
		else if(!memcmp(response_code,"55",2))
		{
			flag = 1;
			if(reGetPwd(title) == 0) //密码错误，重新输入密码, 2006-10-25
				continue;
			else
				return CANCLE_KEY;
		}
		else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
			if (iSelect!=0)
			{
				return -1;
			}else
				continue;
		}
		else
		{
			returnFail(response_code);
			return -1;
		}
	}
	return -1;
}

int CTrade::sendMsg()
{
	int iRet, iSelect;
	char tmp[200];
	TSSendShortMsg msg;  //短信结构体
	
	wrLog("【sendMsg】");
	memset(&msg, 0, sizeof(msg));
	strcpy(msg.sendNum, "12345");	//发送方号码
	strcpy(msg.sendTime, "07-08-10 14:25");	//发送时间, 格式[07-08-02 11:11]
	strcpy(msg.content, "This is a test!\n这是一个测试\n1234@$");	//短信息内容，最大140字节
	iRet = TS_SendShortMsg(gbl.dPosInfo, &msg);
	wrLog("返回值：[%d]", iRet);
	bbzero(tmp);
	sprintf(tmp,"存储结果:[%d]",iRet);
	TS_OutPutMsg(gbl.dPosInfo, tmp, 0, iSelect);
	return iRet;
}

//银行卡余额查询（建行和招行）
int CTrade::getBankMny(const char *title)
{
	int  iRet, flag = 0;
	int  iSelect, mngCard_count = 1;
	char tmp[256], temp_buff[256], response_code[3];
	char mny[20];
	
	strcpy(gbl.fee_type, "0177");
	wrLog("【银行卡余额查询】");
	TS_OutPutMsg(gbl.dPosInfo, "您将用1分钱使用建设银行,招商银行银行卡余额查询功能\n同意请按【确认】键", 0, iSelect);
	if(iSelect)
		return -1;
	mngCard_count = 1;
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{
		if(!flag)
		{
			iRet = 1;
			while(iRet > 0)	//刷卡错误，重新刷卡
			{
				if(mngCard_count==1)
					iRet = mngCard(title, 0, gbl.get_card);//gbl.get_card:0要刷卡；1：不用刷卡
				else
					iRet = mngCard(title, 0, MNG_MUL);
				mngCard_count = mngCard_count + 1 ;//标志着不是第一次刷卡
				if(iRet == CANCLE_KEY)
					return CANCLE_KEY;
				if(iRet == RE_MNG_CARD)
					continue;
				else if(iRet != 0)
					return -1;
			}
		}
		strcpy(gbl.amount, "000000000001");  //1分钱
		pack.wrField(2, gbl);
		/*******************修改部分包内容****************/
		//bit46
		strcpy((char *)pack.FIELD46,"2");
		pack.Packet_Table[46].Real_Length=1;
		//bit48
		memset(pack.FIELD48, 0, sizeof(pack.FIELD48) );
		memcpy(pack.FIELD48, gbl.fee_type, 4);
		strncat((char *)pack.FIELD48, "00", 2);
		pack.Packet_Table[48].Real_Length = 6;
		/**************************************************/
		//打包   
		iRet = packHdl(2);
		if(iRet < 0)
			return -1;
		
		//返回数据给终端
		memset(response_code, 0, sizeof(response_code));
		memcpy(response_code, pack.FIELD39, 2);
		if (!memcmp(response_code,"00",2)) 
		{
			memset(mny, 0, sizeof(mny));
			memset(tmp, 0, sizeof(tmp));
			memset(temp_buff, 0, sizeof(temp_buff));
			memcpy(tmp, pack.FIELD54+1, 12);
			CTools::chgToMny(tmp, mny);
			sprintf((char *)temp_buff, "余额：%s\n按【确认】返回", mny);
			iRet = TS_OutPutMsg(gbl.dPosInfo, (char *)temp_buff, 0,iSelect);
		}
		else if(!memcmp(pack.FIELD39,"55",2))
		{
			flag = 1;
			iRet = reGetPwd(title);
			if(iRet == 0) //密码错误，重新输入密码, 2006-10-25
				continue;
			else
				return CANCLE_KEY;
		}
		else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
			if (iSelect!=0)
			{
				return -1;
			}else
				continue;
		}
		else
		{
			iRet = returnFail(response_code);
		}
		return iRet;
	}
	return -1;
}

//获取业务代码对应的业务名
void CTrade::getFeeType(const char *feeType, char *name)
{
	if(name == NULL)
		return;
	switch( atoi(feeType) )
	{
	case 1:
		strcpy(name, "固话/小灵通话费");
		break;
	case 13:
		strcpy(name, "ADSL网费");
		break;
	case 46:
		strcpy(name, "电信预缴费卡充值");
		break;
	case 49:
		strcpy(name, "中国联通");
		break;
	case 56:
		strcpy(name, "羊城通充值");
		break;
	case 64:
		strcpy(name, "小灵通预付费");
		break;
	case 65:
		strcpy(name, "车船税");
		break;
	case 71:
		strcpy(name, "ADSL预缴基本月租");
		break;
	case 76:
	case 167:
	case 295:
		strcpy(name, "Q币充值");
		break;
	case 77:
	case 168:
		strcpy(name, "QQ会员包月");
		break;
	case 81:
		strcpy(name, "PICC车强险");
		break;
	case 89:
	case 153:
		strcpy(name, "售卡");
		break;
	case 96:
		strcpy(name, "固话/小灵通话费预存");
		break;
	case 97:
		strcpy(name, "ADSL网费预存");
		break;
	case 98:
		strcpy(name, "固话预付费");
		break;
	case 100:
		strcpy(name, "珠江数码月租费");
		break;
	case 111:
		strcpy(name, "珠江数码预付费");
		break;
	case 112:
		strcpy(name, "珠江宽频月租费");
		break;
	case 113:
		strcpy(name, "珠江宽频预付费");
		break;
	case 114:
		strcpy(name, "有线电视月租费");
		break;
	case 115:
		strcpy(name, "有线电视预付费");
		break;
	case 123:
		strcpy(name, "天天洗衣");
		break;
	case 137:
		strcpy(name, "ITV费用");
		break;
	case 138:
		strcpy(name, "ITV预存");
		break;
	case 140:
		strcpy(name, "预付费ADSL充值");
		break;
	case 143:
		strcpy(name, "自由互联帐号充值");
		break;
	case 163:
		strcpy(name, "付费易卡转帐");
		break;
	case 164:
		strcpy(name, "付费易卡充值");
		break;
	case 169:
	case 180:
	case 174:
	case 343:
	case 305:
		strcpy(name, "移动话费直充");
		break;
	case 170:
		strcpy(name, "e卡充值");
		break;
	case 173:
		strcpy(name, "最新电影折扣票");
		break;
	case 3012:
		strcpy(name, "移动话费");
		break;
	case 131:
		strcpy(name, "电信后付费缴费");
		break;
	case 176:
		strcpy(name, "全球通预付费");
		break;
	case 255:
	case 256:
	case 257:
	case 296:
	case 297:
		strcpy(name, "电信话费直充");
		break;
	case 213:
	case 316:
		strcpy(name, "移动话费直充");
		break;
	case 232:
		strcpy(name, "代收交通罚款");
		break;
	case 265:
	case 300:
	case 342:
	case 356:
		strcpy(name, "联通话费直充");
		break;
	case 273:
	case 277:
		strcpy(name,"QQ堂紫钻包月");
		break;
	case 294:
	case 88:
		strcpy(name,"蓝钻贵族包月");
		break;
	case 293:
	case 87:
		strcpy(name,"红钻贵族包月");
		break;
	case 278:
	case 274:
		strcpy(name,"黄钻贵族包月");
		break;
	case 334:
	case 335:
		strcpy(name,"移动卡充");
		break;
	case 321:
	case 344:
		strcpy(name,"电信直充");
		break;
	default:
		CDB::getBizName(feeType,name);
		break;
	}
	return;
}


//解得密码
int CTrade::getRealPwd(char *card, char *inPwd, char *outPwd)
{
	int i, cardLen;
	char pan[16+1], bcdPan[8+1], tmp[12+1], hexPwd[17];
	//提取PAN
	cardLen = 0;
	while(card[cardLen] && cardLen<23)
		cardLen++;
	if(cardLen==23)
		return -1;
	memset(tmp, 'F', sizeof(tmp));
	tmp[sizeof(tmp)-1] = 0;
	if(cardLen>12)
		memcpy(tmp, card+cardLen-13, 12);
	else
		memcpy(tmp+13-cardLen, card, cardLen-1);
	strcpy(pan, "0000");
	strcat(pan, tmp);
	bbzero(bcdPan);
	CTools::hex_to_byte((BYTE *)pan, (BYTE *)bcdPan, 16);
	//异或
	bbzero(tmp);
	for(i=0; i<8; i++)
		tmp[i] = inPwd[i]^bcdPan[i];
	bbzero(hexPwd);
	CTools::byte_to_hex((BYTE *)tmp, (BYTE *)hexPwd, 8);
	bbzero(tmp);
	memcpy(tmp, hexPwd, 2);  //2位长度
	memcpy(outPwd, hexPwd+2, atoi(tmp));
	return 0;
}


//更新连接提示信息
int CTrade::updateConInfo()
{
	int ret = 0;
	TSCueInfo cueInfo;
	
	memset(&cueInfo, 0, sizeof(cueInfo));
	cueInfo.num = 2;
	
	cueInfo.info[0].index = 2;
	cueInfo.info[0].flag = '1';
	cueInfo.info[0].operInfo.num = 1;
	cueInfo.info[0].operInfo.tempInfo[0].showType = 0xA3;
	strcpy(cueInfo.info[0].operInfo.tempInfo[0].content, CONNECT_SENTENCE);
	cueInfo.info[0].operInfo.tempInfo[0].len = strlen(CONNECT_SENTENCE);
	
	ret = TS_UpdateCueInfo(gbl.dPosInfo, 2, &cueInfo);
	
	wrLog("返回值：[%d]", ret);
	return ret;
}

//重打印失败发票
int CTrade::print_fail(const char *title){
	int iRet,iseny,iSelect,num;
	char card_info[200],pMsg[10][2048];
	char stan[12+1];
	bbzero(stan);
	
	int i = 0;
	if(gbl.group_type != 0){//如果非(商户版或美宜佳)版，要刷卡
		/**************取得卡号*******************/
		for(i=0;i<10;i++)
		{
			bbzero(card_info);
			iRet = getCardInfo("title", card_info, MNG_OR_INPUT, gbl.get_card, "", 6, 19);
			if( iRet == 0 )
				iRet = getCardNum(card_info, MNG_OR_INPUT);//取得卡号
			if( (iRet == CANCLE_KEY) )
				return CANCLE_KEY;
			else if( (iRet == RE_MNG_CARD) )
				continue;
			else if(iRet != 0)
				return -1;
			else
				break;
		}
		if(i==10){
			TS_OutPutMsg(gbl.dPosInfo, "\n  读取卡号出错\n   按【确认】返回", 0,iSelect);
			return -1;
		}
	}
	else{//如果是商户版或美宜佳版，要输入stan号(免除刷卡，因为一上来就已经刷过卡)
		/************输入stan号****************/
		TSTradeInfoSend tradeInfoSend;
		TSTradeInfoRecv tradeInfoRecv; 
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
		
		tradeInfoSend.uTotalContents = 1;	
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入系统参考号");
		tradeInfoSend.Contents[0].uMinLen = 12;
		tradeInfoSend.Contents[0].uMaxLen = 12;
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;//超时30秒
		
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		if(iRet != 0)
		{
			wrLog("TS_TradeControl返回错误[%d]", iRet);
			wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
			return iRet;
		}
		bbzero(stan);
		memcpy(stan,tradeInfoRecv.Contents[0].uMsg,12);
	}
	CPrint print;
	print.set_in_par(gbl);
	
	if(CDB::getRePrint(stan,gbl.pos_no,gbl.card_no,iseny,pMsg,gbl.dPosInfo.prmVer,&num)==0)
	{
		for(i = 0; i < num; i++)
		{
			if(print.print_fail(iseny,pMsg[i],0)==0)
			{
				if(atoi(gbl.dPosInfo.prmVer)>=9000)
				{
					NULL;
				}
				else
				{
					CDB::updateRePrint(stan,gbl.pos_no,gbl.card_no,iseny);
				}			
			}
			else
			{
				NULL;
			}
		}
		
	}
	/* 删除从pe数据库查找63域数据。
	else if( atoi(prmVer)>=9000 && memcmp(stan, "000000000000", 12)!=0 )//售卡去商户管理系统生成发票
	{
		CGlobal m_gbl;
		CPack m_pack;
		char date8[8+1];
		
		m_pack.init8583();
		memcpy(&m_gbl, &gbl, sizeof(m_gbl));
		
		if(CDB::getCardPrint(stan, (char *)m_pack.FIELD63, m_gbl.fee_type, m_gbl.sell_card_type, m_gbl.card_amount, m_gbl.card_no)==0)
		{
			m_gbl.card_no_len = strlen(m_gbl.card_no);
			strcpy(m_gbl.stan_no, stan);		
			bbzero(m_gbl.fee_type2);
			bbzero(m_gbl.phone_no);
			bbzero(m_gbl.xmcard_name);
			strcpy(m_gbl.xmcard_name, "游戏点卡");
			
			CTools::get_time(m_gbl.pos_serial);
			bbzero(m_pack.FIELD12);
			CTools::hex_to_byte((BYTE *)m_gbl.pos_serial, (BYTE *)m_pack.FIELD12, 6, 0);
			
			bbzero(date8);
			CTools::get_date8(date8);
			bbzero(m_pack.FIELD13);
			CTools::hex_to_byte((BYTE *)date8, (BYTE *)m_pack.FIELD13, 8, 0);	
			
			bbzero(m_pack.FIELD37);
			strcpy((char *)m_pack.FIELD37, m_gbl.stan_no);
			
			CPrint prt;
			prt.set_in_par(m_gbl, m_pack);
			prt.print_detail(3, "电子售卡");//打印明细
			
		}
		else
		{
			TS_OutPutMsg(gbl.dPosInfo, "\n无打印失败信息，有疑问请致电400-80-11888\n   按【确认】返回", 0,iSelect);
			return -1;
		}
	}
	*/
	else
	{
		TS_OutPutMsg(gbl.dPosInfo, "\n无打印失败信息，有疑问请致电400-80-11888\n   按【确认】返回", 0,iSelect);
		return -1;
	}
	return 0;
}

//电信交费后，附加询问是否做预付金和办理授权
//type 标题
int CTrade::telPayExtend(const char *type)	
{	
	wrLog("【询问是否做预付金和办理授权】");
	int iRet=0,iSelect,memu_flag=0;//memu_flag-1:预付金和办理授权 2:预付金 3:办理授权
	char next_fee_type[5];
	char next_biz_name[30+1];
	switch(atoi(gbl.fee_type)){
	case 1:		//若长市话费或小灵通
		strcpy(next_fee_type,"0096");
		strcpy(next_biz_name,"固话/小灵通话费预存");
		memu_flag=2;
		break;
	case 13:	//ADSL
		strcpy(next_fee_type,"0097");
		strcpy(next_biz_name,"ADSL网费预存");
		memu_flag=2;
		break;
	case 137:	//ITV
		strcpy(next_fee_type,"0138");
		strcpy(next_biz_name,"ITV预存");
		memu_flag=2;
		break;
	case 241:
		strcpy(next_fee_type,"0242");
		strcpy(next_biz_name,"CDMA预存");
		memu_flag=2;
		break;
	case 96:
	case 97:
	case 138:
	case 242:
		memu_flag = 3;
		break;
	default:
		return -1;
	}
	//如果可以做预授权
	if(memcmp(gbl.card_no,"8828",4)!=0 && memcmp(gbl.card_no,"1088",4)!=0 && !memcmp(pack.FIELD39,"00",2) && !memcmp(pack.FIELD55,"00",2)){	//若不是付费易卡且不是e卡且成功
		if(memu_flag==2)
			memu_flag=1;
		else
			NULL;
	}else if(memu_flag==2){
		NULL;
	}else{
		memu_flag=0;
		return -1;
	}
	
	TSMENULIST menuList;
	memset(&menuList,0,sizeof(menuList));
	switch(memu_flag){
	case 1:
		menuList.iTotalNum = 3;
		strcpy(menuList.acTitle, "请选择其他业务");
		strcpy(menuList.menuItem[0], next_biz_name);
		strcpy(menuList.menuItem[1], "办理银行划扣");
		strcpy(menuList.menuItem[2], "退出");
		iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
		if(iRet)
			return -2;
		switch(iSelect)
		{
		case 1:
			strcpy(gbl.fee_type,next_fee_type);
			return telTrade(next_biz_name,1);
		case 2:
			//////////////////银行划扣受理入口
			return ysqHdl();
		default: 
			return CANCLE_KEY;
		}
		break;
		case 2:
			menuList.iTotalNum = 2;
			strcpy(menuList.acTitle, "请选择其他业务");
			strcpy(menuList.menuItem[0], next_biz_name);
			strcpy(menuList.menuItem[1], "退出");
			iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
			if(iRet)
				return -1;
			switch(iSelect)
			{
			case 1:
				strcpy(gbl.fee_type,next_fee_type);
				return telTrade(next_biz_name,1);
			default: 
				return CANCLE_KEY;
			}
			break;
			case 3:
				menuList.iTotalNum = 2;
				strcpy(menuList.acTitle, "请选择其他业务");
				strcpy(menuList.menuItem[0], "办理银行划扣");
				strcpy(menuList.menuItem[1], "退出");
				iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
				if(iRet)
					return -1;
				switch(iSelect)
				{
				case 1:
					return ysqHdl();
				default: 
					return CANCLE_KEY;
				}
				break;
				default:
					return -1;
	}
}

//电信交费后，附加做预付授权
//type 1:用户名匹配 2:银行划扣受理

int CTrade::ysqHdl()
{
	int iSelect, iRet = 0;
	
	iSelect = ysqconfirm();
	if(iSelect==0)
	{
		wrLog("【开始用户名匹配】");
        strcpy(gbl.fee_type,"0216");
		iRet = ysqInqHdl(1);
		if(iRet==0)
		{
			wrLog("【开始银行划扣受理】");
			strcpy(gbl.fee_type,"0217");
			iRet = ysqInqHdl(2);
		}
	}
	return iRet;
}

int CTrade::ysqconfirm()
{
	
	int iSelect;
	char temp_buff[512];
	wrLog("【银行划扣受理信息确定】");
	sprintf(temp_buff,"客户须知\n1.本受理视为帐户持有人同意电信公司在其帐户上自动划扣受理回执上号码的电信费用\n2.用户号码所属的户名必须与帐户持有人为同一自然人，否则受理无效\n用户名：%s\n电话号码：%s\n银行卡号：%s\n【确认】登记\n【返回】返回",gbl.user_name, gbl.phone_no, gbl.card_no);
	TS_OutPutMsg(gbl.dPosInfo, temp_buff, 0,iSelect);
	return iSelect;
	
}

int CTrade::ysqInqHdl(int type)	//银行划扣受理用户名匹配
{
	int  iSelect,iRet;
	char response_code[3];
	char temp_buff[512];
	char tittle[50];
	int name_len=0;	
	
	pack.wrField(1, gbl);	
	if(type==1)
	{
		wrLog("【银行划扣受理用户名匹配】");
		//写查询域
		/***********修改一些域信息*********/	
		bbzero(pack.FIELD48);
		memcpy(pack.FIELD48,gbl.fee_type,4);	//4位信息码
		pack.Packet_Table[48].Real_Length=4;
		bbzero(pack.FIELD63);
		for(name_len=0; name_len<sizeof(gbl.user_name) && gbl.user_name[name_len]!=0x00 && gbl.user_name[name_len]!=0x20; name_len++);
		memcpy(pack.FIELD63,gbl.user_name,name_len);
		pack.Packet_Table[63].Real_Length = name_len;
		
	}
	else{
		memcpy(pack.FIELD48,gbl.fee_type,4);	//4位信息码		       		       
		bbzero(pack.FIELD63);
		memcpy(pack.FIELD63,"0000",4);
		pack.Packet_Table[63].Real_Length = 4;
	}
	
	//bit2
	memset(pack.FIELD2, 0, sizeof(pack.FIELD2));
	memset((char *)temp_buff,0,sizeof(temp_buff));
	strcpy((char *)temp_buff,gbl.card_no);
	CTools::hex_to_byte((BYTE *)temp_buff, pack.FIELD2, gbl.card_no_len, 1);	//变为bcd码（后补0）
	pack.Packet_Table[2].Real_Length=gbl.card_no_len;
	//  查询包打包   
	if(packHdl(1) < 0)
	{
		return -1;
	}
	else{
		memset(response_code,0,sizeof(response_code));
		memcpy(response_code,pack.FIELD39,2);
		if (!memcmp(response_code,"00",2)) 
		{
			if(type==2)
			{
				iRet = TS_OutPutMsg(gbl.dPosInfo,"		  登记成功！\n请检查打印机电源及打印线路是否正常,有问题请即与400-80-11888联系\n按【确认】打印发票",0,iSelect);
				if(iRet!=0 || iSelect==0)
				{
					CPrint prt;
					prt.set_in_par(gbl);
					bbzero(tittle);
					strcpy((char *)tittle,"更改缴费帐号受理回执");
					//prt.print_detail(8, tittle);	//打印明细
					prt.print_ysq_detail(pack,tittle);
				}
			}
			return 0;
		}
		else {
			returnFail((char *)pack.FIELD39);
			return -1;
		}
	}
}

int CTrade::rePrintTel(const char *title)
{
	int iRet;
	
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	
	memset(&tradeInfoSend,0,sizeof(tradeInfoSend));
	memset(&tradeInfoRecv,0,sizeof(tradeInfoRecv));
	
	tradeInfoSend.uHasTradeID=1;
	tradeInfoSend.uTotalContents=3;
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入要补打的号码：");	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//全字符
	tradeInfoSend.Contents[0].uCount = 0;		//输入1次
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
	tradeInfoSend.Contents[0].uMinLen = 7;		
	tradeInfoSend.Contents[0].uMaxLen = 15;
	
	strcpy(tradeInfoSend.Contents[1].acTitle, "请输入客户密码：");	
	tradeInfoSend.Contents[1].uCount = 0;		//输入1次
	tradeInfoSend.Contents[1].uTimeOut = EPOS_OVER_TIME;	//超时30秒
	tradeInfoSend.Contents[1].uMinLen = 6;		
	tradeInfoSend.Contents[1].uMaxLen = 6;
	if(!gbl.posInfo.enyFlag)	//加密改造，旧加密体系
	{
		tradeInfoSend.Contents[1].uCommand = TS_INPUT_PWD;	//密码(明文)
	}
	else
	{
		tradeInfoSend.Contents[1].uCommand = TS_INPUT_PIN;	//密码
		tradeInfoSend.Contents[1].uCardType = CARD_TYPE;	//大卡加密，修改密码标志
		tradeInfoSend.Contents[1].uDesMode = TS_DES_3_TEK_ENC;		//3次des
		tradeInfoSend.Contents[1].uKeyIndex = TS_TEK_KEY;	//密钥组号 
	}
	
	strcpy(tradeInfoSend.Contents[2].acTitle, "请输入月份\n(格式200806):");	 
	tradeInfoSend.Contents[2].uCommand = TS_INPUT_MATH;	//数字
	tradeInfoSend.Contents[2].uCount = 0;		//输入1次月份	
	tradeInfoSend.Contents[2].uTimeOut = EPOS_OVER_TIME;	//超时30秒
	tradeInfoSend.Contents[2].uMinLen = 6;		
	tradeInfoSend.Contents[2].uMaxLen = 6;
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if (iRet)
	{
		wrLog("第一次和终端交互失败 iRet=%d",iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);
		return(iRet);
	}
	memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
	strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
	pack.wrField(1,gbl);//初始化包
	
	char temp48[24];//pack48 temp;
	char temp63[999+1];//pack63 temp;
	char tempLenTel[2+1];//电话号码长度
	char tempTel[15+1];//电话号码
	char tempFlag[2+1]="01";//flag=01
	char tempMonth[6+1];//月份
	char tempPW[8+1];//密码
	//初始化参数
	wrLog("初始参数!");
	memset(temp48,0,sizeof(temp48));
	memset(temp63,0,sizeof(temp63));
	memset(tempTel,0,sizeof(tempTel));
	memset(tempLenTel,0,sizeof(tempLenTel));
	memset(tempMonth,0,sizeof(tempMonth));
	memset(tempPW,0,sizeof(tempPW));
	//赋值
	wrLog("赋值!");
	memcpy(tempTel,tradeInfoRecv.Contents[0].uMsg,tradeInfoRecv.Contents[0].uMsgLen);
	CTools::lowerToUpper(tempTel);
	sprintf(tempLenTel,"%02d",strlen(tempTel));
	strcpy(temp48,gbl.fee_type);
	strcat(temp48,tempLenTel);
	strcat(temp48,tempTel);
	strcat(temp48,tempFlag);
	
	memcpy(tempPW,tradeInfoRecv.Contents[1].uMsg,tradeInfoRecv.Contents[1].uMsgLen);
	memcpy(tempMonth,tradeInfoRecv.Contents[2].uMsg,tradeInfoRecv.Contents[2].uMsgLen);
	
	strcpy(temp63,tempMonth);
	strcat(temp63,tempPW);
	
	wrLog("tempTel:[%s]",tempTel);
	wrLog("tempPW:[%s]",tempPW);
	wrLog("tempMonth:[%s]",tempMonth);
	wrLog("temp48:[%s]",temp48);
	wrLog("temp63:[%s]",temp63);
	
	memset(pack.FIELD48,0,sizeof(pack.FIELD48));
	memcpy(pack.FIELD48,temp48,strlen(temp48));
	pack.Packet_Table[48].Real_Length=strlen(temp48);
	memset(pack.FIELD63,0,sizeof(pack.FIELD63));
	memcpy(pack.FIELD63,temp63,strlen(temp63));
	pack.Packet_Table[63].Real_Length=strlen(temp63);
	
	wrLog("pack.FIELD48:[%s]",pack.FIELD48);
	wrLog("pack.FIELD63:[%s]",pack.FIELD63);
	
	gbl.phone_len=atoi(tempLenTel);
	memset(gbl.phone_no,0,sizeof(gbl.phone_no));
	memcpy(gbl.phone_no,tempTel,strlen(tempTel));
	
	wrLog("与PE交互");
	if(iRet=packHdl(1)<0)// send pack
	{
		wrLog("与PE交互失败！");
		return iRet;
	}else if(!memcmp(pack.FIELD39,"00",2)){	
		wrLog("打印发票");
		CPrint prt;
		prt.set_in_par(gbl);
		//prt.print_detail(1, title);	//打印欠费明细
		prt.print_pym_detail(pack,title);
		return 0;
	}else{
		returnFail((char *)pack.FIELD39);
		return -1;
	}
}

//flag-0:提取未看过的5条信息;1:提取最近5条信息
int CTrade::getEcardMsg(const char *title, int flag){
	int iSelect;
	char tmp[512], event_seq[15+1], txn_type[2+1], txn_time[19+1], chg_amount[12+1], mny[12], last_event_seq[15+1];
	bbzero(tmp);
	bbzero(event_seq);
	bbzero(txn_type);
	bbzero(txn_time);
	bbzero(chg_amount);
	bbzero(mny);
	bbzero(last_event_seq);
	strcpy(last_event_seq,"999999999999999");
	for(int i=0; i<5 && CDB::getEcardTxn(gbl.mer_ecard, flag, last_event_seq, event_seq, txn_type, txn_time, chg_amount)==0; i++){
		if(flag==0)
			CDB::updateEcardTxn(event_seq);
		memcpy(last_event_seq, event_seq, sizeof(last_event_seq)-1);
		CTools::chgToMny(chg_amount, mny);
		if(!strcmp(txn_type,"05")){
			sprintf(tmp ,"卡号:%s\n%s\n交易类型:充值\n注入金额:%s\n按【确认】继续", gbl.mer_ecard, txn_time, mny);
		}else{
			sprintf(tmp ,"卡号:%s\n%s\n交易类型:调帐\n注入金额:%s\n按【确认】继续", gbl.mer_ecard, txn_time, mny);
		}		
		TS_OutPutMsg(gbl.dPosInfo,tmp,0,iSelect);
		bbzero(tmp);
		bbzero(event_seq);
		bbzero(txn_type);
		bbzero(txn_time);
		bbzero(chg_amount);
		bbzero(mny);
	}
	if(flag==1 && i==0){
		sprintf(tmp ,"卡号:%s\n无资金注入记录\n按【确认】继续", gbl.mer_ecard);
		TS_OutPutMsg(gbl.dPosInfo,tmp,1,iSelect);
	}
	return 0;
}

int CTrade::testIcReaderCommand(const char *title){
	int iRet,select;
	char tmp[200];		
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	memset(&tradeInfoSend,0,sizeof(tradeInfoSend));
	memset(&tradeInfoRecv,0,sizeof(tradeInfoRecv));
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;
	tradeInfoSend.Contents[0].uCount = 0;
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
	tradeInfoSend.Contents[0].uMinLen = 1;
	tradeInfoSend.Contents[0].uMaxLen = 40;
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);						
	if(iRet == 0){
		bbzero(tmp);
		strcpy(tmp,(char *)tradeInfoRecv.Contents[0].uMsg);
		TS_OutPutMsg(gbl.dPosInfo, tmp, 0, select);
	}
	else{
		bbzero(tmp);
		strcpy(tmp,"0C01000281008E");
		TS_OutPutMsg(gbl.dPosInfo, tmp, 0, select);				
	}
	wrLog("【串口透传】");
	TSIcReaderCommand ic;
	memset(&ic, 0, sizeof(ic));
	strcpy(ic.acTitle, title);
	if(gbl.posInfo.inType==5 || gbl.posInfo.inType==8)
	{
		ic.comType = gbl.posInfo.inType;
		ic.com  = 0x03;
	}
	//左串口
	else if(gbl.posInfo.leftType==5 || gbl.posInfo.leftType==8)
	{
		ic.comType = gbl.posInfo.leftType;
		ic.com  = 0x01;
	}
	//右串口
	else if(gbl.posInfo.rightType==5 || gbl.posInfo.rightType==8)
	{
		ic.comType = gbl.posInfo.rightType;
		ic.com  = 0x02;
	}
	wrLog("uDownData[%s]",tmp);
	CTools::hex_to_byte((BYTE *)tmp, ic.uDownData, strlen(tmp));
	ic.uDownLen = strlen(tmp)/2;
	iRet = TS_IcReaderCommand(gbl.dPosInfo, &ic);
	if(!iRet){
		bbzero(tmp);
		strcpy(tmp,"[");
		CTools::byte_to_hex((BYTE *)ic.uUpData, (BYTE *)tmp+1, ic.uUpLen);					
		strcat(tmp,"]");
		TS_OutPutMsg(gbl.dPosInfo, tmp, 0, select);
	}else{
		TS_OutPutMsg(gbl.dPosInfo, "出错", 0, select);
	}
	return 0;
}

int CTrade::testFSKPack(const char *title){
	BYTE sendMsg[700], sendMsgBCD[1400], getMsg[700];
	int ret=0,sendMsgLen=0,getMsgLen=0;
	CConnect con;
	CString  FilePath = ".\\ctsi.ini";	
	CString strValue = _T("");
	
	//交易类型
	CString strSection = "POSMAG";
	CString strSectionKey = "PACKCONT";	
	GetPrivateProfileString (strSection,strSectionKey, NULL, (char *)sendMsgBCD, sizeof(sendMsgBCD), FilePath); 
	sendMsgLen = CTools::hex_to_byte((const BYTE *)sendMsgBCD, (BYTE *)sendMsg,strlen((const char *)sendMsgBCD));
	
	ret = con.sndMsg(gbl.dPosInfo.sd, (char *)sendMsg, sendMsgLen, 60);
	if(ret!=0)
		return -1;
	
	//收包
	bbzero(getMsg);
	ret = con.rcvMsg(gbl.dPosInfo.sd, (char *)getMsg, &getMsgLen, sizeof(getMsg), 60);
	if( ret!=0 )
	{
		return -2;
	}
	wrHex("testFSKPack response",getMsg,getMsgLen);
	return 0;
}


int CTrade::carnum_trafficTrade(const char *title, int flag)
{
	int iRet = 0,iSelect;
	int b48_len = 0;
	int b63_len = 0;
	int paper_count = 0;
	int data_len = 0;
	char buff[4+1];
	char paper_count_buff[4+1],area[20+1],paper_data[10+1],paper_time[8+1],behavior[20+1],paper_no_buff[16+1];
	char enqFIELD48[42+1], enqFIELD63[999+1], enqStan[12+1];
	char trafficType[4+1], trafficNo[16+1];
	char carType[2+1];
	char carnum[6+1];
	char response_code[3];
	char temp[4096];
	
	car_paper_info car_paperinfo[100];
	
	memset(&car_paperinfo,0,sizeof(car_paperinfo));
	bbzero(area);
	bbzero(behavior);
	bbzero(paper_count_buff);
	bbzero(response_code);
	bbzero(carnum);
	bbzero(enqStan);
	bbzero(carType);
	bbzero(enqFIELD48);
	bbzero(enqFIELD63);
	bbzero(trafficNo);
	bbzero(trafficType);
	
	strcpy(gbl.fee_type,"0233");
	wrLog("%s【按车牌号查询】", title);
	
	
	//取得罚单文书类型
	if (flag ==0)
	{
		strcpy(carType,"02");
	}else
		strcpy(carType,"01");
	
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, title);
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入车牌号码:粤");
	tradeInfoSend.Contents[0].uMinLen = 6;		
	tradeInfoSend.Contents[0].uMaxLen = 6;
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//数字
	tradeInfoSend.Contents[0].uCount = 0;		//输入1次		
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
	strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
	memcpy( carnum, (char *)tradeInfoRecv.Contents[0].uMsg, 6);
	wrLog("车辆类型：【%s】车牌号码是：【粤%s】",carType,carnum);
	
	//写查询域
	pack.wrField(1, gbl);
	bbzero(pack.FIELD48);
	memcpy(pack.FIELD48,gbl.fee_type,4);	//4位信息码
	b48_len = 4;
	sprintf((char *)pack.FIELD48+b48_len,"%02d", 14);	//总长度
	b48_len +=2;
	sprintf((char *)pack.FIELD48+b48_len,"%02d", 2);	//长度
	b48_len +=2;
	memcpy(pack.FIELD48+b48_len, "粤",2);	//车辆所属区域
	b48_len +=2;
	sprintf((char *)pack.FIELD48+b48_len,"%02d", 6);	//长度
	b48_len +=2;
	sprintf((char *)pack.FIELD48+b48_len,"%s", carnum);	//车号
	b48_len +=6;
	memcpy(pack.FIELD48+b48_len, carType, 2);	//车辆类型
	b48_len += 2;
	pack.Packet_Table[48].Real_Length=b48_len;
	
	//查询包打包   
	iRet = packHdl(1);
	if(iRet < 0)
		return -1;
	
	memcpy(enqFIELD48, pack.FIELD48, pack.Packet_Table[48].Real_Length);
	memcpy(enqFIELD63, pack.FIELD63, pack.Packet_Table[63].Real_Length);
	memcpy(enqStan, pack.FIELD37, 12);
	memcpy(response_code,pack.FIELD39,2);
	
	if (!memcmp(response_code,"00",2))
	{
		if (strlen(enqFIELD63) == 0)
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n\n     数据包错误\n   请按【确认】返回",1,iSelect);
			return -1;
		}
		memcpy(paper_count_buff,enqFIELD63+b63_len,4);
		b63_len+=4;
		paper_count = atoi(paper_count_buff);
		for (int i=0;i<paper_count;i++)
		{
			memcpy(car_paperinfo[i].data,enqFIELD63+b63_len,14);
			b63_len+=14;
			memcpy(car_paperinfo[i].behavior,enqFIELD63+b63_len,32);
			b63_len+=32;
			memcpy(car_paperinfo[i].area,enqFIELD63+b63_len,32);
			b63_len+=32;
			memcpy(car_paperinfo[i].paper_type,enqFIELD63+b63_len,4);
			b63_len+=4;
			bbzero(paper_no_buff);
			memcpy(paper_no_buff,enqFIELD63+b63_len,16);
			b63_len+=16;
			trim(paper_no_buff,16);//如果末尾有空格则去掉空格
			strcpy(car_paperinfo[i].paper_num,paper_no_buff);
			bbzero(paper_data);
			bbzero(paper_time);
			bbzero(buff);
			data_len = 2;
			memcpy(buff,car_paperinfo[i].data+data_len,2);
			strcat(paper_data,buff);
			data_len += 2;
			strcat(paper_data,"/");
			bbzero(buff);
			memcpy(buff,car_paperinfo[i].data+data_len,2);
			strcat(paper_data,buff);
			data_len += 2;
			strcat(paper_data,"/");
			bbzero(buff);
			memcpy(buff,car_paperinfo[i].data+data_len,2);
			strcat(paper_data,buff);
			data_len += 2;
			bbzero(buff);
			memcpy(buff,car_paperinfo[i].data+data_len,2);
			strcat(paper_time,buff);
			data_len += 2;
			strcat(paper_time,":");
			bbzero(buff);
			memcpy(buff,car_paperinfo[i].data+data_len,2);
			strcat(paper_time,buff);
			data_len += 2;
			strcat(paper_time,":");
			bbzero(buff);
			memcpy(buff,car_paperinfo[i].data+data_len,2);
			strcat(paper_time,buff);
			data_len += 2;
			bbzero(temp);
			for (int k = 31;k >= 0;k --)
			{
				if (car_paperinfo[i].behavior[k]==' ')
				{
					car_paperinfo[i].behavior[k] = 0;
				}else if (k == 31)
				{
					memcpy(car_paperinfo[i].behavior+k+1,"..." ,3);
					break;
				}
			}
			for (k = 31;k >= 0;k --)
			{
				if (car_paperinfo[i].area[k]==' ')
				{
					car_paperinfo[i].area[k] = 0;
				}else if (k == 31)
				{
					memcpy(car_paperinfo[i].area+k+1,"..." ,3);
					break;
				}
			}
			if (paper_count == i+1)
			{
				sprintf(temp,"粤%s      %d/%d张\n文书类型:%s\n文号:%s\n日期%s %s\n地点:%s\n行为:%s\n【确认】缴纳罚款\n【返回】返回"
					,carnum,i+1,paper_count,car_paperinfo[i].paper_type,car_paperinfo[i].paper_num,paper_data,paper_time,car_paperinfo[i].area,car_paperinfo[i].behavior);
				
			}
			else
				sprintf(temp,"粤%s      %d/%d张\n文书类型:%s\n文号:%s\n日期%s %s\n地点:%s\n行为:%s\n【确认】缴纳罚款\n【返回】查看下一张"
				,carnum,i+1,paper_count,car_paperinfo[i].paper_type,car_paperinfo[i].paper_num,paper_data,paper_time,car_paperinfo[i].area,car_paperinfo[i].behavior);
			iRet = TS_OutPutMsg(gbl.dPosInfo,temp,0,iSelect);
			if (iSelect == 0)
				traffic_pay(title,car_paperinfo[i].paper_type,car_paperinfo[i].paper_num);
		}
		
	}else{
		returnFail(response_code);
		return -1;
	}
	
	return 0;
}

int CTrade::traffic_pay(const char *title, char *car_type, char *paper_num)
{
	//写查询域
	int b48_len =0,iRet,iRetB=0,paper_num_len;
	char enqStan[12+1],amount[12+1];
	int iSelect=0, b63Idx=0;
	char enqFIELD48[42+1], enqFIELD63[999+1];
	char temp_buff[512], detail_buf[100], len_buf[2+1], date[14+1], tatolAmo[12+1], mark_card[30+1];
	bbzero(enqFIELD48);
	bbzero(enqFIELD63);
	bbzero(temp_buff);
	bbzero(detail_buf);
	bbzero(len_buf);
	bbzero(date);
	bbzero(amount);
	bbzero(tatolAmo);
	bbzero(enqStan);
	bbzero(amount);
	bbzero(mark_card);
	strncpy(mark_card, gbl.card_no, sizeof(mark_card)-1);
	pack.wrField(1, gbl);
	bbzero(pack.FIELD48);
	bbzero(gbl.fee_type);
	paper_num_len = strlen(paper_num);
	
	iRet = get_area_biz(BIZ_AREA_BIZ_TRAFFIC, gbl.city_no, gbl.acc_city_no, gbl.fee_type);
	if( iRet==0 )
	{
		wrLog("gbl.fee_type = [%s]", gbl.fee_type);
	}
	else
	{
		return -1;
	}
	
	memcpy(pack.FIELD48,gbl.fee_type,4);	//4位信息码
	b48_len = 4;
	sprintf((char *)pack.FIELD48+b48_len,"%02d", 4+paper_num_len);	//
	b48_len +=2;
	memcpy(pack.FIELD48+b48_len, car_type, 4);	//文书类型
	b48_len +=4;
	memcpy(pack.FIELD48+b48_len, paper_num, paper_num_len);	//文书号
	b48_len += paper_num_len;
	pack.Packet_Table[48].Real_Length=b48_len;
	
	//查询包打包   
	iRet = packHdl(1);
	if(iRet < 0)
		return -1;
	if (!memcmp((char *)pack.FIELD39,"00",2))
	{
		memcpy(enqStan, pack.FIELD37, 12);
		bbzero(temp_buff);
		b63Idx = 2;
		memcpy(len_buf, pack.FIELD63+b63Idx, 2);
		b63Idx += 2;
		b63Idx += atoi(len_buf);
		
		
		memcpy(len_buf, pack.FIELD63+b63Idx, 2);
		b63Idx += 2;
		b63Idx += atoi(len_buf);
		
		b63Idx += 2;
		
		memcpy(len_buf, pack.FIELD63+b63Idx, 2);
		b63Idx += 2;
		b63Idx += atoi(len_buf);
		
		memcpy(len_buf, pack.FIELD63+b63Idx, 2);
		b63Idx += 2;
		b63Idx += atoi(len_buf);
		
		memcpy(len_buf, pack.FIELD63+b63Idx, 2);
		b63Idx += 2;
		b63Idx += atoi(len_buf);
		
		memcpy(len_buf, pack.FIELD63+b63Idx, 2);
		b63Idx += 2;
		b63Idx += atoi(len_buf);
		
		b63Idx += 14;
		
		b63Idx += 12;
		
		memcpy(tatolAmo, pack.FIELD63+b63Idx, sizeof(tatolAmo)-1);
		memcpy(amount, tatolAmo, 12);
		bbzero(gbl.amount);
		strcpy(gbl.amount,amount);
		memcpy(enqFIELD48, pack.FIELD48, pack.Packet_Table[48].Real_Length);
		memcpy(enqFIELD63, pack.FIELD63, pack.Packet_Table[63].Real_Length);
		iRet = trafficPayHdl(title,enqFIELD48,enqFIELD63, enqStan);
		if( gbl.get_card == MNG_ONE_BIND_E || gbl.get_card == MNG_MUL_BIND_E )//还原原先刷的卡
		{
			iRetB = bindcard(mark_card, gbl.card_no, &gbl.card_no_len);
			if(iRetB != 0)
			{
				TS_OutPutMsg(gbl.dPosInfo,"绑定原卡号出错!请挂机重连!",0,iSelect);
				TS_HangUp(gbl.dPosInfo);
			}
		}
		return iRet;
	}else
	{
		returnFail((char *)pack.FIELD39);
		return -1;
	}
	
	
}

int CTrade::Present_handsel(const char*type)
{
    int iRet=0,iSelect=0;
    wrLog("赠送领取，业务暂停。");
    TS_OutPutMsg(gbl.dPosInfo , "【业务暂停！】" , 0 , iSelect);
    return 0;
	char mark_card[30+1],mark_pwd[9+1];
	bbzero(mark_card);
	bbzero(mark_pwd);
	strncpy(mark_card, gbl.card_no, sizeof(mark_card)-1);
	
	bbzero(gbl.fee_type);
	strcpy(gbl.fee_type,"0322");
	bbzero(gbl.card_no);
	strcpy(gbl.card_no,"1088103004020009");//生产
	//	strcpy(gbl.card_no,"1088100103001088");//测试
	iRet = Present_handsel_Hdl(type);
	
	bbzero(gbl.card_no);
	strncpy(gbl.card_no,mark_card,  sizeof(gbl.card_no)-1);
	return iRet;
}
int CTrade::Present_handsel_Hdl(const char*type)
{
	int  iRet,iSelect,i,flag;
	char response_code[3];
	char temp_buff[2048],len_buff[10],lastYear[4+1],lastMonth[2+1],lastDay[2+1];
	char start_date[14+1],end_date[14+1],donate_count[12+1],remain_count[12+1],all_amount[12+1];
	int donate_acount,remain_acount,pay_acount;
	char cDatebuff[128],buff[512],mny[15+1],cStartBuff[10+1],cEndBuff[10+1],promot_id[20+1];
	CDB db;
	bbzero(start_date);
	bbzero(end_date);
	bbzero(donate_count);
	bbzero(remain_count);
	bbzero(all_amount);
	bbzero(promot_id);
	
	iRet = db.getIposPromo(gbl.pos_no,start_date,end_date,donate_count,remain_count,all_amount,promot_id);
	
	if (iRet != 0)
	{
		TS_OutPutMsg(gbl.dPosInfo,"暂无赠送领取,敬请关注！",0,iSelect);
		return -1;
	}
	
	donate_acount = atoi(donate_count);
	remain_acount = atoi(remain_count);
	int nYear=0, nMonth=0, nDay=0, nHour=0, nMin=0, nSec=0;
	bbzero(cDatebuff);
	strncpy(cDatebuff,start_date,4);
	nYear = atoi(cDatebuff);
	bbzero(cDatebuff);
	strncpy(cDatebuff,start_date+4,2);
	nMonth = atoi(cDatebuff);
	bbzero(cDatebuff);
	strncpy(cDatebuff,start_date+6,2);
	nDay = atoi(cDatebuff);
	CTime cStartTime = CTime(nYear, nMonth, nDay, nHour, nMin, nSec);
	
	bbzero(cDatebuff);
	strncpy(cDatebuff,end_date,4);
	nYear = atoi(cDatebuff);
	bbzero(cDatebuff);
	strncpy(cDatebuff,end_date+4,2);
	nMonth = atoi(cDatebuff);
	bbzero(cDatebuff);
	strncpy(cDatebuff,end_date+6,2);
	nDay = atoi(cDatebuff);
	CTime cEndTime = CTime(nYear, nMonth, nDay, nHour, nMin, nSec);
	
	CTime cCurTime = CTime::GetCurrentTime();
	CTime cCurDate = CTime(cCurTime.GetYear(), cCurTime.GetMonth(), cCurTime.GetDay(), 0, 0, 0);
	
	if (cCurDate<cStartTime)
	{
		TS_OutPutMsg(gbl.dPosInfo, "活动未开始，敬请关注！", 0, iSelect);
		return -1;
	}
	if (cCurDate>cEndTime)
	{
		TS_OutPutMsg(gbl.dPosInfo, "活动已结束，谢谢您的参与！", 0, iSelect);
		return -1;
	}
	
	bbzero(mny);//成功交易总额
	CTools::chgToMny(all_amount, mny);
	if (strcmp(promot_id,"201105QQ")!=0)
	{
		//bbzero(buff);
		//sprintf(buff,"提示：您3月成功交易总额：%s\n未能达到1万元的赠送起点，请继续加油！",mny);
		//TS_OutPutMsg(gbl.dPosInfo, buff, 0, iSelect);
		TS_OutPutMsg(gbl.dPosInfo,"暂无赠送领取,敬请关注！",0,iSelect);
		return -1;
	}
	
	bbzero(buff);
	bbzero(cStartBuff);
	bbzero(cEndBuff);
	memcpy(cStartBuff,start_date,4);
	strcat(cStartBuff,"-");
	memcpy(cStartBuff+5,start_date+4,2);
	strcat(cStartBuff,"-");
	memcpy(cStartBuff+8,start_date+6,2);
	
	memcpy(cEndBuff,end_date,4);
	strcat(cEndBuff,"-");
	memcpy(cEndBuff+5,end_date+4,2);
	strcat(cEndBuff,"-");
	memcpy(cEndBuff+8,end_date+6,2);
	sprintf(buff,"活动名称：★★交费易五月出行购票回馈★★\n兑换额度:%d\n已兑换额度:%d\n剩余兑换额度:%d\n兑换日期:%s至%s",donate_acount,donate_acount-remain_acount,remain_acount,cStartBuff,cEndBuff);
	iRet = TS_OutPutMsg(gbl.dPosInfo, buff, 0, iSelect);
	
	if (iRet == 0  && iSelect ==0)
	{
		NULL;
	}else
		return -2;
	
	if (remain_acount==0)
	{
		TS_OutPutMsg(gbl.dPosInfo,"\n您所获赠送Q币已全部使用\n感谢您对交费易的支持\n祝生意兴隆！",0,iSelect);
		return -3;
	}
	
	
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, type);
	
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入QQ号码：");	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
	tradeInfoSend.Contents[0].uCount = 1;		//输入1次卡号
	tradeInfoSend.Contents[0].uTimeOut = 30;	//超时30秒
	tradeInfoSend.Contents[0].uMinLen = 1;
	tradeInfoSend.Contents[0].uMaxLen = 11;
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
	strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
	gbl.phone_len = tradeInfoRecv.Contents[0].uMsgLen;
	memset( gbl.phone_no,0,sizeof(gbl.phone_no) );
	strcpy( gbl.phone_no,(char *)tradeInfoRecv.Contents[0].uMsg );
	
	//写查询域
	pack.wrField(1, gbl);
	
	//  查询包打包   
	iRet = packHdl(1);
	if(iRet < 0)
		return -1;
	memset(response_code,0,sizeof(response_code));
	memset(temp_buff,0,sizeof(temp_buff));
	memset(len_buff,0,sizeof(len_buff));
	memset(lastYear,0,sizeof(lastYear));
	memset(lastMonth,0,sizeof(lastMonth));
	memset(lastDay,0,sizeof(lastDay));
	memset(gbl.QQrate,0,sizeof(gbl.QQrate));
	
	memcpy(response_code,pack.FIELD39,2);
	wrLog("业务代码:[%s]",gbl.fee_type);
	if (!memcmp(response_code,"00",2)) 
	{
		memcpy(len_buff,&pack.FIELD48[4],2);
		gbl.phone_len =atoi(len_buff);
		memset( gbl.phone_no,0,sizeof(gbl.phone_no));
		memcpy(gbl.phone_no,&pack.FIELD48[6],gbl.phone_len);
		
		wrLog("pack.FIELD63:[%s]",pack.FIELD63);
		memcpy(lastYear,pack.FIELD63,4);
		lastYear[4]='\0';
		memcpy(lastMonth,pack.FIELD63+4,2);
		lastMonth[2]='\0';
		memcpy(lastDay,pack.FIELD63+6,2);
		lastDay[2]='\0';
		
		for(i=0;i<sizeof(pack.FIELD63)-10 && pack.FIELD63[i]!=':';i++);
		sprintf(gbl.QQrate, "%0.2d", (int) ( atof( (const char *)(pack.FIELD63+i+1) )*100 )) ;
		wrLog("gbl.QQrate: [%s]", gbl.QQrate);
		
		flag=0;
		while (flag==0)
		{
			TSMENULIST menuList;
			memset(&menuList,0,sizeof(menuList));
			menuList.iTotalNum = 5;
			strcpy(menuList.acTitle, "请选择您要充的Q币个数");
			strcpy(menuList.menuItem[0], "10个Q币");
			strcpy(menuList.menuItem[1], "20个Q币");
			strcpy(menuList.menuItem[2], "30个Q币");
			strcpy(menuList.menuItem[3], "40个Q币");
			strcpy(menuList.menuItem[4], "50个Q币");
			
			iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
			if (iRet)
			{
				return -1;
			}
			bbzero(gbl.amount);
			bbzero(gbl.QQ_amount);
			switch(iSelect)
			{
			case 1:
				strcpy(gbl.QQ_amount,"0010");
				sprintf(gbl.amount,"%0.12d",10*atoi(gbl.QQrate));
				pay_acount = 10;
				break;
			case 2:
				strcpy(gbl.QQ_amount,"0020");
				sprintf(gbl.amount,"%0.12d",20*atoi(gbl.QQrate));
				pay_acount = 20;
				break;
			case 3:
				strcpy(gbl.QQ_amount,"0030");
				sprintf(gbl.amount,"%0.12d",30*atoi(gbl.QQrate));
				pay_acount = 30;
				break;
			case 4:
				strcpy(gbl.QQ_amount,"0040");
				sprintf(gbl.amount,"%0.12d",40*atoi(gbl.QQrate));
				pay_acount = 40;
				break;
			case 5:
				strcpy(gbl.QQ_amount,"0050");
				sprintf(gbl.amount,"%0.12d",50*atoi(gbl.QQrate));
				pay_acount = 50;
				break;
			default:
				return -1;
			}
			if (pay_acount>remain_acount)
			{
				TS_OutPutMsg(gbl.dPosInfo,"\n您选择的Q币充值数量大于您所剩余的赠送量\n请重新选择！",0,iSelect);
				flag=0;
			}else
				flag=1;
		}
		bbzero(buff);
		sprintf(buff,"活动名称：★★交费易五月出行购票回馈★★\n\nQQ号码:%s\n充值Q币个数:%d\n\n【是 Enter】  【否 Esc】",gbl.phone_no,pay_acount);
		TS_OutPutMsg(gbl.dPosInfo,buff,0,iSelect);
		if (iSelect != 0)
		{
			return -1;
		}
		
		
		/********************请求刷卡****************/
		wrLog("gbl.amount: [%s]", gbl.amount);
		
		
		flag = 0;
		for(int curTry=0; curTry<MAXTRY; curTry++)
		{
			if(!flag)
			{
				iRet = mngCard_Hdl(type);
				if(iRet == CANCLE_KEY)
					return CANCLE_KEY;
				else if(iRet != 0)
					return -1;
			}
			if(!memcmp(gbl.card_no,"8828",4))	//若是付费易卡
			{
				memset(gbl.xlt_type, 0, sizeof(gbl.xlt_type));
				memcpy(gbl.xlt_type, "01",2);
				iRet = xltMulCard( type, 0);
				return iRet;
			}
			iRet = db.setIposPromo(gbl.pos_no,promot_id,remain_acount-pay_acount);
			if (iRet != 0)
			{
				TS_OutPutMsg(gbl.dPosInfo,"数据库操作失败，请稍后重试！",0,iSelect);
				return -1;
			}
			pack.wrField(2, gbl);	//写交费域
			
			//因为是QQ，所以要在63域加Q币个数或月数
			/*------------------------------*/
			memcpy(pack.FIELD63+pack.Packet_Table[63].Real_Length, gbl.QQ_amount, 4);
			pack.Packet_Table[63].Real_Length += 4;
			bbzero(pack.FIELD52);
			bbzero(buff);
			strcpy(buff,"17e82fbbddd53327");//生产
			//			strcpy(buff,"265C357F1A7C9B4E");//测试
			CTools::hex_to_byte((BYTE*)buff,(BYTE*)pack.FIELD52,16);
			pack.Packet_Table[52].Real_Length = 8;
			/*------------------------------*/
			
			iRet = packHdl(2);
			if(iRet < 0){
				return -1;
			}
			
			if (!memcmp(pack.FIELD39,"00",2))
			{
				bbzero(buff);
				sprintf(buff,"\nQ币充值成功\n剩余可使用赠送Q币个数为：%d",remain_acount-pay_acount);
				iRet = TS_OutPutMsg(gbl.dPosInfo,buff,0,iSelect);
				return 0;
			}
			else{
				iRet = db.setIposPromo(gbl.pos_no,promot_id,remain_acount);
				if (iRet != 0)
				{
					TS_OutPutMsg(gbl.dPosInfo,"数据库操作失败，如若出现剩余Q币问题，请联系在线客服【Ctrl+H】或者致电400-80-11888！",0,iSelect);
					return -1;
				}
				returnFail((char *)pack.FIELD39);
			}
			return -1;
		}
		return -1;
	}
	else
	{
		returnFail(response_code);
		return -1;
	}
	return 0;
}


//type：标题
int CTrade::trafficTrade(const char *type, int flag)		//交罚交易
{
	int iRet=0, iRetB=0, iSelect=0;	
	char enqFIELD48[42+1], enqFIELD63[999+1], enqStan[12+1], mark_card[30+1];
	bbzero(enqFIELD48);
	bbzero(enqFIELD63);
	bbzero(mark_card);
	strncpy(mark_card, gbl.card_no, sizeof(mark_card)-1);
	
	if (strcmp(gbl.acc_city_no,"0769")==0)
	{
		bbzero(gbl.fee_type);
		strcpy(gbl.fee_type,"0232");
	}
	
	iRet = trafficInqHdl(type, enqFIELD48, enqFIELD63, enqStan,flag);
	if(iRet==0)
	{
		iRet = trafficPayHdl(type, enqFIELD48, enqFIELD63, enqStan);
	}
	if( gbl.get_card == MNG_ONE_BIND_E || gbl.get_card == MNG_MUL_BIND_E )//还原原先刷的卡
	{
		iRetB = bindcard(mark_card, gbl.card_no, &gbl.card_no_len);
		if(iRetB != 0)
		{
			TS_OutPutMsg(gbl.dPosInfo,"绑定原卡号出错!请挂机重连!",0,iSelect);
			TS_HangUp(gbl.dPosInfo);
		}
	}
	return iRet;
}

int CTrade::trafficInqHdl(const char *type, char *enqFIELD48, char *enqFIELD63, char *enqStan,int flag)	//交罚查询
{
	int  iRet,iSelect;
	int  b48_len,trafficNo_len;
	char trafficType[4+1], trafficNo[16+1];
	
	wrLog("%s【查询】", type);
	
	if(atoi(gbl.dPosInfo.prmVer)>=9000)
	{
		;
	}
	else{
		iRet = TS_OutPutMsg(gbl.dPosInfo, "本系统暂只受理文书号前四位为'4401'的处罚通知书\n【确认】继续\n【返回】返回", 0,iSelect);
		if(iSelect)
			return CANCLE_KEY;
	}
	
	//取得罚单文书类型
	if (flag ==0)
	{
		strcpy(trafficType,"1001");
	}else if(flag==1){
		iRet = selectAmount();
		bbzero(trafficType);
		if(iRet == CANCLE_KEY)
			return CANCLE_KEY;
		else if(iRet < 0)
			return -1;
		switch(iRet){
		case 1:
			strcpy(trafficType,"6001");
			break;
		case 2:
			strcpy(trafficType,"8001");
			break;
		case 3:
			strcpy(trafficType,"1002");
			break;
		case 4:
			strcpy(trafficType,"1004");
			break;
		case 5:
			strcpy(trafficType, "2006");
			break;
		default:
			return -2;
		}
	}else{
        iRet = selectAmount();
		bbzero(trafficType);
		if(iRet == CANCLE_KEY)
			return CANCLE_KEY;
		else if(iRet < 0)
			return -1;
		switch(iRet){
		case 1:
			strcpy(trafficType,"1001");
			break;
		case 2:
			strcpy(trafficType,"6001");
			break;
		case 3:
			strcpy(trafficType,"8001");
			break;
		case 4:
			strcpy(trafficType,"1002");
			break;
		case 5:
			strcpy(trafficType,"1004");
			break;
		case 6:
			strcpy(trafficType, "2006");
			break;
		default:
			return -2;
		}
	}
	
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, type);
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入文书号");	
	tradeInfoSend.Contents[0].uMinLen = 15;		
	tradeInfoSend.Contents[0].uMaxLen = 16;
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
	tradeInfoSend.Contents[0].uCount = 0;		//输入1次		
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
	strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
	memset( trafficNo,0,sizeof(trafficNo) );
	memcpy( trafficNo, (char *)tradeInfoRecv.Contents[0].uMsg, tradeInfoRecv.Contents[0].uMsgLen);
	trafficNo_len = tradeInfoRecv.Contents[0].uMsgLen;
	wrLog("文书类型:[%s]文书号:[%s]", trafficType, trafficNo);
	
	//写查询域
	pack.wrField(1, gbl);
	bbzero(pack.FIELD48);
	memcpy(pack.FIELD48,gbl.fee_type,4);	//4位信息码
	b48_len = 4;
	sprintf((char *)pack.FIELD48+b48_len,"%02d", 4+trafficNo_len);	//文书号以及文书类型长度
	b48_len +=2;
	memcpy(pack.FIELD48+b48_len, trafficType, 4);	//文书类型
	b48_len +=4;
	memcpy(pack.FIELD48+b48_len, trafficNo, trafficNo_len);	//文书号
	b48_len += trafficNo_len;
	pack.Packet_Table[48].Real_Length=b48_len;
	
	//查询包打包   
	iRet = packHdl(1);
	if(iRet < 0)
		return -1;
	
	memcpy(enqFIELD48, pack.FIELD48, pack.Packet_Table[48].Real_Length);
	memcpy(enqFIELD63, pack.FIELD63, pack.Packet_Table[63].Real_Length);
	memcpy(enqStan, pack.FIELD37, 12);
	//返回数据给终端
	iRet = trafficInqMsg(type, (char *)pack.FIELD39, enqFIELD63, gbl.amount);
	return iRet;
}


//下发交罚查询信息
int CTrade::trafficInqMsg(const char *type, char *enqFIELD39, char *enqFIELD63, char *gbl_amount)	
{
	int iSelect=0, b63Idx=0;
	char response_code[3];
	char temp_buff[512], detail_buf[100], len_buf[2+1], date[14+1], amount[12+1], tatolAmo[12+1];
	bbzero(temp_buff);
	bbzero(detail_buf);
	bbzero(len_buf);
	bbzero(date);
	bbzero(amount);
	bbzero(tatolAmo);
	memcpy(response_code,enqFIELD39,2);
	if (!memcmp(response_code,"00",2))
	{
		bbzero(temp_buff);
		b63Idx = 2;
		memcpy(len_buf, enqFIELD63+b63Idx, 2);
		b63Idx += 2;
		bbzero(detail_buf);
		memcpy(detail_buf, enqFIELD63+b63Idx, atoi(len_buf));
		b63Idx += atoi(len_buf);
		sprintf(temp_buff+strlen(temp_buff), "违章顺序号:\n%s\n", detail_buf);
		
		memcpy(len_buf, enqFIELD63+b63Idx, 2);
		b63Idx += 2;
		bbzero(detail_buf);
		memcpy(detail_buf, enqFIELD63+b63Idx, atoi(len_buf));
		b63Idx += atoi(len_buf);
		sprintf(temp_buff+strlen(temp_buff), "身份证:\n%s\n", detail_buf);
		
		bbzero(detail_buf);
		memcpy(detail_buf, enqFIELD63+b63Idx, 2);
		b63Idx += 2;
		sprintf(temp_buff+strlen(temp_buff), "号牌种类:%s\n", detail_buf);
		
		memcpy(len_buf, enqFIELD63+b63Idx, 2);
		b63Idx += 2;
		bbzero(detail_buf);
		memcpy(detail_buf, enqFIELD63+b63Idx, atoi(len_buf));
		b63Idx += atoi(len_buf);
		sprintf(temp_buff+strlen(temp_buff), "号牌简称:%s\n", detail_buf);
		
		memcpy(len_buf, enqFIELD63+b63Idx, 2);
		b63Idx += 2;
		bbzero(detail_buf);
		memcpy(detail_buf, enqFIELD63+b63Idx, atoi(len_buf));
		b63Idx += atoi(len_buf);
		sprintf(temp_buff+strlen(temp_buff), "车牌号码:%s\n", detail_buf);
		
		memcpy(len_buf, enqFIELD63+b63Idx, 2);
		b63Idx += 2;
		bbzero(detail_buf);
		memcpy(detail_buf, enqFIELD63+b63Idx, atoi(len_buf));
		b63Idx += atoi(len_buf);
		sprintf(temp_buff+strlen(temp_buff), "当事人:%s\n", detail_buf);
		
		memcpy(len_buf, enqFIELD63+b63Idx, 2);
		b63Idx += 2;
		bbzero(detail_buf);
		memcpy(detail_buf, enqFIELD63+b63Idx, atoi(len_buf));
		b63Idx += atoi(len_buf);
		//		sprintf(temp_buff+strlen(temp_buff), "联系电话:%s\n", detail_buf);
		
		bbzero(date);
		memcpy(date, enqFIELD63+b63Idx, 14);
		b63Idx += 14;
		bbzero(detail_buf);
		memcpy(detail_buf, date, 8);
		memcpy(detail_buf + strlen(detail_buf), " ", 1);
		memcpy(detail_buf + strlen(detail_buf), date+8, 6);
		sprintf(temp_buff+strlen(temp_buff), "时间:%s\n", detail_buf);
		
		bbzero(detail_buf);
		memcpy(amount, enqFIELD63+b63Idx,sizeof(amount)-1);
		b63Idx += 12;
		CTools::chgToMny(amount, detail_buf);			
		sprintf(temp_buff+strlen(temp_buff), "罚款金额:%s\n", detail_buf);
		
		memcpy(tatolAmo, enqFIELD63+b63Idx, sizeof(tatolAmo)-1);
		memcpy(gbl_amount, tatolAmo, 12);
		b63Idx += 12;//合计罚款金额
		
		bbzero(detail_buf);
		memcpy(amount, enqFIELD63+b63Idx,sizeof(amount)-1);
		b63Idx += 12;
		CTools::chgToMny(amount, detail_buf);
		sprintf(temp_buff+strlen(temp_buff), "滞纳金:%s\n", detail_buf);
		
		bbzero(detail_buf);
		CTools::chgToMny(tatolAmo, detail_buf);
		sprintf(temp_buff+strlen(temp_buff), "合计罚款金额:%s\n", detail_buf);
		
		memcpy(len_buf, enqFIELD63+b63Idx, 2);
		b63Idx += 2;
		bbzero(detail_buf);
		memcpy(detail_buf, enqFIELD63+b63Idx, atoi(len_buf));
		b63Idx += atoi(len_buf);
		//		sprintf(temp_buff+strlen(temp_buff), "执罚单位:%s\n【确认】交罚单\n【返回】返回", detail_buf);
		sprintf(temp_buff+strlen(temp_buff), "【确认】交罚单\n【返回】返回");
		TS_OutPutMsg(gbl.dPosInfo, temp_buff, 0,iSelect);
		return iSelect;
	}
	else
	{
		returnFail(response_code);
		return -1;
	}
}

//type：标题
//返回0表示成功
int CTrade::trafficPayHdl(const char *type, char *enqFIELD48, char *enqFIELD63, char *enqStan)	//电信交费
{
	int  iRet, flag,iSelect;
	
	wrLog("%s【交费】", type);
	flag = 0;	//重输密码标识
	/********************请求刷卡****************/
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{
		if(!flag) 
		{
			if( gbl.get_card == MNG_ONE_BIND_E || gbl.get_card == MNG_MUL_BIND_E )
				iRet = mngCard_Hdl(type, "", 0, 1);//只能刷卡，多次刷卡模式
			else
				iRet = mngCard_Hdl(type);
			if(iRet == CANCLE_KEY)
				return CANCLE_KEY;
			else if(iRet != 0){
				TS_OutPutMsg(gbl.dPosInfo,"读取输入数据错误!\n交易失败!\n按【确认】返回",1,iSelect);
				return -1;
			}
			
			if(!memcmp(gbl.card_no,"8828",4))	//若是付费易卡,走付费易卡刷卡流程（多卡交易）
			{
				memset(gbl.xlt_type, 0, sizeof(gbl.xlt_type));
				memcpy(gbl.xlt_type, "01",2);
				iRet = xltMulCard( type, 0);
				return iRet;
			}
		}
		
		pack.wrField(2, gbl);	//写交费域
		/***********修改一些域信息*********/
		bbzero(pack.FIELD48);
		memcpy(pack.FIELD48, enqFIELD48, strlen(enqFIELD48));
		pack.Packet_Table[48].Real_Length = strlen(enqFIELD48);
		memcpy(pack.FIELD63+8, enqStan, 12);
		pack.Packet_Table[63].Real_Length = 20;
		
		/**********************************/
		
		//交费包处理
		iRet = packHdl(2);
		if(iRet < 0)
			return -1;
		
		if (!memcmp(pack.FIELD39,"00",2)) 
		{
			
			iRet = TS_OutPutMsg(gbl.dPosInfo,"     交费成功！\n    谢谢您的使用\n请按【确认】打印票据",0,iSelect);
			
			if(iRet!=0 || iSelect==0)
			{
				CPrint prt;
				prt.set_in_par(gbl);
				prt.print_detail(9, "代收交通罚款", enqFIELD48, enqFIELD63);	//打印欠费明细
				//prt.print_traffic_detail(pack,"代收交通罚款", enqFIELD48, enqFIELD63);
				
			}	
			return 0;
		}// end if (!memcmp(pack.FIELD39,"00",2))
		else if(!memcmp(pack.FIELD39,"55",2))
		{
			flag = 1;
			if(reGetPwd( type) == 0) //密码错误，重新输入密码, 2006-10-25
				continue;
			else
				return CANCLE_KEY;
		}	
		else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
			if (iSelect!=0)
			{
				return -1;
			}else
				continue;
		}
		returnFail((char *)pack.FIELD39);		
		return -1;
	}// end for(int curTry=0; curTry<MAXTRY; curTry++)
	return -1;
}


//交罚凭证补打
int CTrade::rePrintTra(const char *title){
	
	int  iRet;
	int  b48_len,trafficNo_len;
	char trafficType[4+1], trafficNo[20+1],tmp[20+1];
	char card_info[200];
	char enqFIELD48[42+1], enqFIELD63[999+1], enqStan[12+1];
	bbzero(enqFIELD48);
	bbzero(enqFIELD63);
	BYTE temp_buff[2048];
	
    
	/**************取得卡号*******************/
	if(atoi(gbl.dPosInfo.prmVer)>=9000){
		for(int curTry=0; curTry<MAXTRY; curTry++)
		{
			bbzero(card_info);
			if( gbl.get_card == MNG_ONE_BIND_E || gbl.get_card == MNG_MUL_BIND_E )
				iRet = getCardInfo( title, card_info, ONLY_MNG, MNG_MUL, "请刷卡");//只能刷卡，多次刷卡模式
			else
				iRet = getCardInfo( title, card_info, ONLY_MNG, gbl.get_card, "请刷卡");//刷卡取得卡信息
			
			if(iRet==0)
				iRet = getCardNum(card_info);
			
			if( (iRet == CANCLE_KEY) )
				return CANCLE_KEY;
			else if( (iRet == RE_MNG_CARD) )
				return RE_MNG_CARD;
			else if(iRet != 0)
				return -1;
			else
				break;
		}
	}else{
		for(int curTry=0; curTry<MAXTRY; curTry++)
		{
			bbzero(card_info);
			iRet = getCardInfo("补打交罚凭证", card_info, MNG_OR_INPUT, gbl.get_card, "", 6, 19);
			if( iRet == 0 )
				iRet = getCardNum(card_info, MNG_OR_INPUT);//取得卡号
			if( (iRet == CANCLE_KEY) )
				return CANCLE_KEY;
			else if( (iRet == RE_MNG_CARD) )
				continue;
			else if(iRet != 0)
				return -1;
			else
				break;
		}
	}
	
	if( !memcmp( gbl.card_no, "991088", 6) )
	{
		char tmp_card[20];
		bbzero(tmp_card);
		gbl.card_no_len -= 2;
		memcpy(tmp_card, gbl.card_no+2, gbl.card_no_len);
		bbzero(gbl.card_no);
		strcpy(gbl.card_no, tmp_card);
	}
	
	wrLog("卡号[%d]：[%s]",gbl.card_no_len,gbl.card_no);
	
	
	//取得罚单文书类型
	iRet = selectAmount();
	bbzero(trafficType);
	if(iRet == CANCLE_KEY)
		return CANCLE_KEY;
	else if(iRet < 0)
		return -1;
	switch(iRet){
	case 1:
		strcpy(trafficType,"1001");
		break;
	case 2:
		strcpy(trafficType,"6001");
		break;
	case 3:
		strcpy(trafficType,"8001");
		break;
	case 4:
		strcpy(trafficType,"1002");
		break;
	case 5:
		strcpy(trafficType,"1004");
		break;
	case 6:
		strcpy(trafficType, "2006");
		break;
	default:
		return -2;
	}
    
	
	
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	
	memset(&tradeInfoSend,0,sizeof(tradeInfoSend));
	memset(&tradeInfoRecv,0,sizeof(tradeInfoRecv));
	
	tradeInfoSend.uHasTradeID=1;
	tradeInfoSend.uTotalContents=1;
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入文书号");	
	tradeInfoSend.Contents[0].uMinLen = 15;		
	tradeInfoSend.Contents[0].uMaxLen = 20;
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//数字
	tradeInfoSend.Contents[0].uCount = 0;		//输入1次		
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if (iRet)
	{
		wrLog("第一次和终端交互失败 iRet=%d",iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);
		return(iRet);
	}
	
	memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
	strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
	memset( trafficNo,0,sizeof(trafficNo) );
	memcpy( trafficNo, (char *)tradeInfoRecv.Contents[0].uMsg, tradeInfoRecv.Contents[0].uMsgLen);
	memset(tmp,0,sizeof(tmp));
	memcpy(tmp,trafficNo,4);
	if(atoi(tmp)==1001||atoi(tmp)==6001||atoi(tmp)==8001||atoi(tmp)==1002||atoi(tmp)==1004){
		memset(tmp,0,sizeof(tmp));
		strcpy(tmp,trafficNo);
		memset(trafficNo,0,sizeof(trafficNo) );
		strcpy(trafficNo, tmp+4);
		
	}
	trafficNo_len = strlen(trafficNo);
	wrLog("文书类型:[%s]文书号:[%s]", trafficType, trafficNo);
	
	//写查询域
	pack.wrField(1, gbl);
	
	//bit2
    bbzero(pack.FIELD2);
	memset((char *)temp_buff,0,sizeof(temp_buff));
	strcpy((char *)temp_buff,gbl.card_no);
	if(gbl.card_no_len%2)		//卡号是奇数，后补"F"
	{
		strcat((char *)temp_buff,"F");
	}
	CTools::hex_to_byte((BYTE *)temp_buff, pack.FIELD2, gbl.card_no_len, 1);	//变为bcd码（后补0）
	pack.Packet_Table[2].Real_Length=gbl.card_no_len;
    
	//bit48
	bbzero(pack.FIELD48);
	memcpy(pack.FIELD48,gbl.fee_type,4);	//4位信息码
	b48_len = 4;
	sprintf((char *)pack.FIELD48+b48_len,"%02d", 4+trafficNo_len);	//
	b48_len +=2;
	memcpy(pack.FIELD48+b48_len, trafficType, 4);	//文书类型
	b48_len +=4;
	memcpy(pack.FIELD48+b48_len, trafficNo, trafficNo_len);	//文书号
	b48_len += trafficNo_len;
	pack.Packet_Table[48].Real_Length=b48_len;
	
	wrLog("与PE交互");
	if(iRet=packHdl(1)<0)// send pack
	{
		wrLog("与PE交互失败！");
		return iRet;
	}else if(!memcmp(pack.FIELD39,"00",2)){	
		wrLog("打印发票");	
		memcpy(enqFIELD48, pack.FIELD48, pack.Packet_Table[48].Real_Length);
		memcpy(enqFIELD63, pack.FIELD63, pack.Packet_Table[63].Real_Length);
		memcpy(enqStan, pack.FIELD37, 12);
		
		CPrint prt;
		prt.set_in_par(gbl);
		prt.print_detail(10, "代收交通罚款",enqFIELD48,enqFIELD63);	//交罚补打凭证
		//prt.print_traffic_detail(pack,"代收交通罚款",enqFIELD48,enqFIELD63);
        return 0;
		
	}else{
		returnFail((char *)pack.FIELD39);
		return -1;
	}
	
	
}

//设置羊城通PIN
int CTrade::SetPIN(int flag)
{
	char sendPIN[31],pin[6+1],password[8+1],temp_buff[4096];
	int  iRet,iSelect;
	
	bbzero(sendPIN);
	bbzero(pin);
	bbzero(password);
	bbzero(temp_buff);
	
	memcpy(password,"12345678",strlen("12345678"));
	
	if (flag == 1)
	{
		TSTradeInfoSend tradeInfoSend;
		TSTradeInfoRecv tradeInfoRecv;
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
		
		strcpy(tradeInfoSend.acMainTitle, "羊城通设置PIN");
		
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents = 1;
		
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入羊城通PIN：");	
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
		tradeInfoSend.Contents[0].uCount = 0;		//输入1次卡号
		tradeInfoSend.Contents[0].uTimeOut = 30;	//超时30秒
		tradeInfoSend.Contents[0].uMinLen = 6;
		tradeInfoSend.Contents[0].uMaxLen = 6;
		
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		
		if(iRet != 0)
		{
			wrLog("TS_TradeControl返回错误[%d]", iRet);
			wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
			return iRet;
		}
		
		strcpy(pin,(char *)tradeInfoRecv.Contents[0].uMsg);
		sprintf(sendPIN,"c%s%s",password,pin);
		
		wrLog("【PIN】%s",pin);
		wrLog("【传输字串】%s",sendPIN);
		
		sprintf(temp_buff,"您输入的PIN是：%s\n\n请按【确定】继续设置",pin);
		TS_OutPutMsg(gbl.dPosInfo, temp_buff, 0,iSelect);
		CYCTYPTrade cycttrade;
		cycttrade.setInPar(gbl);
		cycttrade.yctSetting(sendPIN);
		
	}
	else if (flag == 2)
	{
		CDB::getYctPIN(gbl.pos_no,pin);
		sprintf(sendPIN,"c%s%s",password,pin);
		wrLog("【PIN】%s",pin);
		wrLog("【传输字串】%s",sendPIN);
		CYCTYPTrade cycttrade;
		cycttrade.setInPar(gbl);
		cycttrade.yctSetting(sendPIN);		
	}
	else
		return -1;
	return 0;
}

int CTrade::ysqCatv()
{
	wrLog("【Catv预授权】");
	
	int  iSelect,curTry=0;
	char response_code[3],card_info[200+1];
	char outputmassage[1024];
	char tmp[10];
	char tittle[50];
	int name_len=0;	
	int id_len=0;
	int iRet;
	char temp_buff[250];
	char title[1024];
	bbzero(title);
	memcpy(title,"Catv预授权",strlen("Catv预授权"));
    TS_OutPutMsg(gbl.dPosInfo,"友情提示：\n   本业务只支持以下银行：招商银行，邮政储蓄，建设银行，民生银行，广发银行。\n\n请按【确定】继续",0,iSelect);              
	//刷卡
	wrLog("开始刷卡");
	for(curTry=0; curTry<MAXTRY; curTry++)
	{
		bbzero(card_info);
		iRet = getCardInfo(title, card_info);//刷卡取得卡信息
		if( iRet == 0 )
			iRet = getCardNum(card_info);//取得卡号
		
		if(!iRet)
			break;
		else if(iRet == CANCLE_KEY)
		{
			wrLog("取消刷卡");
			return CANCLE_KEY;
		}
		else if(iRet == RE_MNG_CARD)
		{
			wrLog("重新刷卡");
			continue;
		}
		else if(iRet != 0)
		{
			wrLog("刷卡失败");
			return -1;
		}
	}

	wrLog("刷卡成功");
	/*不推出则继续流程*/
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	/*提示输入身份证号码*/
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	
	strcpy(tradeInfoSend.acMainTitle, "有线预授权");
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 2;
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入您的手机号码");	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
	tradeInfoSend.Contents[0].uCount = 0;		//输入2次
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
	tradeInfoSend.Contents[0].uMinLen = 11;		
	tradeInfoSend.Contents[0].uMaxLen = 11;	
	
	strcpy(tradeInfoSend.Contents[1].acTitle, "请输入您的身份证号码");
	tradeInfoSend.Contents[1].uCommand = TS_INPUT_ALL_CHAR;	//全字符(因身份证末尾可能有字母)
	tradeInfoSend.Contents[1].uTimeOut = EPOS_OVER_TIME + 10;	//超时40秒
	tradeInfoSend.Contents[1].uMinLen = 15;		
	tradeInfoSend.Contents[1].uMaxLen = 18;
	
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	memset( gbl.CATV_id_card,0,sizeof(gbl.CATV_id_card) );
	memcpy(gbl.CATV_id_card,(char *)tradeInfoRecv.Contents[1].uMsg,tradeInfoRecv.Contents[1].uMsgLen);
	wrLog("身份证号码:[%s]", gbl.CATV_id_card);
	wrLog("身份证长度:[%d]", strlen(gbl.CATV_id_card));            
	
	gbl.phone_len = tradeInfoRecv.Contents[0].uMsgLen;
	memset( gbl.phone_no,0,sizeof(gbl.phone_no) );
	strcpy( gbl.phone_no,(char *)tradeInfoRecv.Contents[0].uMsg );
	wrLog("手机号码:[%s]", gbl.phone_no);
	
	bbzero(outputmassage);
	sprintf(outputmassage,"您输入的信息：\n1.手机号码：%s\n2.身份证号码：%s\n3.银行卡号：%s\n请按【确定】继续",gbl.phone_no,gbl.CATV_id_card,gbl.card_no);
	TS_OutPutMsg(gbl.dPosInfo,outputmassage,0,iSelect);
	
	bbzero(pack.FIELD48);
	strcpy(gbl.fee_type,"0222");                 
	pack.wrField(1, gbl);
	bbzero(pack.FIELD3);
	CTools::hex_to_byte((BYTE *)"310000", pack.FIELD3, 6);
	memcpy(pack.FIELD48,gbl.fee_type,4);	//4位信息码
	memcpy(pack.FIELD48+4,gbl.phone_no,11);	//4位信息码
	pack.Packet_Table[48].Real_Length=15;
	
	bbzero(pack.FIELD63);
	id_len=strlen(gbl.CATV_id_card);
	bbzero(tmp);
	sprintf(tmp,"%02d",id_len);
	memcpy(pack.FIELD63,tmp,2);
	memcpy(pack.FIELD63+2,gbl.CATV_id_card,id_len);
	pack.Packet_Table[63].Real_Length = 2+id_len;
	//bit2
	memset(pack.FIELD2, 0, sizeof(pack.FIELD2));
	memset((char *)temp_buff,0,sizeof(temp_buff));
	strcpy((char *)temp_buff,gbl.card_no);
	CTools::hex_to_byte((BYTE *)temp_buff, pack.FIELD2, gbl.card_no_len, 1);	//变为bcd码（后补0）
	pack.Packet_Table[2].Real_Length=gbl.card_no_len;
	//  查询包打包   
	if(packHdl(1) < 0)
	{
		return -1;
	}
	else{
		memset(response_code,0,sizeof(response_code));
		memcpy(response_code,pack.FIELD39,2);
		if (!memcmp(response_code,"00",2)) 
		{
			
			iRet = TS_OutPutMsg(gbl.dPosInfo,"		  登记成功！\n请检查打印机电源及打印线路是否正常,有问题请即与400-80-11888联系\n按【确认】打印发票",0,iSelect);
			if(iRet!=0 || iSelect==0)
			{
				CPrint prt;
				prt.set_in_par(gbl);
				bbzero(tittle);
				strcpy((char *)tittle,"有线登记回执");
				//prt.print_detail(8, tittle);	//打印明细
				prt.print_ysq_detail(pack,tittle);
			}
			
			return 0;
		}
		else if (!memcmp(response_code,"96",2))
		{
			TS_OutPutMsg(gbl.dPosInfo, " \n   登记操作出错\n请稍候再试!\n   按【确认】返回", 0,iSelect);
			return -1;
		}else if (!memcmp(response_code,"94",2))
		{
			TS_OutPutMsg(gbl.dPosInfo, " \n   登记操作出错\n该身份证已进行过登记\n请联系在线客服中心【Ctrl+H】  400-80-11888\n   按【确认】返回", 0,iSelect);
			return -1;
		}
		else{
			returnFail((char *)pack.FIELD39);
			return -1;
		}
	}               
	
}

int CTrade::ysqCatv_new()
{                  
	int  iSelect,curTry=0;
	char response_code[3];
	char tmp[10];
	char tittle[50];
	int name_len=0;	
	int id_len=0;
	int iRet;
	char temp_buff[250];
	char len_buff[2+1];
	char title[1024];
	int tel_type=0;
	int b48_len;
	char pwd_buf[8+1];
	TSMENULIST menuList;
	strcpy(gbl.fee_type,"0222");  
	bbzero(title);
	memcpy(title,"交费易签约",strlen("交费易签约"));
    TS_OutPutMsg(gbl.dPosInfo,"交费易签约步骤：\n1、输入身份证号码\n2、刷银行卡\n3、手机30元充值\n4、输入自设密码\n请按【确定】继续",0,iSelect);
	if (iSelect!=0)
	{
		return -1;
	}
	
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	
	strcpy(tradeInfoSend.acMainTitle, "交费易签约");
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;	
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入您的身份证号码");
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//全字符(因身份证末尾可能有字母)
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME + 10;	//超时40秒
	tradeInfoSend.Contents[0].uMinLen = 15;		
	tradeInfoSend.Contents[0].uMaxLen = 18;
	
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	memset( gbl.CATV_id_card,0,sizeof(gbl.CATV_id_card) );
	memcpy(gbl.CATV_id_card,(char *)tradeInfoRecv.Contents[0].uMsg,tradeInfoRecv.Contents[0].uMsgLen);
	wrLog("身份证号码:[%s]", gbl.CATV_id_card);
	wrLog("身份证长度:[%d]", strlen(gbl.CATV_id_card));            
	
	//刷卡
	wrLog("开始刷卡");
	int flag = 0;
	for(curTry=0; curTry<MAXTRY; curTry++)
	{
		if(!flag)
		{
			iRet = mngCard_Hdl(title);
			if(iRet == CANCLE_KEY)
				return CANCLE_KEY;
			else if(iRet != 0)
				return -1;
		}
		
		if(iRet == RE_MNG_CARD)
		{
			wrLog("重新刷卡");
			continue;
		}
		else if (iRet == 0)
		{
			wrLog("刷卡成功");	
			
			memset(&menuList,0,sizeof(menuList));
			menuList.iTotalNum = 2;
			strcpy(menuList.acTitle, "请选择手机充值类型");
			strcpy(menuList.menuItem[0], "中国移动");
			strcpy(menuList.menuItem[1], "中国联通");
			
			iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
			if(iRet)
				return -1;
			memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
			memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
			
			strcpy(tradeInfoSend.acMainTitle, title);
			tradeInfoSend.uHasTradeID = 1;
			tradeInfoSend.uTotalContents = 1;
			switch(iSelect)
			{
			case 1:
				tel_type = 1;
				wrLog("【移动空中充值】");
				strcpy(gbl.fee_type,AIRPAY);		
				
				strcpy(tradeInfoSend.Contents[0].acTitle, "请输入要充值的手机号码");	
				tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
				tradeInfoSend.Contents[0].uCount = 1;		//输入2次
				tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
				tradeInfoSend.Contents[0].uMinLen = 11;		
				tradeInfoSend.Contents[0].uMaxLen = 11;	
				
				iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
				if(iRet != 0)
				{
					wrLog("TS_TradeControl返回错误[%d]", iRet);
					wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
					return iRet;
				}
				break;
			case 2:
				tel_type = 2;
				wrLog("【联通充值】");
				strcpy(gbl.fee_type,"0049");		
				memset(gbl.uni_flag,0,sizeof(gbl.uni_flag));
				strcpy(gbl.uni_flag,"1");
				memset(gbl.sub_code,0,sizeof(gbl.sub_code));
				strcpy(gbl.sub_code,"01");
				strcpy(tradeInfoSend.Contents[0].acTitle, "请输入手机号码");	
				tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
				tradeInfoSend.Contents[0].uCount = 0;		//输入1次
				tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
				tradeInfoSend.Contents[0].uMinLen = 11;		
				tradeInfoSend.Contents[0].uMaxLen = 11;	
				
				iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
				if(iRet != 0)
				{
					wrLog("TS_TradeControl返回错误[%d]", iRet);
					wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
					return iRet;
				}
				break;
			default: 
				return -1;
			}
			memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
			strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
			gbl.phone_len = tradeInfoRecv.Contents[0].uMsgLen;
			memset( gbl.phone_no,0,sizeof(gbl.phone_no) );
			strcpy( gbl.phone_no,(char *)tradeInfoRecv.Contents[0].uMsg );
			wrLog("手机号码:[%s]", gbl.phone_no);
			
			
			memset(&menuList,0,sizeof(menuList));
			menuList.iTotalNum = 1;
			strcpy(menuList.acTitle, "请选择您要充值的金额");
			strcpy(menuList.menuItem[0], "30元");
			
			iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
			if(iRet)
				return -1;
			switch(iSelect)
			{
			case 1:
				strcpy(gbl.amount,"000000003000");
				break;
			default:
				return -1;
			}
			if (tel_type == 2)
			{
				
				//写查询域
				pack.wrField(1, gbl);
				/************修改一些域*********/
				b48_len = pack.Packet_Table[48].Real_Length;
				memcpy(pack.FIELD48+b48_len,gbl.uni_flag,1);
				b48_len +=1;
				memcpy(pack.FIELD48+b48_len,gbl.sub_code,2);
				b48_len +=2;
				wrLog("bit48:[%s]",pack.FIELD48);
				pack.Packet_Table[48].Real_Length = b48_len;
				/*******************************/
				
				//  查询包打包   
				iRet = packHdl(1);
				if(iRet < 0)
					return -1;
				
			}
			
			pack.wrField(2, gbl);	//写交费域
			if (tel_type == 2)
			{
				/**************修改一些域**************/
				bbzero(pack.FIELD48);
				bbzero(len_buff);
				sprintf(len_buff,"%02d",gbl.pay_no_len);
				memcpy(pack.FIELD48,gbl.fee_type,4);
				b48_len =4;
				memcpy(pack.FIELD48+b48_len,len_buff,2);
				b48_len +=2;
				memcpy(pack.FIELD48+b48_len,gbl.pay_no,gbl.pay_no_len);
				b48_len +=gbl.pay_no_len;
				memcpy(pack.FIELD48+b48_len,gbl.uni_flag,1);
				b48_len +=1;
				memcpy(pack.FIELD48+b48_len,gbl.sub_code,2);
				b48_len +=2;
				memset(pack.FIELD48+b48_len,'A',1);
				b48_len +=1;
				pack.Packet_Table[48].Real_Length=b48_len;
				/**************************************/
				
			}
			//交费包
			iRet = packHdl(2);
			if(iRet < 0)
				return -1;
			
			memset(response_code,0,sizeof(response_code));
			memcpy(response_code,pack.FIELD39,2);
			if (!memcmp(response_code,"00",2)) 
			{
				TS_OutPutMsg(gbl.dPosInfo,"\n      充值成功！\n  请按【确认】继续",0,iSelect);
				if (iSelect == 0)
				{
					break;
				}else
					return -1;
				
			}
			else if(!memcmp(response_code,"55",2))
			{
				flag = 1;
				if(reGetPwd(title) == 0) //密码错误，重新输入密码, 2006-10-25
					continue;
				else
					return CANCLE_KEY;
			}
			else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
			{
				TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
				if (iSelect!=0)
				{
					return -1;
				}else
					continue;
			}
			else{
				returnFail(response_code);
				return -1;
			}
			
		}else
			return -1;
		
	}
	
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	
	strcpy(tradeInfoSend.acMainTitle, "交费易签约");
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;	
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请设置交费易密码");
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_PWD;	//全字符(因身份证末尾可能有字母)
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME + 10;	//超时40秒
	tradeInfoSend.Contents[0].uCount = 1;		//输入2次
	tradeInfoSend.Contents[0].uMinLen = 6;		
	tradeInfoSend.Contents[0].uMaxLen = 6;
	
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	memset( gbl.catv_paypassword,0,sizeof(gbl.catv_paypassword) );
	memcpy(gbl.catv_paypassword,(char *)tradeInfoRecv.Contents[0].uMsg,tradeInfoRecv.Contents[0].uMsgLen);        
	
	bbzero(pack.FIELD48);
	strcpy(gbl.fee_type,"0222");                 
	pack.wrField(1, gbl);
	bbzero(pack.FIELD3);
	CTools::hex_to_byte((BYTE *)"310060", pack.FIELD3, 6);
	memcpy(pack.FIELD48,gbl.fee_type,4);
	memcpy(pack.FIELD48+4,"11",2);
	memcpy(pack.FIELD48+6,gbl.phone_no,11);	
	pack.Packet_Table[48].Real_Length=17;
	
	bbzero(pack.FIELD63);
	bbzero(pwd_buf);
	if(TEKEny(gbl.dPosInfo,gbl.catv_paypassword,6,"2000000000000001",pwd_buf)>=0)
	{
		NULL;
	}
	else
	{
		TS_OutPutMsg(gbl.dPosInfo, "\n签约出错\n请稍候再试!\n或联系在线客服中心【Ctrl+H】  400-80-11888", 0, iSelect);
		return -1;
	}
	memcpy(pack.FIELD63,pwd_buf,8);
	pack.Packet_Table[63].Real_Length +=8;
	id_len=strlen(gbl.CATV_id_card);
	bbzero(tmp);
	sprintf(tmp,"%02d",id_len);
	memcpy(pack.FIELD63+8,tmp,2);
	pack.Packet_Table[63].Real_Length += 2;
	memcpy(pack.FIELD63+10,gbl.CATV_id_card,id_len);
	pack.Packet_Table[63].Real_Length += id_len;
	
	//bit2
	memset(pack.FIELD2, 0, sizeof(pack.FIELD2));
	memset((char *)temp_buff,0,sizeof(temp_buff));
	strcpy((char *)temp_buff,gbl.card_no);
	CTools::hex_to_byte((BYTE *)temp_buff, pack.FIELD2, gbl.card_no_len, 1);	//变为bcd码（后补0）
	pack.Packet_Table[2].Real_Length=gbl.card_no_len;
	//  查询包打包   
	if(packHdl(1) < 0)
	{
		return -1;
	}
	else{
		memset(response_code,0,sizeof(response_code));
		memcpy(response_code,pack.FIELD39,2);
		if (!memcmp(response_code,"00",2)) 
		{
			
			iRet = TS_OutPutMsg(gbl.dPosInfo,"		  签约成功！\n请妥善保管手机号码与交费易密码，如有疑问，请拨打客服热线400-80-11888\n 按【确认】打印回执",0,iSelect);
			if(iRet!=0 || iSelect==0)
			{
				CPrint prt;
				prt.set_in_par(gbl);
				bbzero(tittle);
				strcpy((char *)tittle,"交费易签约");
				//prt.print_detail(8, tittle);	//打印明细
				prt.print_ysq_detail(pack,tittle);
			}
			
			return 0;
		}
		else if (!memcmp(response_code,"96",2))
		{
			TS_OutPutMsg(gbl.dPosInfo, " \n    登记操作出错\n请稍候再试!\n或联系在线客服中心【Ctrl+H】  400-80-11888\n   按【确认】返回", 0,iSelect);
			return -1;
		}else if (!memcmp(response_code,"94",2))
		{
			TS_OutPutMsg(gbl.dPosInfo, " \n    登记操作出错\n该手机号码已经登记过\n请联系在线客服中心【Ctrl+H】  400-80-11888\n   按【确认】返回", 0,iSelect);
			return -1;
		}
		else{
			returnFail((char *)pack.FIELD39);
			return -1;
		}
	}              
}


int CTrade::UnionTransfer_in(const char *title)
{
	int  iRet=0 , flag = 1, curTry=0;
	int  iSelect;
	char tmp[256], card_info[201];
	char amo_buff[13];
	char prc_amo[13], prc_amo_buff[13];	//手续费
	char tra_amo[13], tra_amo_buff[13];	//交易金额
	char PSAMNum_buff[16+1];		//PSAM卡号和随机数
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	
	wrLog("【转账】转账业务");
	strcpy(gbl.fee_type,"0227");
	
	//输入金额
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	
	strcpy(tradeInfoSend.acMainTitle, title);
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入转账金额：");
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_MONEY;	//金额
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
	tradeInfoSend.Contents[0].uMinLen = 1;		
	tradeInfoSend.Contents[0].uMaxLen = 8;	
	wrLog("【转账】开始输入金额");
	for(curTry=0; curTry<MAXTRY; curTry++)
	{
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		if(iRet != 0)
		{
			if(iRet == 1 || iRet ==2)
				wrLog("【转账】输入金额用户取消或超时");
			else
				wrLog("【转账】输入金额失败");
			wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
			return -1;
		}
		bbzero(tra_amo);
		strcpy(tra_amo, (char *)tradeInfoRecv.Contents[0].uMsg);	//读入金额
		wrLog("tra_amo: [%s]", tra_amo);
		if(atoi(tra_amo)>10000000)
		{
			TS_OutPutMsg(gbl.dPosInfo, "超过最大金额(10万元)\n【确认】重新输入\n【返回】退出", 0, iSelect);
			if(iSelect)
				return CANCLE_KEY;
			else
				continue;
		}
		else
			break;
	}
	wrLog("【转账】输入金额成功");
	bbzero(gbl.pos_serial);
	strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
	
	//刷卡
	wrLog("【转账】开始刷卡");
	for(curTry=0; curTry<MAXTRY; curTry++)
	{
		bbzero(card_info);
		iRet = getCardInfo(title, card_info);//刷卡取得卡信息
		if( iRet == 0 )
			iRet = getCardNum(card_info);//取得卡号
		
		if(!iRet)
			break;
		else if(iRet == CANCLE_KEY)
		{
			wrLog("【转账】取消刷卡");
			return CANCLE_KEY;
		}
		else if(iRet == RE_MNG_CARD)
		{
			wrLog("【转账】重新刷卡");
			continue;
		}
		else if(iRet != 0)
		{
			wrLog("【转账】刷卡失败");
			return -1;
		}
	}
	wrLog("【转账】刷卡成功");
	
	pack.wrField(2, gbl);	//写交费域
	/*-----------------------------------------------*/
	bbzero(pack.FIELD3);
	CTools::hex_to_byte((BYTE *)"310060", pack.FIELD3, 6);
	bbzero(pack.FIELD48);
	memcpy(pack.FIELD48, gbl.fee_type, 4);
	pack.Packet_Table[48].Real_Length = 4;
	bbzero(pack.FIELD63);
	memcpy(pack.FIELD63, tra_amo, 12);
	pack.Packet_Table[63].Real_Length = 12;
	/*-----------------------------------------------*/
	iRet = packHdl(1);
	if(iRet < 0)
		return -1;
	
	if (!memcmp(pack.FIELD39,"00",2)) 
	{
		wrLog("【转账】查询手续费成功");
		bbzero(tra_amo);
		bbzero(prc_amo);
		memcpy(tra_amo, pack.FIELD63, 12);		//交易金额
		memcpy(prc_amo, pack.FIELD63+12, 12);	//手续费
		
		bbzero(amo_buff);
		bbzero(prc_amo_buff);
		bbzero(tra_amo_buff);
		bbzero(gbl.amount);
		sprintf(gbl.amount, "%012ld", atoi(tra_amo)+atoi(prc_amo));	//总额
		wrLog("gbl.amount: [%s]", gbl.amount);
		
		CTools::chgToMny(gbl.amount, amo_buff);	//总额
		CTools::chgToMny(tra_amo, tra_amo_buff);	//交易金额
		CTools::chgToMny(prc_amo, prc_amo_buff);	//手续费
		bbzero(tmp);
		sprintf(tmp, "卡号:%s\n交易本金:%s\n手续费:%s\n总额:%s\n按【确定】转帐", gbl.card_no, tra_amo_buff, prc_amo_buff, amo_buff);
		iRet = TS_OutPutMsg(gbl.dPosInfo, tmp, 0, iSelect);
		if(iRet)
		{
			wrLog("【转账】下发提示信息返回失败");
			return -1;
		}
	}
	else
	{
		wrLog("【转账】查询手续费失败");
		return  returnFail((char *)pack.FIELD39);
	}
	if(iSelect)
	{
		wrLog("【转账】用户取消");
		return CANCLE_KEY;
	}
	
	strcpy(gbl.fee_type,"0224");
	flag = 0;
	bbzero(PSAMNum_buff);
	// 	CTools::byte_to_hex((BYTE*)gbl.posInfo.psamNum,(BYTE*)PSAMNum_buff,8);
	strcpy(PSAMNum_buff,"0000000000000000");
	wrLog("【转账】开始输密码");
	for(curTry=0; curTry<MAXTRY; curTry++)
	{
		if(!flag)
		{
			iRet = getCardPwd(title);	//取得密码
			
			if(iRet == CANCLE_KEY)
			{
				wrLog("【转账】密码取消");
				return CANCLE_KEY;
			}
			else if(iRet != 0)
			{
				wrLog("【转账】密码返回失败");
				return -1;
			}
		}
		wrLog("【转账】输入密码成功");
		pack.wrField(2, gbl);	//写交费域
		/*-----------------------------------------------*/
		bbzero(pack.FIELD3);
		CTools::hex_to_byte((BYTE *)"000000", pack.FIELD3, 6);
		memset(pack.FIELD48,0,sizeof(pack.FIELD48));
		memcpy(pack.FIELD48, gbl.fee_type, 4);
		pack.Packet_Table[48].Real_Length = 4;
		
		memcpy(pack.FIELD63, prc_amo, 12);
		memcpy(pack.FIELD63+12, PSAMNum_buff, 16);
		pack.Packet_Table[63].Real_Length = 28;
		/*-----------------------------------------------*/
		if( atoi(gbl.amount) > 11000000 )	//若金额过大
		{
			wrLog("【转账】金额过大，错误！");
			return -1;
		}
		//打8583包
		iRet = packHdl(2);
		if(iRet < 0)
			return -1;
		
		if (!memcmp(pack.FIELD39,"00",2)) 
		{
			bbzero(gbl.stan_no);
			memcpy(gbl.stan_no, (char *)pack.FIELD37, 12);//读入系统参考号
			wrLog("【转账】转帐成功！");
			TS_OutPutMsg(gbl.dPosInfo, "\n      转帐成功！\n   按【确认】打印票据", 0, iSelect);
			//		if(iSelect)
			//			return 0;
			CPrint prt;
			prt.set_in_par(gbl);
			iRet = prt.print_Unionban_detail();	 //打印明细
			if (iRet != 0)
			{
				TS_OutPutMsg(gbl.dPosInfo, "\n      打印失败！\n   按【确认】返回", 0, iSelect);
			}else{
				strcpy(gbl.fee_type,"0226");
				pack.wrField(1, gbl);	//写交费域
				/*-----------------------------------------------*/
				bbzero(pack.FIELD3);
				CTools::hex_to_byte((BYTE *)"310050", pack.FIELD3, 6);
				memset(pack.FIELD48,0,sizeof(pack.FIELD48));
				memcpy(pack.FIELD48, gbl.fee_type, 4);
				pack.Packet_Table[48].Real_Length = 4;
				
				memcpy(pack.FIELD63, gbl.stan_no, 12);
				pack.Packet_Table[63].Real_Length = 12;
				
				//打8583包
				iRet = packHdl(1);
				if(iRet < 0)
					return -1;
				TS_OutPutMsg(gbl.dPosInfo, "\n      打印成功！\n   按【确认】返回", 0, iSelect);
			}
			return 0;
		}
		else if(!memcmp(pack.FIELD39, "55", 2) || !memcmp(pack.FIELD62, "P20004855", 9))
		{
			wrLog("【转账】密码错误，重新输入");
			flag = 1;
			if(reGetPwd(title) == 0) //密码错误，重新输入密码, 2006-10-25
				continue;
			else
				return CANCLE_KEY;
		}
		else
		{
			wrLog("【转账】转帐失败");
			iRet = banReturnFail((char *)pack.FIELD39);
			return -1;
		}
	}
	return -1;
 }
 
 
 int CTrade::UnionTransfer_out(const char *title)
 {
	 int  iRet=0 , flag = 1, curTry=0;
	 int  iSelect;
	 char tmp[256], card_info[201];
	 char amo_buff[13];
	 char prc_amo[13], prc_amo_buff[13];	//手续费
	 char tra_amo[13], tra_amo_buff[13];	//交易金额
	 char PSAMNum_buff[16+1];		//PSAM卡号和随机数
	 char card_num[30+1],card_len_buff[2+1];
	 int card_len;
	 TSTradeInfoSend tradeInfoSend;
	 TSTradeInfoRecv tradeInfoRecv;
	 
	 wrLog("【转账】转账业务");
	 strcpy(gbl.fee_type,"0227");
	 
	 //输入金额
	 memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	 
	 strcpy(tradeInfoSend.acMainTitle, title);
	 tradeInfoSend.uHasTradeID = 1;
	 tradeInfoSend.uTotalContents = 2;
	 
	 strcpy(tradeInfoSend.Contents[0].acTitle, "请输入转入卡号(到账卡号)：");
	 tradeInfoSend.Contents[0].uCommand = TS_INPUT_CARD;	//卡号
	 tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
	 tradeInfoSend.Contents[0].uMinLen = 1;		
	 tradeInfoSend.Contents[0].uMaxLen = 30;	
	 
	 strcpy(tradeInfoSend.Contents[1].acTitle, "请输入转账金额：");
	 tradeInfoSend.Contents[1].uCommand = TS_INPUT_MONEY;	//金额
	 tradeInfoSend.Contents[1].uTimeOut = EPOS_OVER_TIME;	//超时30秒
	 tradeInfoSend.Contents[1].uMinLen = 1;		
	 tradeInfoSend.Contents[1].uMaxLen = 8;	
	 wrLog("【转账】开始输入账号和金额");
	 for(curTry=0; curTry<MAXTRY; curTry++)
	 {
		 memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
		 iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		 if(iRet != 0)
		 {
			 if(iRet == 1 || iRet ==2)
				 wrLog("【转账】输入金额用户取消或超时");
			 else
				 wrLog("【转账】输入金额失败");
			 wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
			 return -1;
		 }
		 bbzero(tra_amo);
		 bbzero(card_num);
		 strcpy(card_num, (char *)tradeInfoRecv.Contents[0].uMsg);	//读入金额
		 strcpy(tra_amo, (char *)tradeInfoRecv.Contents[1].uMsg);	//读入金额
		 card_len = strlen(card_num);
		 bbzero(card_len_buff);
		 if (card_len<10)
		 {
			 sprintf(card_len_buff,"0%d",card_len);
		 }else{
			 sprintf(card_len_buff,"%d",card_len);
		 }
		 wrLog("到账卡号: [%s]", card_num);
		 wrLog("tra_amo: [%s]", tra_amo);
		 if(atoi(tra_amo)>10000000)
		 {
			 TS_OutPutMsg(gbl.dPosInfo, "超过最大金额(10万元)\n【确认】重新输入\n【返回】退出", 0, iSelect);
			 if(iSelect)
				 return CANCLE_KEY;
			 else
				 continue;
		 }
		 else
			 break;
	 }
	 wrLog("【转账】输入到账卡号和金额成功");
	 bbzero(gbl.pos_serial);
	 strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
	 
	 //刷卡
	 wrLog("【转账】开始刷卡");
	 for(curTry=0; curTry<MAXTRY; curTry++)
	 {
		 bbzero(card_info);
		 iRet = getCardInfo(title, card_info);//刷卡取得卡信息
		 if( iRet == 0 )
			 iRet = getCardNum(card_info);//取得卡号
		 
		 if(!iRet)
			 break;
		 else if(iRet == CANCLE_KEY)
		 {
			 wrLog("【转账】取消刷卡");
			 return CANCLE_KEY;
		 }
		 else if(iRet == RE_MNG_CARD)
		 {
			 wrLog("【转账】重新刷卡");
			 continue;
		 }
		 else if(iRet != 0)
		 {
			 wrLog("【转账】刷卡失败");
			 return -1;
		 }
	 }
	 wrLog("【转账】刷卡成功");
	 
	 pack.wrField(2, gbl);	//写交费域
	 /*-----------------------------------------------*/
	 bbzero(pack.FIELD3);
	 CTools::hex_to_byte((BYTE *)"310060", pack.FIELD3, 6);
	 bbzero(pack.FIELD48);
	 memcpy(pack.FIELD48, gbl.fee_type, 4);
	 pack.Packet_Table[48].Real_Length = 4;
	 bbzero(pack.FIELD63);
	 memcpy(pack.FIELD63, tra_amo, 12);
	 pack.Packet_Table[63].Real_Length = 12;
	 /*-----------------------------------------------*/
	 iRet = packHdl(1);
	 if(iRet < 0)
		 return -1;
	 
	 if (!memcmp(pack.FIELD39,"00",2)) 
	 {
		 wrLog("【转账】查询手续费成功");
		 bbzero(tra_amo);
		 bbzero(prc_amo);
		 memcpy(tra_amo, pack.FIELD63, 12);		//交易金额
		 memcpy(prc_amo, pack.FIELD63+12, 12);	//手续费
		 
		 bbzero(amo_buff);
		 bbzero(prc_amo_buff);
		 bbzero(tra_amo_buff);
		 bbzero(gbl.amount);
		 sprintf(gbl.amount, "%012ld", atoi(tra_amo)+atoi(prc_amo));	//总额
		 wrLog("gbl.amount: [%s]", gbl.amount);
		 
		 CTools::chgToMny(gbl.amount, amo_buff);	//总额
		 CTools::chgToMny(tra_amo, tra_amo_buff);	//交易金额
		 CTools::chgToMny(prc_amo, prc_amo_buff);	//手续费
		 bbzero(tmp);
		 sprintf(tmp, "卡号:%s\n交易本金:%s\n手续费:%s\n总额:%s\n按【确定】转帐", gbl.card_no, tra_amo_buff, prc_amo_buff, amo_buff);
		 iRet = TS_OutPutMsg(gbl.dPosInfo, tmp, 0, iSelect);
		 if(iRet)
		 {
			 wrLog("【转账】下发提示信息返回失败");
			 return -1;
		 }
	 }
	 else
	 {
		 wrLog("【转账】查询手续费失败");
		 return  returnFail((char *)pack.FIELD39);
	 }
	 if(iSelect)
	 {
		 wrLog("【转账】用户取消");
		 return CANCLE_KEY;
	 }
	 
	 strcpy(gbl.fee_type,"0225"); 
	 flag = 0;
	 bbzero(PSAMNum_buff);
	 // 	CTools::byte_to_hex((BYTE*)gbl.posInfo.psamNum,(BYTE*)PSAMNum_buff,8);
	 strcpy(PSAMNum_buff,"0000000000000000");
	 wrLog("【转账】开始输密码");
	 for(curTry=0; curTry<MAXTRY; curTry++)
	 {
		 if(!flag)
		 {
			 iRet = getCardPwd(title);	//取得密码
			 
			 if(iRet == CANCLE_KEY)
			 {
				 wrLog("【转账】密码取消");
				 return CANCLE_KEY;
			 }
			 else if(iRet != 0)
			 {
				 wrLog("【转账】密码返回失败");
				 return -1;
			 }
		 }
		 wrLog("【转账】输入密码成功");
		 pack.wrField(2, gbl);	//写交费域
		 /*-----------------------------------------------*/
		 bbzero(pack.FIELD3);
		 CTools::hex_to_byte((BYTE *)"000000", pack.FIELD3, 6);
		 memset(pack.FIELD48,0,sizeof(pack.FIELD48));
		 memcpy(pack.FIELD48, gbl.fee_type, 4);
		 memcpy(pack.FIELD48+4, card_len_buff, 2);
		 memcpy(pack.FIELD48+6, card_num, card_len);
		 pack.Packet_Table[48].Real_Length = 6+card_len;
		 
		 memcpy(pack.FIELD63, prc_amo, 12);
		 memcpy(pack.FIELD63+12, PSAMNum_buff, 16);
		 pack.Packet_Table[63].Real_Length = 28;
		 /*-----------------------------------------------*/
		 if( atoi(gbl.amount) > 11000000 )	//若金额过大
		 {
			 wrLog("【转账】金额过大，错误！");
			 return -1;
		 }
		 //打8583包
		 iRet = packHdl(2);
		 if(iRet < 0)
			 return -1;
			 /*---------test----------*
			 strcpy((char *)pack.FIELD39,"00");
			 wrLog("FIELD39: [%s]", (char *)pack.FIELD39);
		 /*-----------------------*/
		 if (!memcmp(pack.FIELD39,"00",2)) 
		 {
			 bbzero(gbl.stan_no);
			 memcpy(gbl.stan_no, (char *)pack.FIELD37, 12);//读入系统参考号
			 wrLog("【转账】转帐成功！");
			 TS_OutPutMsg(gbl.dPosInfo, "\n      转帐成功！\n   按【确认】打印票据", 0, iSelect);
			 //		if(iSelect)
			 //			return 0;
			 CPrint prt;
			 prt.set_in_par(gbl);
			 iRet = prt.print_Unionban_detail();	 //打印明细
			 if (iRet != 0)
			 {
				 TS_OutPutMsg(gbl.dPosInfo, "\n      打印失败！\n   按【确认】返回", 0, iSelect);
			 }else{
				 strcpy(gbl.fee_type,"0226");
				 pack.wrField(1, gbl);	//写交费域
				 /*-----------------------------------------------*/
				 bbzero(pack.FIELD3);
				 CTools::hex_to_byte((BYTE *)"310050", pack.FIELD3, 6);
				 memset(pack.FIELD48,0,sizeof(pack.FIELD48));
				 memcpy(pack.FIELD48, gbl.fee_type, 4);
				 pack.Packet_Table[48].Real_Length = 4;
				 
				 memcpy(pack.FIELD63, gbl.stan_no, 12);
				 pack.Packet_Table[63].Real_Length = 12;
				 
				 //打8583包
				 iRet = packHdl(1);
				 if(iRet < 0)
					 return -1;
				 TS_OutPutMsg(gbl.dPosInfo, "\n      打印成功！\n   按【确认】返回", 0, iSelect);
			 }
			 return 0;
		 }
		 else if(!memcmp(pack.FIELD39, "55", 2) || !memcmp(pack.FIELD62, "P20004855", 9))
		 {
			 wrLog("【转账】密码错误，重新输入");
			 flag = 1;
			 if(reGetPwd(title) == 0) //密码错误，重新输入密码, 2006-10-25
				 continue;
			 else
				 return CANCLE_KEY;
		 }
		 else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
		 {
			 TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
			 if (iSelect!=0)
			 {
				 return -1;
			 }else
				 continue;
		 }
		 else
		 {
			 wrLog("【转账】转帐失败");
			 iRet = banReturnFail((char *)pack.FIELD39);
			 return -1;
		 }
	}
	return -1;
}


int CTrade::UnionbanInqMoney(const char *title)
{
	int  iRet=0 , iSelect, flag;
	char tmp[256], amo_buff[13], amount[13];
	
	strcpy(gbl.fee_type, "0228");
	flag = 0;
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{
		if(!flag)
		{
			iRet = mngCard_Hdl(title);
			if(iRet == CANCLE_KEY)
				return CANCLE_KEY;
			else if(iRet != 0)
				return -1;
		}
		bbzero(gbl.phone_no);
		strcpy(gbl.phone_no,"00000000");
		gbl.phone_len = strlen(gbl.phone_no);
		pack.wrField(2, gbl);	//写交费域
		/*----------------------------------*/
		bbzero(pack.FIELD3);
		CTools::hex_to_byte((BYTE *)"310060", pack.FIELD3, 6);
		bbzero(pack.FIELD48);
		memcpy(pack.FIELD48, gbl.fee_type, 4);
		pack.Packet_Table[48].Real_Length = 4;
		/*----------------------------------*/
		//打查询包
		iRet = packHdl(1);
		if(iRet < 0)
			return -1;
		
		if (!memcmp(pack.FIELD39,"00",2)) 
		{
			bbzero(amo_buff);
			memcpy(amo_buff, (char *)pack.FIELD63, 12);
			wrLog("余额：[%s]", amo_buff);
			bbzero(amount);
			CTools::chgToMny(amo_buff, amount);
			bbzero(tmp);
			sprintf(tmp, "卡号：\n%s\n余额：%s\n【确认】返回", gbl.card_no, amount);
			TS_OutPutMsg(gbl.dPosInfo, tmp, 0, iSelect);
			return iSelect;
		}
		else if(!memcmp(pack.FIELD39,"55",2) || !memcmp(pack.FIELD62, "P20004855", 9))
		{
			flag = 1;
			if(reGetPwd(title) == 0) //密码错误，重新输入密码
				continue;
			else
				return CANCLE_KEY;
		}
		else
		{
			iRet = banReturnFail((char *)pack.FIELD39);
			return -1;
		}
	}
	return -1;
}

int CTrade::UnionbanInqLast()
{
	int iRet=0 , iSelect, len;
	char tmp[512];
	char cDate[11], amo[13], cTime[9];
	BanDetail banDetail;
	
	wrLog("【上笔交易查询】");
	strcpy(gbl.fee_type, "0229");
	strcpy(gbl.pos_serial, "999999");
	pack.wrField(2, gbl);	//写交费域
	/*----------------------------------*/
	bbzero(pack.FIELD3);
	CTools::hex_to_byte((BYTE *)"310060", pack.FIELD3, 6);
	bbzero(pack.FIELD48);
	memcpy(pack.FIELD48, gbl.fee_type, 4);
	pack.Packet_Table[48].Real_Length = 4;
	/*----------------------------------*/
	//打查询包
	iRet = packHdl(1);
	if(iRet < 0)
		return -1;
	
	if (!memcmp(pack.FIELD39,"00",2)) 
	{
		memset(&banDetail, 0, sizeof(banDetail));
		len = 0;
		bbzero(tmp);
		memcpy(tmp, pack.FIELD63, 2);  //卡号长度
		len+=2;
		if(atoi(tmp) > 20)  //卡号长度过大
		{
			wrLog("卡号长度超过20，len=%d", atoi(tmp));
			TS_OutPutMsg(gbl.dPosInfo, "\n\n 取得查询明细错误！\n请稍候再试!\n或联系在线客服中心【Ctrl+H】  400-80-11888", 1, iSelect, 10);
			return -1;
		}
		memcpy(banDetail.card, pack.FIELD63+len, atoi(tmp));  //卡号
		len+=atoi(tmp);
		strcpy(gbl.card_no, banDetail.card);
		gbl.card_no_len = atoi(tmp);
		memcpy(banDetail.traDate, pack.FIELD63+len, 8);  //日期
		len+=8;
		memcpy(banDetail.traTime, pack.FIELD63+len, 6);  //时间
		len+=6;
		memcpy(banDetail.amount, pack.FIELD63+len, 12);  //金额
		len+=12;
		memcpy(banDetail.serial, pack.FIELD63+len, 6);  //流水
		len+=6;
		memcpy(banDetail.peStan, pack.FIELD63+len, 12);  //pe系统参考号
		len+=12;
		memcpy(banDetail.uniStan, pack.FIELD63+len, 12);  //银联系统参考号
		len+=12;
		bbzero(pack.FIELD12); //时间
		bbzero(pack.FIELD13); //日期
		CTools::hex_to_byte((BYTE *)banDetail.traTime, pack.FIELD12, 6);
		CTools::hex_to_byte((BYTE *)banDetail.traDate, pack.FIELD13, 8);
		wrHex("traTime", pack.FIELD12, 3);
		wrHex("traDate", pack.FIELD13, 4);
		
		bbzero(amo);
		bbzero(cDate);
		bbzero(cTime);
		CTools::chgToMny(banDetail.amount, amo);
		CTools::formatDate(banDetail.traDate, cDate);
		CTools::formatTime(banDetail.traTime, cTime);
		bbzero(tmp);
		sprintf(tmp, "支付卡号:%s\n交易金额:%s\n流水号:%s\n日期:%s\n时间:%s\n【确认】打印\n【返回】退出", banDetail.card, amo, banDetail.serial, cDate, cTime);
		wrLog("查询提示信息：\n%s", tmp);
		iRet = TS_OutPutMsg(gbl.dPosInfo, tmp, 0, iSelect);
		if(iRet!=0 || iSelect==0)
		{
			strcpy(gbl.card_no, banDetail.card);
			gbl.card_no_len = strlen(gbl.card_no);
			CPrint prt;
			prt.set_in_par(gbl);
			prt.print_Unionban_detail(1);	 //打印明细
		}
		
		return 0;
	}
	else
	{
		iRet = banReturnFail((char *)pack.FIELD39);
		return -1;
	}
}

//历史记录查询
//inqType: 1-当日交易查询
//		   2-历史交易明细查询
int CTrade::UnionbanInqHistory(int inqType)
{
	int iRet=0 , iSelect, len, type, flag;
	int total, remain;
	char currNum[4+1];
	char inqDate[9], tmp[512], title[20], *p = NULL;
	char cDate[11], cTime[9], amo[13];
	char card[22], serial[7], uniStan[13];  //按卡号、流水、银联参考号查询
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	BanDetail banDetail;
	
	bbzero(title);
	if(inqType == 1)
	{
		wrLog("【当日交易明细查询】");
		strcpy(gbl.fee_type, "0230");
		strcpy(title, "当日交易明细查询");
	}
	else if(inqType == 2)
	{
		wrLog("【历史交易明细查询】");
		strcpy(gbl.fee_type, "0231");
		strcpy(title, "历史交易明细查询");
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
		
		strcpy(tradeInfoSend.acMainTitle, "历史交易明细查询");
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents = 1;
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_DATE;		//日期
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		if(iRet != 0)
		{
			wrLog("【UnionbanInqHistory】失败，返回码[%d]", iRet);
			wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
			return -1;
		}
		bbzero(gbl.pos_serial);
		strcpy(gbl.pos_serial, (char *)tradeInfoRecv.uTradeID);
		bbzero(inqDate);
		strcpy(inqDate, (char *)tradeInfoRecv.Contents[0].uMsg);
	}
	else
		return -1;
	
	bbzero(currNum);
	strcpy(currNum, "0000");
	flag = 1;
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{	
		if(flag)	//若还有明细，不选择菜单
		{
			type = banInqMenu();	//选择查询方式
			wrLog("type: %d", type);
			if(type == CANCLE_KEY || type<0)
				return CANCLE_KEY;
			memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
			memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
			strcpy(tradeInfoSend.acMainTitle, title);
			tradeInfoSend.uHasTradeID = 1;
			tradeInfoSend.uTotalContents = 1;
			switch(type)
			{
			case 1:  //按卡号
				strcpy(tradeInfoSend.Contents[0].acTitle, "请输入交易帐号");
				tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;
				tradeInfoSend.Contents[0].uMinLen = 12;
				tradeInfoSend.Contents[0].uMaxLen = 20;
				tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
				break;
			case 2:  //按流水号
				strcpy(tradeInfoSend.Contents[0].acTitle, "请输入流水号");
				tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;
				tradeInfoSend.Contents[0].uMinLen = 6;
				tradeInfoSend.Contents[0].uMaxLen = 6;
				tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
				break;
			case 3:  //按银联参考号
				strcpy(tradeInfoSend.Contents[0].acTitle, "请输入银联参考号");
				tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;
				tradeInfoSend.Contents[0].uMinLen = 12;
				tradeInfoSend.Contents[0].uMaxLen = 12;
				tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
				break;
			default:
				break;
			}
			if(type != 4)
			{
				iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
				if(iRet)
				{
					wrLog("【banInqHistory】失败，返回值：[%d]", iRet);
					wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
					continue;
				}
				bbzero(gbl.pos_serial);
				strcpy(gbl.pos_serial, (char *)tradeInfoRecv.uTradeID);
				bbzero(card);
				bbzero(serial);
				bbzero(uniStan);
				if(type == 1)
					p = card;
				else if(type == 2)
					p = serial;
				else if(type == 3)
					p = uniStan;	
				strcpy(p, (char *)tradeInfoRecv.Contents[0].uMsg);
				wrLog("p: [%s]", p);
			}
			else
				strcpy(gbl.pos_serial, "999999");
		}
		pack.wrField(2, gbl);	//写交费域
		/*----------------------------------*/
		bbzero(pack.FIELD3);
		CTools::hex_to_byte((BYTE *)"310060", pack.FIELD3, 6);
		bbzero(pack.FIELD48);
		memcpy(pack.FIELD48, gbl.fee_type, 4);
		pack.Packet_Table[48].Real_Length = 4;
		bbzero(pack.FIELD63);
		if(type == 1)
			sprintf((char *)pack.FIELD63, "%d%02d%s", type, strlen(p), p);
		else if(type == 4)
			sprintf((char *)pack.FIELD63, "%d00", type);
		else
			sprintf((char *)pack.FIELD63, "%d%s", type, p);
		wrLog("FIELD63: [%s]", pack.FIELD63);
		if(inqType == 1)  //当日明细
		{
			strcat((char *)pack.FIELD63, currNum);
			pack.Packet_Table[63].Real_Length = strlen((char *)pack.FIELD63);
		}
		else if(inqType == 2)  //历史明细
		{
			strcat((char *)pack.FIELD63, inqDate);
			strcat((char *)pack.FIELD63, currNum);
			pack.Packet_Table[63].Real_Length = strlen((char *)pack.FIELD63);
		}
		/*----------------------------------*/
		//打查询包
		iRet = packHdl(1);
		if(iRet < 0)
			return -1;
		if (!memcmp(pack.FIELD39,"00",2)) 
		{
			wrLog("Bit63: [%s]", pack.FIELD63);
			memset(&banDetail, 0, sizeof(banDetail));
			len = 0;
			bbzero(tmp);
			memcpy(tmp, pack.FIELD63+len, 4);  //总笔数
			len+=4;
			total = atoi(tmp);
			bbzero(tmp);
			memcpy(tmp, pack.FIELD63+len, 2);  //记录数
			len+=2;
			remain = total-atoi(currNum)-1;  //剩余数，仅用于显示给用户看
			sprintf(currNum, "%04d", atoi(currNum)+1);
			wrLog("currNum: [%s]", currNum);
			wrLog("remain: [%d]", remain);
			
			bbzero(tmp);
			memcpy(tmp, pack.FIELD63+len, 2);  //卡号长度
			len+=2;
			if(atoi(tmp) > 20)  //卡号长度过大
			{
				wrLog("卡号长度超过20，len=%d", atoi(tmp));
				TS_OutPutMsg(gbl.dPosInfo, "\n\n 取得查询明细错误！\n请稍候再试!\n或联系在线客服中心【Ctrl+H】  400-80-11888", 1, iSelect, 10);
				return -1;
			}
			memcpy(banDetail.card, pack.FIELD63+len, atoi(tmp));  //卡号
			len+=atoi(tmp);
			strcpy(gbl.card_no, banDetail.card);
			gbl.card_no_len = atoi(tmp);
			memcpy(banDetail.traDate, pack.FIELD63+len, 8);  //日期
			len+=8;
			memcpy(banDetail.traTime, pack.FIELD63+len, 6);  //时间
			len+=6;
			memcpy(banDetail.amount, pack.FIELD63+len, 12);  //金额
			len+=12;
			memcpy(banDetail.serial, pack.FIELD63+len, 6);  //流水
			len+=6;
			memcpy(banDetail.peStan, pack.FIELD63+len, 12);  //pe系统参考号
			len+=12;
			memcpy(banDetail.uniStan, pack.FIELD63+len, 12);  //银联系统参考号
			len+=12;
			
			bbzero(amo);
			bbzero(cDate);
			bbzero(cTime);
			CTools::chgToMny(banDetail.amount, amo);
			CTools::formatDate(banDetail.traDate, cDate);
			CTools::formatTime(banDetail.traTime, cTime);
			bbzero(tmp);
			sprintf(tmp, "支付卡号:%s\n交易金额:%s\n流水号:%s\n日期:%s\n时间:%s\n【剩余%d条】\n【确认】继续\n【返回】退出", banDetail.card, amo, banDetail.serial, cDate, cTime, remain);
			
			if( TS_OutPutMsg(gbl.dPosInfo, tmp, 0, iSelect) )
				return -1;
			if(iSelect == CANCLE_KEY)
				return CANCLE_KEY;
			//用户选择处理方式
			iRet = banInqMenu(1);
			if(iRet == CANCLE_KEY)
				return CANCLE_KEY;
			wrLog("banInqMenu return: %d", iRet);
			if(iRet == 1) //打印
			{
				CPrint prt;
				prt.set_in_par(gbl);
				prt.print_Unionban_detail(2);	 //打印明细
				TS_OutPutMsg(gbl.dPosInfo, "     打印成功！\n【确认】查看下一笔\n【返回】退出", 0, iSelect);
				if(iSelect)
					return 0;
				if(atoi(currNum) == total)
				{
					TS_OutPutMsg(gbl.dPosInfo, "\n\n 所有记录查询完毕！", 1, iSelect);
					flag = 1;
					strcpy(currNum, "0000");
				}
				else if(atoi(currNum) < total)
					flag = 0;
				else
					flag = 1;
				continue;
			}
			else if(iRet == 2) //查看下一笔
			{
				if(atoi(currNum) == total)
				{
					TS_OutPutMsg(gbl.dPosInfo, "\n\n 所有记录查询完毕！", 1, iSelect);
					flag = 1;
					strcpy(currNum, "0000");
				}
				else if(atoi(currNum) < total)
					flag = 0;
				else
					flag = 1;
				continue;
			}
			else
				return CANCLE_KEY;
		}
		else
		{
			iRet = banReturnFail((char *)pack.FIELD39);
			return -1;
		}
	}
	return -1;
}

//type: 0-选择查询方式（默认）
//		1-选择处理方式
int CTrade::UnionbanInqMenu(int type)
{
	int iRet, iSelect, count=0;
	TSMENULIST menuList;
	
	memset(&menuList,0,sizeof(menuList));
	if(!type)
	{
		strcpy(menuList.acTitle, "请选择查询方式");
		strcpy(menuList.menuItem[0], "交易帐号");
		strcpy(menuList.menuItem[1], "流水号");
		strcpy(menuList.menuItem[2], "银联参考号");
		strcpy(menuList.menuItem[3], "全  部");
		count = 0;
		while(strcmp(menuList.menuItem[count++], ""))
			menuList.iTotalNum++;
		iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
		if(iRet)
			return -1;
		if(iSelect>0 && iSelect<5)
			return iSelect;
		else
			return CANCLE_KEY;
	}
	else
	{
		strcpy(menuList.acTitle, "请选择：");
		strcpy(menuList.menuItem[0], "打  印");
		strcpy(menuList.menuItem[1], "查看下一笔");
		strcpy(menuList.menuItem[2], "取  消");
		
		count = 0;
		while(strcmp(menuList.menuItem[count++], ""))
			menuList.iTotalNum++;
		iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
		if(iRet)
			return -1;
		if(iSelect>0 && iSelect<3)
			return iSelect;
		else
			return CANCLE_KEY;
	}
}


int CTrade::signWorkID(char *workid)
{
	char workID[8+1];
	char temp_buff[1024+1];
	int  iRet,iSelect;
	bbzero(workID);
	
	
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, "按工号签到");
	
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入8位工号：");	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
	tradeInfoSend.Contents[0].uCount = 0;		//输入1次工号
	tradeInfoSend.Contents[0].uTimeOut = 30;	//超时30秒
	tradeInfoSend.Contents[0].uMinLen = 8;
	tradeInfoSend.Contents[0].uMaxLen = 8;
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return -1;
	}
	
	strcpy(workID,(char *)tradeInfoRecv.Contents[0].uMsg);
	
	wrLog("输入的工号：【%s】",workID);
	iRet = CDB::checkworkID(gbl,workID);
	if (iRet <0 )
	{
		bbzero(temp_buff);
		sprintf(temp_buff,"\n\n 您输入的工号不存在!\n  请按【确定】返回");
		TS_OutPutMsg(gbl.dPosInfo, temp_buff, 1,iSelect);
		return -2;
	}
	sprintf(temp_buff,"您输入的工号是：%s\n\n\n请按【确定】继续签到",workID);
	TS_OutPutMsg(gbl.dPosInfo, temp_buff, 0,iSelect);
	if (iSelect == 0)
	{
		iRet = CDB::setworkID(gbl,workID);
		if (iRet <0)
		{
			bbzero(temp_buff);
			sprintf(temp_buff,"\n\n    工号签到失败!\n  请按【确定】返回");
			TS_OutPutMsg(gbl.dPosInfo, temp_buff, 1,iSelect);
			return -3;
		}else{
			bbzero(workid);
			strcpy(workid,workID);
			return 0;
		}
	}else
		return -4;
}


int CTrade::BankHK(const char *type, int inputTel)//银行划扣
{
	int iSelect,iRet,first3mon=1;
	char tmp[521];
	
	for(int i=0; first3mon && i<10; i++)
	{
		iSelect = BankHK_telInqHdl(type, inputTel, first3mon);
		if(iSelect==0)
		{
			iRet = BankHK_telPayHdl(type, 0, first3mon);
		}else if (iSelect == 1)
		{
			iRet = 0;
		}else
		{
			iRet = -1;
			break;
		}
		inputTel = 1;
	}
	if(iRet == 0)
	{
		bbzero(tmp);
		sprintf(tmp,"\n\n请按【确认】继续进行银行划扣业务的办理");
		TS_OutPutMsg(gbl.dPosInfo,tmp,0,iSelect);
		if (iSelect == 0)
		{
			iRet = BankHK_nameconfirm(type);
		}else
			return -1;
	}
	return iRet;
}
//first3mon:0-非三个月以上欠费的前3个月的交费 1-三个月以上欠费的前3个月的交费
int CTrade::BankHK_telInqHdl(const char *type, int inputTel, int &first3mon)
{
	int  iRet;
	
	wrLog("%s【查询】", type);
	
	if(inputTel==0){//如果需要输入电话号码等查询信息
		
		TSTradeInfoSend tradeInfoSend;
		TSTradeInfoRecv tradeInfoRecv;
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
		
		strcpy(tradeInfoSend.acMainTitle, type);
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents = 1;
		
		switch( atoi(gbl.fee_type) )
		{
		case 13://ADSL网费
        case 97://ADSL网费预存
			strcpy(tradeInfoSend.Contents[0].acTitle, "请输入电话或ADSL号码");	
			tradeInfoSend.Contents[0].uMinLen = 5;
			tradeInfoSend.Contents[0].uMaxLen = 8;
			break;
		default:
			strcpy(tradeInfoSend.Contents[0].acTitle, "请输入电话号码：");	
			tradeInfoSend.Contents[0].uMinLen = 8;		
			tradeInfoSend.Contents[0].uMaxLen = 8;
			break;
		}
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
		tradeInfoSend.Contents[0].uCount = 0;		//输入1次		
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
		
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		
		if(iRet != 0)
		{
			wrLog("TS_TradeControl返回错误[%d]", iRet);
			wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
			return iRet;
		}
		memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
		strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
		gbl.phone_len = tradeInfoRecv.Contents[0].uMsgLen;
		memset( gbl.phone_no,0,sizeof(gbl.phone_no) );
		strcpy( gbl.phone_no,(char *)tradeInfoRecv.Contents[0].uMsg );
	}
	wrLog("电话号码：[%s]", gbl.phone_no);
	
	//写查询域
	pack.wrField(1, gbl);
	
	//查询包打包   
	iRet = packHdl(1);
	if(iRet < 0)
		return -1;
	
	//返回数据给终端
	iRet = BankHK_telInqMsg(type, first3mon);
	return iRet;
}

//下发电信查询信息
//first3mon:0-非三个月以上欠费的前3个月的交费 1-三个月以上欠费的前3个月的交费
int CTrade::BankHK_telInqMsg(const char *type, int &first3mon)//下发查询信息
{
	wrLog("phone no1:[%s]",gbl.phone_no);
	char response_code[3],user_name_tmp[60+1];
	int b63_offset;
	char temp_buff[512],len_buff[10],mny[20];
	int iSelect,iRet,pMonNum=0,tMonNum=0;//pMonNum缴费月份数,tMonNum总欠费月份数
	double totalAmount = 0.0;//综合收费总金额，by kf
	
	
	memset(gbl.amount,0,sizeof(gbl.amount));
	memset(gbl.total_fee_type,0,sizeof(gbl.total_fee_type));//综合收费业务组
	memset(gbl.total_amount,0,sizeof(gbl.total_amount));//综合收费业务欠费组
	memset(response_code,0,sizeof(response_code));
	memset(temp_buff,0,sizeof(temp_buff));
	memset(len_buff,0,sizeof(len_buff));
	memset(mny,0,sizeof(mny));
	
	memcpy(response_code,pack.FIELD39,2);
	wrLog("业务代码:[%s]",gbl.fee_type);
	first3mon = 0;//非三个月以上欠费的前3个月的交费
	if (!memcmp(response_code,"00",2))
	{
		wrLog("phone no2:[%s]",gbl.phone_no);
		switch(atoi(gbl.fee_type))
		{
		case 96:	//长市话费预付金
		case 97:	//ADSL话费预付金
			memcpy(gbl.user_name,pack.FIELD63,30);
			gbl.user_name_len = trim(gbl.user_name, 30);
			bbzero(user_name_tmp);
			strcpy(user_name_tmp,gbl.user_name);
			if(gbl.group_type != 0 && strlen(gbl.user_name)>2 ){//如果不是商户版，用户名最后一位要变为*
				user_name_tmp[gbl.user_name_len-2]='*';
				user_name_tmp[gbl.user_name_len-1]='\0';				
			}
			b63_offset = 60;
			memcpy( gbl.amount, pack.FIELD63 + b63_offset, 12);	
			CTools::chgToMny(gbl.amount,mny);
			sprintf(temp_buff,"%s\n电话号码：%s\n用户名：%s\n预存余额：%s\n【确认】预存\n【返回】返回",type,gbl.phone_no,user_name_tmp,mny);
			TS_OutPutMsg(gbl.dPosInfo, temp_buff, 0,iSelect);
			break;
		default:	//固话、小灵通话费、ADSL费用
			CTools::byte_to_hex( pack.FIELD4, (BYTE *)gbl.amount, 6 );
			CTools::chgToMny(gbl.amount,mny);
			b63_offset = 0;
			pMonNum = (pack.FIELD63)[b63_offset]-0x30;
			b63_offset++;
			bbzero(user_name_tmp);
			memcpy(user_name_tmp,pack.FIELD63+b63_offset,6);
			b63_offset += 6;
			tMonNum = atoi(user_name_tmp);			
			memcpy(gbl.user_name,pack.FIELD63+b63_offset,60);
			b63_offset += 60;
			gbl.user_name_len = trim(gbl.user_name, 60);
			bbzero(user_name_tmp);
			strcpy(user_name_tmp,gbl.user_name);
			if(gbl.group_type != 0 && strlen(gbl.user_name)>2 ){//如果不是商户版，用户名最后一位要变为*
				user_name_tmp[gbl.user_name_len-2]='*';
				user_name_tmp[gbl.user_name_len-1]='\0';				
			}
			if(tMonNum<=3 || tMonNum>100000)
			{
				sprintf(temp_buff,"用户名：%s\n金额：%s\n欠费月份数为%d个月\n请按【确认】交费",user_name_tmp,mny,tMonNum);
			}
			else{
				sprintf(temp_buff,"用户名：%s\n金额：%s\n欠费月份数为%d个月\n请按【确认】交纳前3个月费用",user_name_tmp,mny,tMonNum);
				first3mon = 1;//三个月以上欠费的前3个月的交费
			}
			TS_OutPutMsg(gbl.dPosInfo, temp_buff, 0,iSelect);
			break;
		}
		return iSelect;
	}
	else
	{
		if( ( !memcmp(gbl.fee_type,"0001",4) || !memcmp(gbl.fee_type,"0013",4) ) && !memcmp(pack.FIELD39,"80",2) && !memcmp(&pack.FIELD62[1+6],"82",2)){//无欠费,提示交预付金和办理预授权
			TS_OutPutMsg(gbl.dPosInfo, "\n    该号码无欠费!\n请按【确认】预存50元办理划扣", 0, iSelect);
			if (iSelect == 0)
			{
				iRet = BankHK_prepay(type);
			}
			if (iRet == 0)
			{
				return 1;
			}else
				return -1;
			
		}
		returnFail(response_code);
		return -1;
	}
}
int CTrade::BankHK_telPayHdl(const char *type, int bizIdx, int first3mon)//交欠费
{
	int  iRet, flag,iSelect;
	int b48_len = 0;
	
	
	wrLog("电信入口【交费】");
	// 	iRet = selectAmount();
	// 	if(iRet == CANCLE_KEY)
	// 		return CANCLE_KEY;
	// 	else if(iRet < 0)
	// 		return -1;
	flag = 0;	//重输密码标识
	//	strcpy(gbl.amount, "000000000100");
	/********************请求刷卡****************/
	wrLog("phone no3:[%s]", gbl.phone_no);
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{
		if(bizIdx<=1 && !flag) 
		{
			iRet = mngCard_Hdl(type);
			if(iRet == CANCLE_KEY)
				return CANCLE_KEY;
			else if(iRet != 0){
				TS_OutPutMsg(gbl.dPosInfo,"读取输入数据错误!\n交易失败!\n按【确认】返回",1,iSelect);
				return -1;
			}
			
			if(!memcmp(gbl.card_no,"8828",4))	//若是付费易卡,走付费易卡刷卡流程（多卡交易）
			{
				memset(gbl.xlt_type, 0, sizeof(gbl.xlt_type));
				memcpy(gbl.xlt_type, "01",2);
				iRet = xltMulCard( type, 0);
				return iRet;
			}
		}
		
		pack.wrField(2, gbl);	//写交费域
		/***********修改一些域信息*********/
		switch( atoi(gbl.fee_type) )
		{
		case 1:		//电信发票修改20080129
		case 13:
			bbzero(pack.FIELD3);	
			if(gbl.key_num == 8)
				CTools::hex_to_byte((BYTE *)"400080", pack.FIELD3, 6);
			else
				CTools::hex_to_byte((BYTE *)"400000", pack.FIELD3, 6);
			break;
			
		default:
			break;
		}
		/**********************************/
		
		//交费包处理
		iRet = packHdl(2);
		if(iRet < 0)
			return -1;
		
		if (!memcmp(pack.FIELD39,"00",2)) 
		{
			
			iRet = TS_OutPutMsg(gbl.dPosInfo,"     交费成功！\n    谢谢您的使用\n请按【确认】打印发票",0,iSelect);
			
			if(iRet || iSelect==0)
			{
				CPrint prt;
				prt.set_in_par(gbl);
				if(memcmp(gbl.card_no,"8828",4)==0){//若是付费易卡
					switch(atoi(gbl.fee_type))
					{
					case 96:	//小灵通话费预付金
					case 97:	//adsl网费预付金
						memcpy(gbl.amount, pack.FIELD63, 12);
						break;
					default:
						//prt.print_detail(1, type);	//打印欠费明细
						prt.print_pym_detail(pack,type);
					}
					//prt.print_detail(2, type);	 //打印预付费明细
					prt.print_pre_detail(pack,type);
				}else{
					switch(atoi(gbl.fee_type))
					{
					case 96:	//小灵通话费预付金
					case 97:	//adsl网费预付金
						memcpy(gbl.amount, pack.FIELD63, 12);					
						//prt.print_detail(2, type);	 //打印预付费明细
						prt.print_pre_detail(pack,type);
						break;
					default:
						//prt.print_detail(1, type);	//打印欠费明细
						prt.print_pym_detail(pack,type);

					}
				}
			}
			
			return 0;
		}// end if (!memcmp(pack.FIELD39,"00",2))
		else if(!memcmp(pack.FIELD39,"55",2))
		{
			flag = 1;
			if(reGetPwd( type) == 0) //密码错误，重新输入密码, 2006-10-25
				continue;
			else
				return CANCLE_KEY;
		}	
		else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
			if (iSelect!=0)
			{
				return -1;
			}else
				continue;
		}
		returnFail((char *)pack.FIELD39);		
		return -1;
	}
	return -1;
}
int CTrade::BankHK_prepay(const char *type)//无欠费时预存
{
	wrLog("【询问是否做预付金和办理授权】");
	int iRet=0,memu_flag=0;//memu_flag-1:预付金和办理授权 2:预付金 3:办理授权
	char next_fee_type[5];
	char next_biz_name[30+1];
	bbzero(gbl.amount);
	strcpy(gbl.amount, "000000005000");
	switch(atoi(gbl.fee_type)){
	case 1:		//若长市话费或小灵通
		strcpy(next_fee_type,"0096");
		strcpy(next_biz_name,"固话/小灵通话费预存");
		memu_flag=2;
		break;
	case 13:	//ADSL
		strcpy(next_fee_type,"0097");
		strcpy(next_biz_name,"ADSL网费预存");
		memu_flag=2;
		break;
	default:
		return -1;
	}
	
	switch(memu_flag){
	case 1:
		strcpy(gbl.fee_type,next_fee_type);
		return BankHK_telPayHdl(next_biz_name);
		break;
	case 2:
		strcpy(gbl.fee_type,next_fee_type);
		return BankHK_telPayHdl(next_biz_name);
		break;
	default:
		return -1;
	}
}
int CTrade::BankHK_nameconfirm(const char *type)//用户名匹配
{
	int iRet = 0;
	
	
	wrLog("【开始用户名匹配】");
    strcpy(gbl.fee_type,"0216");
	iRet = BankHK_HK(1);
	if(iRet==0)
	{
		wrLog("【开始银行划扣受理】");
		strcpy(gbl.fee_type,"0217");
		iRet = BankHK_HK(2);
	}
	return iRet;
	
}
int CTrade::BankHK_HK(int type)//登记划扣
{
	int  iSelect,iRet;
	char response_code[3];
	char temp_buff[512];
	char tittle[50];
	char tmp_buff[512];
	char temp[512];
	int name_len=0;	
	int tmp_buff_len=0;
	pack.wrField(1, gbl);	
	if(type==1)
	{		
		TSTradeInfoSend tradeInfoSend;
		TSTradeInfoRecv tradeInfoRecv;
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
		
		strcpy(tradeInfoSend.acMainTitle, "划扣办理用户名匹配");
		
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents = 2;
		
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入姓名：");	
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_CH;	//汉字
		tradeInfoSend.Contents[0].uCount = 0;		//输入1次工号
		tradeInfoSend.Contents[0].uTimeOut = 30;	//超时30秒
		tradeInfoSend.Contents[0].uMinLen = 0;
		tradeInfoSend.Contents[0].uMaxLen = 60;
		
		strcpy(tradeInfoSend.Contents[1].acTitle, "请输入11位手机号：");	
		tradeInfoSend.Contents[1].uCommand = TS_INPUT_MATH;	//数字
		tradeInfoSend.Contents[1].uCount = 0;		//输入1次工号
		tradeInfoSend.Contents[1].uTimeOut = 30;	//超时30秒
		tradeInfoSend.Contents[1].uMinLen = 11;
		tradeInfoSend.Contents[1].uMaxLen = 11;
		
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		
		if(iRet != 0)
		{
			wrLog("TS_TradeControl返回错误[%d]", iRet);
			wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
			return -1;
		}
		bbzero(gbl.user_name);
		bbzero(gbl.telphone);
		strcpy(gbl.user_name,(char *)tradeInfoRecv.Contents[0].uMsg);
		strcpy(gbl.telphone,(char *)tradeInfoRecv.Contents[1].uMsg);
		bbzero(temp);
		sprintf(temp,"用户名：%s\n手机号：%s\n【确认】继续\n【返回】返回",gbl.user_name,gbl.telphone);
		TS_OutPutMsg(gbl.dPosInfo,temp,0,iSelect);
		if (iSelect < 0)
		{
			return -1;
		}
		//写查询域
		/***********修改一些域信息*********/	
		bbzero(pack.FIELD48);
		memcpy(pack.FIELD48,gbl.fee_type,4);	//4位信息码
		pack.Packet_Table[48].Real_Length=4;
		bbzero(pack.FIELD63);
		for(name_len=0; name_len<sizeof(gbl.user_name) && gbl.user_name[name_len]!=0x00 && gbl.user_name[name_len]!=0x20; name_len++);
		memcpy(pack.FIELD63,gbl.user_name,name_len);
		pack.Packet_Table[63].Real_Length = name_len;
		
	}
	else{
		memcpy(pack.FIELD48,gbl.fee_type,4);	//4位信息码		       		       
		bbzero(pack.FIELD63);
		bbzero(tmp_buff);
		sprintf(tmp_buff,"%02d%s%02d%s",strlen(gbl.user_name),gbl.user_name,11,gbl.telphone);
		memcpy(pack.FIELD63,tmp_buff,strlen(tmp_buff));
		tmp_buff_len = strlen(tmp_buff);
		pack.Packet_Table[63].Real_Length = tmp_buff_len;
	}
	
	//bit2
	memset(pack.FIELD2, 0, sizeof(pack.FIELD2));
	memset((char *)temp_buff,0,sizeof(temp_buff));
	strcpy((char *)temp_buff,gbl.card_no);
	CTools::hex_to_byte((BYTE *)temp_buff, pack.FIELD2, gbl.card_no_len, 1);	//变为bcd码（后补0）
	pack.Packet_Table[2].Real_Length=gbl.card_no_len;
	//  查询包打包   
	if(packHdl(1) < 0)
	{
		return -1;
	}
	else{
		memset(response_code,0,sizeof(response_code));
		memcpy(response_code,pack.FIELD39,2);
		if (!memcmp(response_code,"00",2)) 
		{
			if(type==2)
			{
				iRet = TS_OutPutMsg(gbl.dPosInfo,"		  登记成功！\n请检查打印机电源及打印线路是否正常,有问题请即与400-80-11888联系\n按【确认】打印发票",0,iSelect);
				if(iRet!=0 || iSelect==0)
				{
					CPrint prt;
					prt.set_in_par(gbl);
					bbzero(tittle);
					strcpy((char *)tittle,"银行划扣受理回执");
					//prt.print_detail(8, tittle);	//打印明细
					prt.print_ysq_detail(pack,tittle);
				}
			}
			return 0;
		}
		else {
			returnFail((char *)pack.FIELD39);
			return -1;
		}
	}
	return 0;
}



int CTrade::YH_xlt(const char *type)		//电信交易
{
	int iSelect,iRet=0;
	
	iSelect = YH_xlttelInqHdl(type);
	if(iSelect==0)
	{
		strcpy(gbl.fee_type,"0240");
		iRet = YH_xlttelPayHdl(type);
	}
	return iRet;
}

int CTrade::YH_xlttelInqHdl(const char *type)	//电信查询
{
	int  iRet;
	
	wrLog("%s【查询】", type);
	
	
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, type);
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入电话号码：");
	tradeInfoSend.Contents[0].uMinLen = 8;		
	tradeInfoSend.Contents[0].uMaxLen = 8;
	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
	tradeInfoSend.Contents[0].uCount = 0;		//输入1次		
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
	strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
	gbl.phone_len = tradeInfoRecv.Contents[0].uMsgLen;
	memset( gbl.phone_no,0,sizeof(gbl.phone_no) );
	strcpy( gbl.phone_no,(char *)tradeInfoRecv.Contents[0].uMsg );
	
	wrLog("电话号码：[%s]", gbl.phone_no);
	
	//写查询域
	pack.wrField(1, gbl);
	
	
	//查询包打包   
	iRet = packHdl(1);
	if(iRet < 0)
		return -1;
	
	//返回数据给终端
	iRet = YH_xlttelInqMsg(type);
	return iRet;
}


int CTrade::YH_xlttelInqMsg(const char *type)	
{
	wrLog("phone no1:[%s]",gbl.phone_no);
	char response_code[3],user_name_tmp[60+1];
	int b63_offset;
	char temp_buff[512],len_buff[10],mny[20];
	int iSelect,pMonNum=0,tMonNum=0;//pMonNum缴费月份数,tMonNum总欠费月份数
	double totalAmount = 0.0;//综合收费总金额，by kf
	
	
	
	memset(gbl.amount,0,sizeof(gbl.amount));
	memset(gbl.total_fee_type,0,sizeof(gbl.total_fee_type));//综合收费业务组
	memset(gbl.total_amount,0,sizeof(gbl.total_amount));//综合收费业务欠费组
	memset(response_code,0,sizeof(response_code));
	memset(temp_buff,0,sizeof(temp_buff));
	memset(len_buff,0,sizeof(len_buff));
	memset(mny,0,sizeof(mny));
	
	memcpy(response_code,pack.FIELD39,2);
	wrLog("业务代码:[%s]",gbl.fee_type);
	
	if (!memcmp(response_code,"00",2))
	{
		wrLog("phone no2:[%s]",gbl.phone_no);
		memcpy(gbl.user_name,pack.FIELD63,30);
		gbl.user_name_len = trim(gbl.user_name, 30);
		bbzero(user_name_tmp);
		strcpy(user_name_tmp,gbl.user_name);
		if(gbl.group_type != 0 && strlen(gbl.user_name)>2 ){//如果不是商户版，用户名最后一位要变为*
			user_name_tmp[gbl.user_name_len-2]='*';
			user_name_tmp[gbl.user_name_len-1]='\0';				
		}
		b63_offset = 30;
		char c;
		c = pack.FIELD63[b63_offset];
		b63_offset += 1;
		memcpy( gbl.amount, pack.FIELD63 + b63_offset, 12);	
		CTools::chgToMny(gbl.amount,mny);
		
		sprintf(temp_buff,"用户名：%s\n预付费余额：%s\n【确认】充100送300\n【返回】返回",user_name_tmp,mny);
		
		TS_OutPutMsg(gbl.dPosInfo, temp_buff, 0,iSelect);	
		
		return iSelect;
	}
	else
	{
		returnFail(response_code);
		return -1;
	}
}


int CTrade::YH_xlttelPayHdl(const char *type)	//电信交费
{
	int  iRet, flag,iSelect;
	int b48_len = 0;
	
	
	
	flag = 0;	//重输密码标识
	strcpy(gbl.amount, "000000010000");
	strcpy(gbl.xlt_type,"02");
	/********************请求刷卡****************/
	wrLog("phone no3:[%s]", gbl.phone_no);
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{
		if(!flag) 
		{
			iRet = mngCard_Hdl(type);
			if(iRet == CANCLE_KEY)
				return CANCLE_KEY;
			else if(iRet != 0){
				TS_OutPutMsg(gbl.dPosInfo,"读取输入数据错误!\n交易失败!\n请稍候再试!\n或联系在线客服中心【Ctrl+H】  400-80-11888\n按【确认】返回",1,iSelect);
				return -1;
			}
			
			if(!memcmp(gbl.card_no,"8828",4))	//若是付费易卡,走付费易卡刷卡流程（多卡交易）
			{
				memset(gbl.xlt_type, 0, sizeof(gbl.xlt_type));
				memcpy(gbl.xlt_type, "01",2);
				iRet = xltMulCard( type, 0);
				return iRet;
			}
		}
		
		pack.wrField(2, gbl);	//写交费域
		
		
		//交费包处理
		iRet = packHdl(2);
		if(iRet < 0)
			return -1;
		
		if (!memcmp(pack.FIELD39,"00",2)) 
		{
			
			iRet = TS_OutPutMsg(gbl.dPosInfo,"     受理成功！\n    谢谢您的使用\n请按【确认】打印发票",0,iSelect);
			
			if(iRet || iSelect==0)
			{
				CPrint prt;
				prt.set_in_par(gbl);
				
			//	prt.print_detail(2, type);	 //打印预付费明细
				prt.print_pre_detail(pack,type);
			}			
			return 0;
		}// end if (!memcmp(pack.FIELD39,"00",2))
		else if(!memcmp(pack.FIELD39,"55",2))
		{
			flag = 1;
			if(reGetPwd( type) == 0) //密码错误，重新输入密码, 2006-10-25
				continue;
			else
				return CANCLE_KEY;
		}
		else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
			if (iSelect!=0)
			{
				return -1;
			}else
				continue;
		}
		returnFail((char *)pack.FIELD39);		
		return -1;
	}
	return -1;
}


//////////////////*测试功能函数*/////////////////////////

//////////////////////*测试获取终端信息*//////////////////////////////
/*
flag : 1.显示终端电话号码 2.显示终端号 3.显示终端左串口设备 
4.显示终端右串口设备 5.显示终端内置设备
*/
//////////////////////////////////////////////////////////////////////
int CTrade::Test_TS_GetPosInfo(int flag)
{
	int iRet, iSelect;
	char tmp[100];
	if(flag == 1)
	{
		bbzero(tmp);
		sprintf(tmp, "终端电话号码是：\n%s\n按【确认】返回", gbl.call_tel);
		iRet = TS_OutPutMsg(gbl.dPosInfo, tmp, 3, iSelect);
	}
	else if(flag == 2)
	{		
		bbzero(tmp);
		sprintf(tmp, "终端号是：\n%s\n按【确认】返回", gbl.pos_no);
		iRet = TS_OutPutMsg(gbl.dPosInfo, tmp, 3, iSelect);
	}
	else if(flag == 3)
	{		
		bbzero(tmp);
		sprintf(tmp, "终端左串口设备是：\n%d\n按【确认】返回", gbl.posInfo.leftType);
		iRet = TS_OutPutMsg(gbl.dPosInfo, tmp, 3, iSelect);
	}
	else if(flag == 4)
	{
		bbzero(tmp);
		sprintf(tmp, "终端右串口设备是：\n%d\n按【确认】返回", gbl.posInfo.rightType);
		iRet = TS_OutPutMsg(gbl.dPosInfo, tmp, 3, iSelect);
		
	}
	else if(flag == 5)
	{
		bbzero(tmp);
		sprintf(tmp, "终端内置设备是：\n%d\n按【确认】返回", gbl.posInfo.inType);
		iRet = TS_OutPutMsg(gbl.dPosInfo, tmp, 3, iSelect);		
	}
	else 
		return -1;
	if( iSelect )
		return 0;
	iRet = selectAmount();
	if(iRet == CANCLE_KEY)
		return 0;
	else if(iRet < 0)
		return -1;
	return 0;
}
////////////////////////*测试下发消息*////////////////////////////////////
/*
flag : 1.下发提示信息 2.下发安全提示信息 3.下发多条提示信息
*/
//////////////////////////////////////////////////////////////////////////
int CTrade::Test_TS_OutPutMsg(int flag)
{
	int iRet, iSelect;
	if (flag == 1)
	{
		iRet = TS_OutPutMsg(gbl.dPosInfo, "下发提示信息成功\n按【确认】返回", 3, iSelect);		
	}
	
	else if (flag == 2)
	{
		TSOutPutMsg_S outPutMsg;
		memset(&outPutMsg, 0, sizeof(outPutMsg));
		outPutMsg.uCardType= CARD_TYPE;
		if(!gbl.posInfo.enyFlag){
			outPutMsg.uKeyIndex = 12;				//密钥组号12
			outPutMsg.uDesMode = TS_DES_2_DOWN;		//下发随机数加密
		}else{
			outPutMsg.uKeyIndex = TS_TEK_KEY;		//密钥TEK
			outPutMsg.uDesMode = TS_EXT_DEC_2;	//加密算法
		}
		outPutMsg.uMsgDataLen= strlen("测试成功");
		memcpy(outPutMsg.uMsgData,"测试成功",strlen("测试成功"));
		
		iRet = TS_OutPutMsg_S(gbl.dPosInfo,&outPutMsg,3,iSelect);
	}
	
	else if (flag == 3)
	{
		MulMsg mulMsg;
		mulMsg.num = 2;
		sprintf(mulMsg.msg[0],"test good!");
		sprintf(mulMsg.msg[1], "test good!!!");
		iRet = TS_OutPutMsg_M(gbl.dPosInfo,&mulMsg,1,iSelect);
	}
	if( iSelect )
		return 0;
	iRet = selectAmount();
	if(iRet == CANCLE_KEY)
		return 0;
	else if(iRet < 0)
		return -1;
	return 0;
}
/////////////////////////*测试打印功能*///////////////////////////////
/*
flag : 1.打印 2.安全打印
*/
//////////////////////////////////////////////////////////////////////
int CTrade::Test_TS_B4Print(int flag)
{
	char msg[700];
	int iRet,iSelect;
	CPrint print;
	memset(msg,0,sizeof(msg));	
	sprintf(msg,"“看到时代左右的人，也在左右这个时代”，王浩喜欢用这句广告词总结自己的发迹史，伤感的是：“炒房的时代，已经结束了。”\n2008年12月5日，下午2点，上海松江区九亭板块一个新楼盘的售楼大厅内，王浩和他的7个亲戚，在离沙盘模型最近的一圈沙发上悠闲地翻着新盘的资料，一位售楼经理则站在一边不厌其烦地宣扬着楼盘的升值潜力。\n此时，一个由上海某网站组织的看房团也刚刚进门，但是，“看房团”对沙盘的兴趣，远远不及对于操着浓重温州口音的王浩的好奇。被打量得有些尴尬的王浩苦笑着对本刊记者说：“我敢打赌，明天我们又会上报纸上网站了，标题是‘温州炒房团上海抄底’。”\n\n\n\n\n");
	int iPrintLen = strlen(msg);
	int m_prtCom,m_prtType;
	print.getPrintPar(gbl.posInfo.leftType, gbl.posInfo.rightType, gbl.posInfo.inType, &m_prtCom, &m_prtType);
	if (flag == 1)
	{		
		iRet = TS_B4Print(gbl.dPosInfo, m_prtCom, m_prtType, 1, "正在打印...", (BYTE *)msg, iPrintLen);
		wrLog("【打印】返回值：%d", iRet);
	}
	else if (flag == 2)
	{
		TSB4Print_S printMsg;
		memset(&printMsg, 0, sizeof(printMsg));
		
		printMsg.uCardType = CARD_TYPE;	//大卡
		if(gbl.posInfo.enyFlag)
		{
			TSMENULIST menuList;
			memset(&menuList,0,sizeof(menuList));
			menuList.iTotalNum = 2;
			strcpy(menuList.acTitle, "安全打印测试");
			strcpy(menuList.menuItem[0], "算法2");
			strcpy(menuList.menuItem[1], "扩展算法2");
			
			iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
			if(iRet)
				return -1;
			switch(iSelect)
			{
			case 1:
				printMsg.uDesMode = TS_DES_3_TEK_DEC;	//加密算法
				break;
			case 2:
				printMsg.uDesMode = TS_EXT_DEC_2;		//加密算法
				break;
			default: 
				return CANCLE_KEY;
				
			}
			printMsg.uKeyIndex = TS_TEK_KEY;		//密钥TEK			
		}
		else
		{
			printMsg.uKeyIndex = 12;		//密钥组号12
			printMsg.uDesMode = TS_DES_2_DOWN;			//加密算法
		}
		memcpy(printMsg.uPrintData, msg, iPrintLen);
		printMsg.iDataLen = iPrintLen;
		
		iRet = TS_B4Print_S(gbl.dPosInfo, m_prtCom, m_prtType, 1, "正在打印...", &printMsg);
	}
	else
		return -1;
	return 0;
}
////////////////////////*测试消息传递*////////////////////////////////
/*
flag : 1.下发通知 2.下发交易结果 3.下发账单交易结果
4.下发账单 5.显示版本号 6.显示终端序列号
*/
//////////////////////////////////////////////////////////////////////
int CTrade::Test_TS_SendMsg(int flag)
{
	int iRet,iSelect;
	char bmp[500];
	if (flag == 1)
	{
		TSSendInform tsSendInform;
		memset(&tsSendInform,0,sizeof(tsSendInform));
		memcpy(tsSendInform.sendTime,"20080710153020",strlen("20080710153020"));
		memcpy(tsSendInform.title,"测试通知标题",strlen("测试通知标题"));
		memcpy(tsSendInform.content,"测试通知内容",strlen("测试通知内容"));
		iRet = TS_SendInform(gbl.dPosInfo,&tsSendInform);
		if(iRet >= 0)
			iRet = TS_OutPutMsg(gbl.dPosInfo,"发送通知成功",1,iSelect);
		else 
			iRet = TS_OutPutMsg(gbl.dPosInfo,"发送通知不成功",1,iSelect);
	}
	else if (flag == 2)
	{
		TSTradeResult tsTradeResult;
		memset(&tsTradeResult,0,sizeof(tsTradeResult));
		memcpy(tsTradeResult.sendTime,"20080710153020",strlen("20080710153020"));
		memcpy(tsTradeResult.title,"测试交易结果标题",strlen("测试交易结果标题"));
		memcpy(tsTradeResult.content,"测试交易结果内容",strlen("测试交易结果内容"));
		iRet = TS_SendTradeResult(gbl.dPosInfo,&tsTradeResult);
		if(iRet >= 0)
			iRet = TS_OutPutMsg(gbl.dPosInfo,"发送交易结果成功",1,iSelect);
		else 
			iRet = TS_OutPutMsg(gbl.dPosInfo,"发送交易结果不成功",1,iSelect);
	}
	else if (flag == 3)
	{
		char amount[12+1];
		TSBillResult tsBillResult;
		memset(&tsBillResult,0,sizeof(tsBillResult));
		bbzero(amount);
		
		iRet = TS_GetBillInfo(gbl.dPosInfo, (char *)tsBillResult.billNo, (char *)amount);
		if(iRet >= 0)
		{
			bbzero(bmp);
			sprintf(bmp,"获取未支付帐单成功\n账单号[%s]\n金额[%s]", tsBillResult.billNo, amount);
			iRet = TS_OutPutMsg(gbl.dPosInfo,bmp,1,iSelect);
			memcpy(tsBillResult.sendTime,"201501010001",strlen("201501010001"));
			tsBillResult.result = 0x01;
			iRet = TS_SendBillResult(gbl.dPosInfo,&tsBillResult);
			if(iRet >= 0)
			{
				bbzero(bmp);			
				sprintf(bmp,"发送账单交易结果成功\n账单交易结果日期：%s\n账单交易结果账号：%s\n账单交易结果:%d",tsBillResult.sendTime,tsBillResult.billNo,(int)tsBillResult.result);
				iRet = TS_OutPutMsg(gbl.dPosInfo,bmp,1,iSelect);
			}
			else 
				iRet = TS_OutPutMsg(gbl.dPosInfo,"发送账单交易结果不成功",1,iSelect);
		}
		else
		{
			iRet = TS_OutPutMsg(gbl.dPosInfo,"获取未支付帐单不成功",1,iSelect);
		}	
	}
	else if (flag == 4)
	{
		TSUnpayedBill tsUnpayedBill;
		memset(&tsUnpayedBill,0,sizeof(tsUnpayedBill));
		tsUnpayedBill.dispFlag = 1;
		memcpy(tsUnpayedBill.billNo,"1234567890123456",strlen("1234567890123456"));
		memcpy(tsUnpayedBill.sendTime,"201501010001",strlen("201501010001"));
		memcpy(tsUnpayedBill.endTime,"201501010001",strlen("201501010001"));
		memcpy(tsUnpayedBill.title,"测试账单标题",strlen("测试账单标题"));
		memcpy(tsUnpayedBill.amount,"000000012345",strlen("000000012345"));
		memcpy(tsUnpayedBill.merInfo,"测试用户商家",strlen("测试用户商家"));
		memcpy(tsUnpayedBill.billDetail,"测试账单具体内容",strlen("测试账单具体内容"));
		iRet = TS_SendBill(gbl.dPosInfo,&tsUnpayedBill);
		if (iRet == 0)
			iRet = TS_OutPutMsg(gbl.dPosInfo,"发送账单成功",1,iSelect);
		else
			iRet = TS_OutPutMsg(gbl.dPosInfo,"发送账单不成功",1,iSelect);
	}
	else if (flag == 5)
	{
		char version[100];
		bbzero(version);
		iRet = TS_GetVersion(gbl.dPosInfo,version);
		if(iRet == 0)
		{
			bbzero(bmp);
			sprintf(bmp,"发送终端版本号成功\n终端版本号:%s",version);
			iRet = TS_OutPutMsg(gbl.dPosInfo,bmp,1,iSelect);
		}
		else
			iRet = TS_OutPutMsg(gbl.dPosInfo,"发送终端版本号不成功",1,iSelect);
		
		
	}
	else if (flag == 6)
	{
		char posSerial[100];
		bbzero(posSerial);
		iRet = TS_GetPosSerial(gbl.dPosInfo,posSerial);
		if(iRet == 0)
		{
			bbzero(bmp);
			sprintf(bmp,"获取终端序列号成功\n终端序列号[%s]",posSerial);
			iRet = TS_OutPutMsg(gbl.dPosInfo,bmp,1,iSelect);
		}
		else
			iRet = TS_OutPutMsg(gbl.dPosInfo,"获取终端序列号不成功",1,iSelect);		
	}
	else 
		return -1;
	return 0;
}
//////////////////////////*测试psam卡信息：功能未开通*////////////////
/*
flag : 1.显示PSAM卡号 2.显示PSAM卡随机数 
*/
//////////////////////////////////////////////////////////////////////
int CTrade::Test_TS_PSAM(int flag)
{
	int iRet,iSelect;
	char tmp[100];
	char PSAMNum[100],random[100];
	/////////////////////////卡座号:测试：0；生产：1//////////////////////
	bbzero(PSAMNum);
	bbzero(random);
	iRet = TS_GetPSAMNum(gbl.dPosInfo,0,PSAMNum,random);
	if (flag == 1)
	{
		bbzero(tmp);
		sprintf(tmp, "PSAM卡号是：\n%s\n按【确认】返回", PSAMNum);
		iRet = TS_OutPutMsg(gbl.dPosInfo, tmp, 3, iSelect);
	}
	else if (flag == 2)
	{
		bbzero(tmp);
		sprintf(tmp, "PSAM卡随机数是：\n%s\n按【确认】返回", random);
		iRet = TS_OutPutMsg(gbl.dPosInfo, tmp, 3, iSelect);
	}
	else 
		return -1;
	
	return 0;
}
////////////////////////////*测试更新功能*////////////////////////////
/*
flag : 2.更新终端号3.更新首页信息

*/
//////////////////////////////////////////////////////////////////////
int CTrade::Test_TS_UpdateMsg(int flag)
{
	int iSelect=0,iRet=0;
	char msg[100];
	if (flag == 1)
	{
		TS_OutPutMsg(gbl.dPosInfo, " \n\n\n测试函数未完成！", 1,iSelect);
	}
	else if (flag == 2)
	{
		TSPosPar tsposPar;
		tsposPar.num=1;		
		tsposPar.parCont[0].parId=24;
		tsposPar.parCont[0].parLen=8;
		strcpy((char *)tsposPar.parCont[0].parCont,"00000000");
		if(TS_UpdatePosPar(gbl.dPosInfo, &tsposPar)==SUCC)
		{
			TS_OutPutMsg(gbl.dPosInfo, "更新终端号为00000000\n操作成功", 1,iSelect);
		}else
		{
			TS_OutPutMsg(gbl.dPosInfo, "更新终端号为00000000\n操作出错", 1, iSelect);
		}		
	}
	else if (flag == 3)
	{
		bbzero(msg);
		sprintf(msg, "更新首页信息成功");
		TS_UpdateHeadPage(gbl.dPosInfo,msg);	
	}
	else if (flag == 4)
	{
		TS_OutPutMsg(gbl.dPosInfo, " \n\n\n测试函数未完成！", 1,iSelect);
	}
	else if (flag == 5)
	{
		TS_OutPutMsg(gbl.dPosInfo, " \n\n\n测试函数未完成！", 1,iSelect);
	}
	else if (flag == 6)
	{
		iRet = TS_ClearMenus(gbl.dPosInfo);
		wrLog("TS_ClearMenus return [%d]",iRet);
		
		TSMenus menus;
		memset(&menus, 0, sizeof(menus));
		menus.num=5;
		
		/************************************************************************/
		menus.menus[0].isused='1';
		menus.menus[0].level1=1;
		menus.menus[0].level2=0;
		menus.menus[0].level3=0;
		menus.menus[0].askType=0x00;
		menus.menus[0].sysnum='1';	
		
		///////////可做成一个独立的函数
		TSTradeInfoSend tradeInfoSend;
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		tradeInfoSend.uTotalContents = 0;
		tradeInfoSend.sendType = 1;
		strcpy(tradeInfoSend.acMainTitle, "交费易");
		////////////////////////////////
		
		iRet = TS_TradeEncode(gbl.dPosInfo, &tradeInfoSend, menus.menus[0].tcode, &(menus.menus[0].tcodelen));
		wrLog("TS_TradeEncode return [%d]",iRet);
		
		strcpy(menus.menus[0].menu, tradeInfoSend.acMainTitle);
		menus.menus[0].menulen = strlen(menus.menus[0].menu);
		menus.menus[0].menuid=0;
		
		/************************************************************************/
		
		menus.menus[1].isused='1';
		menus.menus[1].level1=2;
		menus.menus[1].level2=0;
		menus.menus[1].level3=0;
		menus.menus[1].tcodelen=3;
		memset(menus.menus[1].tcode, 0, 3);
		strcpy(menus.menus[1].menu, "金融目录");
		menus.menus[1].menulen = strlen(menus.menus[1].menu);
		menus.menus[1].menuid=0;
		
		/************************************************************************/
		
		menus.menus[2].isused='1';
		menus.menus[2].level1=2;
		menus.menus[2].level2=1;
		menus.menus[2].level3=0;
		menus.menus[2].askType=0x09;
		menus.menus[2].sysnum='1';		
		
		///////////可做成一个独立的函数
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		tradeInfoSend.sendType = 1;
		strcpy(tradeInfoSend.acMainTitle, "交费易");
		tradeInfoSend.uTotalContents = 3;
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_MONEY;	//读取金额
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
		tradeInfoSend.Contents[0].uMinLen = 3;
		tradeInfoSend.Contents[0].uMaxLen = 9;
		
		tradeInfoSend.Contents[1].uCommand = TS_MAG_CARD;		//刷卡
		tradeInfoSend.Contents[1].uTimeOut = EPOS_OVER_TIME;
		
		tradeInfoSend.Contents[2].uCommand = TS_INPUT_PIN;		//输密码
		tradeInfoSend.Contents[2].uCardType = CARD_TYPE;
		if(!gbl.posInfo.enyFlag){	//加密改造，旧加密体系
			tradeInfoSend.Contents[2].uDesMode = TS_DES_2;	//2次des
			tradeInfoSend.Contents[2].uKeyIndex = 1;
		}else{
			tradeInfoSend.Contents[2].uDesMode = TS_DES_3;	//3次des
			tradeInfoSend.Contents[2].uKeyIndex = TS_TPK_KEY;	//密钥组号 
		}
		tradeInfoSend.Contents[2].uTimeOut = EPOS_OVER_TIME;
		tradeInfoSend.Contents[2].uMinLen = 6;		
		tradeInfoSend.Contents[2].uMaxLen = 6;
		////////////////////////////////
		
		iRet = TS_TradeEncode(gbl.dPosInfo, &tradeInfoSend, menus.menus[2].tcode, &(menus.menus[2].tcodelen));
		wrLog("TS_TradeEncode return [%d]",iRet);
		
		strcpy(menus.menus[2].menu, tradeInfoSend.acMainTitle);
		menus.menus[2].menulen = strlen(menus.menus[2].menu);
		menus.menus[2].menuid=0;
		
		/************************************************************************/
		
		menus.menus[3].isused='1';
		menus.menus[3].level1=1;
		menus.menus[3].level2=0;
		menus.menus[3].level3=0;
		menus.menus[3].askType=0x05;
		menus.menus[3].sysnum='1';	
		
		///////////可做成一个独立的函数
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		tradeInfoSend.uTotalContents = 0;
		tradeInfoSend.sendType = 1;
		strcpy(tradeInfoSend.acMainTitle, "交费2易");
		////////////////////////////////
		
		iRet = TS_TradeEncode(gbl.dPosInfo, &tradeInfoSend, menus.menus[3].tcode, &(menus.menus[3].tcodelen));
		wrLog("TS_TradeEncode return [%d]",iRet);
		
		strcpy(menus.menus[3].menu, tradeInfoSend.acMainTitle);
		menus.menus[3].menulen = strlen(menus.menus[3].menu);
		menus.menus[3].menuid=0;
		
		/************************************************************************/
		
		menus.menus[4].isused='1';
		menus.menus[4].level1=3;
		menus.menus[4].level2=0;
		menus.menus[4].level3=0;
		menus.menus[4].askType=0x0A;
		menus.menus[4].sysnum='1';	
		
		///////////可做成一个独立的函数
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		tradeInfoSend.uTotalContents = 0;
		tradeInfoSend.sendType = 1;
		strcpy(tradeInfoSend.acMainTitle, "黑标定位");
		////////////////////////////////
		
		iRet = TS_TradeEncode(gbl.dPosInfo, &tradeInfoSend, menus.menus[4].tcode, &(menus.menus[4].tcodelen));
		wrLog("TS_TradeEncode return [%d]",iRet);
		
		strcpy(menus.menus[4].menu, tradeInfoSend.acMainTitle);
		menus.menus[4].menulen = strlen(menus.menus[4].menu);
		menus.menus[4].menuid=39030;
		
		/************************************************************************/
		
		iRet = TS_UpdateMenus(gbl.dPosInfo, menus);
		wrLog("TS_UpdateMenus return [%d]",iRet);
	}
	else 
		return -1;
	return 0;
}
////////////////////////测试交易控制函数///////////////////////////////////
/*
flag: 1.测试手输卡号 2.测试刷卡并获取卡的信息 3.测试输入金额 4.测试输入数字
5.测试输入全字符 6.测试日期 7.测试年月 8.测试明文密码 9.测试输入字母 
10.测试输入汉字 11.刷卡或手输卡号
*/
//////////////////////////////////////////////////////////////////////////
int CTrade::Test_TS_TradeControl(int flag)
{
	int iRet,iSelect;
	char tmp[100],tmp_amo[13],allchartest[20+1],chartest[12+1],hztest[10+1],paswtest[6+1],datetest[8+1],timetest[6+1];
	char card_info_test[200];
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	if (flag == 1 || flag == 2 || flag == 11)
	{	
		int card_flag=ONLY_MNG;
		char title[200];
		bbzero(title);
		if(flag==1)
		{
			card_flag=ONLY_INPUT;
			strcpy(title, "");
		}
		else if(flag==2)
		{
			strcpy(title, "");
			card_flag=ONLY_MNG;
		}
		else if(flag==11)
		{
			strcpy(title, "");
			card_flag=MNG_OR_INPUT;
		}
		
		strcpy(tradeInfoSend.acMainTitle, "刷卡相关测试");
		tradeInfoSend.uTotalContents = 1;	
		tradeInfoSend.uHasTradeID = 1;
		
		tradeInfoSend.Contents[0].uCount = 0;
		tradeInfoSend.Contents[0].uDesMode = TS_NO_ENC;		//不加密
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
		
		if(card_flag==ONLY_INPUT)  //只输卡号
		{
			strcpy(tradeInfoSend.Contents[0].acTitle, title);
			tradeInfoSend.Contents[0].uCommand = TS_INPUT_CARD;	//手输卡号
			tradeInfoSend.Contents[0].uMaxLen = 19;
			tradeInfoSend.Contents[0].uMinLen = 1;
		}
		else if(card_flag==MNG_OR_INPUT)	//如果是既可刷卡又可输卡号的形式
		{
			strcpy(tradeInfoSend.Contents[0].acTitle, title);
			tradeInfoSend.Contents[0].uCommand = TS_MAG_INPUT_CARD;	//刷卡或输卡号
			tradeInfoSend.Contents[0].uMaxLen = 19;
			tradeInfoSend.Contents[0].uMinLen = 1;
		}
		else	//只刷卡
		{
			strcpy(tradeInfoSend.Contents[0].acTitle, title);
			tradeInfoSend.Contents[0].uCommand = TS_MAG_CARD;	//刷卡
		}
		
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		
		if(iRet != 0)
		{
			wrLog("#TS_TradeControl返回错误[%d]", iRet);
			wrMonitorLog(2, 1, iRet, gbl, pack);	//监控日志
			if(iRet == 1)
				return CANCLE_KEY;
			else
				return iRet;
		}
		
		memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
		strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
		
		//平台测试整改(不记录磁道信息)
		//wrLog("磁道信息tradeInfoRecv[%d]：[%s]", tradeInfoRecv.Contents[0].uMsgLen, tradeInfoRecv.Contents[0].uMsg);
		
		if(tradeInfoSend.Contents[0].uCommand == TS_MAG_INPUT_CARD)	//刷卡或输卡号
		{
			if(tradeInfoRecv.Contents[0].uMsgLen != 142)	//手输卡号
				strcpy(card_info_test, (char *)tradeInfoRecv.Contents[0].uMsg);
			else		//刷卡
				memcpy(card_info_test, tradeInfoRecv.Contents[0].uMsg, tradeInfoRecv.Contents[0].uMsgLen);
		}
		else	//刷卡、手输卡号
		{
			memcpy(card_info_test, tradeInfoRecv.Contents[0].uMsg, tradeInfoRecv.Contents[0].uMsgLen);
		}
		getCardNum(card_info_test, card_flag);
		bbzero(tmp);
		sprintf(tmp, "卡号是：\n%s\n按【确认】返回", gbl.card_no);
		wrLog("银行卡号是：[%s]",gbl.card_no);
		iRet = TS_OutPutMsg(gbl.dPosInfo, tmp, 3, iSelect);
	}
	else if (flag == 3)
	{
		strcpy(tradeInfoSend.acMainTitle, "测试输入金额");
		tradeInfoSend.uHasTradeID = 1; //返回终端流水		
		tradeInfoSend.uTotalContents = 1;	//项数		
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入测试金额：");	
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_MONEY;	//金额
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
		tradeInfoSend.Contents[0].uMinLen = 1;
		tradeInfoSend.Contents[0].uMaxLen = 6;
		
		if( TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv) )
			return -1;
		
		bbzero(gbl.pos_serial);
		bbzero(gbl.amount);
		strcpy( gbl.pos_serial, (char *)tradeInfoRecv.uTradeID );
		strcpy( gbl.amount, (char *)tradeInfoRecv.Contents[0].uMsg);
		wrLog("返回金额(分): [%s]", gbl.amount);
		bbzero(tmp_amo);
		bbzero(tmp);
		CTools::chgToMny(gbl.amount, tmp_amo);
		sprintf(tmp, "测试金额是：【%s】\n\n按【确认】返回", tmp_amo);
		iRet = TS_OutPutMsg(gbl.dPosInfo, tmp, 3, iSelect);
	}
	else if (flag == 4)
	{
		strcpy(tradeInfoSend.acMainTitle, "测试输入数字");
		tradeInfoSend.uHasTradeID = 1; //返回终端流水		
		tradeInfoSend.uTotalContents = 1;	//项数		
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入测试数字：");	
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
		tradeInfoSend.Contents[0].uMinLen = 1;
		tradeInfoSend.Contents[0].uMaxLen = 11;
		
		if( TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv) )
			return -1;
		
		bbzero( gbl.phone_no );
		strcpy( gbl.phone_no, (char *)tradeInfoRecv.Contents[0].uMsg );
		
		wrLog("输入的测试数字是:[%s]", gbl.phone_no);
		
		bbzero( gbl.pos_serial );
		strcpy( gbl.pos_serial, (char *)tradeInfoRecv.uTradeID );
		
		bbzero(tmp);
		sprintf(tmp, "测试数字是：【%s】\n\n按【确认】返回", gbl.phone_no);
		iRet = TS_OutPutMsg(gbl.dPosInfo, tmp, 3, iSelect);
	}
	else if (flag == 5)
	{
		strcpy(tradeInfoSend.acMainTitle, "测试输入全字符");
		tradeInfoSend.uHasTradeID = 1; //返回终端流水		
		tradeInfoSend.uTotalContents = 1;	//项数		
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入测试全字符：");	
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//字符
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
		tradeInfoSend.Contents[0].uMinLen = 1;
		tradeInfoSend.Contents[0].uMaxLen = 20;
		
		if( TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv) )
			return -1;
		
		bbzero( allchartest );
		strcpy( allchartest, (char *)tradeInfoRecv.Contents[0].uMsg );
		
		wrLog("输入的测试字符是:[%s]", allchartest);
		
		bbzero( gbl.pos_serial );
		strcpy( gbl.pos_serial, (char *)tradeInfoRecv.uTradeID );
		
		bbzero(tmp);
		sprintf(tmp, "测试全字符是：【%s】\n\n按【确认】返回", allchartest);
		iRet = TS_OutPutMsg(gbl.dPosInfo, tmp, 3, iSelect);
	}
	else if (flag == 6)
	{
		strcpy(tradeInfoSend.acMainTitle, "测试输入日期");
		tradeInfoSend.uHasTradeID = 1; //返回终端流水		
		tradeInfoSend.uTotalContents = 1;	//项数		
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入日期：");	
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_DATE;	//日期
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
		tradeInfoSend.Contents[0].uMinLen = 8;
		tradeInfoSend.Contents[0].uMaxLen = 8;
		
		if( TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv) )
			return -1;
		
		bbzero( datetest );
		strcpy( datetest, (char *)tradeInfoRecv.Contents[0].uMsg );
		
		wrLog("输入的日期是:[%s]", datetest);
		
		bbzero( gbl.pos_serial );
		strcpy( gbl.pos_serial, (char *)tradeInfoRecv.uTradeID );
		
		bbzero(tmp);
		sprintf(tmp, "日期是：【%s】\n\n按【确认】返回", datetest);
		iRet = TS_OutPutMsg(gbl.dPosInfo, tmp, 3, iSelect);
	}
	else if (flag == 7)
	{
		strcpy(tradeInfoSend.acMainTitle, "测试输入年月");
		tradeInfoSend.uHasTradeID = 1; //返回终端流水		
		tradeInfoSend.uTotalContents = 1;	//项数		
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入年月：");	
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_YYYYMM;	//年月
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
		tradeInfoSend.Contents[0].uMinLen = 8;
		tradeInfoSend.Contents[0].uMaxLen = 8;
		
		if( TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv) )
			return -1;
		
		bbzero( timetest );
		strcpy( timetest, (char *)tradeInfoRecv.Contents[0].uMsg );
		
		wrLog("输入的年月是:[%s]", timetest);
		
		bbzero( gbl.pos_serial );
		strcpy( gbl.pos_serial, (char *)tradeInfoRecv.uTradeID );
		
		bbzero(tmp);
		sprintf(tmp, "年月是：【%s】\n\n按【确认】返回", timetest);
		iRet = TS_OutPutMsg(gbl.dPosInfo, tmp, 3, iSelect);
	}
	else if (flag == 8)
	{
		strcpy(tradeInfoSend.acMainTitle, "测试明文密码");
		tradeInfoSend.uHasTradeID = 1; //返回终端流水		
		tradeInfoSend.uTotalContents = 1;	//项数		
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入密码：");
		
		if(!gbl.posInfo.enyFlag)	//加密改造，旧加密体系
		{
			tradeInfoSend.Contents[0].uCommand = TS_INPUT_PWD;	//密码(明文)
		}
		else
		{
			tradeInfoSend.Contents[0].uCommand = TS_INPUT_PWD;	//密码
			tradeInfoSend.Contents[0].uCardType = CARD_TYPE;	//大卡加密，修改密码标志
			tradeInfoSend.Contents[0].uDesMode = TS_EXT_ENC_1;		//3次des
			tradeInfoSend.Contents[0].uKeyIndex = TS_TEK_KEY;	//密钥组号 
		}
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
		tradeInfoSend.Contents[0].uMinLen = 6;
		tradeInfoSend.Contents[0].uMaxLen = 6;
		
		if( TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv) )
			return -1;
		
		bbzero( paswtest );
		strcpy( paswtest, (char *)tradeInfoRecv.Contents[0].uMsg );
		
		wrLog("输入的密码是:[%s]", paswtest);
		
		bbzero( gbl.pos_serial );
		strcpy( gbl.pos_serial, (char *)tradeInfoRecv.uTradeID );
		
		bbzero(tmp);
		sprintf(tmp, "密码是：【%s】\n\n按【确认】返回", paswtest);
		iRet = TS_OutPutMsg(gbl.dPosInfo, tmp, 3, iSelect);
	}
	else if (flag == 9)
	{
		strcpy(tradeInfoSend.acMainTitle, "测试输入字符");
		tradeInfoSend.uHasTradeID = 1; //返回终端流水		
		tradeInfoSend.uTotalContents = 1;	//项数		
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入测试字符：");	
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_LET;	//字符
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
		tradeInfoSend.Contents[0].uMinLen = 1;
		tradeInfoSend.Contents[0].uMaxLen = 12;
		
		if( TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv) )
			return -1;
		
		bbzero( chartest );
		strcpy( chartest, (char *)tradeInfoRecv.Contents[0].uMsg );
		
		wrLog("输入的测试字符是:[%s]", chartest);
		
		bbzero( gbl.pos_serial );
		strcpy( gbl.pos_serial, (char *)tradeInfoRecv.uTradeID );
		
		bbzero(tmp);
		sprintf(tmp, "测试字符是：【%s】\n\n按【确认】返回", chartest);
		iRet = TS_OutPutMsg(gbl.dPosInfo, tmp, 3, iSelect);
	}
	else if (flag == 10)
	{
		strcpy(tradeInfoSend.acMainTitle, "测试输入汉字");
		tradeInfoSend.uHasTradeID = 1; //返回终端流水		
		tradeInfoSend.uTotalContents = 1;	//项数		
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入测试汉字：");	
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_CH;	//字符
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
		tradeInfoSend.Contents[0].uMinLen = 1;
		tradeInfoSend.Contents[0].uMaxLen = 10;
		
		if( TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv) )
			return -1;
		
		bbzero( hztest );
		strcpy( hztest, (char *)tradeInfoRecv.Contents[0].uMsg );
		
		wrLog("输入的测试汉字是:[%s]", hztest);
		
		bbzero( gbl.pos_serial );
		strcpy( gbl.pos_serial, (char *)tradeInfoRecv.uTradeID );
		
		bbzero(tmp);
		sprintf(tmp, "测试汉字是：【%s】\n\n按【确认】返回", hztest);
		iRet = TS_OutPutMsg(gbl.dPosInfo, tmp, 3, iSelect);
	}
	return 0;
}
//////////////////////////////////////////////////////////////////////////


int CTrade::add_ADSL(const char *title)
{
	int  iSelect,curTry=0;
	char response_code[3];
	int name_len=0;	
	int id_len=0;
	int iRet,flag;
	char temp_buff[250];
	char test_type[2+1],custom_type[2+1],by_type[2+1],modem_type[2+1];
	char pay_amount1[12+1],pay_amount2[12+1],amoMny[12+1];
	int b48_len,b63_len;
	char pwd_buf[8+1];
	char b63_buff[1024];
	char len_buf[2+1];
	TSMENULIST menuList;
	TSMENULIST menuList1;
	
	strcpy(gbl.fee_type,"0246");  
	
	
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, "固话加装ADSL");
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;	
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入固话号码");
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME ;	//超时30秒
	tradeInfoSend.Contents[0].uMinLen = 8;		
	tradeInfoSend.Contents[0].uMaxLen = 8;
	
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
	strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
	memset( gbl.phone_no,0,sizeof(gbl.phone_no) );
	memcpy(gbl.phone_no,(char *)tradeInfoRecv.Contents[0].uMsg,tradeInfoRecv.Contents[0].uMsgLen);
	wrLog("电话号码:[%s]", gbl.phone_no);
	gbl.phone_len = strlen( gbl.phone_no);          
	
	
	memset(&menuList,0,sizeof(menuList));
	menuList.iTotalNum = 2;
	strcpy(menuList.acTitle, "请选择验证途径");
	strcpy(menuList.menuItem[0], "电信密码验证");
	strcpy(menuList.menuItem[1], "身份证号码验证");
	
	iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
	if(iRet)
		return -1;
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, title);
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	switch(iSelect)
	{
	case 1:	
		bbzero(test_type);
		strcpy(test_type,"01");
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入客户密码：");	
		tradeInfoSend.Contents[0].uCount = 0;		//输入1次
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
		tradeInfoSend.Contents[0].uMinLen = 6;		
		tradeInfoSend.Contents[0].uMaxLen = 6;
		if(!gbl.posInfo.enyFlag)	//加密改造，旧加密体系
		{
			tradeInfoSend.Contents[0].uCommand = TS_INPUT_PWD;	//密码(明文)
		}
		else
		{
			tradeInfoSend.Contents[0].uCommand = TS_INPUT_PIN;	//密码
			tradeInfoSend.Contents[0].uCardType = CARD_TYPE;	//大卡加密，修改密码标志
			tradeInfoSend.Contents[0].uDesMode = TS_DES_3_TEK_ENC;		//3次des
			tradeInfoSend.Contents[0].uKeyIndex = TS_TEK_KEY;	//密钥组号 
		}
		
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		if(iRet != 0)
		{
			wrLog("TS_TradeControl返回错误[%d]", iRet);
			wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
			return iRet;
		}
		memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
		strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
		bbzero(pwd_buf);
		strcpy( pwd_buf,(char *)tradeInfoRecv.Contents[0].uMsg );
		wrLog("电信密码:[%s]", pwd_buf);
		break;
	case 2:
		bbzero(test_type);
		strcpy(test_type,"02");
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入身份证号");	
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//数字
		tradeInfoSend.Contents[0].uCount = 0;		//输入1次
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
		tradeInfoSend.Contents[0].uMinLen = 15;		
		tradeInfoSend.Contents[0].uMaxLen = 18;	
		
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		if(iRet != 0)
		{
			wrLog("TS_TradeControl返回错误[%d]", iRet);
			wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
			return iRet;
		}
		memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
		strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
		memset( gbl.id_num,0,sizeof(gbl.id_num) );
		strcpy( gbl.id_num,(char *)tradeInfoRecv.Contents[0].uMsg );
		wrLog("身份证号:[%s]", gbl.id_num);
		break;
	default: 
		return -1;
	}
	
	memset(&menuList,0,sizeof(menuList));
	menuList.iTotalNum = 2;
	strcpy(menuList.acTitle, "请选择客户类型");
	strcpy(menuList.menuItem[0], "普通客户");
	strcpy(menuList.menuItem[1], "商业客户");
	
	iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
	if(iRet)
		return -1;
	bbzero(custom_type);
	bbzero(by_type);
	bbzero(pay_amount1);
	switch(iSelect)
	{
	case 1:	
		strcpy(custom_type,"01");
		strcpy(gbl.adsl_custom_type,"普通用户");
		memset(&menuList1,0,sizeof(menuList1));
		menuList1.iTotalNum = 3;
		strcpy(menuList1.acTitle, "请选择包月类型");
		strcpy(menuList1.menuItem[0], "200元包月");
		strcpy(menuList1.menuItem[1], "150元包月");
		strcpy(menuList1.menuItem[2], "130元包月");
		
		iRet = TS_Menu(gbl.dPosInfo, &menuList1, iSelect, MENU_TIME_OUT);
		if(iRet)
			return -1;
		
		switch(iSelect)
		{
		case 1:
			strcpy(by_type,"01");
			strcpy(gbl.adsl_by_type,"200元包月");
			strcpy(pay_amount1,"000000020000");
			break;
		case 2:
			strcpy(by_type,"02");
			strcpy(gbl.adsl_by_type,"150元包月");
			strcpy(pay_amount1,"000000015000");
			break;
		case 3:
			strcpy(by_type,"03");
			strcpy(gbl.adsl_by_type,"130元包月");
			strcpy(pay_amount1,"000000013000");
			break;
		default:
			return -1;
		}
		break;
		case 2:
			strcpy(custom_type,"02");
			strcpy(gbl.adsl_custom_type,"商业用户");
			memset(&menuList1,0,sizeof(menuList1));
			menuList1.iTotalNum = 5;
			strcpy(menuList1.acTitle, "请选择包月类型");
			strcpy(menuList1.menuItem[0], "120元60小时");
			strcpy(menuList1.menuItem[1], "200元100小时");
			strcpy(menuList1.menuItem[2], "220元包月上班时间");
			strcpy(menuList1.menuItem[3], "500元包月");
			strcpy(menuList1.menuItem[4], "250元包月");
			
			iRet = TS_Menu(gbl.dPosInfo, &menuList1, iSelect, MENU_TIME_OUT);
			if(iRet)
				return -1;
			
			switch(iSelect)
			{
			case 1:
				strcpy(by_type,"04");
				strcpy(gbl.adsl_by_type,"120元60小时");
				strcpy(pay_amount1,"000000012000");
				break;
			case 2:
				strcpy(by_type,"05");
				strcpy(gbl.adsl_by_type,"200元100小时");
				strcpy(pay_amount1,"000000020000");
				break;
			case 3:
				strcpy(by_type,"06");
				strcpy(gbl.adsl_by_type,"220元包月上班时间");
				strcpy(pay_amount1,"000000022000");
				break;
			case 4:
				strcpy(by_type,"07");
				strcpy(gbl.adsl_by_type,"500元包月");
				strcpy(pay_amount1,"000000050000");
				break;
			case 5:
				strcpy(by_type,"08");
				strcpy(gbl.adsl_by_type,"250元包月");
				strcpy(pay_amount1,"000000025000");
				break;
			default:
				return -1;
			}
			break;
			default: 
				return -1;
	}
	
	memset(&menuList,0,sizeof(menuList));
	menuList.iTotalNum = 3;
	strcpy(menuList.acTitle, "请选择ADSL MODEM类型");
	strcpy(menuList.menuItem[0], "单口以太网100元");
	strcpy(menuList.menuItem[1], "多功能无线350元");
	strcpy(menuList.menuItem[2], "自备MODEM");
	
	iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
	if(iRet)
		return -1;
	bbzero(pay_amount2);
	bbzero(modem_type);
	switch(iSelect)
	{
	case 1:
		strcpy(modem_type,"01");
		strcpy(gbl.adsl_modem_type,"单口以太网100元");
		strcpy(pay_amount2,"000000010000");
		break;
	case 2:
		strcpy(modem_type,"02");
		strcpy(gbl.adsl_modem_type,"多功能无线350元");
		strcpy(pay_amount2,"000000035000");
		break;
	case 3:
		strcpy(modem_type,"03");
		strcpy(gbl.adsl_modem_type,"自备MODEM");
		strcpy(pay_amount2,"000000000000");
		break;
	default:
		return -1;
	}
	
	//写查询域
	pack.wrField(1, gbl);
	/************修改一些域*********/
	bbzero(pack.FIELD3);
	CTools::hex_to_byte((BYTE *)"310000", pack.FIELD3, 6);
	b48_len = 0;
	memcpy(pack.FIELD48+b48_len,"0246",4);
	b48_len += 4;
	memcpy(pack.FIELD48+b48_len,"08",2);
	b48_len +=2;
	memcpy(pack.FIELD48+b48_len,gbl.phone_no,8);
	b48_len +=8;
	wrLog("bit48:[%s]",pack.FIELD48);
	pack.Packet_Table[48].Real_Length = b48_len;
	
	b63_len = 0;
	memcpy(pack.FIELD63+b63_len,test_type,2);
	b63_len += 2;
	memcpy(pack.FIELD63+b63_len,custom_type,2);
	b63_len += 2;
	memcpy(pack.FIELD63+b63_len,by_type,2);
	b63_len += 2;
	memcpy(pack.FIELD63+b63_len,modem_type,2);
	b63_len += 2;
	bbzero(len_buf);
	switch (atoi(test_type))
	{
	case 1:
		sprintf(len_buf,"%02d",6);
		memcpy(pack.FIELD63+b63_len,len_buf,2);
		b63_len += 2;
		memcpy(pack.FIELD63+b63_len,pwd_buf,6);
		b63_len += 6;
		break;
	case 2:
		sprintf(len_buf,"%02d",strlen(gbl.id_num));
		memcpy(pack.FIELD63+b63_len,len_buf,2);
		b63_len += 2;
		memcpy(pack.FIELD63+b63_len,gbl.id_num,strlen(gbl.id_num));
		b63_len += strlen(gbl.id_num);
		break;
	default:
		return -1;
	}
	wrLog("bit63:[%s]",pack.FIELD63);
	pack.Packet_Table[63].Real_Length = b63_len;
	
	/*******************************/
	
	//  查询包打包   
	iRet = packHdl(1);
	if(iRet < 0)
		return -1;
	memset(response_code,0,sizeof(response_code));
	memcpy(response_code,pack.FIELD39,2);
	if (!memcmp(response_code,"00",2)) 
	{
		bbzero(b63_buff);
		memcpy(b63_buff,(char *)(pack.FIELD63),strlen((char *)pack.FIELD63));
		memcpy(gbl.amount,(char *)(pack.FIELD4),strlen((char *)pack.FIELD4));
		memset(amoMny,0,sizeof(amoMny));
		CTools::chgToMny(gbl.amount,amoMny);
		bbzero(temp_buff);
		sprintf(temp_buff,"\n      验证通过！需交纳总额为:%s\n  请按【确认】支付",amoMny);
		TS_OutPutMsg(gbl.dPosInfo,temp_buff,0,iSelect);
		if (iSelect == 0)
		{
			flag = 0;
			for(int curTry=0; curTry<MAXTRY; curTry++)
			{
				if(!flag)
				{
					iRet = mngCard_Hdl(title);
					if(iRet == CANCLE_KEY)
						return CANCLE_KEY;
					else if(iRet != 0)
						return -1;
				}
				pack.wrField(2, gbl);	//写交费域
				/**************修改一些域**************/
				b48_len = 0;
				memcpy(pack.FIELD48+b48_len,"0246",4);
				b48_len += 4;
				memcpy(pack.FIELD48+b48_len,"08",2);
				b48_len +=2;
				memcpy(pack.FIELD48+b48_len,gbl.phone_no,8);
				b48_len +=8;
				//wrLog("bit48:[%s]",pack.FIELD48);
				pack.Packet_Table[48].Real_Length = b48_len;
				
				memcpy(pack.FIELD63,b63_buff,strlen(b63_buff));
				pack.Packet_Table[63].Real_Length = strlen(b63_buff);
				/**************************************/
				//交费包
				iRet = packHdl(2);
				if(iRet < 0)
					return -1;
				
				memset(response_code,0,sizeof(response_code));
				memcpy(response_code,pack.FIELD39,2);
				if (!memcmp(response_code,"00",2)) 
				{
					iRet = TS_OutPutMsg(gbl.dPosInfo,"     交费成功！\n    谢谢您的使用\n请按【确认】打印回执",0,iSelect);
					if(iRet!=0 || iSelect==0)
					{
						CPrint prt;
						prt.set_in_par(gbl);
						//prt.print_detail(12, title);
						prt.print_ADD_ADSL(pack,title);
					}
					return 0;
				}
				else if(!memcmp(response_code,"55",2))
				{
					flag = 1;
					if(reGetPwd( title) == 0) //密码错误，重新输入密码, 2006-10-25
						continue;
					else
						return CANCLE_KEY;
				}
				else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
				{
					TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
					if (iSelect!=0)
					{
						return -1;
					}else
						continue;
				}
				else
					returnFail(response_code);
				return -1;	
			}
		}else
			return -1;
		
	}else
		returnFail(response_code);
	return -1;
}



//星空网盟点卡销售
/**************************************************/
/*
cflag:  0.其他种类卡（数据库中配置）
1.魔兽世界600点卡
2.盛大互动娱乐卡
3.搜狐一卡通
4.网易一卡通
5.骏网一卡通
*/
/**************************************************/
/*
int CTrade::sell_xmcard(const char *title, int cflag)
{
int  iRet=0, flag = 0;
int  iSelect;
int  b48_len;
char response_code[3];
char temp[1024];
char fee_buff[20];

  TSMENULIST menuList;
  memset(&menuList,0,sizeof(menuList));
  bbzero(gbl.amount);
  bbzero(gbl.card_amount);
  bbzero(gbl.xmcard_type);
  bbzero(gbl.xmcard_name);
  
	if (cflag == 0)
	{
	iRet = selectAmount();
	
	  if((iRet < 0) || (iRet == CANCLE_KEY))
	  return -1;
	  }else if (cflag == 1)
	  {
	  strcpy(gbl.amount,"000000003000");
	  strcpy(gbl.card_amount,"000000003000");
	  strcpy(gbl.xmcard_type,"ZK0407100001");
	  strcpy(gbl.xmcard_name,"魔兽世界600点卡");
	  }else if (cflag == 2)
	  {
	  menuList.iTotalNum =5;
	  strcpy(menuList.acTitle, "请选择游戏卡类型");
	  strcpy(menuList.menuItem[0], "洛奇/跑跑卡丁车100");
	  strcpy(menuList.menuItem[1], "洛奇/跑跑卡丁车400");
	  strcpy(menuList.menuItem[2], "传奇世界25元");
	  strcpy(menuList.menuItem[3], "热血江湖专用卡10元");
	  strcpy(menuList.menuItem[4], "热血传奇25元21元宝");
	  
		iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
		if(iRet)
		return -1;
		switch(iSelect)
		{
		case 1:
		strcpy(gbl.amount,"000000001000");
		strcpy(gbl.card_amount,"000000001000");
		strcpy(gbl.xmcard_type,"ZK0410300002");
		strcpy(gbl.xmcard_name,"洛奇/跑跑卡丁车100点");
		break;
		case 2:
		strcpy(gbl.amount,"000000004000");
		strcpy(gbl.card_amount,"000000004000");
		strcpy(gbl.xmcard_type,"ZK0410300001");
		strcpy(gbl.xmcard_name,"洛奇/跑跑卡丁车400点");
		break;
		case 3:
		strcpy(gbl.amount,"000000002500");
		strcpy(gbl.card_amount,"000000002500");
		strcpy(gbl.xmcard_type,"ZK0400300024");
		strcpy(gbl.xmcard_name,"传奇世界25元");
		break;
		case 4:
		strcpy(gbl.amount,"000000001000");
		strcpy(gbl.card_amount,"000000001000");
		strcpy(gbl.xmcard_type,"ZK0408600004");
		strcpy(gbl.xmcard_name,"热血江湖专用卡10元");
		break;
		case 5:
		strcpy(gbl.amount,"000000002500");
		strcpy(gbl.card_amount,"000000002500");
		strcpy(gbl.xmcard_type,"ZK0400500020");
		strcpy(gbl.xmcard_name,"热血传奇25元21元宝");
		break;
		default: 
		return CANCLE_KEY;
		}
		}else if (cflag == 3)
		{
		menuList.iTotalNum =2;
		strcpy(menuList.acTitle, "请选择游戏卡类型");
		strcpy(menuList.menuItem[0], "刀剑/天龙八部600点");
		strcpy(menuList.menuItem[1], "刀剑/天龙八部300点");
		
		  iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
		  if(iRet)
		  return -1;
		  switch(iSelect)
		  {
		  case 1:
		  strcpy(gbl.amount,"000000003000");
		  strcpy(gbl.card_amount,"000000003000");
		  strcpy(gbl.xmcard_type,"ZK0401100002");
		  strcpy(gbl.xmcard_name,"刀剑/天龙八部600点");
		  break;
		  case 2:
		  strcpy(gbl.amount,"000000001500");
		  strcpy(gbl.card_amount,"000000001500");
		  strcpy(gbl.xmcard_type,"ZK0401100001");
		  strcpy(gbl.xmcard_name,"刀剑/天龙八部300点");
		  break;
		  default: 
		  return CANCLE_KEY;
		  }
		  }else if (cflag == 4)
		  {
		  menuList.iTotalNum =2;
		  strcpy(menuList.acTitle, "请选择游戏卡类型");
		  strcpy(menuList.menuItem[0], "网易一卡通150点");
		  strcpy(menuList.menuItem[1], "网易一卡通300点");
		  
			iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
			if(iRet)
			return -1;
			switch(iSelect)
			{
			case 1:
			strcpy(gbl.amount,"000000001500");
			strcpy(gbl.card_amount,"000000001500");
			strcpy(gbl.xmcard_type,"ZK0400400001");
			strcpy(gbl.xmcard_name,"网易一卡通150点");
			break;
			case 2:
			strcpy(gbl.amount,"000000003000");
			strcpy(gbl.card_amount,"000000003000");
			strcpy(gbl.xmcard_type,"ZK0400400002");
			strcpy(gbl.xmcard_name,"网易一卡通300点");
			break;
			default: 
			return CANCLE_KEY;
			}
			}else if (cflag == 5)
			{
			menuList.iTotalNum =3;
			strcpy(menuList.acTitle, "请选择游戏卡类型");
			strcpy(menuList.menuItem[0], "骏网一卡通10元");
			strcpy(menuList.menuItem[1], "骏网一卡通30元");
			strcpy(menuList.menuItem[2], "梦想世界-150点");
			
			  iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
			  if(iRet)
			  return -1;
			  switch(iSelect)
			  {
			  case 1:
			  strcpy(gbl.amount,"000000001000");
			  strcpy(gbl.card_amount,"000000001000");
			  strcpy(gbl.xmcard_type,"ZK0411700003");
			  strcpy(gbl.xmcard_name,"骏网一卡通10元");
			  break;
			  case 2:
			  strcpy(gbl.amount,"000000003000");
			  strcpy(gbl.card_amount,"000000003000");
			  strcpy(gbl.xmcard_type,"ZK0411700002");
			  strcpy(gbl.xmcard_name,"骏网一卡通30元");
			  break;
			  case 3:
			  strcpy(gbl.amount,"000000001500");
			  strcpy(gbl.card_amount,"000000001500");
			  strcpy(gbl.xmcard_type,"ZK0411900001");
			  strcpy(gbl.xmcard_name,"梦想世界-150点");
			  break;
			  default: 
			  return CANCLE_KEY;
			  }
			  }else 
			  return -1;
			  
				bbzero(temp);
				bbzero(fee_buff);
				CTools::chgToMny(gbl.amount,fee_buff);
				sprintf(temp,"点卡名称：\n%s\n点卡价格：%s\n\n    请按【确认】继续",gbl.xmcard_name,fee_buff);
				TS_OutPutMsg(gbl.dPosInfo,temp,0,iSelect);
				if (iSelect!=0)
				{
				return -1;
				}
				
				  for(int curTry=0; curTry<MAXTRY; curTry++)
				  {	
				  if(!flag)
				  {
				  iRet = mngCard_Hdl(title);
				  if(iRet == CANCLE_KEY)
				  return CANCLE_KEY;
				  else if(iRet != 0)
				  return -1;
				  }
				  
					pack.wrField(2, gbl);	//写交费域
					//*************48bit****************
					b48_len = 0;
					bbzero(pack.FIELD48);
					memcpy(pack.FIELD48, "0245", 4);
					b48_len += 4;
					memcpy(pack.FIELD48 + b48_len, "12", 2);
					b48_len += 2;
					memcpy(pack.FIELD48 + b48_len, gbl.xmcard_type, 12);
					b48_len += 12;
					pack.Packet_Table[48].Real_Length=b48_len;
					
					  memcpy(pack.FIELD63+8,"01",2);
					  pack.Packet_Table[63].Real_Length=10;
					  //*************end 48bit****************
					  
						iRet = packHdl(2);
						if(iRet < 0)
						return -1;
						
						  memset(response_code,0,sizeof(response_code));
						  memcpy(response_code,pack.FIELD39,2);
						  if (!memcmp(response_code,"00",2)) 
						  {
						  TS_OutPutMsg(gbl.dPosInfo,"     售卡成功！\n按【确认】打印卡数据\n如无法正常获得卡数据，请立即致电400-80-11888（最好于3小时以内），我们将为您优先处理",0,iSelect);
						  wrLog("售卡成功，准备打印!");
						  CPrint prt;
						  prt.set_in_par(gbl, pack);
						  prt.print_detail(3, title);	 //打印售卡明细
						  return 0;
						  }
						  else if(!memcmp(response_code,"55",2))
						  {
						  flag = 1;
						  if(reGetPwd( title) == 0) //密码错误，重新输入密码, 2006-10-25，lihk
						  continue;
						  else
						  return CANCLE_KEY;
						  }
						  else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
						  {
						  TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
						  if (iSelect!=0)
						  {
						  return -1;
						  }else
						  continue;
						  }
						  else
						  {					
						  returnFail(response_code);
						  }
						  return 1;
						  }
						  return -1;
						  }
*/

//////////////////////////////////////////////////////////////////////////

int CTrade::selectxlt()//小灵通选号
{
	char xltIP[16+1],YYT_termid[6+1],send_buff[4096],rev_buff[4096],msg[1024],lenbuf[4+1],id_card[18+1],xltselect[30+1],yytname[30+1];
	char *xltnum[150];
	int xltport=0, iRet=0, iSelect=0, xltcount=0, i;
	CConnect con;	
	if(TRADE_FLAG)
	{
		strcpy(xltIP,"132.97.9.151");
		xltport = 30000;		
	}
	else
	{
		// 		strcpy(xltIP,"132.97.10.55");
		// 		xltport = 40000;
		strcpy(xltIP,"132.97.9.151");
		xltport = 30000;
	}
	
	char yytids[25][6+1];
	char yytnames[25][30+1];
	strcpy(yytids[0 ],"107920");
	strcpy(yytids[1 ],"91078"); 
	strcpy(yytids[2 ],"91092"); 
	strcpy(yytids[3 ],"91093"); 
	strcpy(yytids[4 ],"91098"); 
	strcpy(yytids[5 ],"104669");
	strcpy(yytids[6 ],"104671");
	strcpy(yytids[7 ],"104704");
	strcpy(yytids[8 ],"104716");
	strcpy(yytids[9 ],"104717");
	strcpy(yytids[10],"104744");
	strcpy(yytids[11],"104757");
	strcpy(yytids[12],"107875");
	strcpy(yytids[13],"107875");
	strcpy(yytids[14],"107876");
	strcpy(yytids[15],"107878");
	strcpy(yytids[16],"107879");
	strcpy(yytids[17],"107880");
	strcpy(yytids[18],"107882");
	strcpy(yytids[19],"107889");
	strcpy(yytids[20],"107890");
	strcpy(yytids[21],"107919");
	strcpy(yytids[22],"107924");
	strcpy(yytids[23],"107925");
	strcpy(yytids[24],"110869");
	
	
	strcpy(yytnames[0 ],"中山二路电信营业厅");  
	strcpy(yytnames[1 ],"番禺大石营业厅");      
	strcpy(yytnames[2 ],"番禺东城营业厅");      
	strcpy(yytnames[3 ],"番禺大南营业厅");      
	strcpy(yytnames[4 ],"大学城营业厅");        
	strcpy(yytnames[5 ],"增城荔城电信营业处");  
	strcpy(yytnames[6 ],"增城新塘电信营业处");  
	strcpy(yytnames[7 ],"花都新华营业厅");      
	strcpy(yytnames[8 ],"从化青云路营业厅");    
	strcpy(yytnames[9 ],"从化东成路营业厅");    
	strcpy(yytnames[10],"花都狮岭营业厅");      
	strcpy(yytnames[11],"花都新都营业厅");      
	strcpy(yytnames[12],"江南中营业厅");        
	strcpy(yytnames[13],"江南中营业厅大客户部");
	strcpy(yytnames[14],"昌岗东路电信营业厅");  
	strcpy(yytnames[15],"黄埔电信营业厅");      
	strcpy(yytnames[16],"东圃电信营业厅");      
	strcpy(yytnames[17],"芳村电信营业厅");      
	strcpy(yytnames[18],"人民中电信营业厅");    
	strcpy(yytnames[19],"较场西电信营业厅");    
	strcpy(yytnames[20],"淘金电信营业厅");      
	strcpy(yytnames[21],"天河电信营业厅");      
	strcpy(yytnames[22],"环市西电信营业厅");    
	strcpy(yytnames[23],"同德围营业厅");        
	strcpy(yytnames[24],"沙河电信营业厅");      
	
	//下发显示选择营业厅
	TSMENULIST menuList;
	memset(&menuList,0,sizeof(menuList));
	strcpy(menuList.acTitle, "请选择营业厅");
	
	menuList.iTotalNum = 25;
	for(i=0;i<25;i++){
		strcpy(menuList.menuItem[i], yytnames[i]);
	}
	
	iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
	if(iRet)
		return -1;
	
	bbzero(yytname);
	if(iSelect>0 && iSelect<26)
	{
		strcpy(YYT_termid,yytids[iSelect-1]);
		strcpy(yytname,yytnames[iSelect-1]);
	}
	else
	{
		return CANCLE_KEY;
	}
	
	
	/*放号请求*/
	char testshowstr1[] = "FFFF   payeasy    8888881234567890010001140004                    0006000510016001700001901";
	char testshowstr2[] = "80540005CKQRY";
	bbzero(send_buff);	
	strcpy(send_buff, testshowstr1);
	CTools::itemAppend(YYT_termid, 4, send_buff+strlen(send_buff));
	strcat(send_buff, testshowstr2);
	
	bbzero(rev_buff);
	iRet = con.xltHostSendRecvData(send_buff, strlen(send_buff), rev_buff, 4096, xltIP, xltport);
	
	/*放号回应*/
	if ( iRet==0 )
	{
		if(rev_buff[73] == 0x31)
		{
			memcpy(rev_buff, rev_buff+96, 1446);
			rev_buff[1446]=0;
			bbzero(xltnum);
			int i=0,rev_len=strlen(rev_buff);
			for(i=0,xltcount=0; i<rev_len && xltcount<sizeof(xltnum)/sizeof(char *); i++)
			{
				if(rev_buff[i]=='|')
				{
					rev_buff[i]=0;
					xltnum[xltcount]=&(rev_buff[i+1]);
					xltcount++;
				}
			}
			if(xltcount==0){
				TS_OutPutMsg(gbl.dPosInfo,"  \n\n     没有可用号码！\n   按【确认】返回",0,iSelect);
				return -1;
			}
		}
		else{
			memcpy(lenbuf, rev_buff+71, 4);
			memcpy(rev_buff, rev_buff+74, atoi(lenbuf));//失败原因
			rev_buff[atoi(lenbuf)]=0;
			if(strlen(rev_buff)<150)
			{
				sprintf(msg,"%s\n   按【确认】返回",rev_buff);
				TS_OutPutMsg(gbl.dPosInfo,msg,0,iSelect);
			}else
			{
				TS_OutPutMsg(gbl.dPosInfo,"  \n\n网络不稳定导致超时！\n   按【确认】返回",0,iSelect);
			}
			return -1;
		}
	}else
	{
		TS_OutPutMsg(gbl.dPosInfo,"  \n\n网络不稳定导致超时！\n   按【确认】返回",0,iSelect);
		return -1;
	}
	
	//下发显示选择
	memset(&menuList,0,sizeof(menuList));
	strcpy(menuList.acTitle, "请选择小灵通号码");
	
	menuList.iTotalNum = xltcount>25?25:xltcount;
	for(i=0; i<menuList.iTotalNum; i++)
	{
		strcpy(menuList.menuItem[i], xltnum[i]);
	}
	
	iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
	if(iRet)
		return -1;
	if(iSelect>0 && iSelect<(xltcount>25?25:xltcount))
	{
		bbzero(xltselect);
		strcpy(xltselect, xltnum[iSelect]);
	}
	else
	{
		return CANCLE_KEY;
	}
	
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, "小灵通号码放号");
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入身份证号码");	
	tradeInfoSend.Contents[0].uMinLen = 15;		
	tradeInfoSend.Contents[0].uMaxLen = 18;
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME + 10;	//超时40秒
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		TS_OutPutMsg(gbl.dPosInfo,"\n输入身份证号码出错！\n   按【确认】返回",0,iSelect);
		return iRet;
	}
	memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
	strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
	bbzero(id_card);
	strncpy(id_card, (char *)tradeInfoRecv.Contents[0].uMsg, 18);
	
	//占号请求
	char testpickstr1[] = "FFFF   payeasy    8888881234567890010001490005                    00060005100170017";
	char testpickstr2[] = "0028";
	char testpickstr3[] = "1901";
	char testpickstr4[] = "80540006OCYTEL";
	
	bbzero(send_buff);	
	strcpy(send_buff, testpickstr1);
	CTools::itemAppend(id_card, 4, send_buff+strlen(send_buff));
	strcat(send_buff, testpickstr2);
	CTools::itemAppend(xltselect, 4, send_buff+strlen(send_buff));
	strcat(send_buff, testpickstr3);
	CTools::itemAppend(YYT_termid, 4, send_buff+strlen(send_buff));
	strcat(send_buff, testpickstr4);
	
	bbzero(rev_buff);
	iRet = con.xltHostSendRecvData(send_buff, strlen(send_buff), rev_buff, 4096, xltIP, xltport);
	
	/*占号回应*/
	if ( iRet==0 )
	{
		memcpy(lenbuf, rev_buff+71, 4);
		memcpy(rev_buff, rev_buff+74, atoi(lenbuf));//结果
		rev_buff[atoi(lenbuf)]=0;
		if(strcmp(rev_buff,"占用成功")==0)
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n   业务受理成功！\n 按【确认】打印回执",0,iSelect);			
		}
		else if(atoi(lenbuf)<150)
		{
			sprintf(msg,"%s\n   按【确认】返回",rev_buff);
			TS_OutPutMsg(gbl.dPosInfo,msg,0,iSelect);
			return -1;
		}
		else
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n   占用号码失败！\n   按【确认】返回",0,iSelect);
			return -1;
		}
	}else
	{
		TS_OutPutMsg(gbl.dPosInfo,"\n   网络连接超时！\n   按【确认】返回",0,iSelect);
		return -1;
	}
	
	CPrint prt;
	prt.set_in_par(gbl);
	prt.print_ibss(xltselect,id_card,yytname);
	return 0;
}

int CTrade::sx_ysl(int flag)
{
	int  iRet=0 , iSelect, xflag;
	char temp[1024];
	strcpy(gbl.fee_type, "0238");
	char title[100];
	bbzero(title);
	if (flag == 1)
	{
		strcpy(title,"银行划扣办理");		
	}else if (flag == 2)
	{
		strcpy(title,"已有固话新装ADSL");		
	}else if (flag == 3)
	{
		strcpy(title,"e8套餐申请");		
	}else if (flag == 4)
	{
		strcpy(title,"e8包年升级套餐");		
	}else if (flag == 5)
	{
		strcpy(title,"e6套餐申请");		
	}else
		return -1;
	xflag = 0;
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{
		if(!xflag)
		{
			if( gbl.get_card == MNG_ONE || gbl.get_card == MNG_ONE_BIND || gbl.get_card == MNG_ONE_BIND_E || gbl.get_card == MNG_MUL_BIND_E )//还原原先刷的卡
				iRet = mngCard_Hdl(title, "", 0, 1);//业务需要，一定要刷卡，且只能刷卡
			else
				iRet = mngCard_Hdl(title);
			if(iRet == CANCLE_KEY)
				return CANCLE_KEY;
			else if(iRet != 0)
				return -1;
		}
		bbzero(gbl.phone_no);
		strcpy(gbl.phone_no,"00000000");
		gbl.phone_len = strlen(gbl.phone_no);
		pack.wrField(2, gbl);	//写交费域
		/*----------------------------------*/
		bbzero(pack.FIELD3);
		CTools::hex_to_byte((BYTE *)"310060", pack.FIELD3, 6);
		bbzero(pack.FIELD48);
		memcpy(pack.FIELD48, gbl.fee_type, 4);
		pack.Packet_Table[48].Real_Length = 4;
		/*----------------------------------*/
		//打查询包
		iRet = packHdl(1);
		if(iRet < 0)
			return -1;
		
		if (!memcmp(pack.FIELD39,"00",2)) 
		{
			TSTradeInfoSend tradeInfoSend;
			TSTradeInfoRecv tradeInfoRecv;
			memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
			memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
			
			strcpy(tradeInfoSend.acMainTitle, "小灵通号码放号");
			tradeInfoSend.uHasTradeID = 1;
			tradeInfoSend.uTotalContents = 3;
			
			strcpy(tradeInfoSend.Contents[0].acTitle, "请输入固话号码");	
			tradeInfoSend.Contents[0].uMinLen = 8;		
			tradeInfoSend.Contents[0].uMaxLen = 8;
			tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
			tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME + 10;	//超时40秒
			
			strcpy(tradeInfoSend.Contents[1].acTitle, "请输入身份证号");	
			tradeInfoSend.Contents[1].uMinLen = 15;		
			tradeInfoSend.Contents[1].uMaxLen = 18;
			tradeInfoSend.Contents[1].uCommand = TS_INPUT_ALL_CHAR;	//数字
			tradeInfoSend.Contents[1].uTimeOut = EPOS_OVER_TIME + 10;	//超时40秒
			
			strcpy(tradeInfoSend.Contents[2].acTitle, "请输入手机号码");	
			tradeInfoSend.Contents[2].uMinLen = 11;		
			tradeInfoSend.Contents[2].uMaxLen = 11;
			tradeInfoSend.Contents[2].uCommand = TS_INPUT_MATH;	//数字
			tradeInfoSend.Contents[2].uTimeOut = EPOS_OVER_TIME + 10;	//超时40秒
			
			iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
			if(iRet != 0)
			{
				wrLog("TS_TradeControl返回错误[%d]", iRet);
				wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
				TS_OutPutMsg(gbl.dPosInfo,"  \n输入身份证号码出错！\n   按【确认】返回",0,iSelect);
				return iRet;
			}
			memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
			strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
			bbzero(gbl.phone_no);
			bbzero(gbl.id_num);
			bbzero(gbl.telphone);
			strncpy(gbl.phone_no, (char *)tradeInfoRecv.Contents[0].uMsg, 8);
			strncpy(gbl.id_num, (char *)tradeInfoRecv.Contents[1].uMsg,tradeInfoRecv.Contents[1].uMsgLen);
			strncpy(gbl.telphone, (char *)tradeInfoRecv.Contents[2].uMsg, 11);
			bbzero(temp);
			sprintf(temp,"电话号码:%s\n身份证号:%s\n手机号码:%s\n请按【确认】继续",gbl.phone_no,gbl.id_num,gbl.telphone);
			TS_OutPutMsg(gbl.dPosInfo,temp,0,iSelect);
			if (iSelect == 0)
			{
				Sleep(1000*3);
				TS_OutPutMsg(gbl.dPosInfo, "\n      网络繁忙\n   按【确认】返回", 0,iSelect);
				return -1;
				/*bbzero(temp);
				sprintf(temp,"\n    业务受理成功\n请按【确认】打印回执");
				TS_OutPutMsg(gbl.dPosInfo,temp,0,iSelect);
				if (iSelect == 0)
				{
				CPrint prt;
				prt.set_in_par(gbl, pack);
				prt.print_sx_ysl(flag);
				return 0;
				}else
				return -1;*/
			}else
				return -1;
		}
		else if(!memcmp(pack.FIELD39,"55",2) || !memcmp(pack.FIELD62, "P20004855", 9))
		{
			xflag = 1;
			if(reGetPwd(title) == 0) //密码错误，重新输入密码
				continue;
			else
				return CANCLE_KEY;
		}
		else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
			if (iSelect!=0)
			{
				return -1;
			}else
				continue;
		}
		else
		{
			iRet = banReturnFail((char *)pack.FIELD39);
			return -1;
		}
	}
	return -1;
}

//bizid:业务ID：2815-小灵通 1264-小灵通预付费 14007-CDMA 14017-预付费CDMA
//
int CTrade::telIBSS(const char *title, char *ctrl3, char *biztid5)//IB接口
{
	char teltype2[100];
	char telno4[100];
	
	char xltIP[16+1],YYT_termid[6+1],send_buff[4096],rev_buff[4096],lenbuf[4+1],tempPW[8+1];//密码
	int xltport=0, iRet=0, iSelect=0, xltcount=0;
	TSMENULIST menuList;
	
	
	
	CConnect con;
	strcpy(YYT_termid,"107924");
	if(TRADE_FLAG)
	{
		strcpy(xltIP,"132.97.9.151");
		xltport = 30000;		
	}
	else
	{
		// 		strcpy(xltIP,"132.97.10.55");
		// 		xltport = 40000;
		strcpy(xltIP,"132.97.9.151");
		xltport = 30000;
	}
	
	//请选择号码类型	
	memset(&menuList,0,sizeof(menuList));
	strcpy(menuList.acTitle, "请选择号码类型");
	
	menuList.iTotalNum = 4;
	strcpy(menuList.menuItem[0], "后付费小灵通");
	strcpy(menuList.menuItem[1], "预付费小灵通");
	strcpy(menuList.menuItem[2], "后付费CDMA");
	strcpy(menuList.menuItem[3], "预付费CDMA");
	
	iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
	if(iRet)
		return -1;
	
	bbzero(teltype2);
	if( iSelect>0 && iSelect<5 )
	{
		switch(iSelect)
		{
		case 1:
			strcpy(teltype2,"2815");
			break;
		case 2:
			strcpy(teltype2,"1264");
			break;
		case 3:
			strcpy(teltype2,"14007");
			break;
		case 4:
			strcpy(teltype2,"14017");
			break;
		}
	}
	else
	{
		return CANCLE_KEY;
	}
	
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	
	memset(&tradeInfoSend,0,sizeof(tradeInfoSend));
	memset(&tradeInfoRecv,0,sizeof(tradeInfoRecv));
	
	tradeInfoSend.uHasTradeID=1;
	tradeInfoSend.uTotalContents=2;
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入号码：");	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//全字符
	tradeInfoSend.Contents[0].uCount = 0;		//输入1次
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
	tradeInfoSend.Contents[0].uMinLen = 8;		
	tradeInfoSend.Contents[0].uMaxLen = 11;
	
	strcpy(tradeInfoSend.Contents[1].acTitle, "请输入客户密码：");	
	tradeInfoSend.Contents[1].uCount = 0;		//输入1次
	tradeInfoSend.Contents[1].uTimeOut = EPOS_OVER_TIME;	//超时30秒
	tradeInfoSend.Contents[1].uMinLen = 6;		
	tradeInfoSend.Contents[1].uMaxLen = 6;
	tradeInfoSend.Contents[1].uCommand = TS_INPUT_PWD;	//密码(明文)
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		TS_OutPutMsg(gbl.dPosInfo,"  \n输入电话号码出错！\n   按【确认】返回",0,iSelect);
		return iRet;
	}
	memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
	strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
	bbzero(telno4);	
	strncpy(telno4, (char *)tradeInfoRecv.Contents[0].uMsg, sizeof(telno4)-1);
	bbzero(tempPW);
	strncpy(tempPW, (char *)tradeInfoRecv.Contents[1].uMsg, sizeof(tempPW)-1);
	
	
	char *cont_idx;
	//修改密码请求
	char pwdIB1[] = "FFFF rsduanxin    888888000000000201";
	char pwdIB2[] =	"0012                    00060005101038056000411980028";
	char pwdIB3[] = "8131000120063000211006400015006500022100220000002300000075";
	char pwdIB4[] = "0076";
	char pwdIB5[] = "007800011";
	
	bbzero(send_buff);	
	strcpy(send_buff, pwdIB1);
	cont_idx=send_buff+strlen(pwdIB1)+6;
	strcpy(cont_idx, pwdIB2);
	CTools::itemAppend(telno4, 4, cont_idx+strlen(cont_idx));
	strcat(cont_idx, pwdIB3);
	CTools::itemAppend(tempPW, 4, cont_idx+strlen(cont_idx));
	strcat(cont_idx, pwdIB4);
	CTools::itemAppend(tempPW, 4, cont_idx+strlen(cont_idx));
	strcat(cont_idx, pwdIB5);
	
	//长度
	sprintf(lenbuf,"%06d", strlen(cont_idx)+(cont_idx-send_buff));
	memcpy(send_buff+strlen(pwdIB1),lenbuf,6);
	
	bbzero(rev_buff);
	wrLog("修改密码请求[%s]",send_buff);
	iRet = con.xltHostSendRecvData(send_buff, strlen(send_buff), rev_buff, 4096, xltIP, xltport);
	wrLog("修改密码回应[%s]",rev_buff);
	//回应
	if ( memcmp(rev_buff+strlen(rev_buff)-2, "OK", 2) )
	{
		TS_OutPutMsg(gbl.dPosInfo,"  电信密码错误！\n   按【确认】返回",0,iSelect);
		return -1;
	}
	
	//开通或撤销等业务处理请求
	char telIB1[] = "FFFF rsduanxin    888888000000000201";
	char telIB2[] = "0014                    000600051005280910000809200008056";
	char telIB3[] = "8064";
	char telIB4[] = "19010002111903000320080130002990028";
	char telIB5[] = "19020009rsduanxin806500008063";
	char telIB6[] = "850000011850100010";
	
	bbzero(send_buff);	
	strcpy(send_buff, telIB1);
	cont_idx=send_buff+strlen(telIB1)+6;
	strcpy(cont_idx, telIB2);
	CTools::itemAppend(teltype2, 4, cont_idx+strlen(cont_idx));
	strcat(cont_idx, telIB3);
	CTools::itemAppend(ctrl3, 4, cont_idx+strlen(cont_idx));
	strcat(cont_idx, telIB4);
	CTools::itemAppend(telno4, 4, cont_idx+strlen(cont_idx));
	strcat(cont_idx, telIB5);
	CTools::itemAppend(biztid5, 4, cont_idx+strlen(cont_idx));
	strcat(cont_idx, telIB6);
	
	//长度
	sprintf(lenbuf,"%06d", strlen(cont_idx)+(cont_idx-send_buff));
	memcpy(send_buff+strlen(telIB1),lenbuf,6);
	
	bbzero(rev_buff);
	wrLog("业务处理请求[%s]",send_buff);
	iRet = con.xltHostSendRecvData(send_buff, strlen(send_buff), rev_buff, 4096, xltIP, xltport);
	wrLog("业务处理回应[%s]",rev_buff);
	
	Sleep(1000*3);
	TS_OutPutMsg(gbl.dPosInfo, "\n      网络繁忙\n   按【确认】返回", 0,iSelect);
	return -1;
	/*char cont[50][2][50];	
	bbzero(send_buff);
	memcpy(send_buff, rev_buff+, 4);
	bbzero(cont);
	CTools::decIBcont(atoi(),)
	//回应
	if ( memcmp(rev_buff+strlen(rev_buff)-2, "OK", 2) )
	{
	sprintf(msg,"%s\n   按【确认】返回",rev_buff);
	TS_OutPutMsg(gbl.dPosInfo,msg,0,iSelect);
	}else
	{
	TS_OutPutMsg(gbl.dPosInfo,"  \n 开通语音信箱成功！\n   按【确认】返回",0,iSelect);
	return -1;
	}
	return 0;*/
}

int CTrade::selectcdma()
{
	char tell_phone[11+1];
	char YYT_termid[6+1],yytname[30+1];
	int iRet,iSelect,j,i;
	TSMENULIST menuList;
	int  xflag;
	char title[50];
	int curTry;
	
	
	char yytids[25][6+1];
	char yytnames[25][30+1];
	strcpy(yytids[0 ],"107920");
	strcpy(yytids[1 ],"91078"); 
	strcpy(yytids[2 ],"91092"); 
	strcpy(yytids[3 ],"91093"); 
	strcpy(yytids[4 ],"91098"); 
	strcpy(yytids[5 ],"104669");
	strcpy(yytids[6 ],"104671");
	strcpy(yytids[7 ],"104704");
	strcpy(yytids[8 ],"104716");
	strcpy(yytids[9 ],"104717");
	strcpy(yytids[10],"104744");
	strcpy(yytids[11],"104757");
	strcpy(yytids[12],"107875");
	strcpy(yytids[13],"107875");
	strcpy(yytids[14],"107876");
	strcpy(yytids[15],"107878");
	strcpy(yytids[16],"107879");
	strcpy(yytids[17],"107880");
	strcpy(yytids[18],"107882");
	strcpy(yytids[19],"107889");
	strcpy(yytids[20],"107890");
	strcpy(yytids[21],"107919");
	strcpy(yytids[22],"107924");
	strcpy(yytids[23],"107925");
	strcpy(yytids[24],"110869");
	
	
	strcpy(yytnames[0 ],"中山二路电信营业厅");  
	strcpy(yytnames[1 ],"番禺大石营业厅");      
	strcpy(yytnames[2 ],"番禺东城营业厅");      
	strcpy(yytnames[3 ],"番禺大南营业厅");      
	strcpy(yytnames[4 ],"大学城营业厅");        
	strcpy(yytnames[5 ],"增城荔城电信营业处");  
	strcpy(yytnames[6 ],"增城新塘电信营业处");  
	strcpy(yytnames[7 ],"花都新华营业厅");      
	strcpy(yytnames[8 ],"从化青云路营业厅");    
	strcpy(yytnames[9 ],"从化东成路营业厅");    
	strcpy(yytnames[10],"花都狮岭营业厅");      
	strcpy(yytnames[11],"花都新都营业厅");      
	strcpy(yytnames[12],"江南中营业厅");        
	strcpy(yytnames[13],"江南中营业厅大客户部");
	strcpy(yytnames[14],"昌岗东路电信营业厅");  
	strcpy(yytnames[15],"黄埔电信营业厅");      
	strcpy(yytnames[16],"东圃电信营业厅");      
	strcpy(yytnames[17],"芳村电信营业厅");      
	strcpy(yytnames[18],"人民中电信营业厅");    
	strcpy(yytnames[19],"较场西电信营业厅");    
	strcpy(yytnames[20],"淘金电信营业厅");      
	strcpy(yytnames[21],"天河电信营业厅");      
	strcpy(yytnames[22],"环市西电信营业厅");    
	strcpy(yytnames[23],"同德围营业厅");        
	strcpy(yytnames[24],"沙河电信营业厅");      
	
	//下发显示选择营业厅
	memset(&menuList,0,sizeof(menuList));
	strcpy(menuList.acTitle, "请选择营业厅");
	
	menuList.iTotalNum = 25;
	for(i=0;i<25;i++){
		strcpy(menuList.menuItem[i], yytnames[i]);
	}
	
	iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
	if(iRet)
		return -1;
	
	bbzero(yytname);
	if(iSelect>0 && iSelect<26)
	{
		strcpy(YYT_termid,yytids[iSelect-1]);
		strcpy(yytname,yytnames[iSelect-1]);
	}
	else
	{
		return CANCLE_KEY;
	}
	
	bbzero(tell_phone);
	memset(&menuList,0,sizeof(menuList));
	menuList.iTotalNum=12;
	
	strcpy(menuList.acTitle, "请选择号码");
	for(j=0; j<menuList.iTotalNum; j++)
	{
		memset(menuList.menuItem[j], 0, sizeof(menuList.menuItem[j]));
	}
	strcpy(menuList.menuItem[0], "18995617001");
	strcpy(menuList.menuItem[1], "18995617002");
	strcpy(menuList.menuItem[2], "18995617003");
	strcpy(menuList.menuItem[3], "18995617004");
	strcpy(menuList.menuItem[4], "18995617005");
	strcpy(menuList.menuItem[5], "18995617006");
	strcpy(menuList.menuItem[6], "18995617007");
	strcpy(menuList.menuItem[7], "18995617008");
	strcpy(menuList.menuItem[8], "18995617009");
	strcpy(menuList.menuItem[9], "18995617010");
	strcpy(menuList.menuItem[10], "18995617011");
	strcpy(menuList.menuItem[11], "18995617012");
	
	iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
	if(iRet)
		return -1;
	switch(iSelect)
	{
	case 1:
		strcpy(tell_phone,"18995617001");
		break;
	case 2:
		strcpy(tell_phone,"18995617002");
		break;
	case 3:
		strcpy(tell_phone,"18995617003");
		break;
	case 4:
		strcpy(tell_phone,"18995617004");
		break;
	case 5:
		strcpy(tell_phone,"18995617005");
		break;
	case 6:
		strcpy(tell_phone,"18995617006");
		break;
	case 7:
		strcpy(tell_phone,"18995617007");
		break;
	case 8:
		strcpy(tell_phone,"18995617008");
		break;
	case 9:
		strcpy(tell_phone,"18995617009");
		break;
	case 10:
		strcpy(tell_phone,"18995617010");
		break;
	case 11:
		strcpy(tell_phone,"18995617011");
		break;
	case 12:
		strcpy(tell_phone,"18995617012");
		break;
	default: 
		return -1;
	}
	
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	
	memset(&tradeInfoSend,0,sizeof(tradeInfoSend));
	memset(&tradeInfoRecv,0,sizeof(tradeInfoRecv));
	
	tradeInfoSend.uHasTradeID=1;
	tradeInfoSend.uTotalContents=1;
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入身份证号码：");	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//全字符
	tradeInfoSend.Contents[0].uCount = 0;		//输入1次
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
	tradeInfoSend.Contents[0].uMinLen = 16;		
	tradeInfoSend.Contents[0].uMaxLen = 18;
	
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		TS_OutPutMsg(gbl.dPosInfo,"  \n输入电话号码出错！\n请稍候再试!\n   按【确认】返回",0,iSelect);
		return iRet;
	}
	memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
	strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
	bbzero(gbl.id_num);
	bbzero(gbl.telphone);
	strncpy(gbl.id_num, (char *)tradeInfoRecv.Contents[0].uMsg, tradeInfoRecv.Contents[0].uMsgLen);
	strcpy(gbl.telphone,tell_phone);
	char tmp[256];
	bbzero(tmp);
	sprintf(tmp,"所选号码：%s\n选号费：50.00元\n所选营业厅：\n%s\n输入的身份证号：\n%s\n    按【确认】继续",gbl.telphone,yytname,gbl.id_num);
	TS_OutPutMsg(gbl.dPosInfo,tmp,0,iSelect);
	if (iSelect != 0)
	{
		return -2;
	}
	memset(&menuList,0,sizeof(menuList));
	menuList.iTotalNum = 2;
	strcpy(menuList.acTitle, "是否进行选号费的支付");
	for(j=0; j<menuList.iTotalNum; j++)
	{
		memset(menuList.menuItem[j], 0, sizeof(menuList.menuItem[j]));
	}
	strcpy(menuList.menuItem[0], "是");
	strcpy(menuList.menuItem[1], "否");
	
	iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
	if(iRet)
		return -1;
	switch(iSelect)
	{
	case 1:
		strcpy(gbl.fee_type, "0238");
		xflag = 0;
		bbzero(title);
		strcpy(title,"C网选号");
		for(curTry=0; curTry<MAXTRY; curTry++)
		{
			if(!xflag)
			{
				if( gbl.get_card == MNG_ONE || gbl.get_card == MNG_ONE_BIND || gbl.get_card == MNG_ONE_BIND_E || gbl.get_card == MNG_MUL_BIND_E )//还原原先刷的卡
					iRet = mngCard_Hdl(title, "", 0, 1);//业务需要，一定要刷卡，且只能刷卡
				else
					iRet = mngCard_Hdl(title);
				if(iRet == CANCLE_KEY)
					return CANCLE_KEY;
				else if(iRet != 0)
					return -1;
			}
			bbzero(gbl.phone_no);
			strcpy(gbl.phone_no,"00000000");
			gbl.phone_len = strlen(gbl.phone_no);
			pack.wrField(2, gbl);	//写交费域
			/*----------------------------------*/
			bbzero(pack.FIELD3);
			CTools::hex_to_byte((BYTE *)"310060", pack.FIELD3, 6);
			bbzero(pack.FIELD48);
			memcpy(pack.FIELD48, gbl.fee_type, 4);
			pack.Packet_Table[48].Real_Length = 4;
			/*----------------------------------*/
			//打查询包
			iRet = packHdl(1);
			if(iRet < 0)
				return -1;
			bbzero(pack.FIELD39);
			memcpy(pack.FIELD39,"00",2);
			
			if (!memcmp(pack.FIELD39,"00",2)) 
			{
				iRet = TS_OutPutMsg(gbl.dPosInfo,"\n     选号成功!\n请按【确认】打印回执",0,iSelect);
				if (iRet!=0 || iSelect == 0)
				{
					CPrint prt;
					prt.set_in_par(gbl);
					prt.print_selectcdma(1,yytname);
					return 0;
				}
				return -1;
			}
			else 
				if(!memcmp(pack.FIELD39,"55",2) || !memcmp(pack.FIELD62, "P20004855", 9))
				{
					xflag = 1;
					if(reGetPwd(title) == 0) //密码错误，重新输入密码
						continue;
					else
						return CANCLE_KEY;
				}
				else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
				{
					TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
					if (iSelect!=0)
					{
						return -1;
						
					}else
						
						continue;
				}
				else
				{
					TS_OutPutMsg(gbl.dPosInfo,"\n   网络连接超时！\n请稍候再试!\n 如果交易结果不明确请做 最后一笔交易查询\n   按【确认】返回",0,iSelect);
					return -1;
				}
		}
		return -1;
	case 2:
		TS_OutPutMsg(gbl.dPosInfo,"\n\n   预约选号完成！\n请按【确认】打印回执",0,iSelect);
		if (iSelect == 0)
		{
			CPrint prt;
			prt.set_in_par(gbl);
			prt.print_selectcdma(2,yytname);
			return 0;
		}
		return -1;
	default: 
		return -1;
	}
}

//终端销售 sflag 1:终端 2:发票及凭条 3:288礼包 4:CDMA选号 5:海报套装 6:标准招牌 8:打印机 9:色带及色带芯
//gbl.product_flag 1:终端 21:发票 22:凭条 3:288礼包 4:CDMA选号  5:海报套装 6:标准招牌 7:服务  81:发票打印机 82:凭条打印机 91:色带 92:色带芯
int CTrade::sell_pos(int sflag)
{
	int iRet = 0, iSelect,flag = 0, count=0;
	char tmp[512];
	char product_type[10+1];
	char sell_count[4+1];
	char title[30],per_price[12+1];
	char mny[20];
	int b48_len=0,b63_len=0;
	
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	bbzero(product_type);
	bbzero(gbl.fee_type);
	bbzero(sell_count);
	bbzero(gbl.stan_no);
	bbzero(title);
	strcpy(gbl.stan_no,"000000000000");
	strcpy(gbl.fee_type, "0248");
	if (sflag == 1)
	{
		strcpy(title,"终端采购");
		gbl.product_flag = 1;
		
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
		
		strcpy(tradeInfoSend.acMainTitle, title);
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents = 2;
		
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入设备单价");	
		tradeInfoSend.Contents[0].uMinLen = 1;		
		tradeInfoSend.Contents[0].uMaxLen = 8;
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_MONEY;	//数字
		tradeInfoSend.Contents[0].uCount = 0;		//输入1次		
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
		
		strcpy(tradeInfoSend.Contents[1].acTitle, "请输入购买数量");	
		tradeInfoSend.Contents[1].uMinLen = 1;		
		tradeInfoSend.Contents[1].uMaxLen = 4;
		tradeInfoSend.Contents[1].uCommand = TS_INPUT_MATH;	//数字
		tradeInfoSend.Contents[1].uCount = 0;		//输入1次		
		tradeInfoSend.Contents[1].uTimeOut = EPOS_OVER_TIME;	//超时30秒
		
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		
		if(iRet != 0)
		{
			wrLog("TS_TradeControl返回错误[%d]", iRet);
			return iRet;
		}
		memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
		bbzero(gbl.product_perprice);
		bbzero(per_price);
		strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
		memcpy( per_price, (char *)tradeInfoRecv.Contents[0].uMsg, tradeInfoRecv.Contents[0].uMsgLen);
		memcpy( sell_count, (char *)tradeInfoRecv.Contents[1].uMsg, tradeInfoRecv.Contents[0].uMsgLen);
		sprintf(gbl.product_perprice,"%12d",per_price);
		count = atoi(sell_count);
		
		bbzero(gbl.amount);
		sprintf(gbl.amount,"%12d",atoi(per_price)*count);
		strcpy(product_type,"SB00000002");
	}else if (sflag == 2)
	{   
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
		strcpy(title,"订购发票及凭条");
		iRet = selectAmount(2);
		if(iRet == CANCLE_KEY)
			return CANCLE_KEY;
		else if(iRet < 0)
			return -1;
		
		wrLog("%d", gbl.term_level);
		if (iRet == 1)
		{   
			if(gbl.term_level >= 3){
				gbl.product_flag = 23;
				strcpy(product_type,"WL00000006");
				//strcpy(tradeInfoSend.Contents[0].acTitle, "请输入申请发票套数(含两卷共1000张)");
			}else{
				gbl.product_flag = 21;
				strcpy(product_type,"WL00000003");
				strcpy(tradeInfoSend.Contents[0].acTitle, "请输入订购发票套数(100元/套,含2卷共1000张,包邮费)");
			}
		}else if (iRet == 2)
		{
			if(gbl.term_level >= 3 ){
				gbl.product_flag = 24;
				strcpy(product_type,"WL00000007");
				//strcpy(tradeInfoSend.Contents[0].acTitle, "请输入申请凭条套数(10卷/套)");
			}else{
				gbl.product_flag = 22;
				strcpy(product_type,"WL00000002");
				strcpy(tradeInfoSend.Contents[0].acTitle, "请输入订购凭条套数(50元/套,含10卷,包邮费)");
			}
		}else
			return -1;
		
		if(gbl.term_level < 3)
		{
			strcpy(tradeInfoSend.acMainTitle, title);
			tradeInfoSend.uHasTradeID = 1;
			tradeInfoSend.uTotalContents = 1;	
			tradeInfoSend.Contents[0].uMinLen = 1;		
			tradeInfoSend.Contents[0].uMaxLen = 4;
			tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
			tradeInfoSend.Contents[0].uCount = 0;		//输入1次		
			tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
			
			iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
			
			if(iRet != 0)
			{
				wrLog("TS_TradeControl返回错误[%d]", iRet);
				return iRet;
			}
			memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
			strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
			memcpy( sell_count, (char *)tradeInfoRecv.Contents[0].uMsg, tradeInfoRecv.Contents[0].uMsgLen);
			count = atoi(sell_count);
		}
		bbzero(gbl.amount);
		if(gbl.product_flag==21)
			sprintf(gbl.amount,"%10d00",100*count);
		else if(gbl.product_flag==22)
			sprintf(gbl.amount,"%10d00",50*count);
		else if(gbl.product_flag == 23||gbl.product_flag == 24){
			strcpy(gbl.amount,"000000000000");
		}
		
		//==============================================================================================
	}else if (sflag == 3)
	{
		strcpy(title,"288礼包");
		gbl.product_flag = 3;
		
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
		
		strcpy(tradeInfoSend.acMainTitle, title);
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents = 1;
		
		strcpy(tradeInfoSend.Contents[0].acTitle, "礼包单价288元/份,请输入购买数量");	
		tradeInfoSend.Contents[0].uMinLen = 1;		
		tradeInfoSend.Contents[0].uMaxLen = 4;
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
		tradeInfoSend.Contents[0].uCount = 0;		//输入1次		
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
		
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		
		if(iRet != 0)
		{
			wrLog("TS_TradeControl返回错误[%d]", iRet);
			return iRet;
		}
		memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
		strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
		memcpy( sell_count, (char *)tradeInfoRecv.Contents[0].uMsg, tradeInfoRecv.Contents[0].uMsgLen);
		
		count = atoi(sell_count);
		
		bbzero(gbl.amount);
		sprintf(gbl.amount,"%10d00",288*count);
		strcpy(product_type,"LB00000001");
	}else if (sflag == 9)
	{   
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
		strcpy(title,"订购色带");
		gbl.product_flag = 9;
		strcpy(product_type,"WL00000005");
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入数量(100元/个,含色带架,包邮费)");
		
		strcpy(tradeInfoSend.acMainTitle, title);
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents = 1;	
		tradeInfoSend.Contents[0].uMinLen = 1;		
		tradeInfoSend.Contents[0].uMaxLen = 4;
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
		tradeInfoSend.Contents[0].uCount = 0;		//输入1次		
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
		
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		
		if(iRet != 0)
		{
			wrLog("TS_TradeControl返回错误[%d]", iRet);
			return iRet;
		}
		memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
		strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
		memcpy( sell_count, (char *)tradeInfoRecv.Contents[0].uMsg, tradeInfoRecv.Contents[0].uMsgLen);
		
		count = atoi(sell_count);
		bbzero(gbl.amount);
		sprintf(gbl.amount,"%10d00",100*count);
	}else if (sflag == 5)
	{   
		strcpy(title,"订购交费易宣传套装");
		gbl.product_flag = 5;
		
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
		
		strcpy(tradeInfoSend.acMainTitle, title);
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents = 1;
		
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入数量(50元/套,包邮费)");	
		tradeInfoSend.Contents[0].uMinLen = 1;		
		tradeInfoSend.Contents[0].uMaxLen = 4;
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
		tradeInfoSend.Contents[0].uCount = 0;		//输入1次		
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
		
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		
		if(iRet != 0)
		{
			wrLog("TS_TradeControl返回错误[%d]", iRet);
			return iRet;
		}
		memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
		strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
		memcpy( sell_count, (char *)tradeInfoRecv.Contents[0].uMsg, tradeInfoRecv.Contents[0].uMsgLen);
		
		count = atoi(sell_count);
		
		bbzero(gbl.amount);
		sprintf(gbl.amount,"%10d00",50*count);
		strcpy(product_type,"WL00000008");
	}else if (sflag == 6)
	{
		strcpy(title,"订购交费易标准招牌");
		gbl.product_flag = 6;
		
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
		
		strcpy(tradeInfoSend.acMainTitle, title);
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents = 1;
		
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入数量(1000元/块,面积3平方米以内,包邮费)");	
		tradeInfoSend.Contents[0].uMinLen = 1;		
		tradeInfoSend.Contents[0].uMaxLen = 4;
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
		tradeInfoSend.Contents[0].uCount = 0;		//输入1次		
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
		
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		
		if(iRet != 0)
		{
			wrLog("TS_TradeControl返回错误[%d]", iRet);
			return iRet;
		}
		memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
		strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
		memcpy( sell_count, (char *)tradeInfoRecv.Contents[0].uMsg, tradeInfoRecv.Contents[0].uMsgLen);
		
		count = atoi(sell_count);
		
		bbzero(gbl.amount);
		sprintf(gbl.amount,"%10d00",1000*count);
		strcpy(product_type,"WL00000009");
	}else if (sflag == 7)
	{   
		strcpy(title,"维护服务");
		if (gbl.term_level >= 3 )
		{   
			gbl.product_flag = 71;
			strcpy(gbl.amount,"000000000000");
			strcpy(product_type,"FW00000002");
		}else
		{
			gbl.product_flag = 72;
			strcpy(gbl.amount,"000000002000");
			strcpy(product_type,"FW00000001");
		}
		int cnt=0;
		iRet=CDB::countSaleTxn(gbl.pos_no,product_type,&cnt);
		if(iRet < 0){
            TS_OutPutMsg(gbl.dPosInfo,"数据库操作失败",0,iSelect);
			return -1;
		}else{
			if(cnt>0){
				TS_OutPutMsg(gbl.dPosInfo,"温馨提示：您的申请已受理，请耐心等候。按【确认】返回",0,iSelect);
				return CANCLE_KEY;
			}
		}
		count=1;
		
	}else if (sflag == 8)
	{   
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
		strcpy(title,"订购打印机");
		iRet = selectAmount(8);
		if(iRet == CANCLE_KEY)
			return CANCLE_KEY;
		else if(iRet < 0)
			return -1;
		if (iRet == 1)
		{   
			gbl.product_flag = 81;
			strcpy(product_type,"SB00000003");
			strcpy(tradeInfoSend.Contents[0].acTitle, "请输入订购发票打印机数量(1500元/台)");
		}else if (iRet == 2)
		{
            gbl.product_flag = 82;
			strcpy(product_type,"SB00000004");
			strcpy(tradeInfoSend.Contents[0].acTitle, "请输入订购凭条打印机数量(500元/台)");
		}else
			return -1;
		
		strcpy(tradeInfoSend.acMainTitle, title);
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents = 1;	
		tradeInfoSend.Contents[0].uMinLen = 1;		
		tradeInfoSend.Contents[0].uMaxLen = 4;
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
		tradeInfoSend.Contents[0].uCount = 0;		//输入1次		
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
		
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		
		if(iRet != 0)
		{
			wrLog("TS_TradeControl返回错误[%d]", iRet);
			return iRet;
		}
		memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
		strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
		memcpy( sell_count, (char *)tradeInfoRecv.Contents[0].uMsg, tradeInfoRecv.Contents[0].uMsgLen);
		
		count = atoi(sell_count);
		bbzero(gbl.amount);
		if(gbl.product_flag == 81)
			sprintf(gbl.amount,"%10d00",1500*count);
		else if(gbl.product_flag == 82)
			sprintf(gbl.amount,"%10d00",500*count);
	}
	else
		return -1;
	bbzero(sell_count);
	sprintf(sell_count,"%04d",count);
	strcpy(gbl.product_num,sell_count);
    
	bbzero(tmp);
	bbzero(mny);
	CTools::chgToMny(gbl.amount,mny);
	if (gbl.product_flag == 1)
	{
		strcpy(gbl.product_name,"交费易E830");
		sprintf(tmp,"产品：交费易E830\n数量：%d台\n金额：%s\n      按【确认】继续",count,mny,gbl.telphone);
		TS_OutPutMsg(gbl.dPosInfo,tmp,0,iSelect);
	}else if (gbl.product_flag == 21){
		strcpy(gbl.product_name,"发票");
		sprintf(tmp,"您订购的发票数量：%d套\n合计金额：%s\n     按【确认】继续",count,mny,gbl.telphone);
		TS_OutPutMsg(gbl.dPosInfo,tmp,0,iSelect);
	}else if (gbl.product_flag == 22){
		strcpy(gbl.product_name,"凭条");
		sprintf(tmp,"您订购的凭条数量：%d套\n合计金额：%s\n      按【确认】继续",count,mny);
		TS_OutPutMsg(gbl.dPosInfo,tmp,0,iSelect);
	}else if (gbl.product_flag == 23){
		strcpy(gbl.product_name,"发票");
		sprintf(tmp,"您申请的是交费易标准发票。\n系统会根据您的交易量自动匹配数量。\n    【确认】继续    【返回】取消",count,gbl.telphone);
		TS_OutPutMsg(gbl.dPosInfo,tmp,0,iSelect);
	}else if (gbl.product_flag == 24){
		strcpy(gbl.product_name,"凭条");
		sprintf(tmp,"您申请的是交费易标准凭条。\n系统会根据您的交易量自动匹配数量。\n    【确认】继续    【返回】取消",count,gbl.telphone);
		TS_OutPutMsg(gbl.dPosInfo,tmp,0,iSelect);
	}else if (gbl.product_flag == 3){
		strcpy(gbl.product_name,"288礼包");
		sprintf(tmp,"产品：288礼包\n数量：%d份\n金额：%s\n      按【确认】继续",count,mny);
		TS_OutPutMsg(gbl.dPosInfo,tmp,0,iSelect);
	}else if (gbl.product_flag == 9){
		strcpy(gbl.product_name,"色带");
		sprintf(tmp,"您订购的色带数量：%d个\n合计金额：%s\n      按【确认】继续",count,mny);
		TS_OutPutMsg(gbl.dPosInfo,tmp,0,iSelect);
	}else if (gbl.product_flag == 5){
		strcpy(gbl.product_name,"交费易宣传套装");
		sprintf(tmp,"您订购的数量为：%d套\n合计金额：%s\n      按【确认】继续",count,mny);
		TS_OutPutMsg(gbl.dPosInfo,tmp,0,iSelect);
	}else if (gbl.product_flag == 6){
		strcpy(gbl.product_name,"交费易标准招牌");
		sprintf(tmp,"您订购的招牌数量：%d块\n合计金额：%s\n      按【确认】继续",count,mny);
		TS_OutPutMsg(gbl.dPosInfo,tmp,0,iSelect);
	}else if (gbl.product_flag == 72){
		strcpy(gbl.product_name,"维护服务");
		sprintf(tmp,"您选择的现场维护服务,20元/次,三个工作日内处理\n      按【确认】继续");
		TS_OutPutMsg(gbl.dPosInfo,tmp,0,iSelect);
	}else if (gbl.product_flag == 71){
		strcpy(gbl.product_name,"维护服务");
		sprintf(tmp,"您申请的现场维护服务将在三个工作日内处理\n      按【确认】继续");
		TS_OutPutMsg(gbl.dPosInfo,tmp,0,iSelect);
	}else if (gbl.product_flag == 81){
		strcpy(gbl.product_name,"发票打印机");
		sprintf(tmp,"您订购的发票打印机数量：%d台\n合计金额：%s\n      按【确认】继续",count,mny);
		TS_OutPutMsg(gbl.dPosInfo,tmp,0,iSelect);
	}else if (gbl.product_flag == 82){
		strcpy(gbl.product_name,"凭条打印机");
		sprintf(tmp,"您订购的凭条打印机数量：%d台\n合计金额：%s\n      按【确认】继续",count,mny);
		TS_OutPutMsg(gbl.dPosInfo,tmp,0,iSelect);
	}else
		return -1;
	
	if (iSelect != 0)
	{
		return -1;
	}
	
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, title);
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入联系手机号");	
	tradeInfoSend.Contents[0].uMinLen = 11;		
	tradeInfoSend.Contents[0].uMaxLen = 11;
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
	tradeInfoSend.Contents[0].uCount = 1;		//输入1次		
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		return iRet;
	}
	memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
	strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
	bbzero(gbl.telphone);
	memcpy(gbl.telphone, (char *)tradeInfoRecv.Contents[0].uMsg, tradeInfoRecv.Contents[0].uMsgLen);
	
	
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{
		if(!flag) 
		{
			iRet = mngCard_Hdl(title);
			if(iRet == CANCLE_KEY)
				return CANCLE_KEY;
			else if(iRet != 0)
				return -1;     
		}
		
		pack.wrField(2, gbl);	//写交费域
		//如果交易金额为0，不走银行
		if(atoi(gbl.amount) == 0)
		{
			pack.FIELD46[1] = 0x35;
		}
		bbzero(pack.FIELD48);
		b48_len = 0;
		memcpy(pack.FIELD48,gbl.fee_type,4);
		b48_len += 4;
		memcpy(pack.FIELD48+b48_len,"10",2);
		b48_len += 2;
		memcpy(pack.FIELD48+b48_len,product_type,10);
		b48_len += 10;
		pack.Packet_Table[48].Real_Length = b48_len;
		
		bbzero(pack.FIELD63);
		b63_len += 8;
		memcpy(pack.FIELD63+b63_len,sell_count,4);
		b63_len += 4;
		memcpy(pack.FIELD63+b63_len,"11",2);
		b63_len += 2;
		memcpy(pack.FIELD63+b63_len,gbl.telphone,11);
		b63_len += 11;
		pack.Packet_Table[63].Real_Length = b63_len;
		
		
		//交费包处理
		iRet = packHdl(2);
		if(iRet < 0)
			return -1;
		
		if (!memcmp(pack.FIELD39,"00",2)) 
		{

			if(gbl.product_flag==71){
                iRet = TS_OutPutMsg(gbl.dPosInfo,"\n申请现场维护服务成功，三个工作日内处理\n按【确认】返回",0,iSelect);
			}else if(gbl.product_flag==72){
                iRet = TS_OutPutMsg(gbl.dPosInfo,"\n购买现场维护服务成功，三个工作日内处理\n如未按规定时间内处理，所扣款项将在月底酬金结算中返还\n按【确认】打印票据",0,iSelect);
			}else if(gbl.product_flag==21){
                iRet = TS_OutPutMsg(gbl.dPosInfo,"\n订购发票成功，三天内到货\n按【确认】打印票据",0,iSelect);
			}else if(gbl.product_flag==22){
                iRet = TS_OutPutMsg(gbl.dPosInfo,"\n订购凭条成功，三天内到货\n按【确认】打印票据",0,iSelect);
			}else if(gbl.product_flag==23){
                iRet = TS_OutPutMsg(gbl.dPosInfo,"\n申请发票成功，三天内到货\n按【确认】返回",0,iSelect);
			}else if(gbl.product_flag==24){
                iRet = TS_OutPutMsg(gbl.dPosInfo,"\n申请凭条成功，三天内到货\n按【确认】返回",0,iSelect);
			}else if(gbl.product_flag==81){
                iRet = TS_OutPutMsg(gbl.dPosInfo,"\n订购发票打印机成功，获赠发票1卷，三天内免费上门安装\n按【确认】打印票据",0,iSelect);
			}else if(gbl.product_flag==82){
                iRet = TS_OutPutMsg(gbl.dPosInfo,"\n订购凭条打印机成功，获赠凭条5卷，三天内免费上门安装\n按【确认】打印票据",0,iSelect);
			}else if(gbl.product_flag==9){
                iRet = TS_OutPutMsg(gbl.dPosInfo,"\n订购发票打印机色带成功，三天内到货\n按【确认】打印票据",0,iSelect);
			}else if(gbl.product_flag==5){
                iRet = TS_OutPutMsg(gbl.dPosInfo,"\n订购宣传套装成功，三天内到货\n按【确认】打印票据",0,iSelect);
			}else if(gbl.product_flag==6){
                iRet = TS_OutPutMsg(gbl.dPosInfo,"\n订购招牌成功，7天内现场量尺寸，一个月内安装。面积超过3个平方米，每超过1平方米加200元，超出部分费用于现场安装时收取\n按【确认】打印票据",0,iSelect);
			}else
				iRet = TS_OutPutMsg(gbl.dPosInfo,"\n     购买成功！\n请按【确认】打印票据",0,iSelect);
			if(gbl.product_flag!=71&&gbl.product_flag!=23&&gbl.product_flag!=24){
				if(iRet!=0 || iSelect==0)
				{
					CPrint prt;
					prt.set_in_par(gbl);
					prt.print_detail(13,title);
				//	prt.print_SELL_POS(pack,title);
				}
			}
			return 0;
		}// end if (!memcmp(pack.FIELD39,"00",2))
		else if(!memcmp(pack.FIELD39,"55",2))
		{
			flag = 1;
			if(reGetPwd( title) == 0) //密码错误，重新输入密码, 2006-10-25
				continue;
			else
				return CANCLE_KEY;
		}
		else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
			if (iSelect!=0)
			{
				return -1;
			}else
				continue;
		}
		else		
			returnFail((char *)pack.FIELD39);		
		return -1;
	}
	return -1;
}


//银行卡转账
int CTrade::Bankc_zz(const char *title)
{
	int  iRet=0 , flag = 1, curTry=0;
	int  iSelect;
	char tmp[256];
	char tra_amo[13], tra_amo_buff[13];	//交易金额
	char name_serial[16+1];
	char len_buf[2+1];
	char card_num[30+1],card_len_buff[2+1],bank_type[2+1],zr_lenbuff[2+1],zr_bank[30+1];
	char respond[2+1];
	int card_len;
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	
	wrLog("【转账】转账业务");
	strcpy(gbl.fee_type,"0249");
	
	//输入金额
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, title);
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入转入卡号(到账卡号)：");
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//银行卡号
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
	tradeInfoSend.Contents[0].uCount = 1;		//输入2次
	tradeInfoSend.Contents[0].uMinLen = 1;		
	tradeInfoSend.Contents[0].uMaxLen = 30;	
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return -1;
	}
	bbzero(card_num);
	strcpy(card_num, (char *)tradeInfoRecv.Contents[0].uMsg);	//读入转入卡号
	bbzero(gbl.pos_serial);
	strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
	card_len = strlen(card_num);
	bbzero(card_len_buff);
	if (card_len<10)
	{
		sprintf(card_len_buff,"0%d",card_len);
	}else{
		sprintf(card_len_buff,"%d",card_len);
	}
	wrLog("到账卡号: [%s]", card_num);
	
	pack.wrField(1, gbl);	//写查询域
	/*-----------------------------------------------*/
	bbzero(pack.FIELD3);
	bbzero(gbl.password);
	strcpy(gbl.password,"00000000");
	CTools::hex_to_byte((BYTE *)"310000", pack.FIELD3, 6);
	bbzero(pack.FIELD48);
	memcpy(pack.FIELD48, gbl.fee_type, 4);
	pack.Packet_Table[48].Real_Length = 4;
	bbzero(pack.FIELD63);
	memcpy(pack.FIELD63 +8, "0", 1);
	bbzero(card_len_buff);
	sprintf(card_len_buff,"%02d",card_len);
	memcpy(pack.FIELD63 +8+1, card_len_buff, 2);
	memcpy(pack.FIELD63 +8+1+2, card_num, card_len);
	pack.Packet_Table[63].Real_Length = card_len+11;
	/*-----------------------------------------------*/
	iRet = packHdl(1);
	if(iRet < 0)
		return -1;
	
	if (!memcmp(pack.FIELD39,"00",2)) 
	{
		bbzero(len_buf);
		bbzero(gbl.user_name);
		bbzero(name_serial);
		bbzero(tmp);
		bbzero(bank_type);
		bbzero(zr_bank);
		bbzero(zr_lenbuff);
		
		memcpy(len_buf, pack.FIELD63+1, 2);
		memcpy(gbl.user_name, pack.FIELD63+3, atoi(len_buf));
		memcpy(name_serial, pack.FIELD63+3+atoi(len_buf), 16);		//户名查询流水号
		memcpy(bank_type, pack.FIELD63+19+atoi(len_buf), 2);		//银行行别号
		memcpy(zr_lenbuff, pack.FIELD63+21+atoi(len_buf), 2);		
		memcpy(zr_bank, pack.FIELD63+23+atoi(len_buf), atoi(zr_lenbuff));		
		
		sprintf(tmp,"转入银行卡号：\n%s\n用户名：%s\n      按【确认】继续",card_num,gbl.user_name);
		iRet = TS_OutPutMsg(gbl.dPosInfo, tmp, 0, iSelect);
		if(iRet)
		{
			wrLog("【转账】下发提示信息返回失败");
			return -1;
		}
		if(iSelect != 0)
		{
			wrLog("【转账】用户取消");
			return CANCLE_KEY;
		}
		
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		
		strcpy(tradeInfoSend.acMainTitle, title);
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents = 2;
		
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入转账金额：");
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_MONEY;	//金额
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
		tradeInfoSend.Contents[0].uMinLen = 1;		
		tradeInfoSend.Contents[0].uMaxLen = 8;	
		
		strcpy(tradeInfoSend.Contents[1].acTitle, "请输入手机号：");
		tradeInfoSend.Contents[1].uCommand = TS_INPUT_MATH;	//手机号码
		tradeInfoSend.Contents[1].uTimeOut = EPOS_OVER_TIME;	//超时30秒
		tradeInfoSend.Contents[1].uMinLen = 11;		
		tradeInfoSend.Contents[1].uMaxLen = 11;
		wrLog("【转账】开始输入账号和金额");
		for(curTry=0; curTry<MAXTRY; curTry++)
		{
			memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
			iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
			if(iRet != 0)
			{
				if(iRet == 1 || iRet ==2)
					wrLog("【转账】输入金额用户取消或超时");
				else
					wrLog("【转账】输入金额失败");
				wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
				return -1;
			}
			bbzero(tra_amo);		
			bbzero(gbl.telphone);		
			strcpy(tra_amo, (char *)tradeInfoRecv.Contents[0].uMsg);	//读入金额
			strcpy(gbl.telphone, (char *)tradeInfoRecv.Contents[1].uMsg);	//读入联系电话
			
			wrLog("tra_amo: [%s]", tra_amo);
			if(atoi(tra_amo)>10000000)
			{
				TS_OutPutMsg(gbl.dPosInfo, "超过最大金额(10万元)\n【确认】重新输入\n【返回】退出", 0, iSelect);
				if(iSelect)
					return CANCLE_KEY;
				else
					continue;
			}
			else
				break;
		}
		wrLog("【转账】输入到账卡号和金额成功");
		bbzero(gbl.pos_serial);
		strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
		bbzero(tmp);
		bbzero(tra_amo_buff);
		bbzero(gbl.amount);
		strcpy(gbl.amount,tra_amo);
		CTools::chgToMny(tra_amo,tra_amo_buff);
		sprintf(tmp,"转入银行卡号：\n%s\n金额：%s\n联系电话：%s\n      按【确认】继续",card_num,tra_amo_buff,gbl.telphone);
		iRet = TS_OutPutMsg(gbl.dPosInfo, tmp, 0, iSelect);
		if(iRet)
		{
			wrLog("【转账】下发提示信息返回失败");
			return -1;
		}
		if(iSelect != 0)
		{
			wrLog("【转账】用户取消");
			return CANCLE_KEY;
		}
	}else{
		bbzero(tmp);
		sprintf(tmp,"您输入的账号存在问题，请联系相关银行\n   按【确认】退出");
		iRet = TS_OutPutMsg(gbl.dPosInfo, tmp, 0, iSelect);
		if(iRet)
		{
			wrLog("【转账】下发提示信息返回失败");
		}
		return -1;
	} 	
	
	strcpy(gbl.fee_type,"0250"); 
	flag = 0;
	
	//刷卡
	
	for(curTry=0; curTry<MAXTRY; curTry++)
	{
		if(!flag)
		{
			iRet = mngCard_Hdl(title);
			if(iRet == CANCLE_KEY)
				return CANCLE_KEY;
			else if(iRet != 0){
				TS_OutPutMsg(gbl.dPosInfo,"读取输入数据错误!\n交易失败!\n按【确认】返回",1,iSelect);
				return -1;
			}
			
			if(!memcmp(gbl.card_no,"8828",4))	//若是付费易卡,走付费易卡刷卡流程（多卡交易）
			{
				memset(gbl.xlt_type, 0, sizeof(gbl.xlt_type));
				memcpy(gbl.xlt_type, "01",2);
				iRet = xltMulCard( title, 0);
				return iRet;
			}
		}
		
		pack.wrField(2, gbl);	//写交费域
		/*-----------------------------------------------*/
		bbzero(pack.FIELD3);
		CTools::hex_to_byte((BYTE *)"000000", pack.FIELD3, 6);
		//bit46
		strcpy((char *)pack.FIELD46,"1");
		pack.Packet_Table[46].Real_Length=1;
		//bit48
		memset(pack.FIELD48,0,sizeof(pack.FIELD48));
		memcpy(pack.FIELD48, gbl.fee_type, 4);
		memcpy(pack.FIELD48+4, card_len_buff, 2);
		memcpy(pack.FIELD48+6, card_num, card_len);
		pack.Packet_Table[48].Real_Length = 6+card_len;
		//bit63
		memcpy(pack.FIELD63+8, "000000000000", 12);
		memcpy(pack.FIELD63+20, name_serial, 16);
		memcpy(pack.FIELD63+36, "01", 2);
		memcpy(pack.FIELD63+38, "11", 2);
		memcpy(pack.FIELD63+40, gbl.telphone, 11);
		memcpy(pack.FIELD63+51, bank_type, 2);
		memcpy(pack.FIELD63+53, zr_lenbuff, 2);
		memcpy(pack.FIELD63+55, zr_bank, atoi(zr_lenbuff));
		pack.Packet_Table[63].Real_Length = 55+atoi(zr_lenbuff);
		/*-----------------------------------------------*/
		//打8583包
		iRet = packHdl(2);
		if(iRet < 0)
			return -1;
		
		if (!memcmp(pack.FIELD39,"00",2)) 
		{
			wrLog("【转账】转帐成功！");
			iRet = TS_OutPutMsg(gbl.dPosInfo, "\n      转帐成功！\n   按【确认】打印票据", 0, iSelect);
			// 			if(iRet!=0 || iSelect==0)
			// 			{
			// 				CPrint prt;
			// 				prt.set_in_par(gbl, pack);
			// 				prt.print_detail(2, title);	 
			// 			}
			return 0;
		}
		else if(!memcmp(pack.FIELD39, "55", 2) || !memcmp(pack.FIELD62, "P20005755", 9))
		{
			wrLog("【转账】密码错误，重新输入");
			flag = 1;
			if(reGetPwd(title) == 0) //密码错误，重新输入密码, 2006-10-25
				continue;
			else
				return CANCLE_KEY;
		}
		else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
			if (iSelect!=0)
			{
				return -1;
			}else
				continue;
		}
		else
		{
			wrLog("【转账】转帐失败");
			bbzero(respond);
			memcpy(respond,pack.FIELD62+7,2);
			iRet = banReturnFail((char *)respond);
			return -1;
		}
	}
	return -1;
	
}

int CTrade::UpdateMenus(int menu_group, char sysnum)
{
	int iRet=0, total=0, i=0, j=0, l1=0, l2=0, l3=0, islef=0, menu_id=0;//islef=1:叶子
	TSTradeInfoSend tradeInfoSend;
	TSMenus menus;
	Epos_menu_conf mymenus[MAX_MENU_ITEM];
	char msg[500];
	
	memset(&mymenus, 0, sizeof(mymenus));
	bbzero(msg);
	
	iRet = CDB::getGroupMenus(menu_group, mymenus, &total);
	if( iRet )
	{
		wrLog("获取需要更新的菜单失败");
		return -1;
	}
	
	iRet = TS_ClearMenus(gbl.dPosInfo);
	wrLog("TS_ClearMenus return [%d]",iRet);
	
	for(i=1, l1=0, l2=0, l3=0; i<MAX_MENU_ITEM && i<=total; )
	{
		memset(&menus, 0, sizeof(menus));
		menus.num=0;
		
		for(j=0; j<MAX_LOCAL_MENU && i<MAX_MENU_ITEM && i<=total; i++)
		{
			//如果child非0，则为三级菜单的叶子
			if(mymenus[i].child!=0)
			{
				//三级叶子
				l3++;
				islef = 1;
				menu_id = mymenus[i].child;
			}
			//如果parent与上级不同，parent与下级不同，则为一级菜单的叶子
			else if(mymenus[i].parent!=mymenus[i-1].parent && mymenus[i].parent!=mymenus[i+1].parent)
			{
				//一级叶子
				l1++;
				l2=0;
				l3=0;
				islef = 1;
				menu_id = mymenus[i].parent;
			}
			//如果parent与上级不同，parent与下级相同，则为一级菜单
			else if(mymenus[i].parent!=mymenus[i-1].parent && mymenus[i].parent==mymenus[i+1].parent)
			{
				//一级菜单
				l1++;
				l2=0;
				l3=0;
				islef = 0;
				menu_id = mymenus[i].parent;
			}
			//如果currentm与上级不同，currentm与下级不同，则为二级叶子
			else if(mymenus[i].currentm!=mymenus[i-1].currentm && mymenus[i].currentm!=mymenus[i+1].currentm)
			{
				//二级叶子
				l2++;
				l3=0;
				islef = 1;
				menu_id = mymenus[i].currentm;
			}
			//如果currentm与上级不同，currentm与下级相同，则为二级菜单
			else if(mymenus[i].currentm!=mymenus[i-1].currentm && mymenus[i].currentm==mymenus[i+1].currentm)
			{
				//二级菜单
				l2++;
				l3=0;
				islef = 0;
				menu_id = mymenus[i].currentm;
			}
			else
			{
				//异常
				wrLog("菜单异常[%d][%d][%d][%d]", i, mymenus[i].parent, mymenus[i].currentm, mymenus[i].child);
				return -1;
			}
			
			//如果超出POS终端的8*8*6的范围，将此菜单忽略
			if( l1<=0 || l1 >8 || l2<0 || l2>8 || l3<0 || l3>8 )
			{
				wrLog("级别异常[%d][%d][%d][%d]", i, l1, l2, l3);
				continue;
			}
			
			//如果是叶子
			if(islef)
			{
				menus.menus[j].isused='1';
				menus.menus[j].level1=l1;
				menus.menus[j].level2=l2;
				menus.menus[j].level3=l3;
				menus.menus[j].askType=0x0A;
				menus.menus[j].sysnum=sysnum;					
				memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
				tradeInfoSend.uTotalContents = 0;
				tradeInfoSend.sendType = 1;
				strcpy(tradeInfoSend.acMainTitle, epos_menu[menu_id].name);
				iRet = TS_TradeEncode(gbl.dPosInfo, &tradeInfoSend, menus.menus[j].tcode, &(menus.menus[j].tcodelen));
				wrLog("TS_TradeEncode return [%d]",iRet);
				strcpy(menus.menus[j].menu, tradeInfoSend.acMainTitle);
				menus.menus[j].menulen = strlen(menus.menus[j].menu);
				menus.menus[j].menuid=menu_id;
				strcpy(menus.menus[j].info, epos_menu[menu_id].info);
				
				menus.num++;
				
				wrLog("第[%d]项 位置[%d][%d][%d] 菜单[%d][%s]", i, l1, l2, l3, menu_id, epos_menu[menu_id].name);
			}
			else//如果是目录
			{
				menus.menus[j].isused='1';
				menus.menus[j].level1=l1;
				menus.menus[j].level2=l2;
				menus.menus[j].level3=l3;
				menus.menus[j].tcodelen=3;
				memset(menus.menus[j].tcode, 0, 3);
				strcpy(menus.menus[j].menu, epos_menu[menu_id].name);
				menus.menus[j].menulen = strlen(menus.menus[j].menu);
				menus.menus[j].menuid=0;
				strcpy(menus.menus[j].info, epos_menu[menu_id].info);
				
				menus.num++;
				wrLog("第[%d]项 位置[%d][%d][%d] 目录[%d][%s]", i, l1, l2, l3, menu_id, epos_menu[menu_id].name);
			}
			j++;
		}
		
		if(j>0)
		{
			iRet = TS_UpdateMenus(gbl.dPosInfo, menus);
			wrLog("TS_UpdateMenus return [%d]",iRet);
			
			if( iRet )
			{
				wrLog("更新菜单失败");
				return -1;
			}
		}		
	}	
	
	return 0;
}

/************************************************************************/
/********************演示代码专区****************************************/


int CTrade::payonce(int subtype, const char *title)
{
	int iRet,iSelect;
	
	strcpy(gbl.fee_type,"0001");
	wrLog("【payonce】");
	
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	
	memset(&tradeInfoSend,0,sizeof(tradeInfoSend));
	memset(&tradeInfoRecv,0,sizeof(tradeInfoRecv));
	
	tradeInfoSend.uHasTradeID=1;
	tradeInfoSend.uTotalContents=1;
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入");
	strcat(tradeInfoSend.Contents[0].acTitle, title);
	
	tradeInfoSend.Contents[0].uCount = 0;		//输入1次
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
	if(subtype==1)
	{
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;
		tradeInfoSend.Contents[0].uMinLen = 8;		
		tradeInfoSend.Contents[0].uMaxLen = 8;
	}
	else
	{
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//全字符
		tradeInfoSend.Contents[0].uMinLen = 16;		
		tradeInfoSend.Contents[0].uMaxLen = 16;
	}
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		return iRet;
	}
	memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
	strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
	bbzero(gbl.phone_no);
	strncpy(gbl.phone_no, (char *)tradeInfoRecv.Contents[0].uMsg, tradeInfoRecv.Contents[0].uMsgLen);
	iSelect = TS_OutPutMsg(gbl.dPosInfo,"新装电话费:300.00元\n改装工料费:50.00元\n【确认】支付\n【返回】返回",0,iSelect);
	if (iSelect != 0)
	{
		return -2;
	}
	
	iRet = mngCard_Hdl(title);
	if(iRet == CANCLE_KEY)
		return CANCLE_KEY;
	else if(iRet != 0)
		return -1;
	
	iRet = TS_OutPutMsg(gbl.dPosInfo, "\n      支付成功！\n   按【确认】打印票据", 0, iSelect);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		return iRet;
	}
	CPrint prt;
	prt.set_in_par(gbl);				
	iRet = prt.print_payonce_detail(title);
	return iRet;
}

/************************************************************************/

int CTrade::dxysl_trad(const char *title)
{
	int iRet, iSelect;
	char response_code[3];
	char len_buff[2+1],tc_type[2];
	
	wrLog("【肇庆电信预受理业务】");
	
	strcpy(gbl.fee_type,"0261");
	
	iRet = selectAmount();
	if((iRet < 0) || (iRet == CANCLE_KEY))
		return -1;
	TSMENULIST menuList;
	memset(&menuList,0,sizeof(menuList));
	bbzero(tc_type);
	switch (iRet)
	{
	case 1:
		menuList.iTotalNum = 2;
		strcpy(menuList.acTitle, "请选择预受理业务类型");
		strcpy(menuList.menuItem[0], "乡情网：26元");
		strcpy(menuList.menuItem[1], "乡情网：56元");
		
		iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
		if(iRet)
			return -1;
		switch(iSelect)
		{
		case 1:
			strcpy(tc_type,"001");
			break;
		case 2:
			strcpy(tc_type,"002");
			break;
		default: 
			return CANCLE_KEY;
		}
		break;
		case 2:
			menuList.iTotalNum = 4;
			strcpy(menuList.acTitle, "请选择预受理业务类型");
			strcpy(menuList.menuItem[0], "e8：68元512K");
			strcpy(menuList.menuItem[1], "e8：88元1M");
			strcpy(menuList.menuItem[2], "e8：108元2M");
			strcpy(menuList.menuItem[3], "e8：1098包年");
			
			iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
			if(iRet)
				return -1;
			switch(iSelect)
			{
			case 1:
				strcpy(tc_type,"003");
				break;
			case 2:
				strcpy(tc_type,"004");
				break;
			case 3:
				strcpy(tc_type,"005");
				break;
			case 4:
				strcpy(tc_type,"006");
				break;
			default: 
				return CANCLE_KEY;
			}
			break;
			case 3:
				menuList.iTotalNum = 2;
				strcpy(menuList.acTitle, "请选择预受理业务类型");
				strcpy(menuList.menuItem[0], "48元套餐");
				strcpy(menuList.menuItem[1], "原固话＋30元");
				
				iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
				if(iRet)
					return -1;
				switch(iSelect)
				{
				case 1:
					strcpy(tc_type,"007");
					break;
				case 2:
					strcpy(tc_type,"008");
					break;
				default: 
					return CANCLE_KEY;
				}
				break;
				case 4:
					menuList.iTotalNum = 1;
					strcpy(menuList.acTitle, "请选择预受理业务类型");
					strcpy(menuList.menuItem[0], "乡亲特惠套餐");
					
					iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
					if(iRet)
						return -1;
					switch(iSelect)
					{
					case 1:
						strcpy(tc_type,"009");
						break;
					default: 
						return CANCLE_KEY;
					}
					break;
					case 5:
						menuList.iTotalNum = 1;
						strcpy(menuList.acTitle, "请选择预受理业务类型");
						strcpy(menuList.menuItem[0], "139元融合套餐");
						
						iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
						if(iRet)
							return -1;
						switch(iSelect)
						{
						case 1:
							strcpy(tc_type,"010");
							break;
						default: 
							return CANCLE_KEY;
						}
						break;
						default:
							return -1;
	}
	
	
	
	
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, title);
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入固定号码");	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
	tradeInfoSend.Contents[0].uMinLen = 7;		
	tradeInfoSend.Contents[0].uMaxLen = 7;
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	
	memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
	bbzero(gbl.phone_no);
	strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
	gbl.phone_len = tradeInfoRecv.Contents[0].uMsgLen;
	strcpy( gbl.phone_no,(char *)tradeInfoRecv.Contents[0].uMsg );
	
	
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, title);
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 2;
	
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入联系电话");	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
	tradeInfoSend.Contents[0].uMinLen = 11;		
	tradeInfoSend.Contents[0].uMaxLen = 11;	
	
	strcpy(tradeInfoSend.Contents[1].acTitle, "请输入身份证号");	
	tradeInfoSend.Contents[1].uCommand = TS_INPUT_ALL_CHAR;	//数字
	tradeInfoSend.Contents[1].uCount = 0;		//输入2次
	tradeInfoSend.Contents[1].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
	tradeInfoSend.Contents[1].uMinLen = 15;		
	tradeInfoSend.Contents[1].uMaxLen = 18;	
	
	
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	
	memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
	bbzero(gbl.telphone);
	bbzero(gbl.id_num);
	strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
	strcpy( gbl.telphone,(char *)tradeInfoRecv.Contents[0].uMsg );
	strcpy( gbl.id_num,(char *)tradeInfoRecv.Contents[1].uMsg );
	
	
	pack.wrField(1, gbl);	//写查询域
	/*-----------------------------------------------*/
	bbzero(pack.FIELD3);
	CTools::hex_to_byte((BYTE *)"310000", pack.FIELD3, 6);
	
	bbzero(pack.FIELD48);
	memcpy(pack.FIELD48, gbl.fee_type, 4);
	pack.Packet_Table[48].Real_Length = 4;
	bbzero(len_buff);
	sprintf(len_buff,"%02d",11);
	memcpy(pack.FIELD48+4,len_buff,2);
	pack.Packet_Table[48].Real_Length += 2;
	memcpy(pack.FIELD48+6,gbl.telphone,11);
	pack.Packet_Table[48].Real_Length += 11;
	
	bbzero(pack.FIELD63);
	bbzero(len_buff);
	sprintf(len_buff,"%02d",strlen(gbl.id_num));
	memcpy(pack.FIELD63 ,len_buff, 2);
	pack.Packet_Table[63].Real_Length = 2;
	memcpy(pack.FIELD63 +2, gbl.id_num, strlen(gbl.id_num));
	pack.Packet_Table[63].Real_Length += strlen(gbl.id_num);
	memcpy(pack.FIELD63 +2+strlen(gbl.id_num),"3", 1);
	pack.Packet_Table[63].Real_Length += 1;
	memcpy(pack.FIELD63 +3+strlen(gbl.id_num), tc_type, 3);
	pack.Packet_Table[63].Real_Length += 3;
	memcpy(pack.FIELD63 +6+strlen(gbl.id_num),"8", 1);
	pack.Packet_Table[63].Real_Length += 1;
	memcpy(pack.FIELD63 +7+strlen(gbl.id_num), gbl.phone_no, 8);
	pack.Packet_Table[63].Real_Length += 8;
	/*-----------------------------------------------*/
	iRet = packHdl(1);
	if(iRet < 0)
		return -1;
	
	memset(response_code,0,sizeof(response_code));
	memcpy(response_code,pack.FIELD39,2);
	if (!memcmp(response_code,"00",2)) 
	{
		
		TS_OutPutMsg(gbl.dPosInfo," \n\n   业务受理成功！",0,iSelect);
		return 0;
	}
	else
		returnFail(response_code);	
	
	return -1;
}

/***********************************
清远电信预受理
t_select:   1：对应终端号段  70170101-70170150
2：对应终端号段  70170151-70170265
70170306-70170330
3：对应终端号段  70170266-70170305
70170331-70170400
***********************************/
int CTrade::qy_dxysl_trad(const char *title, int t_select)
{
	int iRet, iSelect,type_select;
	char response_code[3];
	char len_buff[2+1],tc_type[2];
	TSMENULIST menuList;	
	
	strcpy(gbl.fee_type,"0261");
	
	
	memset(&menuList,0,sizeof(menuList));
	menuList.iTotalNum = 5;
	strcpy(menuList.acTitle, "请选择套餐类型");
	strcpy(menuList.menuItem[0], "天翼套餐");
	strcpy(menuList.menuItem[1], "e6套餐");
	strcpy(menuList.menuItem[2], "e8套餐");
	strcpy(menuList.menuItem[3], "e9套餐");
	strcpy(menuList.menuItem[4], "商务领航");
	
	iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
	if(iRet)
		return -1;
	
	switch (iSelect)
	{
	case 1:
		type_select = 1;
		break;
	case 2:
		type_select = 2;
		break;
	case 3:
		type_select = 3;
		break;
	case 4:
		type_select = 4;
		break;
	case 5:
		type_select = 5;
		break;
	default:
		return -1;
	}
	
	
	if (t_select == 1)
	{
		memset(&menuList,0,sizeof(menuList));
		bbzero(tc_type);
		switch (type_select)
		{
		case 1:
			menuList.iTotalNum = 16;
			strcpy(menuList.acTitle, "请选择预受理业务类型");
			strcpy(menuList.menuItem[0], "59元天翼商旅套餐");
			strcpy(menuList.menuItem[1], "89元天翼商旅套餐");
			strcpy(menuList.menuItem[2], "139元商旅套餐");
			strcpy(menuList.menuItem[3], "189元天翼商旅套餐");
			strcpy(menuList.menuItem[4], "289元天翼商旅套餐");
			strcpy(menuList.menuItem[5], "389元天翼商旅套餐");
			strcpy(menuList.menuItem[6], "589元天翼商旅套餐");
			strcpy(menuList.menuItem[7], "889元天翼商旅套餐");
			strcpy(menuList.menuItem[8], "59元加装版(47元)");
			strcpy(menuList.menuItem[9], "89元加装版(71元)");
			strcpy(menuList.menuItem[10], "139元加装版(111元)");
			strcpy(menuList.menuItem[11], "189元加装版(151元)");
			strcpy(menuList.menuItem[12], "289元加装版(231元)");
			strcpy(menuList.menuItem[13], "389元加装版(311元)");
			strcpy(menuList.menuItem[14], "559元加装版(471元)");
			strcpy(menuList.menuItem[15], "889元加装版(711元)");
			
			iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
			if(iRet)
				return -1;
			switch(iSelect)
			{
			case 1:
				strcpy(tc_type,"011");
				break;
			case 2:
				strcpy(tc_type,"012");
				break;
			case 3:
				strcpy(tc_type,"013");
				break;
			case 4:
				strcpy(tc_type,"014");
				break;
			case 5:
				strcpy(tc_type,"015");
				break;
			case 6:
				strcpy(tc_type,"016");
				break;
			case 7:
				strcpy(tc_type,"017");
				break;
			case 8:
				strcpy(tc_type,"018");
				break;
			case 9:
				strcpy(tc_type,"019");
				break;
			case 10:
				strcpy(tc_type,"020");
				break;
			case 11:
				strcpy(tc_type,"021");
				break;
			case 12:
				strcpy(tc_type,"022");
				break;
			case 13:
				strcpy(tc_type,"023");
				break;
			case 14:
				strcpy(tc_type,"024");
				break;
			case 15:
				strcpy(tc_type,"025");
				break;
			case 16:
				strcpy(tc_type,"026");
				break;
			default: 
				return CANCLE_KEY;
			}
			break;
			case 2:
				menuList.iTotalNum = 6;
				strcpy(menuList.acTitle, "请选择预受理业务类型");
				strcpy(menuList.menuItem[0], "66元城镇版e6套餐");
				strcpy(menuList.menuItem[1], "86元城镇版e6套餐");
				strcpy(menuList.menuItem[2], "116元城镇版e6套餐");
				strcpy(menuList.menuItem[3], "36元农村版e6套餐");
				strcpy(menuList.menuItem[4], "66元农村版e6套餐");
				strcpy(menuList.menuItem[5], "86元农村版e6套餐");
				
				iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
				if(iRet)
					return -1;
				switch(iSelect)
				{
				case 1:
					strcpy(tc_type,"027");
					break;
				case 2:
					strcpy(tc_type,"028");
					break;
				case 3:
					strcpy(tc_type,"029");
					break;
				case 4:
					strcpy(tc_type,"030");
					break;
				case 5:
					strcpy(tc_type,"031");
					break;
				case 6:
					strcpy(tc_type,"032");
					break;
				default: 
					return CANCLE_KEY;
				}
				break;
				case 3:
					menuList.iTotalNum = 6;
					strcpy(menuList.acTitle, "请选择预受理业务类型");
					strcpy(menuList.menuItem[0], "48元包月家庭版");
					strcpy(menuList.menuItem[1], "128元包月家庭版");
					strcpy(menuList.menuItem[2], "58元包月家庭版");
					strcpy(menuList.menuItem[3], "68元包月家庭版");
					strcpy(menuList.menuItem[4], "88元包月家庭版");
					strcpy(menuList.menuItem[5], "98元包月家庭版");
					
					iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
					if(iRet)
						return -1;
					switch(iSelect)
					{
					case 1:
						strcpy(tc_type,"033");
						break;
					case 2:
						strcpy(tc_type,"034");
						break;
					case 3:
						strcpy(tc_type,"035");
						break;
					case 4:
						strcpy(tc_type,"036");
						break;
					case 5:
						strcpy(tc_type,"037");
						break;
					case 6:
						strcpy(tc_type,"038");
						break;
					default: 
						return CANCLE_KEY;
					}
					break;
					case 4:
						menuList.iTotalNum = 1;
						strcpy(menuList.acTitle, "请选择预受理业务类型");
						strcpy(menuList.menuItem[0], "169元e9共享套餐");
						
						iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
						if(iRet)
							return -1;
						switch(iSelect)
						{
						case 1:
							strcpy(tc_type,"040");
							break;
						default: 
							return CANCLE_KEY;
						}
						break;
						case 5:
							menuList.iTotalNum = 5;
							strcpy(menuList.acTitle, "请选择预受理业务类型");
							strcpy(menuList.menuItem[0], "69元通信版");
							strcpy(menuList.menuItem[1], "89元通信版");
							strcpy(menuList.menuItem[2], "119元通信版");
							strcpy(menuList.menuItem[3], "169元通信版");
							strcpy(menuList.menuItem[4], "169元信息版");
							
							iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
							if(iRet)
								return -1;
							switch(iSelect)
							{
							case 1:
								strcpy(tc_type,"042");
								break;
							case 2:
								strcpy(tc_type,"043");
								break;
							case 3:
								strcpy(tc_type,"044");
								break;
							case 4:
								strcpy(tc_type,"045");
								break;
							case 5:
								strcpy(tc_type,"046");
								break;
							default: 
								return CANCLE_KEY;
							}
							break;
							default:
								return -1;
		}
	}else if (t_select == 2)
	{
		memset(&menuList,0,sizeof(menuList));
		bbzero(tc_type);
		switch (type_select)
		{
		case 1:
			menuList.iTotalNum = 16;
			strcpy(menuList.acTitle, "请选择预受理业务类型");
			strcpy(menuList.menuItem[0], "59元天翼商旅套餐");
			strcpy(menuList.menuItem[1], "89元天翼商旅套餐");
			strcpy(menuList.menuItem[2], "139元商旅套餐");
			strcpy(menuList.menuItem[3], "189元天翼商旅套餐");
			strcpy(menuList.menuItem[4], "289元天翼商旅套餐");
			strcpy(menuList.menuItem[5], "389元天翼商旅套餐");
			strcpy(menuList.menuItem[6], "589元天翼商旅套餐");
			strcpy(menuList.menuItem[7], "889元天翼商旅套餐");
			strcpy(menuList.menuItem[8], "59元加装版(47元)");
			strcpy(menuList.menuItem[9], "89元加装版(71元)");
			strcpy(menuList.menuItem[10], "139元加装版(111元)");
			strcpy(menuList.menuItem[11], "189元加装版(151元)");
			strcpy(menuList.menuItem[12], "289元加装版(231元)");
			strcpy(menuList.menuItem[13], "389元加装版(311元)");
			strcpy(menuList.menuItem[14], "559元加装版(471元)");
			strcpy(menuList.menuItem[15], "889元加装版(711元)");
			
			iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
			if(iRet)
				return -1;
			switch(iSelect)
			{
			case 1:
				strcpy(tc_type,"011");
				break;
			case 2:
				strcpy(tc_type,"012");
				break;
			case 3:
				strcpy(tc_type,"013");
				break;
			case 4:
				strcpy(tc_type,"014");
				break;
			case 5:
				strcpy(tc_type,"015");
				break;
			case 6:
				strcpy(tc_type,"016");
				break;
			case 7:
				strcpy(tc_type,"017");
				break;
			case 8:
				strcpy(tc_type,"018");
				break;
			case 9:
				strcpy(tc_type,"019");
				break;
			case 10:
				strcpy(tc_type,"020");
				break;
			case 11:
				strcpy(tc_type,"021");
				break;
			case 12:
				strcpy(tc_type,"022");
				break;
			case 13:
				strcpy(tc_type,"023");
				break;
			case 14:
				strcpy(tc_type,"024");
				break;
			case 15:
				strcpy(tc_type,"025");
				break;
			case 16:
				strcpy(tc_type,"026");
				break;
			default: 
				return CANCLE_KEY;
			}
			break;
			case 2:
				menuList.iTotalNum = 6;
				strcpy(menuList.acTitle, "请选择预受理业务类型");
				strcpy(menuList.menuItem[0], "66元城镇版e6套餐");
				strcpy(menuList.menuItem[1], "86元城镇版e6套餐");
				strcpy(menuList.menuItem[2], "116元城镇版e6套餐");
				strcpy(menuList.menuItem[3], "36元农村版e6套餐");
				strcpy(menuList.menuItem[4], "66元农村版e6套餐");
				strcpy(menuList.menuItem[5], "86元农村版e6套餐");
				
				iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
				if(iRet)
					return -1;
				switch(iSelect)
				{
				case 1:
					strcpy(tc_type,"027");
					break;
				case 2:
					strcpy(tc_type,"028");
					break;
				case 3:
					strcpy(tc_type,"029");
					break;
				case 4:
					strcpy(tc_type,"030");
					break;
				case 5:
					strcpy(tc_type,"031");
					break;
				case 6:
					strcpy(tc_type,"032");
					break;
				default: 
					return CANCLE_KEY;
				}
				break;
				case 3:
					menuList.iTotalNum = 1;
					strcpy(menuList.acTitle, "请选择预受理业务类型");
					strcpy(menuList.menuItem[0], "118元城镇家庭版");
					
					iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
					if(iRet)
						return -1;
					switch(iSelect)
					{
					case 1:
						strcpy(tc_type,"039");
						break;
					default: 
						return CANCLE_KEY;
					}
					break;
					case 4:
						menuList.iTotalNum = 1;
						strcpy(menuList.acTitle, "请选择预受理业务类型");
						strcpy(menuList.menuItem[0], "169元e9共享套餐");
						
						iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
						if(iRet)
							return -1;
						switch(iSelect)
						{
						case 1:
							strcpy(tc_type,"040");
							break;
						default: 
							return CANCLE_KEY;
						}
						break;
						case 5:
							menuList.iTotalNum = 5;
							strcpy(menuList.acTitle, "请选择预受理业务类型");
							strcpy(menuList.menuItem[0], "69元通信版");
							strcpy(menuList.menuItem[1], "89元通信版");
							strcpy(menuList.menuItem[2], "119元通信版");
							strcpy(menuList.menuItem[3], "169元通信版");
							strcpy(menuList.menuItem[4], "169元信息版");
							
							iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
							if(iRet)
								return -1;
							switch(iSelect)
							{
							case 1:
								strcpy(tc_type,"042");
								break;
							case 2:
								strcpy(tc_type,"043");
								break;
							case 3:
								strcpy(tc_type,"044");
								break;
							case 4:
								strcpy(tc_type,"045");
								break;
							case 5:
								strcpy(tc_type,"046");
								break;
							default: 
								return CANCLE_KEY;
							}
							break;
							default:
								return -1;
		}
	}else if (t_select == 3)
	{
		memset(&menuList,0,sizeof(menuList));
		bbzero(tc_type);
		switch (type_select)
		{
		case 1:
			menuList.iTotalNum = 16;
			strcpy(menuList.acTitle, "请选择预受理业务类型");
			strcpy(menuList.menuItem[0], "59元天翼商旅套餐");
			strcpy(menuList.menuItem[1], "89元天翼商旅套餐");
			strcpy(menuList.menuItem[2], "139元商旅套餐");
			strcpy(menuList.menuItem[3], "189元天翼商旅套餐");
			strcpy(menuList.menuItem[4], "289元天翼商旅套餐");
			strcpy(menuList.menuItem[5], "389元天翼商旅套餐");
			strcpy(menuList.menuItem[6], "589元天翼商旅套餐");
			strcpy(menuList.menuItem[7], "889元天翼商旅套餐");
			strcpy(menuList.menuItem[8], "59元加装版(47元)");
			strcpy(menuList.menuItem[9], "89元加装版(71元)");
			strcpy(menuList.menuItem[10], "139元加装版(111元)");
			strcpy(menuList.menuItem[11], "189元加装版(151元)");
			strcpy(menuList.menuItem[12], "289元加装版(231元)");
			strcpy(menuList.menuItem[13], "389元加装版(311元)");
			strcpy(menuList.menuItem[14], "559元加装版(471元)");
			strcpy(menuList.menuItem[15], "889元加装版(711元)");
			
			iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
			if(iRet)
				return -1;
			switch(iSelect)
			{
			case 1:
				strcpy(tc_type,"011");
				break;
			case 2:
				strcpy(tc_type,"012");
				break;
			case 3:
				strcpy(tc_type,"013");
				break;
			case 4:
				strcpy(tc_type,"014");
				break;
			case 5:
				strcpy(tc_type,"015");
				break;
			case 6:
				strcpy(tc_type,"016");
				break;
			case 7:
				strcpy(tc_type,"017");
				break;
			case 8:
				strcpy(tc_type,"018");
				break;
			case 9:
				strcpy(tc_type,"019");
				break;
			case 10:
				strcpy(tc_type,"020");
				break;
			case 11:
				strcpy(tc_type,"021");
				break;
			case 12:
				strcpy(tc_type,"022");
				break;
			case 13:
				strcpy(tc_type,"023");
				break;
			case 14:
				strcpy(tc_type,"024");
				break;
			case 15:
				strcpy(tc_type,"025");
				break;
			case 16:
				strcpy(tc_type,"026");
				break;
			default: 
				return CANCLE_KEY;
			}
			break;
			case 2:
				menuList.iTotalNum = 6;
				strcpy(menuList.acTitle, "请选择预受理业务类型");
				strcpy(menuList.menuItem[0], "66元城镇版e6套餐");
				strcpy(menuList.menuItem[1], "86元城镇版e6套餐");
				strcpy(menuList.menuItem[2], "116元城镇版e6套餐");
				strcpy(menuList.menuItem[3], "36元农村版e6套餐");
				strcpy(menuList.menuItem[4], "66元农村版e6套餐");
				strcpy(menuList.menuItem[5], "86元农村版e6套餐");
				
				iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
				if(iRet)
					return -1;
				switch(iSelect)
				{
				case 1:
					strcpy(tc_type,"027");
					break;
				case 2:
					strcpy(tc_type,"028");
					break;
				case 3:
					strcpy(tc_type,"029");
					break;
				case 4:
					strcpy(tc_type,"030");
					break;
				case 5:
					strcpy(tc_type,"031");
					break;
				case 6:
					strcpy(tc_type,"032");
					break;
				default: 
					return CANCLE_KEY;
				}
				break;
				case 3:
					menuList.iTotalNum = 1;
					strcpy(menuList.acTitle, "请选择预受理业务类型");
					strcpy(menuList.menuItem[0], "118元城镇家庭版");
					
					iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
					if(iRet)
						return -1;
					switch(iSelect)
					{
					case 1:
						strcpy(tc_type,"039");
						break;
					default: 
						return CANCLE_KEY;
					}
					break;
					case 4:
						menuList.iTotalNum = 1;
						strcpy(menuList.acTitle, "请选择预受理业务类型");
						strcpy(menuList.menuItem[0], "139元e9共享套餐");
						
						iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
						if(iRet)
							return -1;
						switch(iSelect)
						{
						case 1:
							strcpy(tc_type,"041");
							break;
						default: 
							return CANCLE_KEY;
						}
						break;
						case 5:
							menuList.iTotalNum = 5;
							strcpy(menuList.acTitle, "请选择预受理业务类型");
							strcpy(menuList.menuItem[0], "69元通信版");
							strcpy(menuList.menuItem[1], "89元通信版");
							strcpy(menuList.menuItem[2], "119元通信版");
							strcpy(menuList.menuItem[3], "169元通信版");
							strcpy(menuList.menuItem[4], "169元信息版");
							
							iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
							if(iRet)
								return -1;
							switch(iSelect)
							{
							case 1:
								strcpy(tc_type,"042");
								break;
							case 2:
								strcpy(tc_type,"043");
								break;
							case 3:
								strcpy(tc_type,"044");
								break;
							case 4:
								strcpy(tc_type,"045");
								break;
							case 5:
								strcpy(tc_type,"046");
								break;
							default: 
								return CANCLE_KEY;
							}
							break;
							default:
								return -1;
		}
	}else
		return -1;
	
	
	
	
	
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, title);
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入固定号码");	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
	tradeInfoSend.Contents[0].uMinLen = 7;		
	tradeInfoSend.Contents[0].uMaxLen = 7;
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	
	memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
	bbzero(gbl.phone_no);
	strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
	gbl.phone_len = tradeInfoRecv.Contents[0].uMsgLen;
	strcpy( gbl.phone_no,(char *)tradeInfoRecv.Contents[0].uMsg );
	
	
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, title);
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 2;
	
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入联系电话");	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
	tradeInfoSend.Contents[0].uMinLen = 11;		
	tradeInfoSend.Contents[0].uMaxLen = 11;	
	
	strcpy(tradeInfoSend.Contents[1].acTitle, "请输入身份证号");	
	tradeInfoSend.Contents[1].uCommand = TS_INPUT_ALL_CHAR;	//数字
	tradeInfoSend.Contents[1].uCount = 0;		//输入2次
	tradeInfoSend.Contents[1].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
	tradeInfoSend.Contents[1].uMinLen = 15;		
	tradeInfoSend.Contents[1].uMaxLen = 18;	
	
	
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	
	memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
	bbzero(gbl.telphone);
	bbzero(gbl.id_num);
	strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
	strcpy( gbl.telphone,(char *)tradeInfoRecv.Contents[0].uMsg );
	strcpy( gbl.id_num,(char *)tradeInfoRecv.Contents[1].uMsg );
	
	
	pack.wrField(1, gbl);	//写查询域
	/*-----------------------------------------------*/
	bbzero(pack.FIELD3);
	CTools::hex_to_byte((BYTE *)"310000", pack.FIELD3, 6);
	
	bbzero(pack.FIELD48);
	memcpy(pack.FIELD48, gbl.fee_type, 4);
	pack.Packet_Table[48].Real_Length = 4;
	bbzero(len_buff);
	sprintf(len_buff,"%02d",11);
	memcpy(pack.FIELD48+4,len_buff,2);
	pack.Packet_Table[48].Real_Length += 2;
	memcpy(pack.FIELD48+6,gbl.telphone,11);
	pack.Packet_Table[48].Real_Length += 11;
	
	bbzero(pack.FIELD63);
	bbzero(len_buff);
	sprintf(len_buff,"%02d",strlen(gbl.id_num));
	memcpy(pack.FIELD63 ,len_buff, 2);
	pack.Packet_Table[63].Real_Length = 2;
	memcpy(pack.FIELD63 +2, gbl.id_num, strlen(gbl.id_num));
	pack.Packet_Table[63].Real_Length += strlen(gbl.id_num);
	memcpy(pack.FIELD63 +2+strlen(gbl.id_num),"3", 1);
	pack.Packet_Table[63].Real_Length += 1;
	memcpy(pack.FIELD63 +3+strlen(gbl.id_num), tc_type, 3);
	pack.Packet_Table[63].Real_Length += 3;
	memcpy(pack.FIELD63 +6+strlen(gbl.id_num),"8", 1);
	pack.Packet_Table[63].Real_Length += 1;
	memcpy(pack.FIELD63 +7+strlen(gbl.id_num), gbl.phone_no, 8);
	pack.Packet_Table[63].Real_Length += 8;
	/*-----------------------------------------------*/
	iRet = packHdl(1);
	if(iRet < 0)
		return -1;
	
	memset(response_code,0,sizeof(response_code));
	memcpy(response_code,pack.FIELD39,2);
	if (!memcmp(response_code,"00",2)) 
	{
		
		TS_OutPutMsg(gbl.dPosInfo," \n\n   业务受理成功！",0,iSelect);
		return 0;
	}
	else
		returnFail(response_code);	
	
	return -1;
}

//年票demo版收发包
int CTrade::simplePackHdl(char* send_data,char* recv_data)
{
	char hostname[16];
	int send_len, iRet;
	int port;
	CConnect con;	//连接类
	//打包   
	send_len = strlen(send_data);
	//上送数据包
	bbzero(hostname);
	strcpy(hostname, "132.97.117.215");
	port = 8888;
	iRet = con.xltHostSendRecvData(send_data,send_len,recv_data,1024,hostname,port);
	return iRet;
}
//年票demo版交易函数
int CTrade::nianpiaoTrade(const char *title, int flag)
{
	int i=0,iRet = 0,iSelect;
	int data_len = 0;
	char name[31],year[5];
	char carnumColor[2+1],carnumColorDis[10];;
	char carTypeDis[20];
	char response_code[6];
	char temp[500];
	char send_data[1024],recv_data[1024];
	
    bbzero(name);
	bbzero(response_code);
	bbzero(gbl.car_no);
	bbzero(carnumColor);
	bbzero(carnumColorDis);
	bbzero(gbl.car_type);
	bbzero(carTypeDis);
	bbzero(gbl.telphone);
	bbzero(gbl.user_name);
	bbzero(year);
	
	strcpy(gbl.fee_type,"0400");
	wrLog("%s【年票按车牌号查询】", title);
	
	switch(flag)
	{
	case 1:
		strcpy(carnumColor,"01");
		strcpy(carnumColorDis,"蓝");
		strcpy(gbl.car_type,"02");
		break;
	case 2:
		strcpy(carnumColor,"01");
		strcpy(carnumColorDis,"蓝");
		strcpy(gbl.car_type,"03");
		break;
	case 3:
		strcpy(carnumColor,"02");
		strcpy(carnumColorDis,"黑");
		strcpy(gbl.car_type,"02");
		break;
	case 4:
		strcpy(carnumColor,"02");
		strcpy(carnumColorDis,"黑");
		strcpy(gbl.car_type,"03");
		break;
	case 5:
		strcpy(carnumColor,"03");
		strcpy(carnumColorDis,"黄");
		strcpy(gbl.car_type,"02");
		break;
	case 6:
		strcpy(carnumColor,"03");
		strcpy(carnumColorDis,"黄");
		strcpy(gbl.car_type,"03");
		break;
	default: 
		return CANCLE_KEY;
	}
	
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, title);
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入车牌号码:粤A");
	tradeInfoSend.Contents[0].uMinLen = 5;		
	tradeInfoSend.Contents[0].uMaxLen = 5;
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//数字
	tradeInfoSend.Contents[0].uCount = 0;		//输入1次		
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
	strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
	memcpy(gbl.car_no, (char *)tradeInfoRecv.Contents[0].uMsg, 5);
	
	
   	wrLog("车牌颜色：【%s】车辆类型：【%s】车牌号码是：【粤A%s】",carnumColor,gbl.car_type,gbl.car_no);
	
	//写查询域
	
	bbzero(send_data);
	sprintf(send_data,"0000000490500粤                  A%s      %s%s",gbl.car_no,gbl.car_type,carnumColor);
	wrLog("要发送的数据：%s",send_data);
	
	//发包收包 
	bbzero(recv_data);
	iRet =simplePackHdl(send_data,recv_data);
	if(iRet < 0)
		return -1;
	wrLog("接收的数据：%s",recv_data);
	i=9;
	memcpy(carTypeDis,recv_data+i,2);
	i+=2;
    memcpy(gbl.user_name,recv_data+i,8);
    i+=30;
   	memcpy(response_code,recv_data+i,5);
	i+=5;
    
	wrLog("车型代码：%s 车主姓名：%s 年票查询返回码：%s",carTypeDis,gbl.user_name,response_code);
	
	if (!memcmp(response_code,"00000",5))
	{  
		i+=34;
		memcpy(year,recv_data+i,4);
		if(atoi(year)==2010){
			TS_OutPutMsg(gbl.dPosInfo," \n   2010年年票已缴纳！\n\n   按【确认】返回",0,iSelect);
			return 0;
		}
		else if(atoi(year)<2009){
			TS_OutPutMsg(gbl.dPosInfo," \n   未交的年票过多！\n   请到交警处办理\n\n   按【确认】返回",0,iSelect);
			return 0;
		}
		bbzero(temp);
		sprintf(temp,"车牌：%s牌 粤A%s\n车型代码：%s\n车主：%s\n   2010年年票未缴交\n     按【确认】返回",carnumColorDis,gbl.car_no,carTypeDis,gbl.user_name);
		TS_OutPutMsg(gbl.dPosInfo,temp,0,iSelect);
		if(iSelect != 0)
			return -1;
	}
	else if (!memcmp(response_code,"20000",5))
	{
        TS_OutPutMsg(gbl.dPosInfo," \n   无该车牌记录！\n   按【确认】返回",0,iSelect);
		return 0;
	}
	else if (!memcmp(response_code,"30000",5))
	{
		TS_OutPutMsg(gbl.dPosInfo," \n 年票记录过多！\n\n   按【确认】返回",0,iSelect);
		return 0;
	}
	else{
		returnFail("96");
		return -1;
	}
	
	return 0;
}



int CTrade::NH_Transfer(const char *title)
{
	int  iRet=0 , flag = 1, curTry=0;
	int  iSelect;
	char tmp[512], card_info[201];
	char tra_amo[13], tra_amo_buff[20];	//交易金额
	char recv_name[20+1];
	char kh_bank[100+1];
	char card_num[30+1],card_len_buff[2+1];
	int card_len;
	TSMENULIST menuList;
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	
	strcpy(gbl.fee_type,"0001");
	
	wrLog("【演示版】农行转账业务");
	//输入金额
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	
	strcpy(tradeInfoSend.acMainTitle, title);
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 2;
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入收款人账卡：");
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_CARD;	//卡号
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
	tradeInfoSend.Contents[0].uMinLen = 1;		
	tradeInfoSend.Contents[0].uMaxLen = 25;	
	
	strcpy(tradeInfoSend.Contents[1].acTitle, "请输入收款人姓名：");
	tradeInfoSend.Contents[1].uCommand = TS_INPUT_CH;	//金额
	tradeInfoSend.Contents[1].uTimeOut = 60;	//超时30秒
	tradeInfoSend.Contents[1].uMinLen = 1;		
	tradeInfoSend.Contents[1].uMaxLen = 8;	
	wrLog("【转账】开始输入账号和姓名");
	
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		if(iRet == 1 || iRet ==2)
			wrLog("【转账】输入金额用户取消或超时");
		else
			wrLog("【转账】输入金额失败");
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return -1;
	}
	bbzero(recv_name);
	bbzero(card_num);
	strcpy(card_num, (char *)tradeInfoRecv.Contents[0].uMsg);	//读入卡号
	strcpy(recv_name, (char *)tradeInfoRecv.Contents[1].uMsg);	//读入姓名
	card_len = strlen(card_num);
	bbzero(card_len_buff);
	if (card_len<10)
	{
		sprintf(card_len_buff,"0%d",card_len);
	}else{
		sprintf(card_len_buff,"%d",card_len);
	}
	wrLog("到账卡号: [%s]", card_num);
	wrLog("收款人: [%s]", recv_name);
	
	bbzero(gbl.pos_serial);
	strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
	
	//下发显示选择营业厅
	memset(&menuList,0,sizeof(menuList));
	strcpy(menuList.acTitle, "请选择收款账户开户行");
	
	menuList.iTotalNum = 4;
	strcpy(menuList.menuItem[0], "中国农业银行");
	strcpy(menuList.menuItem[1], "中国工商银行");
	strcpy(menuList.menuItem[2], "中国建设银行");
	strcpy(menuList.menuItem[3], "其他银行");
	
	
	iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
	if(iRet)
		return -1;
	
	bbzero(kh_bank);
	switch (iSelect)
	{
	case 1:
		strcpy(kh_bank,"中国农业银行");
		break;
	case 2:
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		
		strcpy(tradeInfoSend.acMainTitle, title);
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents = 1;
		
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入收款账户开户行关键字：");
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_CH;	//卡号
		tradeInfoSend.Contents[0].uTimeOut = 60;	//超时30秒
		tradeInfoSend.Contents[0].uMinLen = 1;		
		tradeInfoSend.Contents[0].uMaxLen = 9;	
		
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		if(iRet != 0)
		{
			if(iRet == 1 || iRet ==2)
				wrLog("【转账】输入金额用户取消或超时");
			else
				wrLog("【转账】输入金额失败");
			wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
			return -1;
		}
		
		memset(&menuList,0,sizeof(menuList));
		strcpy(menuList.acTitle, "请选择收款账户开户行");
		
		menuList.iTotalNum = 3;
		strcpy(menuList.menuItem[0], "工商广州东山支行");
		strcpy(menuList.menuItem[1], "工商宜昌东山支行");
		strcpy(menuList.menuItem[2], "工商汕头东山支行");
		
		
		iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
		if(iRet)
			return -1;
		switch (iSelect)
		{
		case 1:
			strcpy(kh_bank,"工商广州东山支行");
			break;
		case 2:
			strcpy(kh_bank,"工商宜昌东山支行");
			break;
		case 3:
			strcpy(kh_bank,"工商汕头东山支行");
			break;
		default:
			return -1;
		}
		break;
		case 3:
			memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
			
			strcpy(tradeInfoSend.acMainTitle, title);
			tradeInfoSend.uHasTradeID = 1;
			tradeInfoSend.uTotalContents = 1;
			
			strcpy(tradeInfoSend.Contents[0].acTitle, "请输入收款账户开户行关键字：");
			tradeInfoSend.Contents[0].uCommand = TS_INPUT_CH;	//卡号
			tradeInfoSend.Contents[0].uTimeOut = 60;	//超时30秒
			tradeInfoSend.Contents[0].uMinLen = 1;		
			tradeInfoSend.Contents[0].uMaxLen = 9;	
			
			memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
			iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
			if(iRet != 0)
			{
				if(iRet == 1 || iRet ==2)
					wrLog("【转账】输入金额用户取消或超时");
				else
					wrLog("【转账】输入金额失败");
				wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
				return -1;
			}
			
			memset(&menuList,0,sizeof(menuList));
			strcpy(menuList.acTitle, "请选择收款账户开户行");
			
			menuList.iTotalNum = 3;
			strcpy(menuList.menuItem[0], "建行广州东山支行");
			strcpy(menuList.menuItem[1], "建行宜昌东山支行");
			strcpy(menuList.menuItem[2], "建行汕头东山支行");
			
			
			iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
			if(iRet)
				return -1;
			switch (iSelect)
			{
			case 1:
				strcpy(kh_bank,"建行广州东山支行");
				break;
			case 2:
				strcpy(kh_bank,"建行宜昌东山支行");
				break;
			case 3:
				strcpy(kh_bank,"建行汕头东山支行");
				break;
			default:
				return -1;
			}
			break;
			case 4:
				memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
				
				strcpy(tradeInfoSend.acMainTitle, title);
				tradeInfoSend.uHasTradeID = 1;
				tradeInfoSend.uTotalContents = 1;
				
				strcpy(tradeInfoSend.Contents[0].acTitle, "请输入收款账户开户行关键字：");
				tradeInfoSend.Contents[0].uCommand = TS_INPUT_CH;	//卡号
				tradeInfoSend.Contents[0].uTimeOut = 60;	//超时30秒
				tradeInfoSend.Contents[0].uMinLen = 1;		
				tradeInfoSend.Contents[0].uMaxLen = 9;	
				
				memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
				iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
				if(iRet != 0)
				{
					if(iRet == 1 || iRet ==2)
						wrLog("【转账】输入金额用户取消或超时");
					else
						wrLog("【转账】输入金额失败");
					wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
					return -1;
				}
				
				memset(&menuList,0,sizeof(menuList));
				strcpy(menuList.acTitle, "请选择收款账户开户行");
				
				menuList.iTotalNum = 3;
				strcpy(menuList.menuItem[0], "建行广州东山支行");
				strcpy(menuList.menuItem[1], "建行宜昌东山支行");
				strcpy(menuList.menuItem[2], "建行汕头东山支行");
				
				
				iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
				if(iRet)
					return -1;
				switch (iSelect)
				{
				case 1:
					strcpy(kh_bank,"建行广州东山支行");
					break;
				case 2:
					strcpy(kh_bank,"建行宜昌东山支行");
					break;
				case 3:
					strcpy(kh_bank,"建行汕头东山支行");
					break;
				default:
					return -1;
				}
				break;
				default:
					return -1;
	}
	//输入金额
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	
	strcpy(tradeInfoSend.acMainTitle, title);
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入转账金额：");
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_MONEY;	//金额
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
	tradeInfoSend.Contents[0].uMinLen = 1;		
	tradeInfoSend.Contents[0].uMaxLen = 8;	
	wrLog("【转账】开始输入金额");
	for(curTry=0; curTry<MAXTRY; curTry++)
	{
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		if(iRet != 0)
		{
			if(iRet == 1 || iRet ==2)
				wrLog("【转账】输入金额用户取消或超时");
			else
				wrLog("【转账】输入金额失败");
			wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
			return -1;
		}
		bbzero(tra_amo);
		strcpy(tra_amo, (char *)tradeInfoRecv.Contents[0].uMsg);	//读入金额
		wrLog("tra_amo: [%s]", tra_amo);
		if(atoi(tra_amo)>10000000)
		{
			TS_OutPutMsg(gbl.dPosInfo, "超过最大金额(10万元)\n【确认】重新输入\n【返回】退出", 0, iSelect);
			if(iSelect)
				return CANCLE_KEY;
			else
				continue;
		}
		else
			break;
	}
	bbzero(tmp);
	bbzero(gbl.amount);
	bbzero(tra_amo_buff);
	strcpy(gbl.amount,tra_amo);
	CTools::chgToMny(gbl.amount, tra_amo_buff);
	sprintf(tmp,"收款账号：\n  %s\n收款人姓名：%s\n开户行名称：\n  %s\n转账金额：%s\n\n        【确认】继续",card_num,recv_name,kh_bank,tra_amo_buff);
	TS_OutPutMsg(gbl.dPosInfo, tmp, 0, iSelect);
	if (iSelect!=0)
	{
		return -1;
	}
	//刷卡
	wrLog("【转账】开始刷卡");
	for(curTry=0; curTry<MAXTRY; curTry++)
	{
		bbzero(card_info);
		iRet = getCardInfo(title, card_info);//刷卡取得卡信息
		if( iRet == 0 )
			iRet = getCardNum(card_info);//取得卡号
		
		if(!iRet)
			break;
		else if(iRet == CANCLE_KEY)
		{
			wrLog("【转账】取消刷卡");
			return CANCLE_KEY;
		}
		else if(iRet == RE_MNG_CARD)
		{
			wrLog("【转账】重新刷卡");
			continue;
		}
		else if(iRet != 0)
		{
			wrLog("【转账】刷卡失败");
			return -1;
		}
	}
	wrLog("【转账】刷卡成功");
	
	
	wrLog("【转账】开始输密码");
	for(curTry=0; curTry<MAXTRY; curTry++)
	{
		iRet = getCardPwd(title);	//取得密码
		
		if(iRet == CANCLE_KEY)
		{
			wrLog("【转账】密码取消");
			return CANCLE_KEY;
		}
		else if(iRet != 0)
		{
			wrLog("【转账】密码返回失败");
			return -1;
		}
		
		wrLog("【转账】输入密码成功");
		
		wrLog("【转账】转帐成功！");
		TS_OutPutMsg(gbl.dPosInfo, "\n      转帐成功！\n  按【确认】打印票据", 0, iSelect);
		CPrint prt;
		prt.set_in_par(gbl);
		iRet = prt.print_NHBank_detail(card_num,recv_name,kh_bank,tra_amo_buff);	 //打印明细
		return 0;
		
	}
	return -1;
	
}

int CTrade::customer_sign()
{
	int iRet=0, iRetB=0, iSelect=0;
	char mark_card[30+1];
	
	bbzero(mark_card);
	strncpy(mark_card, gbl.card_no, sizeof(mark_card)-1);
	iRet = customer_sign_Hdl();
	if( gbl.get_card == MNG_ONE || gbl.get_card == MNG_ONE_BIND || gbl.get_card == MNG_ONE_BIND_E || gbl.get_card == MNG_MUL_BIND_E )//还原原先刷的卡
	{
		iRetB = bindcard(mark_card, gbl.card_no, &gbl.card_no_len);
		if(iRetB != 0)
		{
			TS_OutPutMsg(gbl.dPosInfo,"绑定原卡号出错!请挂机重连!",0,iSelect);
			TS_HangUp(gbl.dPosInfo);
		}
	}
	return iRet;
}

int CTrade::customer_sign_Hdl()
{                  
	int  iSelect,curTry=0;
	char response_code[3];
	char tmp[10];
	int name_len=0;	
	int id_len=0;
	int iRet;
	char temp_buff[250];
	char title[1024];
	int tel_type=0;
	char pwd_buf[8+1],name_len_buff[2+1];
	//	char amo_buff[13], amount[13];
	bbzero(title);
	memcpy(title,"商户签约",strlen("商户签约"));
	if(atoi(gbl.dPosInfo.prmVer)>=9000){
		TS_OutPutMsg(gbl.dPosInfo,"商户签约步骤：\n1、刷银行卡输入密码\n2、输入身份证号码\n3、输入手机号码\n4、设置老板密码\n5、输入银行卡户名",1,iSelect);
	}else{
		TS_OutPutMsg(gbl.dPosInfo,"商户签约步骤：\n1、刷银行卡\n2、输入身份证号码\n3、输入商户终端号\n4、设置老板密码",1,iSelect);
	}
	if (iSelect!=0)
	{
		return -1;
	}           
	
	//刷卡
	wrLog("开始刷卡");
	int flag = 0;
	bbzero(gbl.fee_type);
	strcpy(gbl.fee_type,"0177");
	for(curTry=0; curTry<MAXTRY; curTry++)
	{
		if(!flag)
		{
			if( gbl.get_card == MNG_ONE || gbl.get_card == MNG_ONE_BIND || gbl.get_card == MNG_ONE_BIND_E || gbl.get_card == MNG_MUL_BIND_E )//还原原先刷的卡
				iRet = mngCard_Hdl(title, "", 0, 1);//业务需要，一定要刷卡，且只能刷卡
			else
				iRet = mngCard_Hdl(title);
			if(iRet == CANCLE_KEY)
				return CANCLE_KEY;
			else if(iRet != 0)
				return -1;
		}
		bbzero(gbl.amount);
		strcpy(gbl.amount,"000000000001");
		pack.wrField(2, gbl);	//写交费域
		/*----------------------------------*/
		
		bbzero(pack.FIELD48);
		memcpy(pack.FIELD48, gbl.fee_type, 4);
		strncat((char *)pack.FIELD48, "00", 2);
		pack.Packet_Table[48].Real_Length = 6;
		
		bbzero(pack.FIELD63);
		memcpy(pack.FIELD63,gbl.random_num,8);
		pack.Packet_Table[63].Real_Length = 8;
		/*----------------------------------*/
		//打查询包
		iRet = packHdl(2);
		if(iRet < 0)
			return -1;
		
		if (!memcmp(pack.FIELD39,"00",2)) 
		{
			break;
		}
		else if(!memcmp(pack.FIELD39,"55",2) || !memcmp(pack.FIELD62, "P20004855", 9))
		{
			flag = 1;
			if(reGetPwd(title) == 0) //密码错误，重新输入密码
				continue;
			else
				return CANCLE_KEY;
		}
		else
		{
			iRet = banReturnFail((char *)pack.FIELD39);
			return -1;
		}
	}
	
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	//////////////////////////////////////////////////////////////////////////
	//输入身份证号
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	
	strcpy(tradeInfoSend.acMainTitle, "商户签约");
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;	
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入您的身份证号码");
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//全字符(因身份证末尾可能有字母)
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME + 10;	//超时40秒
	tradeInfoSend.Contents[0].uMinLen = 15;	
	tradeInfoSend.Contents[0].uMaxLen = 18;
	
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	memset( gbl.custom_id_card,0,sizeof(gbl.custom_id_card) );
	memcpy(gbl.custom_id_card,(char *)tradeInfoRecv.Contents[0].uMsg,tradeInfoRecv.Contents[0].uMsgLen);
	wrLog("身份证号码:[%s]", gbl.custom_id_card);
	wrLog("身份证长度:[%d]", strlen(gbl.custom_id_card)); 
	
	//////////////////////////////////////////////////////////////////////////
	//输入手机号
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
    
	if(atoi(gbl.dPosInfo.prmVer)>=9000)
	{
		strcpy(tradeInfoSend.acMainTitle, "商户签约");
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents = 1;	
		
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入手机号码：");
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME + 10;	//超时40秒
		tradeInfoSend.Contents[0].uCount = 0;		//输入1次
		tradeInfoSend.Contents[0].uMinLen = 11;		
		tradeInfoSend.Contents[0].uMaxLen = 11;
		
	}else{
		
		strcpy(tradeInfoSend.acMainTitle, "商户签约");
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents = 2;	
		
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入手机号码：");
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME + 10;	//超时40秒
		tradeInfoSend.Contents[0].uCount = 0;		//输入1次
		tradeInfoSend.Contents[0].uMinLen = 11;		
		tradeInfoSend.Contents[0].uMaxLen = 11;
		
		strcpy(tradeInfoSend.Contents[1].acTitle, "请输入商户终端号");
		tradeInfoSend.Contents[1].uCommand = TS_INPUT_MATH;	
		tradeInfoSend.Contents[1].uTimeOut = EPOS_OVER_TIME + 10;	//超时40秒
		tradeInfoSend.Contents[1].uCount = 0;		//输入1次
		tradeInfoSend.Contents[1].uMinLen = 8;		
		tradeInfoSend.Contents[1].uMaxLen = 8;
	}
	
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	memset( gbl.telphone,0,sizeof(gbl.telphone) );
	memcpy(gbl.telphone,(char *)tradeInfoRecv.Contents[0].uMsg,tradeInfoRecv.Contents[0].uMsgLen);  
	memset( gbl.custom_no,0,sizeof(gbl.custom_no) );
	if(atoi(gbl.dPosInfo.prmVer)>=9000)
	{
        memcpy(gbl.custom_no,gbl.pos_no,8);
	}else{
		memcpy(gbl.custom_no,(char *)tradeInfoRecv.Contents[1].uMsg,tradeInfoRecv.Contents[1].uMsgLen); 
	}
	
	//////////////////////////////////////////////////////////////////////////
	//输入老板密码
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	
	strcpy(tradeInfoSend.acMainTitle, "商户签约");
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;	
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请设置老板密码");
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_PWD;	//密码
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME + 10;	//超时40秒
	tradeInfoSend.Contents[0].uCount = 1;		//输入2次
	tradeInfoSend.Contents[0].uMinLen = 6;		
	tradeInfoSend.Contents[0].uMaxLen = 6;
	
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	memset( gbl.custom_pwd,0,sizeof(gbl.custom_pwd) );
	memcpy(gbl.custom_pwd,(char *)tradeInfoRecv.Contents[0].uMsg,tradeInfoRecv.Contents[0].uMsgLen);  
	memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
	strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
	
	//////////////////////////////////////////////////////////////////////////
	//输入用户名
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	
	strcpy(tradeInfoSend.acMainTitle, "商户签约");
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;	
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入姓名");
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//密码
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME + 10;	//超时40秒
	tradeInfoSend.Contents[0].uCount = 0;		
	tradeInfoSend.Contents[0].uMinLen = 4;		
	tradeInfoSend.Contents[0].uMaxLen = 30;
	
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	memset( gbl.user_name,0,sizeof(gbl.user_name) );
	memcpy(gbl.user_name,(char *)tradeInfoRecv.Contents[0].uMsg,tradeInfoRecv.Contents[0].uMsgLen);  
	bbzero(name_len_buff);
	sprintf(name_len_buff,"%02d",tradeInfoRecv.Contents[0].uMsgLen);
	memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
	strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
	
	
	bbzero(gbl.fee_type);
	strcpy(gbl.fee_type,"0269");
	pack.wrField(1, gbl);
	bbzero(pack.FIELD3);
	bbzero(pack.FIELD48);
	CTools::hex_to_byte((BYTE *)"310060", pack.FIELD3, 6);
	memcpy(pack.FIELD48,gbl.fee_type,4);
	memcpy(pack.FIELD48+4,"08",2);
	memcpy(pack.FIELD48+6,gbl.custom_no,8);	
	pack.Packet_Table[48].Real_Length=14;
	
	bbzero(pack.FIELD63);
	pack.Packet_Table[63].Real_Length = 0;
	bbzero(pwd_buf);
	if(TEKEny(gbl.dPosInfo,gbl.custom_pwd,6,"2000000000000001",pwd_buf)>=0)
	{
		NULL;
	}
	else
	{
		TS_OutPutMsg(gbl.dPosInfo, "\n签约出错\n请稍候再试!\n或联系在线客服中心【Ctrl+H】  400-80-11888", 0, iSelect);
		return -1;
	}
	memcpy(pack.FIELD63,pwd_buf,8);
	pack.Packet_Table[63].Real_Length +=8;
	id_len=strlen(gbl.custom_id_card );
	bbzero(tmp);
	sprintf(tmp,"%02d",id_len);
	memcpy(pack.FIELD63+8,tmp,2);
	pack.Packet_Table[63].Real_Length += 2;
	memcpy(pack.FIELD63+10,gbl.custom_id_card,id_len);
	pack.Packet_Table[63].Real_Length += id_len;
	memcpy(pack.FIELD63+10+id_len,"11",2);
	pack.Packet_Table[63].Real_Length += 2;
	memcpy(pack.FIELD63+12+id_len,gbl.telphone,11);
	pack.Packet_Table[63].Real_Length += 11;
	memcpy(pack.FIELD63+23+id_len,name_len_buff,2);
	pack.Packet_Table[63].Real_Length += 2;
	memcpy(pack.FIELD63+25+id_len,gbl.user_name,atoi(name_len_buff));
	pack.Packet_Table[63].Real_Length += atoi(name_len_buff);
	
	//bit2
	memset(pack.FIELD2, 0, sizeof(pack.FIELD2));
	memset((char *)temp_buff,0,sizeof(temp_buff));
	strcpy((char *)temp_buff,gbl.card_no);
	CTools::hex_to_byte((BYTE *)temp_buff, pack.FIELD2, gbl.card_no_len, 1);	//变为bcd码（后补0）
	pack.Packet_Table[2].Real_Length=gbl.card_no_len;
	//  查询包打包   
	if(packHdl(1) < 0)
	{
		return -1;
	}
	else{
		memset(response_code,0,sizeof(response_code));
		memcpy(response_code,pack.FIELD39,2);
		if (!memcmp(response_code,"00",2)) 
		{
			bbzero(gbl.stan_no);
			memcpy(gbl.stan_no,(char *)pack.FIELD37,12);
            TS_OutPutMsg(gbl.dPosInfo, "\n      签约成功！\n  按【确认】打印票据", 0, iSelect);
			if(iRet!=0 || iSelect==0)
			{
				CPrint prt;
				prt.set_in_par(gbl);
				iRet = prt.print_customsign_detail(gbl.custom_id_card,gbl.custom_no,gbl.telphone);	 //打印明细
			}
			return 0;
        }
		else{
			returnFail((char *)pack.FIELD39);
			return -1;
		}
	}              
}



int CTrade::car_np_Trade(const char *title, int input_flag)
{
	int iRet,iSelect,flag;
	char message_buff[20+1],length_buff[2+1],np_year[4+1],buff[512],car_owner[2+1],car_type[2+1],np_fee[10+1];
	
	//	TSMENULIST menuList;
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	
	if(strcmp(gbl.acc_city_no, "020")==0)
	{
		NULL;
	}
	else
	{
		TS_OutPutMsg(gbl.dPosInfo,"汽车年票 东莞地区用户暂未开通\n  请按【确认】返回" ,0, iSelect);
		return -1;
	}
	
	if (input_flag==0)
	{
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
		
		strcpy(tradeInfoSend.acMainTitle, title);
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents = 1;
		
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入车牌号码:粤A");
		tradeInfoSend.Contents[0].uMinLen = 5;		
		tradeInfoSend.Contents[0].uMaxLen = 5;
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//数字
		tradeInfoSend.Contents[0].uCount = 0;		//输入1次		
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
		
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		
		if(iRet != 0)
		{
			wrLog("TS_TradeControl返回错误[%d]", iRet);
			wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
			return iRet;
		}
		memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
		strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
		memcpy(gbl.car_no, (char *)tradeInfoRecv.Contents[0].uMsg, 5);
	}
	
	
	// 	memset(&menuList,0,sizeof(menuList));
	// 	strcpy(menuList.acTitle, "请选择车牌颜色及车型");
	// 	
	// 	menuList.iTotalNum = 1;
	// 	strcpy(menuList.menuItem[0], "蓝牌六座以下");	
	// 	
	// 	iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
	// 	if(iRet)
	// 		return -1;
	// 	
	// 	switch (iSelect)
	// 	{
	// 	case 1:
	// 		break;
	// 	default:
	// 		return -1;
	// 	}
	
	bbzero(message_buff);
	strcat(message_buff,"粤");
	if (strlen(gbl.car_no)==5)
	{
		strcat(message_buff,"A");
	}	
	strcat(message_buff,gbl.car_no);
	strcat(message_buff,"02");
	strcat(message_buff,"蓝");
	bbzero(length_buff);
	sprintf(length_buff,"%02d",strlen(message_buff));
	bbzero(gbl.fee_type);
	strcpy(gbl.fee_type,"0270");
	pack.wrField(1, gbl);
	bbzero(pack.FIELD3);
	bbzero(pack.FIELD48);
	CTools::hex_to_byte((BYTE *)"310000", pack.FIELD3, 6);
	memcpy(pack.FIELD48,gbl.fee_type,4);
	memcpy(pack.FIELD48+4,length_buff,2);
	memcpy(pack.FIELD48+6,message_buff,atoi(length_buff));	
	pack.Packet_Table[48].Real_Length=6+atoi(length_buff);
	
	if(packHdl(1) < 0)
	{
		return -1;
	}
	
	bbzero(np_year);
	bbzero(car_owner);
	bbzero(car_type);
	bbzero(np_fee);
	memcpy(car_owner,pack.FIELD63,2);
	memcpy(car_owner,pack.FIELD63+2,2);
	memcpy(np_year,pack.FIELD63+4,4);
	memcpy(np_fee,pack.FIELD63+8,10);
	
	if (!memcmp(pack.FIELD39,"00",2))
	{
		if (strcmp(np_year,"2010")==0)
		{
			if (input_flag == 1)
			{
				return -1;
			}
			TS_OutPutMsg(gbl.dPosInfo,"\n 2010年年票已经交纳\n  请按【确认】返回" ,0, iSelect);
			return -1;
		}else if (strcmp(np_year,"2009")==0)
		{
			// 			if (atoi(np_fee)!=98000)
			// 			{
			// 				if (input_flag == 1)
			// 				{
			// 					return -1;
			// 				}
			// 				TS_OutPutMsg(gbl.dPosInfo,"\n 2010年年票金额不符\n 请到年票营业厅咨询\n  请按【确认】返回" ,0, iSelect);
			// 				return -1;
			// 			}
			if (input_flag == 1)
			{
				return 0;
			}
			bbzero(buff);
			if (strlen(gbl.car_no)==5)
			{
				sprintf(buff,"车牌号码：粤A%s\n车牌颜色：蓝\n车型代码：02\n车主名称：%s**\n2010年年票未缴纳\n    按【确认】交费",gbl.car_no,car_owner);
				
			}else
				sprintf(buff,"车牌号码：粤%s\n车牌颜色：蓝\n车型代码：02\n车主名称：%s**\n2010年年票未缴纳\n    按【确认】交费",gbl.car_no,car_owner);
			TS_OutPutMsg(gbl.dPosInfo,buff ,0, iSelect);
			if (iSelect!=0)
			{
				return -1;
			}
		}else{
			if (input_flag == 1)
			{
				return -1;
			}
			TS_OutPutMsg(gbl.dPosInfo,"\n  您的未交年票过多\n 请到年票营业厅办理。" ,0, iSelect);
			return -1;
		}
	}else
	{
		if (input_flag == 1)
		{
			return -1;
		}
		returnFail((char *)pack.FIELD39);
		return -1;
	}
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, title);
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入手机号码");
	tradeInfoSend.Contents[0].uMinLen = 11;		
	tradeInfoSend.Contents[0].uMaxLen = 11;
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
	tradeInfoSend.Contents[0].uCount = 1;		//输入1次		
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
	strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
	bbzero(gbl.telphone);
	memcpy(gbl.telphone, (char *)tradeInfoRecv.Contents[0].uMsg, 11);
	
	TS_OutPutMsg(gbl.dPosInfo,"2010年年费：980元\n代办服务费：25元\n合计：1005元\n\n按【确认】交纳" ,0, iSelect);
	if (iSelect!=0)
	{
		return -1;
	}
	bbzero(gbl.amount);
	strcpy(gbl.amount,"000000100500");
	
	flag = 0;
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{
		if(!flag)
		{
			iRet = mngCard_Hdl(title);
			if(iRet == CANCLE_KEY)
				return CANCLE_KEY;
			else if(iRet != 0)
				return -1;
		}
		if(!memcmp(gbl.card_no,"8828",4))	//若是付费易卡
		{
			memset(gbl.xlt_type, 0, sizeof(gbl.xlt_type));
			memcpy(gbl.xlt_type, "01",2);
			iRet = xltMulCard( title, 0);
			return iRet;
		}
		
		pack.wrField(2, gbl);	//写交费域
		
		/*------------------------------*/
		bbzero(pack.FIELD48);
		bbzero(pack.FIELD63);
		
		memcpy(pack.FIELD48,gbl.fee_type,4);
		memcpy(pack.FIELD48+4,length_buff,2);
		memcpy(pack.FIELD48+6,message_buff,atoi(length_buff));	
		pack.Packet_Table[48].Real_Length=6+atoi(length_buff);
		
		memcpy(pack.FIELD63+8, gbl.telphone, 11);
		pack.Packet_Table[63].Real_Length = 19;
		/*------------------------------*/
		
		iRet = packHdl(2);
		if(iRet < 0)
			return -1;
		
		if (!memcmp(pack.FIELD39,"00",2))
		{
			bbzero(gbl.stan_no);
			memcpy(gbl.stan_no,(char *)pack.FIELD37,12);
			iRet = TS_OutPutMsg(gbl.dPosInfo,"     交费成功！\n    谢谢您的使用\n请按【确认】打印凭条",0,iSelect);
			if(iRet!=0 || iSelect==0)
			{
				CPrint prt;
				prt.set_in_par(gbl);
				prt.print_np(car_owner,gbl.car_no,gbl.telphone);	//打印明细
			}
			return 0;
		}
		else if(!memcmp(pack.FIELD39,"55",2))
		{
			flag = 1;
			if(reGetPwd( title) == 0) //密码错误，重新输入密码, 2006-11-09 KF ADD
				continue;
			else
				return CANCLE_KEY;
		}
		else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
			if (iSelect!=0)
			{
				return -1;
			}else
				continue;
		}
		else
			returnFail((char *)pack.FIELD39);
		return -1;
	}
	return 0;
}

//int inout:0交费 1充值 mode:0老板模式 1员工模式
int CTrade::iposTxnEnq(const char *title, int inout, int mode,int mbl_flag, int query_flag)
{
	int iRet=0, count=0, status=0, iSelect=0, itemNum=0;
	char date[16+1], msg[300],end_date[8+1],start_date[8+1];
	TSTxnLogs txnLogs;
	
	if (inout==1 || mode==0)
	{
		if(atoi(gbl.dPosInfo.prmVer)>=9000)
		{
			iRet = checkPEPwd_Hdl(title);
			if(iRet!=0)
				if(iRet==CANCLE_KEY)
					return CANCLE_KEY;
				else
				{	
					info("老板密码校验错误\n\n请联系在线客服中心【Ctrl+H】  400-80-11888\n\n按【Enter】确认返回主菜单。");
					return iRet;
					
				}
		}
	}
	else
	{
		NULL;
	}
	
	if(query_flag == 1)
	{
		bbzero(date);
		CTime cTxnTime = CTime::GetCurrentTime() - CTimeSpan(0,24,0,0);
		sprintf(date, "%02d%02d%02d", cTxnTime.GetHour(), cTxnTime.GetMinute(), cTxnTime.GetSecond());
	}
	else if( inout==1 )//充值
	{
		bbzero(date);
		status = 3;
	}
	else
	{
		TSTradeInfoSend tradeInfoSend;
		TSTradeInfoRecv tradeInfoRecv;
		
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
		
		strcpy(tradeInfoSend.acMainTitle, title);
		tradeInfoSend.uHasTradeID = 1;
		
		if(mode==0)
		{
			strcpy(tradeInfoSend.Contents[0].acTitle, "请输入起始日期");
			tradeInfoSend.Contents[0].uCommand = TS_INPUT_DATE;	
			tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;//超时30秒
			tradeInfoSend.Contents[0].uMinLen = 8;	
			tradeInfoSend.Contents[0].uMaxLen = 8;
			
			strcpy(tradeInfoSend.Contents[1].acTitle, "请输入终止日期");
			tradeInfoSend.Contents[1].uCommand = TS_INPUT_DATE;	
			tradeInfoSend.Contents[1].uTimeOut = EPOS_OVER_TIME;//超时30秒
			tradeInfoSend.Contents[1].uMinLen = 8;	
			tradeInfoSend.Contents[1].uMaxLen = 8;
			
			strcpy(tradeInfoSend.Contents[2].acTitle, "请输入交易结果:1成功;2失败;3全部");
			tradeInfoSend.Contents[2].uCommand = TS_INPUT_MATH;
			tradeInfoSend.Contents[2].uTimeOut = EPOS_OVER_TIME;//超时30秒
			tradeInfoSend.Contents[2].uMinLen = 1;
			tradeInfoSend.Contents[2].uMaxLen = 1;
			
			tradeInfoSend.uTotalContents = 3;
		}
		else
		{
			strcpy(tradeInfoSend.Contents[0].acTitle, "请输入日期");
			tradeInfoSend.Contents[0].uCommand = TS_INPUT_DATE;	
			tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;//超时30秒
			tradeInfoSend.Contents[0].uMinLen = 8;	
			tradeInfoSend.Contents[0].uMaxLen = 8;
			tradeInfoSend.uTotalContents = 1;
		}
		
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		if(iRet != 0)
		{
			wrLog("TS_TradeControl返回错误[%d]", iRet);
			wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
			return iRet;
		}
		
		if(mode==0)
		{
			bbzero(date);
			bbzero(start_date);
			bbzero(end_date);
			memcpy(start_date, (char *)tradeInfoRecv.Contents[0].uMsg, 8);
			memcpy(end_date, (char *)tradeInfoRecv.Contents[1].uMsg, 8);
			sprintf(date,"%s%s",start_date,end_date);
			status = tradeInfoRecv.Contents[2].uMsg[0]-'0';
			int nYear=0, nMonth=0, nDay=0, nHour=0, nMin=0, nSec=0;
			char buff[4+1];
			bbzero(buff);
			memcpy(buff,start_date,4);
			nYear = atoi(buff);
			bbzero(buff);
			memcpy(buff,start_date+4,2);
			nMonth = atoi(buff);
			bbzero(buff);
			memcpy(buff,start_date+6,2);
			nDay = atoi(buff);
			
			if(CTools::chkDate(nYear, nMonth, nDay)==0)
			{
				CTime start_cTxnTime = CTime(nYear, nMonth, nDay, nHour, nMin, nSec);
				bbzero(buff);
				memcpy(buff,end_date,4);
				nYear = atoi(buff);
				bbzero(buff);
				memcpy(buff,end_date+4,2);
				nMonth = atoi(buff);
				bbzero(buff);
				memcpy(buff,end_date+6,2);
				nDay = atoi(buff);
				if(CTools::chkDate(nYear, nMonth, nDay)==0)
				{
					CTime end_cTxnTime = CTime(nYear, nMonth, nDay, nHour, nMin, nSec);
					if( start_cTxnTime < end_cTxnTime - CTimeSpan(31*3,0,0,0) )
					{
						TS_OutPutMsg(gbl.dPosInfo, "您输入的日期段间隔超过三个月，请登陆商户自服务门户查询", 0, iSelect);
						return -1;
					}
					if( start_cTxnTime > end_cTxnTime  )
					{
						TS_OutPutMsg(gbl.dPosInfo, "请确认您输入的起始日期小于等于终止日期", 0, iSelect);
						return -1;
					}
				}
				else
				{
					TS_OutPutMsg(gbl.dPosInfo, "您输入的日期格式不符，无法进行查询", 0, iSelect);
					return -1;
				}				
			}
			else
			{
				TS_OutPutMsg(gbl.dPosInfo, "您输入的日期格式不符，无法进行查询", 0, iSelect);
				return -1;
			}
		}
		else
		{
			bbzero(date);
			memcpy(date, (char *)tradeInfoRecv.Contents[0].uMsg, 8);
			status = 3;
		}
	}	
	
	
	memset(&txnLogs, 0, sizeof(txnLogs));
	
	if (inout == 1 && mode == 0)
	{
		//iRet = CDB::getEcardTrade(gbl.mer_ecard,&txnLogs, &itemNum);
		//20130114-自定义报文查找资金到账记录
		iRet = CDB::getEcardTxnLogs(gbl.mer_ecard,gbl.pos_no,&txnLogs, &itemNum);
	} else {
		iRet = CDB::getTxnLogs(gbl.pos_no, date, status, inout, mode, &txnLogs, &itemNum, gbl.Reversal_count,mbl_flag);
	}

	if(iRet!=0)
	{
		if(itemNum>MAX_TXN_LOG)
		{
			bbzero(msg);
			sprintf(msg, "查找的结果共 %d 条, 已超出最大查找条数 %d 条!\n\n请重新选择条件进行查找!", itemNum, MAX_TXN_LOG);
			TS_OutPutMsg(gbl.dPosInfo, msg, 0, iSelect);
		}
		else if( itemNum<=0 )
		{
			bbzero(msg);
			sprintf(msg, "没有找到交易记录!\n\n请重新选择条件进行查找!");
			TS_OutPutMsg(gbl.dPosInfo, msg, 0, iSelect);
		}
		else
		{
			TS_OutPutMsg(gbl.dPosInfo, "网络繁忙，查找出错!\n\n请稍后再查!", 0, iSelect);
		}
		return iRet;
	}
	iRet = TS_ShowTxnLogs(gbl.dPosInfo, &txnLogs);
	if(iRet != 0)
	{
		wrLog("TS_ShowTxnLogs返回错误[%d]", iRet);
		return iRet;
	}
	
	return 0;
}

//门户调用
//type = 0;单点登录-日交易查询
//type = 1；资金明细查询
int CTrade::online_ser(const std::string& url, int b_boss)
{
    //char url1[1024]   = { 0 };
	char urlhead[1024] = {0};
    char inBuf[1024]  = { 0 };
    char hexBuf[1024] = { 0 };
    char DesBuf[1024] = { 0 };
    char b64Buf[1024] = { 0 };
    char outURL[2048] = { 0 };
    char curtime[20]  = { 0 };
    char curdate[20]  = { 0 };
    char randnum[6]   = { 0 };
    char* key = "61224F588810403828557951CBDD556677297498534036E3";
	//工号
	string staff = "";
	if (b_boss == 0) {
		staff = gbl.dPosInfo.pos_no + string("_01");
	} else {
		staff = gbl.dPosInfo.pos_no;
	}
    //URL由两部分组成，后面参数中的才是真实URL，此处取HEAD只是公用URL，补进入加密
    int iRet = 0;
	if(!memcmp(gbl.pos_no+4, "99", 2) || strcmp(gbl.ip,"132.97.45.31")==0)
	{
		iRet = GetPrivateProfileString ("ONLINE", "dcn_prefix", NULL, (char *)urlhead, sizeof(urlhead), ".\\ctsi.ini"); 

	}
	else
	{
	 	iRet = GetPrivateProfileString ("ONLINE", "prefix", NULL, (char *)urlhead, sizeof(urlhead), ".\\ctsi.ini"); 
	}

	if (iRet < 0) {
		return -1;
	}
    wrLog("配置的URL公共头:[%s]", urlhead);

    CTools::get_termTime(curtime);
    CTools::getDate(curdate);
    srand(time(NULL));
    sprintf(randnum, "%04d", rand()%9999);
    sprintf(inBuf, "TermID=%s&&&StreamID=%s%s&&&StaffID=%s&&&URL=%s", gbl.dPosInfo.pos_no, curtime, randnum, staff.c_str(), url.c_str());
    int src_len = strlen(inBuf);    //源串长
    int prefix_n= 8-src_len%8;      //补位长
    //补足8的倍数。
    memcpy(inBuf + src_len, "\x20\x20\x20\x20\x20\x20\x20\x20", prefix_n);
	wrLog("URL参数串:[%s]", inBuf);
    //转BCD
    CTools::byte_to_hex((BYTE*)inBuf, (BYTE*)hexBuf, src_len + prefix_n);
    wrLog("URL参数BCD串:[%s]", hexBuf);
	//3DES
    CDes::TripleDesEncrypt(key, hexBuf, DesBuf);
    strcat(DesBuf, "31031D73E63C39B6"); //只有加了这个，嘉荣才能解开？？？其实就是8个0x08加密后的结果,0x08就是backspce
    wrLog("3DES加密串:[%s]", DesBuf);
    //BASE64
    //CDes::base64(b64Buf, DesBuf, strlen(DesBuf));
    //wrLog("BASE64加密串:[%s]", b64Buf);
    sprintf(outURL, "%s?BSTokenRequest=%s", urlhead, DesBuf);
    wrLog("最后URL:[%s]", outURL);

    //strcpy(outURL , "http://183.63.191.42:8081/bppf/BSLogin.do?BSTokenRequest=Rjg5QzVGQTQ3MTkwMDI2NTlENzdEOTAxRjgwNDgwNzUzNTNEOTE3NkVGNDE3NEEyQ0M1QkNGRDlCOThDN0NDRjdENjE0RkM0NTI0NkMzQTlFRDY1N0E4Njk4NkU3MDUzNTI4MTI1M0ZENUVGNjVDMDc2NzkwNzVFQUIxOTMxMUUyMkJDMkQ5RjlBODhFRUIxMjQwOUJDRDBCQzNDMkVFNDg4NjhBRDU3RUY0NEFFOTkxQTg0NDYyOENENkM5NjY0RUJCRjIyMzlBRjIxMURENzY2QkU1QjUzQzkwRDdGNjhBNkNERDBFREY3MjYyMkQ2MzkwNjYwODA1ODQyRkE2Mzg3MjU0NDhCRjk3QzUwNzkyMEFBNzdBOEE1NTUwNzU4NDkzMDhEQzFDMjdFOUQ1QUQ3NEJDMDM5QTI2NjQ3RDU2NDAyRUU5ODNGMDI0NTM1MDI3MTUAAAAAAAAAAAAAAAAAAAAAAAAAA");
    TS_OpenIE(gbl.dPosInfo, outURL); 
    
    return 0;
}

//资金到账查询
int CTrade::zjdzcx_online(int b_boss)
{
	char impdate1[20] = { 0 };
    char impdate2[20] = { 0 };
    char url [1024+2] = { 0 };
    SYSTEMTIME systime;   
	int iret;
	iret=pwd_chk(0);
	if (iret != 0) 
	{
		if (iret==CANCLE_KEY)
		{
			return CANCLE_KEY;
		}
		else
		{

			info("老板密码校验错误，\n如您遗忘您的老板密码，请拨打400-80-11888客服电话咨询!\n");
			return -1;
	
		}
       
    }

    ::GetLocalTime(&systime);
    sprintf(impdate1, "%04d-%02d-%02d",systime.wYear, systime.wMonth, systime.wDay);
    sprintf(impdate2, "%04d-%02d-%02d",systime.wYear, systime.wMonth, systime.wDay);

    sprintf(url, "%s", "/bppf/paymentDetail.do?method=list&init=0&K=1");

    return online_ser(url, b_boss);
}


//资金划拨，修改为直接从页面上面跳转

//资金到账查询
int CTrade::cashTransfer_online(int b_boss)
{
	char impdate1[20] = { 0 };
    char impdate2[20] = { 0 };
    char url [1024+2] = { 0 };
	int iret;
	iret=pwd_chk(0);
	if (iret != 0) 
	{
		if (iret==CANCLE_KEY)
		{
			return CANCLE_KEY;
		}
		else
		{
			
			info("老板密码校验错误，\n如您遗忘您的老板密码，请拨打400-80-11888客服电话咨询!\n");
			return -1;
			
		}
		
    }
	
 
    sprintf(url, "%s", "/bppf/cashTransfer/cashTransfer.do?method=cashTransferList&init=0&K=1");
	
    return online_ser(url, b_boss);
}


//当日交易查询
int CTrade::drcx_online(int b_boss)
{
    char impdate1[20] = { 0 };
    char impdate2[20] = { 0 };
    char url [1024+2] = { 0 };

    SYSTEMTIME systime;   
    ::GetLocalTime(&systime);
    sprintf(impdate1, "%04d-%02d-%02d",systime.wYear, systime.wMonth, systime.wDay);
    sprintf(impdate2, "%04d-%02d-%02d",systime.wYear, systime.wMonth, systime.wDay);

    sprintf(url, "/bppf/tcquery.do?method=list&init=0&impDate1=%s&impDate2=%s&K=1", impdate1, impdate2);

    return online_ser(url, b_boss);
}

//上月交易查询
int CTrade::last_mnth_online(int b_boss)
{
  char impdate1[20] = {0};
    char impdate2[20] = {0};
    char url[1024+2] = {0};
	int cur_year = 0;
	int cur_month  = 0;
    SYSTEMTIME systime; 
	int days[12] = {31, 0, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

    ::GetLocalTime(&systime);
	cur_year = systime.wYear;
	cur_month = systime.wMonth;
    
	//闰年否
	if (cur_year % 4 == 0 && cur_year % 100 != 0) {
		days[1] = 29;
	} else {
		days[1] = 28;
	}

	//一月份查讯上一月，为上年的12月份
	if (cur_month == 1) {
		sprintf(impdate1, "%04d-%02d-%02d", cur_year - 1, 12, 1);
		sprintf(impdate2, "%04d-%02d-%02d", cur_year - 1, 12, 31);
	} else {
		sprintf(impdate1, "%04d-%02d-%02d", cur_year, cur_month - 1, 1);
		sprintf(impdate2, "%04d-%02d-%02d", cur_year, cur_month - 1, days[cur_month - 1 - 1]);
	}

    sprintf(url, "/bppf/tcquery.do?method=list&init=0&impDate1=%s&impDate2=%s&K=1", impdate1, impdate2);
    return online_ser(url, b_boss);
}

//当月交易查询
int CTrade::yjycx_online(int b_boss)
{
    char impdate1[20] = { 0 };
    char impdate2[20] = { 0 };
    char url [1024+2] = { 0 };
    
    SYSTEMTIME   systime;   
    ::GetLocalTime(&systime);
    sprintf(impdate1, "%04d-%02d-%02d",systime.wYear, systime.wMonth, 1 );
    sprintf(impdate2, "%04d-%02d-%02d",systime.wYear, systime.wMonth, systime.wDay );
    
    sprintf(url , "/bppf/tcquery.do?method=list&init=0&impDate1=%s&impDate2=%s&K=1" , impdate1 , impdate2);
    
    return online_ser(url, b_boss);
}

//明细冲正查询
int CTrade::mxcx_online(int b_boss)
{
    char url [1024+2] = { 0 };

    if (pwd_chk(0) != 0)
    {
        info("老板密码校验错误，\n如您遗忘您的老板密码，请拨打400-80-11888客服电话咨询!\n");
        return -1;
    }

    string impdate1 = get_line_from_term(1, TS_INPUT_DATE, 8, 8, "请输入查询起始日期");
    if (impdate1.empty())
    {
        return -1;
    }

    string impdate2 = get_line_from_term(1, TS_INPUT_DATE, 8, 8, "请输入查询结束日期");
    if (impdate2.empty())
    {
        return -1;
    }

    int flag = 1;
    string state;
    while(flag)
    {
        state = get_line_from_term(1, TS_INPUT_MATH, 1, 1, "请输入查询条件，【0】成功、【1】失败、【2】全部");
        if (state.empty())
        {
            return -1;
        }

        if (strcmp(state.c_str() , "1") != 0 &&
            strcmp(state.c_str() , "2") != 0 &&
            strcmp(state.c_str() , "0") != 0)
        {
            info("输入错误，请按屏幕提示输入\n");
        }
        else
        {
            flag = 0;
        }
    }
    
    sprintf(url , "/bppf/tcquery.do?method=list&init=0&impDate1=%s&impDate2=%s&odrStat=%s&K=1",\
        impdate1.c_str() , impdate2.c_str() , state.c_str() );
    
    return online_ser(url, b_boss);
}

//查询冲正
int CTrade::cxcz_online(int b_boss)
{
    return online_ser("/bppf/tcquery.do?method=list&init=0&K=1", b_boss);
}

//跳转到子服务门户首页

int CTrade::selfService_online(int b_boss)
{
    return online_ser("/cmpf/issue.do?method=newsList&init=0&K=1", b_boss);
}


string CTrade::get_line_from_term(int count, int type, int minlen, int maxlen, const string& title)
{
    //count 重试次数type，类型是密码还是明文,title提示语
    //min最短长度，max最长长度
    TSTradeInfoSend tradeInfoSend;
    TSTradeInfoRecv tradeInfoRecv;
    int iRet = 0;
    
    memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
    memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
    
    strcpy(tradeInfoSend.acMainTitle, title.c_str());
    tradeInfoSend.uHasTradeID = 1;
    tradeInfoSend.uTotalContents = 1;	
    
    strcpy(tradeInfoSend.Contents[0].acTitle, title.c_str());
    tradeInfoSend.Contents[0].uCommand = type;//密码
    tradeInfoSend.Contents[0].uDesMode = TS_NO_ENC;//不加密
    tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;//超时30秒
    tradeInfoSend.Contents[0].uCount = count - 1;//两次
    tradeInfoSend.Contents[0].uMinLen = minlen;
    tradeInfoSend.Contents[0].uMaxLen = maxlen;

    iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
    if(iRet != 0)
    {
        wrLog("TS_TradeControl返回错误[%d]", iRet);
        return "";
    }
    
    return string((char*)tradeInfoRecv.Contents[0].uMsg, minlen);
}

int CTrade::info(const std::string& msg)
{
    int iRet = 0;
    int iSelect = 0;
    TS_OutPutMsg(gbl.dPosInfo, const_cast<char*>(msg.c_str()), 0, iSelect);
    return iSelect;
}

//支付密码修改
int CTrade::paypwd_chg()
{
    char* title = "交易密码修改";
    int iRet = 0, iSelect = 0;
    string bosspwd , oldpass , newpass ;
   
    iRet = pwd_chk(0);
    if (iRet != 0)
    {
        wrLog("老板密码校验错误:[%s:%d]" , __FILE__ , __FILE__);
        if (iRet == -1)
        {
            info("网络繁忙！\n\n请稍后再试。");
        }
        return -1;
    }
    
    oldpass = get_line_from_term(1 , TS_INPUT_PWD , 6 , 6 , "请输入旧交易密码");
    newpass = get_line_from_term(2 , TS_INPUT_PWD , 6 , 6 , "请输入新交易密码");
    if (oldpass.empty() || newpass.empty())
    {
        wrLog("交易密码输入错误:[%s:%d]" , __FILE__ , __LINE__);
        return -1;
    }

    iRet = Ctsipass::modifypass(gbl.dPosInfo.pos_no ,gbl.mer_ecard, oldpass.c_str() , newpass.c_str() , Ctsipass::CHG_PAY_PWD);
    if (iRet != 0)
    {
        wrLog("交易密码修改失败。:[%s:%d]" , __FILE__ , __LINE__);
        switch(iRet)
        {
		case -1:
			TS_OutPutMsg(gbl.dPosInfo, "交易密码错误!\n请联系在线客服中心【Ctrl+H】  400-80-11888", 0, iSelect);
			break;
        case -2:
            TS_OutPutMsg(gbl.dPosInfo, "连接到密码服务器错误!\n\n请稍后再试!", 0, iSelect);
            break;
        case -3:
            TS_OutPutMsg(gbl.dPosInfo, "交易密码错次数过多，解锁 请联系在线客服中心【Ctrl+H】  400-80-11888", 0, iSelect);
            break;
		case -5:
            TS_OutPutMsg(gbl.dPosInfo, "新密码与旧密码不能重复 请重试!", 0, iSelect);
            break;
		default:
            TS_OutPutMsg(gbl.dPosInfo, "交易密码修改失败。!\n\n请稍后再试!", 0, iSelect);
			break;
        }
        
        return -1;
    }
    info("密码修改已完成，请牢记您的密码。");
    return 0;
}

//密码校验
//flag : 1 支付密码校验，2转账密码校验，0老板密码校验
int CTrade::pwd_chk(int flag)
{
    string pwd;
    string title;
    int iRet = 0;
    char buf[512] = {0};
    Ctsipass::FLAGS pwdflag;
	wrLog("pwd_chk flag:[%d]",flag);

    if (flag == 1)
    {
        title = "请输入支付密码";
        pwdflag = Ctsipass::CHK_PAY_PWD;
    }
    else if (flag == 2)
    {
        title = "请输入转账密码";
        pwdflag = Ctsipass::CHK_TRANS_PWD;
    }
    else if (flag == 0)
    {
        title = "请输入老板密码";
        pwdflag = Ctsipass::CHK_BOSS_PWD;
    }
    pwd = get_line_from_term(1, TS_INPUT_PWD, 6, 6, title);
	wrLog("pwd:[%s]",pwd.c_str());
    if (pwd.empty())
    {
        wrLog("输入错误:[%s:%d]", __FILE__, __LINE__);
        return CANCLE_KEY;
	
    }

    iRet = tenk_encrypt(pwd, buf, sizeof(buf));
    if (-1 == iRet)
    {
        //info("\n密码校验出错\n请稍候再试!\n或联系在线客服中心【Ctrl+H】  400-80-11888");
        return -1;
    }
	wrLog("pwdflag:[%d]",pwdflag);
    iRet = Ctsipass::checkpass(gbl.dPosInfo.pos_no, gbl.mer_ecard, buf, pwdflag);
    if (iRet != 0)
    {
        wrLog("密码校验失败:[%s:%d]" , __FILE__ , __LINE__);
        switch(iRet)
        {
		case -1:
			wrLog("密码校验失败原因:[参数错误]");
			break;
        case -2:
            break;
        case -3:
            break;
		default:
			break;
        }
        wrLog("密码校验失败2。:[%s:%d]" , __FILE__ , __LINE__);
        return -1;
    }

    return 0;
}

int CTrade::tenk_encrypt(const string& pwd , char* outBuf , size_t outMaxLen)
{
    char byteTmp[16] = { 0 };
    int iRet = TEKEny(gbl.dPosInfo,const_cast<char*>(pwd.c_str()),pwd.size(),"2000000000000001",byteTmp);
    if( iRet < 0)
    {
        return -1;
	}

    CTools::byte_to_hex((BYTE*)byteTmp, (BYTE*)outBuf, 8);
    wrLog("TEK返回:[%d]->[%s]" , iRet , outBuf);
    return 0;
}

//老板密码修改
int CTrade::bosspwd_chg()
{
    string oldpwd,newpwd,cell;
    char pwdBuf[1024] =  { 0 };
    int iRet = 0;

    oldpwd = get_line_from_term(1, TS_INPUT_PWD, 6, 6, "请输入旧老板密码");
    if (oldpwd.empty()) {
        wrLog("输入旧老板密码错误:[%s:%d]" , __FILE__ , __LINE__);
        return -1;
    }
    newpwd = get_line_from_term(2, TS_INPUT_PWD, 6, 6, "请输入新老板密码");
    if (newpwd.empty())
    {
        wrLog("输入新老板错误:[%s:%d]" , __FILE__ , __LINE__);
        return -1;
    }
    cell = get_line_from_term(1 , TS_INPUT_MATH , 11 , 11 , "请输入绑定手机号");
    if (cell.empty())
    {
        wrLog("输入绑定手机号错误:[%s:%d]" , __FILE__ , __LINE__);
        return -1;
    }

    iRet = tenk_encrypt(oldpwd , pwdBuf , sizeof(pwdBuf));
    if (iRet != 0)
    {
        return -1;
    }
    oldpwd = pwdBuf ;

    memset(pwdBuf , 0 , sizeof(pwdBuf));
    iRet = tenk_encrypt(newpwd , pwdBuf , sizeof(pwdBuf));
    if (iRet != 0)
    {
        return -1;
    }
    newpwd = pwdBuf ;

    iRet = Ctsipass::modifypass(gbl.dPosInfo.pos_no, gbl.mer_ecard ,oldpwd.c_str(), newpwd.c_str(), Ctsipass::CHG_BOSS_PWD, cell.c_str());
    if (iRet != 0)
    {
        wrLog("密码校验失败[返回:%d]:[%s:%d]", iRet, __FILE__ , __LINE__);
        switch(iRet)
        {
		case -1:
            info("老板密码错误!\n请联系在线客服中心【Ctrl+H】  400-80-11888");
            break;
        case -2:
			info("连接到密码服务器错误!\n\n请稍后再试!");
            break;
		case -3:
			info("老板密码错次数过多，解锁 请联系在线客服中心【Ctrl+H】  400-80-11888");
            break;
        case -4:
            info("老板密码修改失败。!\n\n请稍后再试!");
            break;
		case -5:
			 info("新密码与旧密码不能重复 请重试!");
            break;
        }
        return -1;
    }
    info("老板密码修改成功且已生效，请牢记您的密码。\n\n按【Enter】键返回。");
    return 0;
}

//转账密码修改
int CTrade::transpwd_chg()
{
    string oldpwd,newpwd;
    int iRet = 0;
    
    oldpwd = get_line_from_term(1 , TS_INPUT_PWD , 6 ,6 , "请输入旧转账密码");
    if (oldpwd.empty())
    {
        wrLog("输入旧转账密码错误:[%s:%d]" , __FILE__ , __LINE__);
        return -1;
    }
    newpwd = get_line_from_term(2 , TS_INPUT_PWD , 6 ,6 , "请输入新转账密码");
    if (newpwd.empty())
    {
        wrLog("输入新转账密码错误:[%s:%d]" , __FILE__ , __LINE__);
        return -1;
    }

    char old_buf[100] = { 0 };
    char new_buf[100] = { 0 };
    iRet = tenk_encrypt(oldpwd , old_buf , sizeof(old_buf));
    if (iRet != 0)
    {
        return -1;
    }
    iRet = tenk_encrypt(newpwd , new_buf , sizeof(old_buf));
    if (iRet != 0)
    {
        return -1;
    }
    
    iRet = Ctsipass::modifypass(gbl.dPosInfo.pos_no, gbl.mer_ecard, old_buf, new_buf, Ctsipass::CHG_TRANS_PWD);
    if (iRet != 0)
    {
        wrLog("密码校验失败:[%s:%d]" , __FILE__ , __LINE__);
        switch(iRet)
        {
		case -1:
            info("旧转账密码错误!\n\n请再试!");
			break;
        case -2:
            info("旧转账密码错误次数过多!\n\n请再试!");
            break;
        case -3:
            info("密码错次数过多，解锁 请联系在线客服中心【Ctrl+H】  400-80-11888");
            break;
		case -5:
			 info("新密码与旧密码不能重复 请重试!");
            break;
        default:
            info("转账密码修改失败。!\n\n请稍后再试!");
        }
        
        return -1;
    }
    info("转账密码修改成功，请牢记您的密码。\n\n按【Enter】键返回。");
    return 0;
}

//修改老板密码
int CTrade::chgPEPwd(const char *title)
{
    //密码改造，2012-09-05
    return bosspwd_chg();

	int iRet=0, sLen=0, rLen=0, iSelect=0;
	SOCKET sd=0;
	char rspcode[2+1], oldencpwd[16+1], newencpwd[16+1], pwd[6+1], scont[1024], rcont[1024];
	char pwd_flag[1+1];
	CConnect con;
	
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, title);
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 2;	
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输旧老板密码");
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_PWD;//明文密码
	tradeInfoSend.Contents[0].uDesMode = TS_NO_ENC;//不加密
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;//超时30秒
	tradeInfoSend.Contents[0].uMinLen = 6;
	tradeInfoSend.Contents[0].uMaxLen = 6;
	
	strcpy(tradeInfoSend.Contents[1].acTitle, "请输新老板密码");
	tradeInfoSend.Contents[1].uCommand = TS_INPUT_PWD;//明文密码
	tradeInfoSend.Contents[1].uDesMode = TS_NO_ENC;//不加密
	tradeInfoSend.Contents[1].uTimeOut = EPOS_OVER_TIME;//超时30秒
	tradeInfoSend.Contents[1].uCount = 1;//两次
	tradeInfoSend.Contents[1].uMinLen = 6;
	tradeInfoSend.Contents[1].uMaxLen = 6;
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	
	bbzero(pwd);
	memcpy(pwd, (char *)tradeInfoRecv.Contents[0].uMsg, 6);
	bbzero(pwd_flag);
	if (memcmp(pwd,"111111",6)==0)
	{
		strcpy(pwd_flag,"1");
	}else
		strcpy(pwd_flag,"0");
	bbzero(oldencpwd);
	//myEncryptForPayEasyMemberPwd(pwd, oldencpwd);
	if(TEKEny(gbl.dPosInfo,pwd,6,"2000000000000001",oldencpwd)>=0)
	{
		NULL;
	}
	else
	{
		TS_OutPutMsg(gbl.dPosInfo, "\n修改老板密码出错\n请稍候再试!\n或联系在线客服中心【Ctrl+H】  400-80-11888", 0, iSelect);
		return -1;
    }
	bbzero(pwd);
	memcpy(pwd, (char *)tradeInfoRecv.Contents[1].uMsg, 6);
	bbzero(newencpwd);
	//myEncryptForPayEasyMemberPwd(pwd, newencpwd);
	if(TEKEny(gbl.dPosInfo,pwd,6,"2000000000000001",newencpwd)>=0)
	{
		NULL;
	}
	else
	{
		TS_OutPutMsg(gbl.dPosInfo, "\n修改老板密码出错\n请稍候再试!\n或联系在线客服中心【Ctrl+H】  400-80-11888", 0, iSelect);
		return -1;
	}

	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, title);
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;	
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入绑定号码：");
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;//明文密码
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;//超时30秒
	tradeInfoSend.Contents[0].uMinLen = 11;
	tradeInfoSend.Contents[0].uMaxLen = 11;
	
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	
	bbzero(gbl.telphone);
	memcpy(gbl.telphone, (char *)tradeInfoRecv.Contents[0].uMsg, 11);
	
	if( con.conToHost(pepwd_ip, atoi(pepwd_port), &sd)==0 )
	{
		bbzero(scont);
		sLen = 0;
		strcpy(scont, "00750020208");
		sLen += 11;
		memcpy(scont+sLen, gbl.pos_no, 8);
		sLen += 8;
		strcpy(scont+sLen, "08");
		sLen += 2;
		memcpy(scont+sLen, gbl.pos_no, 8);
		sLen += 8;
		memcpy(scont+sLen, "16", 2);
		sLen += 2;
		memcpy(scont+sLen, oldencpwd, 16);
		sLen += 16;
		memcpy(scont+sLen, "16", 2);
		sLen += 2;
		memcpy(scont+sLen, newencpwd, 16);
		sLen += 16;
		memcpy(scont+sLen, "11", 2);
		sLen += 2;
		memcpy(scont+sLen, gbl.telphone, 11);
		sLen += 11;
		memcpy(scont+sLen, pwd_flag, 1);
		sLen += 1;
		
		iRet = con.sndMsg(sd, scont, sLen);
		if( iRet!=0 )
		{
			TS_OutPutMsg(gbl.dPosInfo, "向改密服务器发错数据出错!\n\n请稍后再试!", 0, iSelect);
			return -1;
		}
		
		iRet = con.rcvMsg(sd, rcont, &rLen, 1024);
		closesocket(sd);
		if( iRet!=0 )
		{
			return -1;
		}
		else
		{
			if(memcmp(rcont, "00200", 5)==0)
			{
				TS_OutPutMsg(gbl.dPosInfo, "修改密码成功!\n\n请记住新密码!", 0, iSelect);
				return 0;
			}
			else
			{
				bbzero(rspcode);
				memcpy(rspcode, rcont+3, 2);
				switch(atoi(rspcode))
				{
				case 14:
					TS_OutPutMsg(gbl.dPosInfo, "没有找到您签约的记录!\n\n修改密码出错!", 0, iSelect);
					break;
				case 36:
				case 37:
				case 60:
				case 75:
					TS_OutPutMsg(gbl.dPosInfo, "老板密码错次数过多，解锁 请联系在线客服中心【Ctrl+H】  400-80-11888", 0, iSelect);
					break;
				case 85:
					TS_OutPutMsg(gbl.dPosInfo, "老板密码错误!\n请联系在线客服中心【Ctrl+H】  400-80-11888", 0, iSelect);
					break;
				case 88:
					TS_OutPutMsg(gbl.dPosInfo, "改密过程中，网络不稳定，数据转换出错!\n请稍候再试!\n或联系在线客服中心【Ctrl+H】  400-80-11888", 0, iSelect);
					break;
				case 94:
					TS_OutPutMsg(gbl.dPosInfo, "改密过程中，网络不稳定，包格式错误!\n请稍候再试!\n或联系在线客服中心【Ctrl+H】  400-80-11888", 0, iSelect);
					break;
				case 96:
					TS_OutPutMsg(gbl.dPosInfo, "改密过程中，网络不稳定，数据库操作出错!\n请稍候再试!\n或联系在线客服中心【Ctrl+H】  400-80-11888", 0, iSelect);
					break;
				default:
					TS_OutPutMsg(gbl.dPosInfo, "网络繁忙，操作出错!\n请稍候再试!\n或联系在线客服中心【Ctrl+H】  400-80-11888", 0, iSelect);
					break;
				}
				return -1;
			}
		}
	}
	else
	{
		TS_OutPutMsg(gbl.dPosInfo, "连接改密服务器出错!\n\n\n请稍候再试!\n或联系在线客服中心【Ctrl+H】  400-80-11888", 0, iSelect);
		return -1;
	}
	return 0;
}

int CTrade::chgTransferPwd(const char *title)
{
    //密码改造，2012-09-05
    return transpwd_chg();

	int iRet=0,iSelect=0;
	char oldpwd[7], newpwd[7];
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	
	iRet=checkPwdNotNull();
	if(iRet==-1){
		TS_OutPutMsg(gbl.dPosInfo, "连接转账密码服务器错误!\n请稍候再试!\n或联系在线客服中心【Ctrl+H】  400-80-11888", 0, iSelect);
		return -1;		   
	}else if(iRet==14||iRet==91){
        TS_OutPutMsg(gbl.dPosInfo, "\n本终端还没设置过转账密码，请在【812】实时转账到交费易时进行设置\n\n   按【确认】返回", 0, iSelect);
		return -1;
	}
	
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
		
		strcpy(tradeInfoSend.acMainTitle, title);
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents = 2;	
		
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输旧转账密码");
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_PWD;//明文密码
		tradeInfoSend.Contents[0].uDesMode = TS_NO_ENC;//不加密
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;//超时30秒
		tradeInfoSend.Contents[0].uMinLen = 6;
		tradeInfoSend.Contents[0].uMaxLen = 6;
		
		strcpy(tradeInfoSend.Contents[1].acTitle, "请输新转账密码");
		tradeInfoSend.Contents[1].uCommand = TS_INPUT_PWD;//明文密码
		tradeInfoSend.Contents[1].uDesMode = TS_NO_ENC;//不加密
		tradeInfoSend.Contents[1].uTimeOut = EPOS_OVER_TIME;//超时30秒
		tradeInfoSend.Contents[1].uCount = 1;//两次
		tradeInfoSend.Contents[1].uMinLen = 6;
		tradeInfoSend.Contents[1].uMaxLen = 6;
		
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		if(iRet != 0)
		{
			wrLog("TS_TradeControl返回错误[%d]", iRet);
			wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
			return iRet;
		}
		
		bbzero(oldpwd);
		memcpy(oldpwd, (char *)tradeInfoRecv.Contents[0].uMsg, 6);
		bbzero(newpwd);
		memcpy(newpwd, (char *)tradeInfoRecv.Contents[1].uMsg, 6);
		iRet=setTransferPwd(newpwd,oldpwd);
		wrLog("修改转账密码setTransferPwd(newpwd,oldpwd) iRet:[%d]",iRet);
		if(iRet == 92)
		{
			TS_OutPutMsg(gbl.dPosInfo, "旧转账密码错误!请重新输入!\n", 0, iSelect);
			if(iSelect==0)
				continue;
			else
				return CANCLE_KEY;
		}else if(iRet != 0)
		{
			switch(iRet)
			{   
			case 93:
				TS_OutPutMsg(gbl.dPosInfo, "旧转账密码错误次数过多，解锁 请联系在线客服中心【Ctrl+H】  400-80-11888!\n", 0, iSelect);
				break;
			case 94:
				TS_OutPutMsg(gbl.dPosInfo, "设置转账密码过程中，网络不稳定，包格式错误!\n请稍候再试!\n或联系在线客服中心【Ctrl+H】  400-80-11888", 0, iSelect);
				break;
			case 96:
				TS_OutPutMsg(gbl.dPosInfo, "设置转账密码过程中，网络不稳定，数据库操作出错!\n请稍候再试!\n或联系在线客服中心【Ctrl+H】  400-80-11888", 0, iSelect);
				break;
			case -1:
				TS_OutPutMsg(gbl.dPosInfo, "连接转账密码服务器错误!\n请稍候再试!\n或联系在线客服中心【Ctrl+H】  400-80-11888", 0, iSelect);
				break;
			default:
				TS_OutPutMsg(gbl.dPosInfo, "网络繁忙，操作出错!\n请稍候再试!\n或联系在线客服中心【Ctrl+H】  400-80-11888", 0, iSelect);
				break;
			}
			return -1;
		}else
			break;
	}
    TS_OutPutMsg(gbl.dPosInfo, "\n转账密码修改成功!\n", 0, iSelect);
	return 0;
}

int CTrade::updatePosPar(const char *title, int t_flag)
{
	int iRet=0, iSelect,setType;
	char pwd[6+1], priType, msg[300],cardDevice,TF_HIDTYPE;
	TSPosPar tsposPar;
	TSMENULIST menuList;
	
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{
		if (t_flag ==0)
		{
			memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
			memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
			
			strcpy(tradeInfoSend.acMainTitle, title);
			tradeInfoSend.uHasTradeID = 1;
			tradeInfoSend.uTotalContents = 1;	
			
			strcpy(tradeInfoSend.Contents[0].acTitle, "请输入高级设置密码");
			tradeInfoSend.Contents[0].uCommand = TS_INPUT_PWD;//明文密码
			tradeInfoSend.Contents[0].uDesMode = TS_NO_ENC;//不加密
			tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;//超时30秒
			tradeInfoSend.Contents[0].uMinLen = 6;
			tradeInfoSend.Contents[0].uMaxLen = 6;
			
			iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
			if(iRet != 0)
			{
				wrLog("TS_TradeControl返回错误[%d]", iRet);
				wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
				return iRet;
			}
			bbzero(pwd);
		}else
		{
			bbzero(tradeInfoRecv.Contents[0].uMsg);
			strcpy((char *)tradeInfoRecv.Contents[0].uMsg,"314159");
		}
		if(memcmp("314159", (char *)tradeInfoRecv.Contents[0].uMsg, 6)==0){
			memset(&menuList,0,sizeof(menuList));
			menuList.iTotalNum = 5; //新增清华同方HID读卡器
			strcpy(menuList.acTitle, "外部设备设置");
			strcpy(menuList.menuItem[0], "打印机设置");
			strcpy(menuList.menuItem[1], "刷卡器设置");
			strcpy(menuList.menuItem[2], "羊城通设置");
			strcpy(menuList.menuItem[3], "东莞公交明华读卡器设置");  
			strcpy(menuList.menuItem[4], "东莞公交清华同方读卡器设置");  
			iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
			if(iRet)
				return -1;
			switch(iSelect)
			{
			case 1:
				setType = 1;
				break; //打印机设置
			case 2:
				setType = 2;
				break; //刷卡器设置
			case 3:
				setType = 3;
				break; //羊城通设置
			case 4:
				setType = 4;
				break; //东莞公交明华读卡器设置
			case 5:
				setType = 5;
				break; //东莞公交清华同方读卡器设置
			default: 
				TS_OutPutMsg(gbl.dPosInfo, "选择有误\n\n请按回车后重新操作", 0, iSelect);
				continue;
			}
			
			if(setType==1)
			{
				memset(&menuList,0,sizeof(menuList));
				menuList.iTotalNum = 8;
				strcpy(menuList.acTitle, "请选打印机类型");
				strcpy(menuList.menuItem[0], "无打印机");
				strcpy(menuList.menuItem[1], "热敏非套打打印机");
				strcpy(menuList.menuItem[2], "针式套打打印机");
				strcpy(menuList.menuItem[3], "针式非套打打印机");
				strcpy(menuList.menuItem[4], "USB热敏非套打印机");
				strcpy(menuList.menuItem[5], "美宜佳自带打印机");
				strcpy(menuList.menuItem[6], "并口打印机");
				strcpy(menuList.menuItem[7], "Windows默认打印机");
				iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
				if(iRet)
					return -1;
				switch(iSelect)
				{
				case 1:
					priType = '\x00';
					break; //热敏套打打印机
				case 2:
					priType = '\x02';
					break; //热敏非套打打印机
				case 3:
					priType = '\x03';
					break; //针式套打打印机
				case 4:
					priType = '\x04';
					break; //针式非套打打印机
				case 5:
					priType = '\x0D';
					break; //USB热敏非套打印机
				case 6:
					priType = '\x0A';
					break; //美宜佳自带打印机
				case 7:
					priType = '\x0B';
					break; //并口打印机
				case 8:
					priType = '\x0C';
					break; //Windows默认打印机
				default: 
					TS_OutPutMsg(gbl.dPosInfo, "选择有误\n\n请按回车后重新操作", 0, iSelect);
					continue;
				}
				
				bbzero(msg);
				sprintf(msg, "你选择的是\n\n【%s】\n\n【确认】设置\n\n【返回】重新操作", menuList.menuItem[iSelect-1]);
				if(iSelect == 8)
				{
					strcat(msg, "\n\n\n【温馨提示】若使用交费易版标准发票或其他凭条纸进行打印，请勿选择此项。");
				}
				iRet = TS_OutPutMsg(gbl.dPosInfo, msg, 0, iSelect);
				if(iSelect==0)
				{
					memset(&tsposPar, 0, sizeof(tsposPar));
					tsposPar.num=1;
					tsposPar.parCont[0].parId=17; //参数17为打印机对应的串口类型
					tsposPar.parCont[0].parLen=1;
					tsposPar.parCont[0].parCont[0] = priType;
					iRet = TS_UpdatePosPar(gbl.dPosInfo, &tsposPar);
					if(iRet)
					{
						TS_OutPutMsg(gbl.dPosInfo, "更新出错\n\n请按回车后重新操作", 0, iSelect);
					}
					else
					{
						if( priType=='\x0C' )
						{
							iRet = TS_OutPutMsg(gbl.dPosInfo, "更新成功\n是否更改WINDOW默认打印机的字体大小\n按【确认】更改\n按【返回】返回", 0, iSelect);
							if( iRet==0 && iSelect==0 )
							{
								memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
								memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
								
								strcpy(tradeInfoSend.acMainTitle, title);
								tradeInfoSend.uHasTradeID = 1;
								tradeInfoSend.uTotalContents = 1;	
								
								strcpy(tradeInfoSend.Contents[0].acTitle, "请输入字体大小的数值");
								tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;//明文密码
								tradeInfoSend.Contents[0].uDesMode = TS_NO_ENC;//不加密
								tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;//超时30秒
								tradeInfoSend.Contents[0].uMinLen = 1;
								tradeInfoSend.Contents[0].uMaxLen = 2;
								
								iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
								if(iRet != 0)
								{
									wrLog("TS_TradeControl返回错误[%d]", iRet);
									wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
									return iRet;
								}
								
								memset(&tsposPar, 0, sizeof(tsposPar));
								tsposPar.num=1;
								tsposPar.parCont[0].parId=39;
								tsposPar.parCont[0].parLen=1;
								tsposPar.parCont[0].parCont[0] = atoi((char *)tradeInfoRecv.Contents[0].uMsg);
								iRet = TS_UpdatePosPar(gbl.dPosInfo, &tsposPar);
								if(iRet)
								{
									TS_OutPutMsg(gbl.dPosInfo, "更新出错\n\n请按回车后重新操作", 0, iSelect);
								}
								else
								{
									TS_OutPutMsg(gbl.dPosInfo, "更新成功\n\n请重新启动程序\n\n以初始化打印机", 0, iSelect);
								}
							}
							else
							{
								NULL;
							}
						}
						else if( priType=='\x03' )
						{
							iRet = TS_OutPutMsg(gbl.dPosInfo, "更新成功\n是否使用新的发票纸（较普通发票稍长）\n按【确认】是\n按【返回】否", 0, iSelect);
							if( iRet==0 && iSelect==0 )
							{
								iRet = CDB::update_print_paper(gbl.pos_no, 1);
							}
							else
							{
								iRet = CDB::update_print_paper(gbl.pos_no, 0);
							}
							if(iRet)
							{
								TS_OutPutMsg(gbl.dPosInfo, "更新出错\n\n请按回车后重新操作", 0, iSelect);
							}
							else
							{
								TS_OutPutMsg(gbl.dPosInfo, "更新成功\n\n请重新启动程序\n\n以初始化打印机", 0, iSelect);
							}
						}
						else
						{
							TS_OutPutMsg(gbl.dPosInfo, "更新成功\n\n请重新启动程序\n\n以初始化打印机", 0, iSelect);
						}
						break;
					}
				}			
			}else if(setType==2)
			{
				memset(&menuList,0,sizeof(menuList));
				menuList.iTotalNum = 2;
				strcpy(menuList.acTitle, "请选有否刷卡器");
				strcpy(menuList.menuItem[0], "无刷卡器");
				strcpy(menuList.menuItem[1], "有刷卡器");
				iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
				if(iRet)
					return -1;
				switch(iSelect)
				{
				case 1:
					cardDevice = '\x00';
					break; //无刷卡器
				case 2:
					cardDevice = '\x0F';
					break; //有刷卡器
				default: 
					TS_OutPutMsg(gbl.dPosInfo, "选择有误\n\n请按回车后重新操作", 0, iSelect);
					continue;
				}
				
				bbzero(msg);
				sprintf(msg, "你选择的是\n\n【%s】\n\n【确认】设置\n\n【返回】重新操作", menuList.menuItem[iSelect-1]);
				iRet = TS_OutPutMsg(gbl.dPosInfo, msg, 0, iSelect);
				if(iSelect==0)
				{
					memset(&tsposPar, 0, sizeof(tsposPar));
					tsposPar.num=1;
					tsposPar.parCont[0].parId=19; //刷卡器的串口类型
					tsposPar.parCont[0].parLen=1;
					tsposPar.parCont[0].parCont[0] = cardDevice;
					iRet = TS_UpdatePosPar(gbl.dPosInfo, &tsposPar);
					if(iRet)
					{
						TS_OutPutMsg(gbl.dPosInfo, "更新出错\n\n请按回车后重新操作", 0, iSelect);
					}
					else
					{
						TS_OutPutMsg(gbl.dPosInfo, "更新成功\n\n请重新启动程序\n\n以初始化刷卡器", 0, iSelect);
						break;
					}
				}			
			}else if(setType==3)
			{
				memset(&menuList,0,sizeof(menuList));
				menuList.iTotalNum = 2;
				strcpy(menuList.acTitle, "请选有否羊城通");
				strcpy(menuList.menuItem[0], "无羊城通");
				strcpy(menuList.menuItem[1], "有羊城通");
				iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
				if(iRet)
					return -1;
				switch(iSelect)
				{
				case 1:
					cardDevice = '\x00';
					break; //无羊城通
				case 2:
					cardDevice = '\x08';
					break; //有羊城通（黑色）
				default: 
					TS_OutPutMsg(gbl.dPosInfo, "选择有误\n\n请按回车后重新操作", 0, iSelect);
					continue;
				}
				
				bbzero(msg);
				sprintf(msg, "你选择的是\n\n【%s】\n\n【确认】设置\n\n【返回】重新操作", menuList.menuItem[iSelect-1]);
				iRet = TS_OutPutMsg(gbl.dPosInfo, msg, 0, iSelect);
				if(iSelect==0)
				{
					memset(&tsposPar, 0, sizeof(tsposPar));
					tsposPar.num=1;
					tsposPar.parCont[0].parId=18; //参数号为18代表的是羊城通的串口类型
					tsposPar.parCont[0].parLen=1;
					tsposPar.parCont[0].parCont[0] = cardDevice;
					iRet = TS_UpdatePosPar(gbl.dPosInfo, &tsposPar);
					if(iRet)
					{
						TS_OutPutMsg(gbl.dPosInfo, "更新出错\n\n请按回车后重新操作", 0, iSelect);
					}
					else
					{
						TS_OutPutMsg(gbl.dPosInfo, "更新成功\n\n请重新启动程序\n\n以初始化刷卡器", 0, iSelect);
						break;
					}
				}			
			}else if(setType==4) //东莞公交明华读卡器
			{
				memset(&menuList,0,sizeof(menuList));
				menuList.iTotalNum = 2;
				strcpy(menuList.acTitle, "请选有否东莞公交明华读卡器");
				strcpy(menuList.menuItem[0], "无明华读卡器");
				strcpy(menuList.menuItem[1], "有明华读卡器");
				iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
				if(iRet)
					return -1;
				switch(iSelect)
				{
				case 1:
					cardDevice = '\x00';
					break; //无东莞公交读卡器
				case 2:
					cardDevice = '\x05';
					break; //有东莞公交读卡器
				default: 
					TS_OutPutMsg(gbl.dPosInfo, "选择有误\n\n请按回车后重新操作", 0, iSelect);
					continue;
				}
				
				bbzero(msg);
				sprintf(msg, "你选择的是\n\n【%s】\n\n【确认】设置\n\n【返回】重新操作", menuList.menuItem[iSelect-1]);
				iRet = TS_OutPutMsg(gbl.dPosInfo, msg, 0, iSelect);
				if(iSelect==0)
				{
					memset(&tsposPar, 0, sizeof(tsposPar));
					tsposPar.num=1;
					tsposPar.parCont[0].parId=18;
					tsposPar.parCont[0].parLen=1;
					tsposPar.parCont[0].parCont[0] = cardDevice;
					iRet = TS_UpdatePosPar(gbl.dPosInfo, &tsposPar);
					if(iRet)
					{
						TS_OutPutMsg(gbl.dPosInfo, "更新出错\n\n请按回车后重新操作", 0, iSelect);
					}
					else
					{
						TS_OutPutMsg(gbl.dPosInfo, "更新成功\n\n请重新启动程序\n\n以初始化刷卡器", 0, iSelect);
						break;
					}

				}	
				
			}


			else if(setType==5) //东莞清华同方读卡器
			{
				memset(&menuList,0,sizeof(menuList));
				menuList.iTotalNum = 2;
				strcpy(menuList.acTitle, "请选有否东莞公交清华同方读卡器");
				strcpy(menuList.menuItem[0], "无清华同方读卡器");
				strcpy(menuList.menuItem[1], "有清华同方读卡器");
				iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
				if(iRet)
					return -1;
				switch(iSelect)
				{
				case 1:
					TF_HIDTYPE='\x00';
					break; //无清华同方公交读卡器
				case 2:
					TF_HIDTYPE='\x01';
					break; //有清华同方公交读卡器
				default: 
					TS_OutPutMsg(gbl.dPosInfo, "选择有误\n\n请按回车后重新操作", 0, iSelect);
					continue;
				}
				
				bbzero(msg);
				sprintf(msg, "你选择的是\n\n【%s】\n\n【确认】设置\n\n【返回】重新操作", menuList.menuItem[iSelect-1]);
				iRet = TS_OutPutMsg(gbl.dPosInfo, msg, 0, iSelect);
				if(iSelect==0)
				{
					memset(&tsposPar, 0, sizeof(tsposPar));
					tsposPar.num=1;
					tsposPar.parCont[0].parId=20; //参数id为20是清华同方usb读卡器
					tsposPar.parCont[0].parLen=1;
					tsposPar.parCont[0].parCont[0] =TF_HIDTYPE ;
					iRet = TS_UpdatePosPar(gbl.dPosInfo, &tsposPar);
					if(iRet)
					{
						TS_OutPutMsg(gbl.dPosInfo, "更新出错\n\n请按回车后重新操作", 0, iSelect);
					}
					else
					{
						iRet = CDB::update_HID_type(gbl.pos_no, (int)TF_HIDTYPE);
						if(iRet)
						{
							TS_OutPutMsg(gbl.dPosInfo, "设置出错\n请稍候再试!", 0, iSelect);
							return -1;
						}
						else
						{
							TS_OutPutMsg(gbl.dPosInfo, "设置成功！！\n请重启IPOS软件", 0, iSelect);
							break;
						}
						
					}

				}	
				
			}
	}

	else
	{
		TS_OutPutMsg(gbl.dPosInfo, "密码错误\n\n请按回车后重新输入", 0, iSelect);
	}		
	}	
	return 0;
}

//校验转账密码是否为空
int CTrade::checkPwdNotNull()
{
    //数据割接，一定产生默认转账密码，且会通过手机短信形式发送给商户，故此处将非必须。
    return 0;

	int iRet=0, sLen=0, rLen=0, iSelect=0;
	SOCKET sd=0;
	char rspcode[2+1], scont[1024], rcont[1024];
	CConnect con;
	
	if( con.conToHost(pepwd_ip, atoi(pepwd_port), &sd)==0 )
	{
		bbzero(scont);
		sLen = 0;
		strcpy(scont, "00250070208");
		sLen += 11;
		memcpy(scont+sLen, gbl.pos_no, 8);
		sLen += 8;
		strcpy(scont+sLen, "08");
		sLen += 2;
		memcpy(scont+sLen, gbl.pos_no, 8);
		sLen += 8;		
		iRet = con.sndMsg(sd, scont, sLen);
		if( iRet!=0 )
		{
			return -1;
		}
		
		iRet = con.rcvMsg(sd, rcont, &rLen, 1024);
		closesocket(sd);
		if( iRet!=0 )
		{
			return -1;
		}
		else
		{
			if(memcmp(rcont+3, "00", 2)==0)
			{
				return 0;
			}
			else
			{
				bbzero(rspcode);
				memcpy(rspcode, rcont+3, 2);
				return atoi(rspcode);				
			}
		}
	}
	else
	{
		return -1;
	}
	return 0;
}


//设置转账密码
int CTrade::setTransferPwd(char *newPwd,char *oldPwd)
{
	int iRet=0, sLen=0, rLen=0, iSelect=0,oldPwdLen=0;
	SOCKET sd=0;
	char rspcode[2+1], encnewpwd[16+1],encoldpwd[16+1], scont[1024], rcont[1024];
	CConnect con;
	
	bbzero(encnewpwd);
	//myEncryptForPayEasyMemberPwd(newPwd, encnewpwd);
	if(TEKEny(gbl.dPosInfo,newPwd,6,"2000000000000001",encnewpwd)>=0)
	{
		NULL;
	}
	else
	{
		TS_OutPutMsg(gbl.dPosInfo, "\n设置转账密码出错\n请稍候再试!\n或联系在线客服中心【Ctrl+H】  400-80-11888", 0, iSelect);
		return -1;
	}

	bbzero(encoldpwd);
	//myEncryptForPayEasyMemberPwd(oldPwd, encoldpwd);
	if(TEKEny(gbl.dPosInfo,oldPwd,6,"2000000000000001",encoldpwd)>=0)
	{
		NULL;
	}
	else
	{
		TS_OutPutMsg(gbl.dPosInfo, "\n设置转账密码出错\n请稍候再试!\n或联系在线客服中心【Ctrl+H】  400-80-11888", 0, iSelect);
		return -1;
	}

	oldPwdLen=strlen(oldPwd);
	
	if( con.conToHost(pepwd_ip, atoi(pepwd_port), &sd)==0 )
	{
		bbzero(scont);
		sLen = 0;
		if(oldPwdLen==0)
			strcpy(scont, "00450060208");
		else
			strcpy(scont, "00610060208");
		sLen += 11;
		memcpy(scont+sLen, gbl.pos_no, 8);
		sLen += 8;
		strcpy(scont+sLen, "08");
		sLen += 2;
		memcpy(scont+sLen, gbl.pos_no, 8);
		sLen += 8;
		if(oldPwdLen!=0){
			memcpy(scont+sLen, "16", 2);
			sLen += 2;
			memcpy(scont+sLen, encoldpwd, 16);
			sLen += 16;
		}else{
			memcpy(scont+sLen, "00", 2);
			sLen += 2;
		}
		memcpy(scont+sLen, "16", 2);
		sLen += 2;
		memcpy(scont+sLen, encnewpwd, 16);
		sLen += 16;
		
		iRet = con.sndMsg(sd, scont, sLen);
		if( iRet!=0 )
		{
			return -1;
		}
		
		iRet = con.rcvMsg(sd, rcont, &rLen, 1024);
		closesocket(sd);
		if( iRet!=0 )
		{
			return -1;
		}
		else
		{
			if(memcmp(rcont+3, "00", 2)==0)
			{
				return 0;
			}
			else
			{
				bbzero(rspcode);
				memcpy(rspcode, rcont+3, 2);
				return atoi(rspcode);				
			}
		}
	}
	else
	{
		return -1;
	}
	return 0;
}

//type==0:校验老板密码 type==1:校验转账密码
int CTrade::checkPEPwd(char *pwd,int type)
{
	int iRet=0, sLen=0, rLen=0, iSelect=0;
	SOCKET sd=0;
	char rspcode[2+1], encpwd[16+1], scont[1024], rcont[1024];
	CConnect con;
	bbzero(encpwd);
	//myEncryptForPayEasyMemberPwd(pwd, encpwd);
	if(TEKEny(gbl.dPosInfo,pwd,6,"2000000000000001",encpwd)>=0)
	{
		NULL;
	}
	else
	{
		TS_OutPutMsg(gbl.dPosInfo, "\n校验密码出错\n请稍候再试!\n或联系在线客服中心【Ctrl+H】  400-80-11888", 0, iSelect);
		return -1;
	}

	if( con.conToHost(pepwd_ip, atoi(pepwd_port), &sd)==0 )
	{
		bbzero(scont);
		sLen = 0;
		if(type==1)
			strcpy(scont, "00430050208");
		else
			strcpy(scont, "00430030208");
		sLen += 11;
		memcpy(scont+sLen, gbl.pos_no, 8);
		sLen += 8;
		strcpy(scont+sLen, "08");
		sLen += 2;
		memcpy(scont+sLen, gbl.pos_no, 8);
		sLen += 8;
		memcpy(scont+sLen, "16", 2);
		sLen += 2;
		memcpy(scont+sLen, encpwd, 16);
		sLen += 16;
		
		iRet = con.sndMsg(sd, scont, sLen);
		if( iRet!=0 )
		{
			return -1;
		}
		
		iRet = con.rcvMsg(sd, rcont, &rLen, 1024);
		closesocket(sd);
		if( iRet!=0 )
		{
			return -1;
		}
		else
		{
			if(memcmp(rcont+3, "00", 5)==0)
			{
				return 0;
			}
			else
			{
				bbzero(rspcode);
				memcpy(rspcode, rcont+3, 2);
				return atoi(rspcode);				
			}
		}
	}
	else
	{
		return -1;
	}
	return 0;
}

int CTrade::checkPEPwd_Hdl(const char *title)
{
    //密码改造，老板密码校验 : 2012-09-05
    int Ret = pwd_chk(0);
	wrLog("pwd_chk ret [%d]", Ret);
    return Ret;

	int iRet = 0 , iSelect=0;
	char pwd[6+1];
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;	
	
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, title);
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;	
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入老板密码");
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_PWD;//明文密码
	tradeInfoSend.Contents[0].uDesMode = TS_NO_ENC;//不加密
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;//超时30秒
	tradeInfoSend.Contents[0].uMinLen = 6;
	tradeInfoSend.Contents[0].uMaxLen = 6;
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	
	bbzero(pwd);
	memcpy(pwd, (char *)tradeInfoRecv.Contents[0].uMsg, 6);
	
	iRet = checkPEPwd(pwd);
	if(iRet!=0)
	{
		switch(iRet)
		{
		case 14:
			TS_OutPutMsg(gbl.dPosInfo, "没有找到您签约的记录!\n\n修改密码出错!", 0, iSelect);
			break;
		case 36:
		case 37:
		case 60:
		case 75:
			TS_OutPutMsg(gbl.dPosInfo, "老板密码错次数过多，解锁 请联系在线客服中心【Ctrl+H】  400-80-11888", 0, iSelect);
			break;
		case 85:
			TS_OutPutMsg(gbl.dPosInfo, "老板密码错误!", 0, iSelect);
			break;
		case 88:
			TS_OutPutMsg(gbl.dPosInfo, "改密过程中，网络不稳定，数据转换出错!", 0, iSelect);
			break;
		case 94:
			TS_OutPutMsg(gbl.dPosInfo, "改密过程中，网络不稳定，包格式错误!", 0, iSelect);
			break;
		case 96:
			TS_OutPutMsg(gbl.dPosInfo, "改密过程中，网络不稳定，数据库操作出错!", 0, iSelect);
			break;
		default:
			TS_OutPutMsg(gbl.dPosInfo, "网络繁忙，操作出错!\n", 0, iSelect);
			break;
		}
		return -1;
	}
	return 0;
}


int CTrade::checkTransferPwd_Hdl(const char *title)
{
    int iRet = pwd_chk(2);
    return iRet;

	int iSelect=0;
	char pwd[6+1];
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;	
	
	
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
		
		strcpy(tradeInfoSend.acMainTitle, title);
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents = 1;	
		
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入转账密码");
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_PWD;//明文密码
		tradeInfoSend.Contents[0].uDesMode = TS_NO_ENC;//不加密
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;//超时30秒
		tradeInfoSend.Contents[0].uMinLen = 6;
		tradeInfoSend.Contents[0].uMaxLen = 6;
		
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		if(iRet != 0)
		{
			wrLog("TS_TradeControl返回错误[%d]", iRet);
			wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
			return iRet;
		}
		
		bbzero(pwd);
		memcpy(pwd, (char *)tradeInfoRecv.Contents[0].uMsg, 6);
		
		iRet = checkPEPwd(pwd,1);
		if(iRet==92){
			TS_OutPutMsg(gbl.dPosInfo, "转账密码错误!请重新输入。若忘记转账密码,请按【Ctrl+H】联系在线客服中心 或致电400-80-11888重置密码\n", 0, iSelect);
			if(iSelect == 0)
			{
				continue;
			}
			else
				return CANCLE_KEY;
		}
		else if(iRet!=0)
		{
			switch(iRet)
			{
			case 14:
				TS_OutPutMsg(gbl.dPosInfo, "没有找到您转账密码信息!\n", 0, iSelect);
				break;
			case 93:
				TS_OutPutMsg(gbl.dPosInfo, "转账密码错次数过多，解锁 请联系在线客服中心【Ctrl+H】  400-80-11888\n", 0, iSelect);
				break;
			case 94:
				TS_OutPutMsg(gbl.dPosInfo, "校验转账密码中，网络不稳定，包格式错误!\n", 0, iSelect);
				break;
			case 96:
				TS_OutPutMsg(gbl.dPosInfo, "校验转账密码中，网络不稳定，数据库操作出错!\n", 0, iSelect);
				break;
			default:
				TS_OutPutMsg(gbl.dPosInfo, "网络繁忙，操作出错!\n", 0, iSelect);
				break;
			}
			return -1;
		}else
			break;
	}
	return 0;
}

int CTrade::chgEPwdType(const char *title)
{
	int sd=0, iRet=0, iSelect=0, setting_type=0, times;
	char epwdType, msg[300];
	CConnect con;
	TSPosPar tsposPar;
	TSMENULIST menuList;
	
	if(atoi(gbl.dPosInfo.prmVer)>=9000)
	{
		iRet = checkPEPwd_Hdl(title);
		if(iRet!=0)
			if(iRet==CANCLE_KEY)
				return CANCLE_KEY;
			else
			{	
				info("老板密码校验错误\n\n请联系在线客服中心【Ctrl+H】  400-80-11888\n\n按【Enter】确认返回主菜单。");
				return iRet;
				
			}
	}
	
	memset(&menuList,0,sizeof(menuList));
	menuList.iTotalNum = 4;
	strcpy(menuList.acTitle, "请选择交易方式");
	strcpy(menuList.menuItem[0], "记住密码,每次交易不输密码");
	strcpy(menuList.menuItem[1], "不记密码,每次交易输入密码");
	strcpy(menuList.menuItem[2], "充值号码只输入一次");
	strcpy(menuList.menuItem[3], "充值号码两次输入确认");
	
	
	iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
	if(iRet)
		return -1;
	switch(iSelect)
	{
	case 1:
		setting_type = 0;
		epwdType = '\x01'; //记住密码
		break;
	case 2:
		setting_type = 0;
		epwdType = '\x03'; //不记住密码
		break;
	case 3:
		setting_type = 1;
		times = 0;
		break;
	case 4:
		setting_type = 1;
		times = 1;
		break;
	default: 
		TS_OutPutMsg(gbl.dPosInfo, "选择有误\n\n请按回车后重新操作", 0, iSelect);
		return -1;
	}
	
	if(setting_type == 0)
	{
		bbzero(msg);
		sprintf(msg, "你选择的是\n\n【%s】\n\n【确认】设置\n\n【返回】重新操作", menuList.menuItem[iSelect-1]);
		iRet = TS_OutPutMsg(gbl.dPosInfo, msg, 0, iSelect);
		if(iSelect==0)
		{
			tsposPar.num=1;
			tsposPar.parCont[0].parId=37;
			tsposPar.parCont[0].parLen=1;
			bbzero(tsposPar.parCont[0].parCont);
			tsposPar.parCont[0].parCont[0] = epwdType;
			iRet = TS_UpdatePosPar(gbl.dPosInfo, &tsposPar);
			if(iRet)
			{
				TS_OutPutMsg(gbl.dPosInfo, "更新出错\n请稍候再试!\n或联系在线客服中心【Ctrl+H】  400-80-11888", 0, iSelect);
				return -1;
			}
		}
		return 0;
	}
	else if(setting_type == 1)
	{
		bbzero(msg);
		if(times == 0)
		{
			sprintf(msg, "你选择的是\n\n【%s】\n\n【风险提示】充值号码只输入一次，容易导致因输入号码错误造成的资金损失，请谨慎操作\n\n【确认】设置\n\n【返回】重新操作", menuList.menuItem[iSelect-1]);
			iRet = TS_OutPutMsg(gbl.dPosInfo, msg, 0, iSelect);
			if(iRet || iSelect)
			{
				return -1;
			}
			else
			{
				gbl.input_times = 0;
			}
		}
		else if(times == 1)
		{
			sprintf(msg, "你选择的是\n\n【%s】\n\n【建议选择】充值号码两次输入确认，将大大减少号码输入错误的风险，建议选择\n\n【确认】设置\n\n【返回】重新操作", menuList.menuItem[iSelect-1]);
			iRet = TS_OutPutMsg(gbl.dPosInfo, msg, 0, iSelect);
			if(iRet || iSelect)
			{
				return -1;
			}
			else
			{
				gbl.input_times = 1;
			}
		}
		else
		{
			gbl.input_times = 1;
		}
		
		iRet = CDB::update_input_times(gbl.pos_no, gbl.input_times);
		if(iRet)
		{
			TS_OutPutMsg(gbl.dPosInfo, "设置出错\n请稍候再试!", 0, iSelect);
			return -1;
		}
		else
		{
			TS_OutPutMsg(gbl.dPosInfo, "设置成功！！\n按【确认】返回", 0, iSelect);
			return 0;
		}
	}
	else
	{
		return -1;
	}
}

//修改日交易限额
int CTrade::chgDayAmo(const char *title)
{
	int iRet=0, count=0, status=0, iSelect, dayAmo=0;
	char amount[12+1], amoMny[12+1], msg[300];
	char dayAmo_c[32] = {0};
	
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	
	if(atoi(gbl.dPosInfo.prmVer)>=9000)
	{
		iRet = checkPEPwd_Hdl(title);
		if(iRet!=0)
			if(iRet==CANCLE_KEY)
				return CANCLE_KEY;
			else
			{	
				info("老板密码校验错误\n\n请联系在线客服中心【Ctrl+H】  400-80-11888\n\n按【Enter】确认返回主菜单。");
				return iRet;
				
			}
	}
	
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, title);
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;	
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入日交易限额");
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_MONEY;	//金额
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
	tradeInfoSend.Contents[0].uMinLen = 1;
	tradeInfoSend.Contents[0].uMaxLen = 8;
	
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	
	dayAmo = atoi((const char *)tradeInfoRecv.Contents[0].uMsg);
	//20121227修改
	sprintf(dayAmo_c, "%012d", dayAmo);
	//iRet = CDB::updateDayAmo(gbl.pos_no, dayAmo);
	iRet = CDB::set_dayAmt(gbl.pos_no, dayAmo_c);
	if(iRet==0)
	{
		bbzero(amount);
		sprintf(amount, "%012ld", dayAmo);
		bbzero(amoMny);
		CTools::chgToMny(amount,amoMny);
		bbzero(msg);
		strcpy(msg, "修改成功!当前的日交易限额为\n\n");
		strcat(msg, amoMny);
		TS_OutPutMsg(gbl.dPosInfo, msg, 0, iSelect);
	}
	else
	{
		TS_OutPutMsg(gbl.dPosInfo, "数据库操作出错，修改失败!\n\n请稍后再试!", 0, iSelect);
		return iRet;
	}
	
	return 0;
}

int CTrade::tel_card_select(const char *title, int tel_card_type)
{
	int iRet,iSelect,count,j,i,s_flag,flag,t_flag;
	int b48_len=0,b63_len=0;
	char product_type[10+1],phone_d[6+1];
	char tmp[512],tc_name[15],mny[12+1];
	CDMA_INFO cdma_info[MAX_CDMA_INFO];    //CDMA选号信息
	TSMENULIST menuList;
	
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	
	
	if(strcmp(gbl.city_no, "020")!=0)
	{
		TS_OutPutMsg(gbl.dPosInfo,"即将开通，敬请关注！",1,iSelect);
		return -1;
	}
	
	
	for (i=0;i<MAX_CDMA_INFO;i++)
	{
		memset(cdma_info[i].phone_num,0,sizeof(cdma_info[i].phone_num));
		memset(cdma_info[i].phone_price,0,sizeof(cdma_info[i].phone_price));
		memset(cdma_info[i].phone_message,0,sizeof(cdma_info[i].phone_message));
		memset(cdma_info[i].yx_date,0,sizeof(cdma_info[i].yx_date));
		cdma_info[i].flag = 0;
	}
	memset(&menuList,0,sizeof(menuList));
	menuList.iTotalNum = 2;
	strcpy(menuList.acTitle, "请选择选号方式");
	strcpy(menuList.menuItem[0], "随机选号");
	strcpy(menuList.menuItem[1], "模糊选号");
	iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);	
	if(iRet)
		return -1;
	t_flag = iSelect;
	switch (tel_card_type)
	{
	case 1:
		if (t_flag == 1)
		{
			iRet = CDB::select_cdma_sj(cdma_info,1);
			if (iRet<0)
			{
				TS_OutPutMsg(gbl.dPosInfo,"号码已售完",0,iSelect);
				return -1;
			}
			gbl.cdma_num = iRet;
		}else if (t_flag == 2)
		{
			memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
			memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
			
			strcpy(tradeInfoSend.acMainTitle, title);
			tradeInfoSend.uHasTradeID = 1;
			tradeInfoSend.uTotalContents = 1;
			
			strcpy(tradeInfoSend.Contents[0].acTitle, "请输入3-6位号码");	
			tradeInfoSend.Contents[0].uMinLen = 3;		
			tradeInfoSend.Contents[0].uMaxLen = 6;
			tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
			tradeInfoSend.Contents[0].uCount = 0;		//输入1次		
			tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
			
			iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
			
			if(iRet != 0)
			{
				wrLog("TS_TradeControl返回错误[%d]", iRet);
				return iRet;
			}
			memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
			strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
			bbzero(phone_d);
			memcpy(phone_d, (char *)tradeInfoRecv.Contents[0].uMsg, tradeInfoRecv.Contents[0].uMsgLen);
			iRet = CDB::select_cdma_mh(cdma_info,phone_d,1);
			if (iRet<0)
			{
				TS_OutPutMsg(gbl.dPosInfo,"号码已售完",0,iSelect);
				return -1;
			}
			gbl.cdma_num = iRet;
		}else
			return -1;
		s_flag = 1;
		strcpy(product_type,"XH00000004");
		break;
	case 2:
		if (t_flag == 1)
		{
			iRet = CDB::select_cdma_sj(cdma_info,2);
			if (iRet<0)
			{
				TS_OutPutMsg(gbl.dPosInfo,"号码已售完",0,iSelect);
				return -1;
			}
			gbl.cdma_num = iRet;
		}else if (t_flag == 2)
		{
			memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
			memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
			
			strcpy(tradeInfoSend.acMainTitle, title);
			tradeInfoSend.uHasTradeID = 1;
			tradeInfoSend.uTotalContents = 1;
			
			strcpy(tradeInfoSend.Contents[0].acTitle, "请输入3-6位号码");	
			tradeInfoSend.Contents[0].uMinLen = 3;		
			tradeInfoSend.Contents[0].uMaxLen = 6;
			tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
			tradeInfoSend.Contents[0].uCount = 0;		//输入1次		
			tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
			
			iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
			
			if(iRet != 0)
			{
				wrLog("TS_TradeControl返回错误[%d]", iRet);
				return iRet;
			}
			memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
			strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
			bbzero(phone_d);
			memcpy(phone_d, (char *)tradeInfoRecv.Contents[0].uMsg, tradeInfoRecv.Contents[0].uMsgLen);
			iRet = CDB::select_cdma_mh(cdma_info,phone_d,2);
			if (iRet<0)
			{
				TS_OutPutMsg(gbl.dPosInfo,"号码已售完",0,iSelect);
				return -1;
			}
			gbl.cdma_num = iRet;
		}else
			return -1;
		s_flag = 2;
		strcpy(product_type,"XH00000003");
		break;
	default:
		return -1;
	}
	j=0;
	while (1)
	{
		count = 0;
		memset(&menuList,0,sizeof(menuList));
		for (i=0;i<20;i++)
		{
			if (cdma_info[j*20+i].flag == 1)
			{
				count ++;
			}else
				break;
		}
		menuList.iTotalNum = count+1;
		strcpy(menuList.acTitle, "请选择号码");
		for (i=0;i<count;i++)
		{
			strcpy(menuList.menuItem[i], cdma_info[j*20+i].phone_num);
		}
		strcpy(menuList.menuItem[count], "其他号码");
		iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
		if(iRet)
			return -1;
		if (iSelect>0&&iSelect<=count)
		{
			bbzero(tmp);
			bbzero(tc_name);
			if (s_flag == 1)
			{
				strcpy(tc_name,"CDMA畅聊套餐");
			}else if (s_flag == 2)
			{
				strcpy(tc_name,"CDMA大众套餐");
			}else
				return -1;
			bbzero(mny);
			CTools::chgToMny(cdma_info[j*20+iSelect-1].phone_price,mny);
			bbzero(gbl.telphone);
			bbzero(gbl.amount);
			strcpy(gbl.amount,cdma_info[j*20+iSelect-1].phone_price);
			strcpy(gbl.telphone,cdma_info[j*20+iSelect-1].phone_num);
			sprintf(tmp,"套餐：%s\n号码：%s\n售价：%s\n有效期：%s\n说明：%s\n按【确认】缴费\n按【返回】继续选号",tc_name,cdma_info[j*20+iSelect-1].phone_num,mny,cdma_info[j*20+iSelect-1].yx_date,cdma_info[j*20+iSelect-1].phone_message);
			TS_OutPutMsg(gbl.dPosInfo,tmp,0,iSelect);
			if (iSelect == 0)
			{
				break;
			}else
				continue;
		}else if(iSelect == count+1)
		{
			j++;
			wrLog("总数:%d  此次显示数目：%d",gbl.cdma_num,count);
			if(j>=5||count<20||((j-1)*20+count==gbl.cdma_num))
				j=0;
		}else
			return -1;
		
	}
	flag = 0;
	bbzero(gbl.fee_type);
	bbzero(gbl.stan_no);
	strcpy(gbl.fee_type,"0248");
	strcpy(gbl.stan_no,"000000000000");
	gbl.product_flag = 4;
	bbzero(gbl.product_name);
	if (s_flag == 1)
	{
		strcpy(gbl.product_name,"153畅聊卡");
	}else if (s_flag == 2)
	{
		strcpy(gbl.product_name,"153大众卡");
	}
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{
		if(!flag) 
		{
			if( gbl.get_card == MNG_ONE_BIND_E || gbl.get_card == MNG_MUL_BIND_E )
				iRet = mngCard_Hdl(title, "", 0, 1);//只能刷卡，多次刷卡模式
			else
				iRet = mngCard_Hdl(title);
			if(iRet == CANCLE_KEY)
				return CANCLE_KEY;
			else if(iRet != 0){
				TS_OutPutMsg(gbl.dPosInfo,"读取输入数据错误!\n交易失败!\n按【确认】返回",1,iSelect);
				return -1;
			}
			
			if(!memcmp(gbl.card_no,"8828",4))	//若是付费易卡,走付费易卡刷卡流程（多卡交易）
			{
				memset(gbl.xlt_type, 0, sizeof(gbl.xlt_type));
				memcpy(gbl.xlt_type, "01",2);
				iRet = xltMulCard( title, 0);
				return iRet;
			}
		}
		
		pack.wrField(2, gbl);	//写交费域
		
		bbzero(pack.FIELD48);
		memcpy(pack.FIELD48,gbl.fee_type,4);
		b48_len += 4;
		memcpy(pack.FIELD48+b48_len,"10",2);
		b48_len += 2;
		memcpy(pack.FIELD48+b48_len,product_type,10);
		b48_len += 10;
		pack.Packet_Table[48].Real_Length = b48_len;
		
		
		bbzero(pack.FIELD63);
		b63_len += 8;
		memcpy(pack.FIELD63+b63_len,"0001",4);
		b63_len += 4;
		memcpy(pack.FIELD63+b63_len,"11",2);
		b63_len += 2;
		memcpy(pack.FIELD63+b63_len,gbl.telphone,11);
		b63_len += 11;
		pack.Packet_Table[63].Real_Length = b63_len;
		
		
		//交费包处理
		iRet = packHdl(2);
		if(iRet < 0)
			return -1;
		
		if (!memcmp(pack.FIELD39,"00",2)) 
		{
			
			
			iRet = TS_OutPutMsg(gbl.dPosInfo,"\n     购买成功！\n请按【确认】打印发票",0,iSelect);
			
			if(iRet!=0 || iSelect==0)
			{
				CPrint prt;
				prt.set_in_par(gbl);
				prt.print_detail(13,title);
			//	prt.print_SELL_POS(pack,title);
			}
			
			return 0;
		}// end if (!memcmp(pack.FIELD39,"00",2))
		else if(!memcmp(pack.FIELD39,"55",2))
		{
			flag = 1;
			if(reGetPwd( title) == 0) //密码错误，重新输入密码, 2006-10-25
				continue;
			else
				return CANCLE_KEY;
		}
		else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
			if (iSelect!=0)
			{
				return -1;
			}else
				continue;
		}
		else		
			returnFail((char *)pack.FIELD39);		
		return -1;
	}
	return -1;
}

int CTrade::PayEasy_MoneyIn(const char *title)
{
	int iSelect,iRet,logon_name_len,b48_len,b63_len,flag;
	char logon_name[80+1],zh_num[100];
	char logon_name_len_buf[2+1],len_buf[2+1];
	
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	
	TSMENULIST menuList;
	
	flag = 0;
	while (!flag)
	{
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
		
		strcpy(tradeInfoSend.acMainTitle, title);
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents = 1;
		
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入要充值的账号");	
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//全字符
		tradeInfoSend.Contents[0].uCount = 1;		//输入2次
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+20;	//超时50秒
		tradeInfoSend.Contents[0].uMinLen = 1;		
		tradeInfoSend.Contents[0].uMaxLen = 80;	
		
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		if(iRet != 0)
		{
			wrLog("TS_TradeControl返回错误[%d]", iRet);
			wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
			return iRet;
		}
		
		memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
		bbzero(logon_name);
		strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);	
		strcpy(logon_name,(char *)tradeInfoRecv.Contents[0].uMsg );
		logon_name_len = tradeInfoRecv.Contents[0].uMsgLen;
		bbzero(logon_name_len_buf);
		sprintf(logon_name_len_buf,"%02d",logon_name_len);
		
		//写查询域
		pack.wrField(1, gbl);
		
		bbzero(pack.FIELD3);
		CTools::hex_to_byte((BYTE *)"310000", pack.FIELD3, 6);
		bbzero(pack.FIELD48);
		b48_len = 0;
		memcpy(pack.FIELD48+b48_len,gbl.fee_type,4);
		b48_len += 4;
		memcpy(pack.FIELD48+b48_len,logon_name_len_buf,2);
		b48_len += 2;
		memcpy(pack.FIELD48+b48_len,logon_name,logon_name_len);
		b48_len +=logon_name_len;
		pack.Packet_Table[48].Real_Length = b48_len;
		
		//查询包打包   
		iRet = packHdl(1);
		if(iRet < 0)
			return -1;
		if (!memcmp(pack.FIELD39,"00",2))
		{
			bbzero(len_buf);
			memcpy(len_buf,pack.FIELD63,2);
			bbzero(zh_num);
			memcpy(zh_num,pack.FIELD63 + 2,atoi(len_buf));
			break;
		}else if (memcmp(pack.FIELD62+6,"14",2) == 0)
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n    该账号不存在\n按【确认】请重新输入",0,iSelect);
			if (iSelect<0 || iSelect == CANCLE_KEY)
			{
				return -1;
			}else
				continue;
		}else
			returnFail((char *)pack.FIELD39);
		return -1;
	}
	bbzero(gbl.pay_easy_zh);
	strcpy(gbl.pay_easy_zh,logon_name);
	memset(&menuList,0,sizeof(menuList));
	menuList.iTotalNum = 3;
	strcpy(menuList.acTitle, "请选择您要充值的金额");
	strcpy(menuList.menuItem[0], "100元");
	strcpy(menuList.menuItem[1], "200元");
	strcpy(menuList.menuItem[2], "其他金额");
	iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);	
	if(iRet)
		return -1;
	bbzero(gbl.amount);
	switch (iSelect)
	{
	case 1:
		strcpy(gbl.amount,"000000010000");
		break;
	case 2:
		strcpy(gbl.amount,"000000010000");
		break;
	case 3:
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
		
		strcpy(tradeInfoSend.acMainTitle, title);
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents = 1;
		
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入要充值的金额");	
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_MONEY;	
		tradeInfoSend.Contents[0].uCount = 0;		//输入1次
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
		tradeInfoSend.Contents[0].uMinLen = 1;		
		tradeInfoSend.Contents[0].uMaxLen = 6;
		
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		if(iRet != 0)
		{
			wrLog("TS_TradeControl返回错误[%d]", iRet);
			wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
			return iRet;
		}
		
		memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
		strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);	
		strcpy(gbl.amount,(char *)tradeInfoRecv.Contents[0].uMsg );
		break;
	default:
		return -1;
	}
	flag = 0;
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{
		if(!flag) 
		{
			if( gbl.get_card == MNG_ONE_BIND_E || gbl.get_card == MNG_MUL_BIND_E )
				iRet = mngCard_Hdl(title, "", 0, 1);//只能刷卡，多次刷卡模式
			else
				iRet = mngCard_Hdl(title);
			if(iRet == CANCLE_KEY)
				return CANCLE_KEY;
			else if(iRet != 0){
				TS_OutPutMsg(gbl.dPosInfo,"读取输入数据错误!\n交易失败!\n按【确认】返回",1,iSelect);
				return -1;
			}
		}
		
		pack.wrField(2, gbl);	//写交费域
		
		bbzero(pack.FIELD48);
		b48_len = 0;
		memcpy(pack.FIELD48+b48_len,gbl.fee_type,4);
		b48_len += 4;
		memcpy(pack.FIELD48+b48_len,logon_name_len_buf,2);
		b48_len += 2;
		memcpy(pack.FIELD48+b48_len,logon_name,logon_name_len);
		b48_len += logon_name_len;
		pack.Packet_Table[48].Real_Length = b48_len;
		
		bbzero(pack.FIELD63);
		b63_len = 0;
		b63_len += 8;
		memcpy(pack.FIELD63+b63_len,len_buf,2);
		b63_len += 2;
		memcpy(pack.FIELD63+b63_len,zh_num,atoi(len_buf));
		b63_len += atoi(len_buf);
		pack.Packet_Table[63].Real_Length = b63_len;
		
		//交费包处理
		iRet = packHdl(2);
		if(iRet < 0)
			return -1;
		
		if (!memcmp(pack.FIELD39,"00",2)) 
		{			
			iRet = TS_OutPutMsg(gbl.dPosInfo,"     充值成功！\n    感谢您的使用\n请按【确认】打印凭据",0,iSelect);
			
			if(iRet!=0 || iSelect==0)
			{
				CPrint prt;
				prt.set_in_par(gbl);
				//prt.print_detail(2,title);
				prt.print_pre_detail(pack,title);
			}			
			return 0;
		}
		else if(!memcmp(pack.FIELD39,"55",2))
		{
			flag = 1;
			if(reGetPwd( title) == 0) //密码错误，重新输入密码, 2006-10-25
				continue;
			else
				return CANCLE_KEY;
		}
		else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
			if (iSelect!=0)
			{
				return -1;
			}else
				continue;
		}
		else		
			returnFail((char *)pack.FIELD39);		
		return -1;
	}
	return 0;
}

//商户结算
int CTrade::chk_money(const char *title)
{
	int iRet=0, iSelect=0;
	//	char bankamo[12+1], bankmny[12+1], ecardamo[12+1], ecardmny[12+1], chktermseq[12+1], chksysseq[12+1], detail[1024], pricont[1024];
	char chktermseq[12+1], chksysseq[12+1], detail[1024], pricont[1024];
	
	// 	iRet = checkPEPwd_Hdl(title);
	// 	if(iRet!=0)
	// 		return iRet;
	
	// 	bbzero(bankamo);
	// 	bbzero(bankmny);
	// 	bbzero(ecardamo);
	// 	bbzero(ecardmny);
	bbzero(chktermseq);
	bbzero(chksysseq);
	bbzero(detail);
	bbzero(pricont);
	
	// 	strcpy(gbl.fee_type, "0238");
	// 	iRet = banInqMoneyTrade(title, bankamo);
	// 	if(iRet!=0)
	// 		return iRet;
	// 
	// 	CTools::chgToMny(bankamo, bankmny);
	// 
	// 	strcpy(gbl.fee_type, "0083");
	// 	iRet = cardInqHdl(ecardamo);
	// 	if(iRet!=0)
	// 		return iRet;
	// 
	// 	CTools::chgToMny(ecardamo, ecardmny);
	
	bbzero(detail);
	iRet = CDB::showchktxn(gbl.pos_no, detail);
	if(iRet!=0)
	{
		iRet = TS_OutPutMsg(gbl.dPosInfo, "读取结算数据出错！", 1, iSelect);
		return iRet;
	}
	
	// 	strcat(detail, "3.帐户余额：");
	// 	strcat(detail, ecardmny);
	// 	strcat(detail, "\n4.银行卡余额：");
	// 	strcat(detail, bankmny);
	strcat(detail, "\n按【确定】结算，按【返回】返回");
	
	iRet = TS_OutPutMsg(gbl.dPosInfo, detail, 1,iSelect);
	if(iSelect==0)
	{
		//iRet = CDB::chktxn(gbl.pos_no, ecardamo, bankamo, chktermseq, chksysseq);
		iRet = CDB::chktxn(gbl.pos_no, "000000000000", "000000000000", chktermseq, chksysseq);
		if(iRet!=0)
		{
			iRet = TS_OutPutMsg(gbl.dPosInfo, "结算出错！\n请稍候再试!\n或联系在线客服中心【Ctrl+H】  400-80-11888", 1, iSelect);
			return iRet;
		}
		strcpy(pricont, "终端结算批次号：");
		strcat(pricont, chktermseq);
		strcat(pricont, "\n系统结算批次号：");
		strcat(pricont, chksysseq);
		strcat(pricont, "\n");
		strcat(pricont, detail);
		CPrint prt;
		prt.set_in_par(gbl);
		//prt.print_detail(14, title, pricont);
		prt.print_chk_amo(pack,title,pricont);
	}
	else
	{
		return -1;
	}
	return 0;
}


//////////////////////////////////////////东莞通公交充值///////////////////////////////////////////////////
int CTrade::dgtBusTrade( char *type,int chargeType)
{
	int iRet=0;
	char showMsg[200];
	int iSelect;
	char errMsg[200];
	int TOTALSVAMT=0;
	int payAmount=0;
	int TOTALSVNUM;

	bbzero(errMsg);
	bbzero(showMsg);
	gbl.random_value=0;

	iRet=CDB::checkSignStatus(gbl.dPosInfo.pos_no,&gbl.dgtSignInfo);
	if (iRet!=0)
	{
		TS_OutPutMsg(gbl.dPosInfo,"您尚未签到,请先进行签到",1,iSelect);
		return CANCLE_KEY;
	}

	//检查上一笔交易
	iRet=checkdgtUnsubmit(2);
	
	//初始化
	bbzero(gbl.TRANSSEQ);
	bbzero(gbl.SYSTEMNO);
	memset(&gbl.dgtCard,0,sizeof(gbl.dgtCard));
	iRet = dgtCardInqHdl(&gbl.dgtCard,1); //卡片余额查询操作
	if (iRet!=0)
	{

		return CANCLE_KEY;
	}

	
	//进行卡检查
	iRet=dgtEffectiveCheck(1,errMsg);
	
	if (iRet!=0)
	{
		TS_OutPutMsg(gbl.dPosInfo,(char *)errMsg,1,iSelect);
		return -1; //有效性检查失败
	}

	sprintf(showMsg,"卡片余额:%.2f元 \n充值请按【Enter】返回请按【Esc】",atof(gbl.dgtCard.cardMny)/100);
	TS_OutPutMsg(gbl.dPosInfo,showMsg,0,iSelect);
	if (iSelect!=0)
	{
		return CANCLE_KEY;
	}

	iRet=selectDGAmount();

	if(iRet==CANCLE_KEY)
		return CANCLE_KEY;
	else if(iRet < 0)
		return -1;
	//进行充值
	wrLog("gbl.amount:%s",gbl.amount);
	
	iRet=dgtCardCharge(type);
	if (iRet!=0)
	{
		wrLog("充值失败");
		return -1;
	}
	
	//更新数据

	payAmount=atoi(gbl.amount); //交易金额变动
	TOTALSVAMT=payAmount+atoi(gbl.dgtSignInfo.TOTALSVAMT);

	TOTALSVNUM=atoi(gbl.dgtSignInfo.TOTALSVNUM); //交易总数变动
	TOTALSVNUM++;

	bbzero(gbl.dgtSignInfo.TOTALSVNUM);
	sprintf(gbl.dgtSignInfo.TOTALSVNUM,"%010d",TOTALSVNUM);
	bbzero(gbl.dgtSignInfo.TOTALSVAMT);
	sprintf(gbl.dgtSignInfo.TOTALSVAMT,"%010d",TOTALSVAMT);

	bbzero(gbl.dgtSignInfo.TOTALSALEDEP);
	strcpy(gbl.dgtSignInfo.TOTALSALEDEP,"0000000000"); //默认为买断,不收取押金

	CDB::update_dgtSignInfo(gbl.pos_no,gbl.dgtSignInfo);
	sprintf(showMsg,"充值成功!\n充值前余额:%.2f元\n交易金额:%.2f元\n充值后余额:%.2f元\n\n按【Esc】返回 按【Enter】打印票据",atof(gbl.dgtCard.tradeBeForeMny)/100,atof(gbl.amount)/100,atof(gbl.dgtCard.tradeAfterMny)/100);
	TS_OutPutMsg(gbl.dPosInfo,showMsg,1,iSelect);
	if (iSelect!=0)
	{
		return 0;
	}

	CPrint print;
	print.set_in_par(gbl);
	print.print_dgtBus_detail(type);
	return iRet;

}


int CTrade::dgtCardsQuery( )
{
	//上电查询卡片类型
	int iRet;
	int iSelect;
	char rsp_code[4+1];
	char errMsg[200];
	bbzero(rsp_code);
	bbzero(errMsg);
	char showMsg[300];
	bbzero(showMsg);


	iRet=CDGTBusTrade::getCardType(gbl.dPosInfo,rsp_code,errMsg);

	if (iRet<0) //如果查询失败
	{
		TS_OutPutMsg(gbl.dPosInfo,"读卡失败,请重新放卡",1,iSelect);
		return CANCLE_KEY;
			
	}

	if (iRet==0) //返回的是cpu卡
		{
			iRet=dgtCardInqHdl(&gbl.dgtCard,0);
			return iRet;
		}
	if (iRet==1)
		{
			iRet=dgtM1CardInqHdl(&gbl.dgtM1Card,0);
			if (iRet!=0) 
			{
				if (iRet==-5)
				{
					return CANCLE_KEY;
				}
				else
				{
					TS_OutPutMsg(gbl.dPosInfo,"读卡失败，请重试",1,iSelect);
					return CANCLE_KEY;
				}
				
			}
				
			//在界面上面显示余额
			sprintf(showMsg,"余额:%.2f元 请按【Esc】返回",atof(gbl.dgtM1Card.bus_amt)/100);
			
			TS_OutPutMsg(gbl.dPosInfo,showMsg,1,iSelect);
			return 0;
		}



	return 0;
	
}


//查询类型，flag 1 查询余额等基础信息 0 只查询余额 。3交易过程中查询余额

int CTrade::dgtCardInqHdl(PDGTCard pdgtCard,int flag) //读取卡片余额等信息
{
	
	int iRet;
	int iSelect;
	char errMsg[255];
	char reader_rsp[4+1];
	bbzero(reader_rsp); //公交读卡器返回的错误吗
	bbzero(errMsg);
	//初始化东莞通卡

	if (flag!=3) //交易过程中更新卡片余额，不初始化
	{
		CDGTBusTrade::init_dgtCard_data(pdgtCard); //初始化卡片信息

	}


	//三次读卡
	for(int i=0;i<3;i++)
	{
	
		iRet=CDGTBusTrade::cardQuery(gbl.dPosInfo,reader_rsp,errMsg,pdgtCard,flag);
		if (iRet!=0) //如果读取错误
		{

			bbzero(errMsg);
			strcpy(errMsg,"查询读卡器失败，请将卡放在读卡器上重试\n 请按【Enter】继续");
			TS_OutPutMsg(gbl.dPosInfo,errMsg,0,iSelect);

		}
		else //读卡成功直接退出寻卡
		{
		
			break;
		}
	
	}

	if (iRet!=0) //三次读卡均失败
	{
		return -1;
	}


	//显示卡片余额；
	char showMsg[200];
	char showLEDMsg[500];
	char cardMny[12+1];

	bbzero(cardMny);
	bbzero(showMsg);
	bbzero(showLEDMsg);

	strcpy(cardMny,pdgtCard->cardMny);
	sprintf(showLEDMsg,"余额:%.2f元",atof(cardMny)/100);
	wrLog("需要显示的信息:%s",showLEDMsg);

	if (flag==0) //如果只是查询
	{

		bbzero(errMsg);
		iRet=CDGTBusTrade::showLEDMsg(gbl.dPosInfo,showLEDMsg,errMsg);
		
		if (iRet!=0)
		{
			TS_OutPutMsg(gbl.dPosInfo,errMsg,0,iSelect);
			return -1;
		}

		sprintf(showMsg,"卡片余额:%.2f元 请按【Esc】返回",atof(cardMny)/100);
		TS_OutPutMsg(gbl.dPosInfo,showMsg,1,iSelect);
	}

	else
	{
	
		return 0;

	}

	return 0;

}

//读取M1卡信息  0.查询余额 1 交易读取

int CTrade::dgtM1CardInqHdl(PDGTM1Card pdgtM1Card,int type) //读取卡片余额等信息
{
	
	int iRet;
	char errMsg[255];
	char reader_rsp[4+1];
	bbzero(reader_rsp); //公交读卡器返回的错误吗
	bbzero(errMsg);
	//初始化东莞通卡

	CDGTBusTrade::init_dgtM1Card_data(pdgtM1Card); //初始化卡片信息
	
	//三次读卡
	for(int i=0;i<3;i++)
	{
	
		iRet=CDGTBusTrade::cardM1Query(gbl.dPosInfo,reader_rsp,type,errMsg,pdgtM1Card);
		if (iRet==0  ) //如果读取错误
		{
			break;
		
		}
		else
		{
			if (iRet==-3)
			{
				return -3;
			}
			else if (iRet==-5)
			{
				return -5;
			}
			else if (iRet==-4)
			{
				return -4;
			}
			else
			{
			
				continue;
			}
		}
	
	}

	if (iRet!=0) //三次读卡不成功。返回失败
	{
		return -1;
	}

	return 0;

}


//////////////////////////////////////////东莞公交///////////////////////////////////////////////////
int CTrade::busTrade(const char *type,int chargeType){
	int iRet=0;
	iRet = busInqHdl(type,chargeType);
	return iRet;
}

/*************************************************************/
//查询
/*************************************************************/
int CTrade::busInqHdl(const char *type,int chargeType)
{
	int iRet, flag = 1, rcvLen=0, inqLen=0, iSelect=0,i,sendLen=0;	
	char rcvData[256],inqdata[128],inqdataHex[256];
	char date[8+1];  //8位日期
	char check_date[6+1];
	char check_date_buff[6+1];
	char temp_buff[1024];
	char check_buff[1024];
	char respond_code[4+1],return_le[4+1],cz_key[80+1];
	int length;
	char sendData[256],yj_amount[8+1];
	char dkq_code[4+1],dkq_PSAM[16+1];
	char old_amount[20],amoMny[12+1],msg[256];
	char sndIcData[256]; //发送给读卡器的数据
	char tmp[250];
	char outPutMsg[50];
	char outPutMsgBuff[50];

	wrLog("【查询】busInqHdl");
	bbzero(rcvData);
	bbzero(sndIcData);
	bbzero(date);
	bbzero(gbl.bus_failcode);
	bbzero(check_date);
	bbzero(check_date_buff);
	strcpy(gbl.bus_failcode,"01");
	CTools::get_date8(date);
	memcpy(check_date,date+2,6);
	bbzero(gbl.bus_card); //票卡号
	bbzero(gbl.bus_conf); //票卡认证码
	bbzero(gbl.bus_old_amo); //票卡金额（充值前）
	bbzero(gbl.bus_card_type); //公交卡类型
	bbzero(gbl.dkq_code); //机具编号
	bbzero(gbl.dkq_PSAM); //psam卡号

	//充值验卡 需要加判断：如果是HID设备。

	if(gbl.HID_TYPE==1) //如果是HID设备已经打开的情况
	{


		if( busSndRcvHID_IcData(type, (const BYTE *)"\xC2\x81",2, (BYTE *)rcvData, rcvLen, gbl.pos_serial) ) //充值验卡是读卡器之间的。
			{

				return -1;
			}
		if ((unsigned char)(rcvData[0]) == 0x81) //如果第一个状态吗发挥0x81，那么执行指令不成功。

			{

				returnHIDBusFail(rcvData[1]); 
				return -3;
		
			}
		
	CTools::byte_to_hex((const BYTE *)rcvData+2,(BYTE*)gbl.bus_card,4); //票卡号
	memcpy(gbl.bus_conf,rcvData+6,4); //票卡认证码
	CTools::byte_to_hex((const BYTE *)rcvData+10, (BYTE *)gbl.bus_old_amo, 4); //票卡金额（充值前）
	CTools::byte_to_hex((const BYTE *)rcvData+14, (BYTE *)gbl.bus_card_type, 1); //应用子类型，卡片类型
	CTools::byte_to_hex((const BYTE *)rcvData+17, (BYTE *)check_date_buff, 3); //年审日期

	wrLog("年审日期：%s   系统日期：%s",check_date_buff,check_date);

	if(!strcmp(gbl.fee_type,"0214") && (strcmp(gbl.bus_old_amo,"00000000") || ((unsigned char)(rcvData[16])==0xBB))) //新卡是0XAA，旧卡是0xBB
	{
		TS_OutPutMsg(gbl.dPosInfo," \n    该卡非空白卡\n   按【确认】返回",0,iSelect);
		return -5;
	}
	if (!strcmp(gbl.fee_type,"0211")&&((unsigned char)(rcvData[16])==0xAA)) //新卡是0XAA
	{
		TS_OutPutMsg(gbl.dPosInfo," \n该卡为空白卡，不能进行充值!\n   按【确认】返回",0,iSelect);
		return -6;
	}
	if (strcmp(gbl.bus_card_type,"01")&&strcmp(gbl.bus_card_type,"A4"))
	{
		TS_OutPutMsg(gbl.dPosInfo," \n卡类型错误或卡已过期\n    不能进行充值!\n   按【确认】返回",0,iSelect);
		return -7;
	}
	if ((atoi(check_date_buff)!=0) && (atoi(check_date)>atoi(check_date_buff)))
	{
		TS_OutPutMsg(gbl.dPosInfo,"  \n     已过年审期!\n    不能进行充值!\n   按【确认】返回",0,iSelect);
		return -8;
	}
	
	memcpy(gbl.dkq_code,rcvData+20,4);
	CTools::byte_to_hex((const BYTE *)rcvData+24, (BYTE *)gbl.dkq_PSAM, 8); //psam卡号
	
	wrHex("充值验卡返回机具编号",(BYTE *)gbl.dkq_code,4);
	wrLog("PSAM卡号是:%s",gbl.dkq_PSAM);
	
	bbzero(gbl.bus_card_serial);//交易流水标识
	memcpy(gbl.bus_card_serial, rcvData+15, 1); //交易流水标志

	//清空读卡器信息
	bbzero(sndIcData);
	sendLen=0;
	bbzero(rcvData);
	rcvLen=0;
	wrLog("清空读卡器显示信息");
	if( busSndRcvHID_IcData(type, (const BYTE *)"\xF0\x40\x00\x01",4, (BYTE *)rcvData, rcvLen, gbl.pos_serial) ) //充值验卡是读卡器之间的。
	{
		
		return -1;
	}
	if ((unsigned char)(rcvData[0]) != 0x00) //如果第一个状态吗发挥0x81，那么执行指令不成功。
		
	{
		
		returnHIDBusFail(rcvData[1]); 
		return -3;
		
	}
	

	//发送读卡器显示余额信息
	wrLog("发送给读卡器显示信息的指令");
	bbzero(sndIcData);
	sendLen=0;
	int msg_len=0;
	bbzero(rcvData);
	rcvLen=0;
	bbzero(old_amount);
	CTools::sixten_toten(gbl.bus_old_amo,old_amount);
	sprintf(outPutMsg,"余额:%.2f元",atof(old_amount)/100); //在读卡器上面显示的
	//for(msg_len=0; msg_len<sizeof(outPutMsg) &&outPutMsg[msg_len]!=0x00 && outPutMsg[msg_len]!=0x20; msg_len++);
	memcpy(sndIcData,"\xF0\x41\x01\x01",4); //显示一行信息
	sendLen+=4;
	memcpy(sndIcData+sendLen,outPutMsg,strlen(outPutMsg)); 
	sendLen+=strlen(outPutMsg);
	
	//发信息到终端 
	if( busSndRcvHID_IcData(type, (const BYTE *)sndIcData,sendLen, (BYTE *)rcvData, rcvLen, gbl.pos_serial) ) //充值验卡是读卡器之间的。
	{
		
		return -1;
	}
	if ((unsigned char)(rcvData[0]) != 0x00) //如果第一个状态吗发挥0x81，那么执行指令不成功。
		
	{
		
		returnHIDBusFail(rcvData[1]); 
		return -3;
		
	}
	

	}

	else //如果不是HID设备，则默认为串口设备
	{

	if( busSndRcvIcData(type, (const BYTE *)"\x0C\x01\x00\x02\x81\x00\x8E", 7, (BYTE *)rcvData, rcvLen, gbl.pos_serial) ) //充值验卡是读卡器之间的。
	{
		return -1;
	}
	if ((unsigned char)(rcvData[4]) == 0xA1)
	{
		returnBusFail(rcvData[5]);
		return -3;
	}	
	
	CTools::byte_to_hex((const BYTE *)rcvData+6, (BYTE *)gbl.bus_card, 4);//卡唯一号 
	memcpy(gbl.bus_conf, rcvData+10, 4);//卡认证码
	CTools::byte_to_hex((const BYTE *)rcvData+14, (BYTE *)gbl.bus_old_amo, 4);
	CTools::byte_to_hex((const BYTE *)rcvData+18, (BYTE *)gbl.bus_card_type, 1);
	CTools::byte_to_hex((const BYTE *)rcvData+21, (BYTE *)check_date_buff, 3);
	wrLog("年审日期：%s   系统日期：%s",check_date_buff,check_date);
	if(!strcmp(gbl.fee_type,"0214") && (strcmp(gbl.bus_old_amo,"00000000") || ((unsigned char)(rcvData[20])==0xBB))){
		TS_OutPutMsg(gbl.dPosInfo," \n    该卡非空白卡\n   按【确认】返回",0,iSelect);
		return -5;
	}
	if (!strcmp(gbl.fee_type,"0211")&&((unsigned char)(rcvData[20])==0xAA))
	{
		TS_OutPutMsg(gbl.dPosInfo," \n该卡为空白卡，不能进行充值!\n   按【确认】返回",0,iSelect);
		return -6;
	}
	if (strcmp(gbl.bus_card_type,"01")&&strcmp(gbl.bus_card_type,"A4"))
	{
		TS_OutPutMsg(gbl.dPosInfo," \n卡类型错误或卡已过期\n    不能进行充值!\n   按【确认】返回",0,iSelect);
		return -7;
	}
	if ((atoi(check_date_buff)!=0) && (atoi(check_date)>atoi(check_date_buff)))
	{
		TS_OutPutMsg(gbl.dPosInfo,"  \n     已过年审期!\n    不能进行充值!\n   按【确认】返回",0,iSelect);
		return -8;
	}

	//进行黑名单交易
	memcpy(gbl.dkq_code,rcvData+24,4);
	CTools::byte_to_hex((const BYTE *)rcvData+28, (BYTE *)gbl.dkq_PSAM, 8);
	bbzero(gbl.bus_card_serial);//交易流水标识
	memcpy(gbl.bus_card_serial, rcvData+19, 1);

	}

	//显示余额信息
	bbzero(tmp);
	CTools::sixten_toten(gbl.bus_old_amo,old_amount);
	if(chargeType==0) //查询
	{
		sprintf(tmp,"余额为:%.2f元 返回请按【Esc】",atof(old_amount)/100); 
		TS_OutPutMsg(gbl.dPosInfo,tmp,0,iSelect);
		return 0;
	}
	
	else if(chargeType==1 || chargeType ==2) //充值,1为普通公交充值，2为莞市通充值
		
	{
		sprintf(tmp,"余额为:%.2f元 充值请按【Enter】返回请按【Esc】",atof(old_amount)/100); 
		TS_OutPutMsg(gbl.dPosInfo,tmp,0,iSelect);
		if(iSelect!=0)
		{
			
			return CANCLE_KEY;
		}
	}

	//检查卡片是否已经锁卡，因为旧的明华读卡器读不出来卡片是否锁卡，所以根据的是系统中是否具有换卡记录来判断的

	if(gbl.HID_TYPE == 1) // 如果是HID设备已经打开的情况 
	{

		
		//校验卡状态是否有效 by linwenxu 20141124
		char errmsg[256];
		bbzero(errmsg);
		memset(&gbl.dgtM1Card,0,sizeof(gbl.dgtM1Card));
		CDGTBusTrade::getM1SBInfo(gbl.dPosInfo,&gbl.dgtM1Card,errmsg);
		if(0 == strcmp(gbl.dgtM1Card.cardStatus,"02"))
		{
			TS_OutPutMsg(gbl.dPosInfo,"  \n     已锁卡!\n    不能进行充值!\n   按【确认】返回",0,iSelect);
			return CANCLE_KEY;
		}

	}
	else  //如果不是HID设备，则默认为串口设备
	{
		//十六进制转换为十进制
		CTools::getDGTM1CardId(gbl.bus_card,gbl.bus_showId);
		if(1 == CDB::IsGetM1CardInDgtTransferLog(&gbl))
		{			
			TS_OutPutMsg(gbl.dPosInfo,"  \n     已锁卡!\n    不能进行充值!\n   按【确认】返回",0,iSelect);
			return CANCLE_KEY;
		}
	}

	//完成检查锁卡操作。

	//黑名单校验向充值服务器发送黑名单交易指令
	wrLog("【校验黑名单】");
	bbzero(gbl.bus_enq_stan);
	iRet = CDB::get_DGBus_stan(gbl.bus_enq_stan);
	if (iRet < 0)
	{
		wrLog("获取公交交易系统参考号失败");
		return -1;
	}

	bbzero(inqdata);
	inqLen = 0;
	inqdata[inqLen++] = 0x00;//城市代码
	inqdata[inqLen++] = 0x00;
	inqdata[inqLen++] = 0x00;//行业代码
	inqdata[inqLen++] = 0x00;
	
	CTools::hex_to_byte((BYTE *)gbl.bus_card,(BYTE *)inqdata+inqLen,8);
	inqLen += 4;
	memset(inqdata+inqLen, 0, 4);//卡应用号
	inqLen += 4;
	CTools::hex_to_byte((const BYTE *)"00000000", (BYTE *)inqdata+inqLen, 8);//卡验证码
	inqLen += 4;
	CTools::hex_to_byte((const BYTE *)"00000000", (BYTE *)inqdata+inqLen, 8);//申请日期
	inqLen += 4;
	CTools::hex_to_byte((const BYTE *)"000000", (BYTE *)inqdata+inqLen, 6);//申请时间
	inqLen += 3;
	CTools::hex_to_byte((const BYTE *)"00000000", (BYTE *)inqdata+inqLen, 8);
	inqLen += 4;
	CTools::hex_to_byte((const BYTE *)"00000000", (BYTE *)inqdata+inqLen, 8);
	inqLen += 4;
	inqdata[inqLen++] = 0x00;//充值类型
	inqdata[inqLen++] = 0x00;//充值点编号
	inqdata[inqLen++] = 0x00;
	CTools::hex_to_byte((const BYTE *)gbl.pos_no+2, (BYTE *)inqdata+inqLen, 6);//充值机编号
	inqLen += 3;
	inqdata[inqLen++] = 0x00;//充值员编号
	inqdata[inqLen++] = 0x00;
	inqdata[inqLen++] = 0x00;
	
	bbzero(temp_buff);
	bbzero(inqdataHex);
	bbzero(check_buff);
	CTools::byte_to_hex((const BYTE *)inqdata, (BYTE *)inqdataHex, inqLen);
	/***********************************************************/
	strncat(temp_buff,"7E7E7E00",8);
	strncat(temp_buff,gbl.pos_no+2,6);
	strncat(temp_buff,"8006",4);
	strncat(temp_buff,&(bus_key.bus_charge_key[2]),2);
	strncat(temp_buff,&(bus_key.bus_charge_key[4]),2);
	strncat(temp_buff,&(bus_key.bus_charge_key[0]),2);
	strncat(temp_buff,"38",2);
	strncat(temp_buff,gbl.bus_enq_stan,12);
	strncat(temp_buff,"002A",4);
	strncat(temp_buff,inqdataHex,inqLen*2);
	
	length = CTools::hex_to_byte((const BYTE *)temp_buff,(BYTE *)check_buff,strlen(temp_buff));
	CTools::crc_cu_16((BYTE *)check_buff,length);
	bbzero(temp_buff);
	CTools::byte_to_hex((const BYTE *)check_buff,(BYTE *)temp_buff,length+2);
	
	for (i=1;i<MAX_BUS_ORDER;i++)
	{
		if (bus_order[i].flag == 0)
		{
			bus_order[i].flag = 1;
			break;
		}
	}
	if (i == MAX_BUS_ORDER)
	{
		wrLog("公交交易内存满");
		return -1;
	}
	bbzero(bus_order[i].data);
	strcpy(bus_order[i].data,temp_buff);
	bbzero(bus_order[i].stan);
	strcpy(bus_order[i].stan,gbl.bus_enq_stan);
	bus_order[i].data_len = strlen(temp_buff);
	time(&(bus_order[i].inTime));
	wrLog("黑名单校验：【内存编号：%d】【STAN：%s】【DATA[%d]：%s】",i,bus_order[i].stan,bus_order[i].data_len,bus_order[i].data);
	/***********************************************************/
    while (1)
    {
		if (bus_order[i].flag == 1 ||bus_order[i].flag == 2)
		{
			Sleep(100*5);
		}else if (bus_order[i].flag == 0)
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n\n  黑名单校验出错",1,iSelect);
			return -1;
		}else if (bus_order[i].flag == 3)
		{
			bbzero(respond_code);
			memcpy(respond_code,bus_order[i].data+42,4);
			wrLog("黑名单校验返回码【%s】",respond_code);
			if (memcmp(respond_code,"8000",4)==0)
			{
				TS_OutPutMsg(gbl.dPosInfo,"      黑名单卡\n   请联系公交公司！\n   按【确认】返回",0,iSelect);
				return -1;
			}else if (memcmp(respond_code,"7000",4)==0)
			{
				TS_OutPutMsg(gbl.dPosInfo,"  不允许充值的POS机\n   请更换充值POS机！\n   按【确认】返回",0,iSelect);
				return -1;
			}else if (memcmp(respond_code,"9000",4)==0)
			{
				bus_order[i].flag = 0;
				bus_order[i].data_len = 0;
				bbzero(bus_order[i].data);
				bbzero(bus_order[i].stan);
				break;
			}else
			{
				TS_OutPutMsg(gbl.dPosInfo,"  \n   黑名单校验出错\n   按【确认】返回",0,iSelect);
				return -1;
			}
		}else 
			return -1;
    }
	

	//选择金额
	if (chargeType==2) //莞市通充值
	{

		iRet=selectDGAmount();
	}
	else
	{

		iRet = selectAmount();

	}

	if(iRet==CANCLE_KEY)
		return CANCLE_KEY;
	else if(iRet < 0)
		return -1;
	
	bbzero(old_amount);
	CTools::sixten_toten(gbl.bus_old_amo,old_amount);
	wrLog("总金额：%d",(atoi(old_amount)+atoi(gbl.amount)));
	if(atoi(old_amount)+atoi(gbl.amount)>100000)
	{
		TS_OutPutMsg(gbl.dPosInfo,"本卡最大额度为1000元\n请确认卡充值后总额小于1000元\n   按【确认】返回",0,iSelect);
		return -1;
	}
	bbzero(yj_amount);
	if (!strcmp(gbl.fee_type,"0214"))
	{
		if (atoi(gbl.amount)==4500)
		{
			strcpy(yj_amount,"000005DC");
		}else if (atoi(gbl.amount)==4800)
		{
			strcpy(yj_amount,"00000708");
		}else if (atoi(gbl.amount)==5500)
		{
			strcpy(yj_amount,"000009C4");
		}else 
			return -1;		
	}else
		strcpy(yj_amount,"00000000");
	bbzero(gbl.bus_yj_amo);
	strcpy(gbl.bus_yj_amo,yj_amount);
	
	
	if(atoi(gbl.dPosInfo.prmVer)>=9000)
	{
		bbzero(amoMny);
		CTools::chgToMny(gbl.amount,amoMny);
		bbzero(msg);
		sprintf(msg, "%s\n\n%s\n\n【是 Enter】  【否 Esc】\n【请认真核对业务类型及金额】",type, amoMny);
		iRet = TS_OutPutMsg(gbl.dPosInfo, msg, 0, iSelect);
		if(iSelect)
		{
			return -1;
		}
	}

	CDB::update_epos_term(gbl.pos_no,"9");//将终端状态设为"正常"
	iRet = busPayHdl(type);				
	if(iRet==CANCLE_KEY)
	{
		CDB::update_epos_term(gbl.pos_no,"1");//将终端状态设为"正常"
		return CANCLE_KEY;

	}
	else if(iRet == -2)	
	{
		/* 超时则作冲正处理 */
		for(i = 0; i < 3 && iRet; i++)
		{
			iRet=busRevHdl(type);
		}

		CDB::update_epos_term(gbl.pos_no,"1");//将终端状态设为"正常"
		TS_OutPutMsg(gbl.dPosInfo, "公交卡充值失败，请稍候再试", 0, iSelect);
		
		return -1;
	}
	else if(iRet < 0)
	{
		CDB::update_epos_term(gbl.pos_no,"1");//将终端状态设为"正常"
		return -1;
	}
	
	wrLog("【充值】");
	bbzero(inqdata);
	inqLen = 0;
	inqdata[inqLen++] = 0x07;//城市代码
	inqdata[inqLen++] = 0x69;
	inqdata[inqLen++] = 0x00;//行业代码
	inqdata[inqLen++] = 0x01;

	CTools::hex_to_byte((const BYTE *) gbl.bus_card,(BYTE *)inqdata+inqLen,8);//卡唯一号
	inqLen += 4;
	memset(inqdata+inqLen, 0, 4);//卡应用号
	inqLen += 4;
	memcpy(inqdata+inqLen, gbl.bus_conf, 4);
	inqLen += 4;
	// 	bbzero(date);
	// 	CTools::get_date8(date);
	// 	bbzero(dtime);	
	// 	CTools::get_time(dtime);
	CTools::hex_to_byte((const BYTE *)gbl.bus_date, (BYTE *)inqdata+inqLen, 8);//申请日期
	inqLen += 4;
	CTools::hex_to_byte((const BYTE *)gbl.bus_time, (BYTE *)inqdata+inqLen, 6);//申请时间
	inqLen += 3;

	CTools::hex_to_byte((BYTE *)gbl.bus_old_amo,(BYTE *)inqdata+inqLen,8);
	//memcpy(inqdata+inqLen, rcvData+14, 4);//卡上余额
	inqLen += 4;

	//申请充值金额
	if(!strcmp(gbl.fee_type,"0214")){//如果是发卡，充值30		
		//充值30元
		memcpy(inqdata+inqLen, "\x00\x00\x0B\xB8", 4);
		inqLen += 4;
	}else{
		unsigned long amount;
		amount = atol(gbl.amount);
		inqdata[inqLen++] = (char)(amount / 0x01000000);
		amount = amount % 0x01000000;
		inqdata[inqLen++] = (char)(amount / 0x010000);
		amount = amount % 0x010000;
		inqdata[inqLen++] = (char)(amount / 0x0100);
		inqdata[inqLen++] = (char)(amount % 0x0100);
	}
	inqdata[inqLen++] = 0x01;//充值类型
	inqdata[inqLen++] = 0x00;//充值点编号
	inqdata[inqLen++] = 0x00;
	CTools::hex_to_byte((const BYTE *)gbl.pos_no+2, (BYTE *)inqdata+inqLen, 6);//充值机编号
	inqLen += 3;
	if (!strcmp(gbl.fee_type,"0214"))
	{
		if (atoi(gbl.amount)==4500)
		{
			inqdata[inqLen++] = 0x0F;//押金
		}else if (atoi(gbl.amount)==4800)
		{
			inqdata[inqLen++] = 0x12;//押金
		}else if (atoi(gbl.amount)==5500)
		{
			inqdata[inqLen++] = 0x19;//押金
		}else{
			inqdata[inqLen++] = 0x00;//押金
		}
		
	}else
		inqdata[inqLen++] = 0x00;
	inqdata[inqLen++] = 0x00;
	inqdata[inqLen++] = 0x00;
	
	bbzero(temp_buff);
	bbzero(inqdataHex);
	bbzero(check_buff);
	CTools::byte_to_hex((const BYTE *)inqdata, (BYTE *)inqdataHex, inqLen);
	
	/***********************************************************/
	strncat(temp_buff,"7E7E7E00",8);
	strncat(temp_buff,gbl.pos_no+2,6);
	strncat(temp_buff,"8006",4);
	strncat(temp_buff,&(bus_key.bus_charge_key[2]),2);
	strncat(temp_buff,&(bus_key.bus_charge_key[4]),2);
	strncat(temp_buff,&(bus_key.bus_charge_key[0]),2);
	strncat(temp_buff,"37",2);
	strncat(temp_buff,gbl.bus_enq_stan,12);
	strncat(temp_buff,"002A",4);
	strncat(temp_buff,inqdataHex,inqLen*2);
	
	length = CTools::hex_to_byte((const BYTE *)temp_buff,(BYTE *)check_buff,strlen(temp_buff));
	CTools::crc_cu_16((BYTE *)check_buff,length);
	bbzero(temp_buff);
	CTools::byte_to_hex((const BYTE *)check_buff,(BYTE *)temp_buff,length+2);
	
	for (i=1;i<MAX_BUS_ORDER;i++)
	{
		if (bus_order[i].flag == 0)
		{
			bus_order[i].flag = 1;
			break;
		}
	}
	if (i == MAX_BUS_ORDER)
	{
		wrLog("公交交易内存满");
		bbzero(gbl.bus_failcode);
		strcpy(gbl.bus_failcode,"02");
		iRet=busRevHdl(type);
		if(iRet!=0){//如果充正不成功则保留状态
			if(iRet==1){
				wrLog("公交卡号：%s  状态值为：6   状态：充值失败冲正失败",gbl.bus_card);
				CDB::update_DGBus_Txn(gbl,"6");//隔天冲正，只有手工对帐后退费
				busConHdl(type,2);
				CDB::update_epos_term(gbl.pos_no,"1");//将终端状态设为"正常"
			}else{
				wrLog("公交卡号：%s  状态值为：3   状态：充值失败未冲正",gbl.bus_card);
				CDB::update_DGBus_Txn(gbl,"3");
				CDB::update_epos_term(gbl.pos_no,"1");//将终端状态设为"正常"
				TS_OutPutMsg(gbl.dPosInfo, "充值失败且冲正失败，请与商服核实是否有冲正次数", 1, iSelect);
			}
			
		}else{
			iRet=busConHdl(type,1);
			if(iRet!=0){//如果确认不成功则保留状态
				wrLog("公交卡号：%s  状态值为：4   状态：充值失败未确认",gbl.bus_card);
				CDB::update_DGBus_Txn(gbl,"4");
				CDB::update_epos_term(gbl.pos_no,"1");//将终端状态设为"正常"
				TS_OutPutMsg(gbl.dPosInfo, "充值失败\n充值返回信息提交出错\n请挂机后重新连接系统\n", 1, iSelect);
			}else{
				wrLog("公交卡号：%s  状态值为：5   状态：充值失败已确认",gbl.bus_card);
				CDB::update_DGBus_Txn(gbl,"5");
				CDB::update_epos_term(gbl.pos_no,"1");//将终端状态设为"正常"
				TS_OutPutMsg(gbl.dPosInfo, "充值失败\n按【确认】返回", 1, iSelect);
			}
		}
		return -1;
	}

	bbzero(bus_order[i].data);
	strcpy(bus_order[i].data,temp_buff);
	bbzero(bus_order[i].stan);
	strcpy(bus_order[i].stan,gbl.bus_enq_stan);
	bus_order[i].data_len = strlen(temp_buff);
	time(&(bus_order[i].inTime));
	wrLog("公交交易：【内存编号：%d】【STAN：%s】【DATA[%d]：%s】",i,bus_order[i].stan,bus_order[i].data_len,bus_order[i].data);
	/***********************************************************/
    while (1)
    {
		if (bus_order[i].flag == 1 ||bus_order[i].flag == 2)
		{
			Sleep(100*5);
		}else if (bus_order[i].flag == 0)
		{
			//TS_OutPutMsg(gbl.dPosInfo,"/n/n      充值失败",1,iSelect); //by liuxiao
			bbzero(gbl.bus_failcode);
			strcpy(gbl.bus_failcode,"02");
			iRet=busRevHdl(type);
			if(iRet!=0){//如果充正不成功则保留状态
				if(iRet==1){
					wrLog("公交卡号：%s  状态值为：6   状态：充值失败冲正失败",gbl.bus_card);
					CDB::update_DGBus_Txn(gbl,"6");//隔天冲正，只有手工对帐后退费
					busConHdl(type,2);
					CDB::update_epos_term(gbl.pos_no,"1");//将终端状态设为"正常"
				}else{
					wrLog("公交卡号：%s  状态值为：3   状态：充值失败未冲正",gbl.bus_card);
					CDB::update_DGBus_Txn(gbl,"3");
					CDB::update_epos_term(gbl.pos_no,"1");//将终端状态设为"正常"
					TS_OutPutMsg(gbl.dPosInfo, "充值失败且冲正失败，请与商服核实是否有冲正次数", 1, iSelect);
				}					
			}else{
				iRet=busConHdl(type,1);
				if(iRet!=0){//如果确认不成功则保留状态
					wrLog("公交卡号：%s  状态值为：4   状态：充值失败未确认",gbl.bus_card);
					CDB::update_DGBus_Txn(gbl,"4");
					CDB::update_epos_term(gbl.pos_no,"1");//将终端状态设为"正常"
					TS_OutPutMsg(gbl.dPosInfo, "充值失败\n充值返回信息提交失败\n请挂机后重新连接系统\n", 1, iSelect);
				}else{
					wrLog("公交卡号：%s  状态值为：5   状态：充值失败已确认",gbl.bus_card);
					CDB::update_DGBus_Txn(gbl,"5");
					CDB::update_epos_term(gbl.pos_no,"1");//将终端状态设为"正常"
					TS_OutPutMsg(gbl.dPosInfo, "充值失败\n按【确认】返回", 1, iSelect);
				}
			}


			return -1;
		}else if (bus_order[i].flag == 3)
		{
			bbzero(return_le);
			memcpy(return_le,bus_order[i].data+38,4);
			if (memcmp(return_le,"002A",4)==0)
			{
				bbzero(cz_key);
				memcpy(cz_key,bus_order[i].data+42,80);
				bus_order[i].flag = 0;
				bus_order[i].data_len = 0;
				bbzero(bus_order[i].data);
				bbzero(bus_order[i].stan);
				break;
			}else if (memcmp(return_le,"0004",4)==0)
			{
				bbzero(respond_code);
				memcpy(respond_code,bus_order[i].data+58,4);
				wrLog("充值密钥申请返回码【%s】",respond_code);
				if (memcmp(respond_code,"8000",4)==0)
				{
					TS_OutPutMsg(gbl.dPosInfo,"      黑名单卡\n   请联系公交公司！\n   按【确认】返回",0,iSelect);
				}else if (memcmp(respond_code,"7000",4)==0)
				{
					TS_OutPutMsg(gbl.dPosInfo,"  不允许充值的POS机\n   请更换充值POS机！\n   按【确认】返回",0,iSelect);
				}else
				{
					if (memcmp(respond_code,"A000",4)==0)
					{
						wrLog("串口没有打开");
					}else if (memcmp(respond_code,"B000",4)==0)
					{
						wrLog("其他错误");
					}else if (memcmp(respond_code,"1000",4)==0)
					{
						wrLog("CRC16校验错误");
					}else if (memcmp(respond_code,"6000",4)==0)
					{
						wrLog("分散密钥失败");
					}else if (memcmp(respond_code,"5000",4)==0)
					{
						wrLog("寻找SAM卡失败");
					}else if (memcmp(respond_code,"3000",4)==0)
					{
						wrLog("通许平台存储数据失败");
					}
					TS_OutPutMsg(gbl.dPosInfo,"  \n  充值密钥申请出错\n   按【确认】返回",0,iSelect);
				}
				bbzero(gbl.bus_failcode);
				strcpy(gbl.bus_failcode,"02");
				iRet=busRevHdl(type);
				if(iRet!=0){//如果充正不成功则保留状态
					if(iRet==1){
						wrLog("公交卡号：%s  状态值为：6   状态：充值失败冲正失败",gbl.bus_card);
						CDB::update_DGBus_Txn(gbl,"6");//隔天冲正，只有手工对帐后退费
						busConHdl(type,2);
						CDB::update_epos_term(gbl.pos_no,"1");//将终端状态设为"正常"
					}else{
						wrLog("公交卡号：%s  状态值为：3   状态：充值失败未冲正",gbl.bus_card);
						CDB::update_DGBus_Txn(gbl,"3");
						CDB::update_epos_term(gbl.pos_no,"1");//将终端状态设为"正常"
						TS_OutPutMsg(gbl.dPosInfo, "充值失败且冲正失败，请与商服核实是否有冲正次数", 1, iSelect);
					}					
				}else{
					iRet=busConHdl(type,1);
					if(iRet!=0){//如果确认不成功则保留状态
						wrLog("公交卡号：%s  状态值为：4   状态：充值失败未确认",gbl.bus_card);
						CDB::update_DGBus_Txn(gbl,"4");
						CDB::update_epos_term(gbl.pos_no,"1");//将终端状态设为"正常"
						TS_OutPutMsg(gbl.dPosInfo, "充值失败\n充值返回信息提交出错\n请挂机后重新连接系统\n", 1, iSelect);
					}else{
						wrLog("公交卡号：%s  状态值为：5   状态：充值失败已确认",gbl.bus_card);
						CDB::update_DGBus_Txn(gbl,"5");
						CDB::update_epos_term(gbl.pos_no,"1");//将终端状态设为"正常"
						TS_OutPutMsg(gbl.dPosInfo, "充值失败\n按【确认】返回", 1, iSelect);
					}
				}
				return -1;
			}else
			{
				bbzero(gbl.bus_failcode);
				strcpy(gbl.bus_failcode,"02");
				TS_OutPutMsg(gbl.dPosInfo,"  \n  充值密钥申请出错\n   按【确认】返回",0,iSelect);
				iRet=busRevHdl(type);
				if(iRet!=0){//如果充正不成功则保留状态
					if(iRet==1){
						wrLog("公交卡号：%s  状态值为：6   状态：充值失败冲正失败",gbl.bus_card);
						CDB::update_DGBus_Txn(gbl,"6");//隔天冲正，只有手工对帐后退费
						CDB::update_epos_term(gbl.pos_no,"1");//将终端状态设为"正常"
						busConHdl(type,2);
					}else{
						wrLog("公交卡号：%s  状态值为：3   状态：充值失败未冲正",gbl.bus_card);
						CDB::update_DGBus_Txn(gbl,"3");
						CDB::update_epos_term(gbl.pos_no,"1");//将终端状态设为"正常"
						TS_OutPutMsg(gbl.dPosInfo, "充值失败且冲正失败，请与商服核实是否有冲正次数", 1, iSelect);
					}					
				}else{
					iRet=busConHdl(type,1);
					if(iRet!=0){//如果确认不成功则保留状态
						wrLog("公交卡号：%s  状态值为：4   状态：充值失败未确认",gbl.bus_card);
						CDB::update_DGBus_Txn(gbl,"4");
						CDB::update_epos_term(gbl.pos_no,"1");//将终端状态设为"正常"
						TS_OutPutMsg(gbl.dPosInfo, "充值失败\n充值返回信息提交出错\n请挂机后重新连接系统\n", 1, iSelect);
					}else{
						wrLog("公交卡号：%s  状态值为：5   状态：充值失败已确认",gbl.bus_card);
						CDB::update_DGBus_Txn(gbl,"5");
						CDB::update_epos_term(gbl.pos_no,"1");//将终端状态设为"正常"
						TS_OutPutMsg(gbl.dPosInfo, "充值失败\n按【确认】返回", 1, iSelect);
					}
				}
				return -1;
			}
			
		}else
		{
			bbzero(gbl.bus_failcode);
			strcpy(gbl.bus_failcode,"02");
			iRet=busRevHdl(type);
			if(iRet!=0){//如果充正不成功则保留状态
				if(iRet==1){
					wrLog("公交卡号：%s  状态值为：6   状态：充值失败冲正失败",gbl.bus_card);
					CDB::update_DGBus_Txn(gbl,"6");//隔天冲正，只有手工对帐后退费
					busConHdl(type,2);
					CDB::update_epos_term(gbl.pos_no,"1");//将终端状态设为"正常"
				}else{
					wrLog("公交卡号：%s  状态值为：3   状态：充值失败未冲正",gbl.bus_card);
					CDB::update_DGBus_Txn(gbl,"3");
					CDB::update_epos_term(gbl.pos_no,"1");//将终端状态设为"正常
					TS_OutPutMsg(gbl.dPosInfo, "充值失败且冲正失败，请与商服核实是否有冲正次数", 1, iSelect);
				}					
			}else{
				iRet=busConHdl(type,1);
				if(iRet!=0){//如果确认不成功则保留状态
					wrLog("公交卡号：%s  状态值为：4   状态：充值失败未确认",gbl.bus_card);
					CDB::update_DGBus_Txn(gbl,"4");
					CDB::update_epos_term(gbl.pos_no,"1");//将终端状态设为"正常"
					TS_OutPutMsg(gbl.dPosInfo, "充值失败\n充值返回信息提交出错\n请挂机后重新连接系统\n", 1, iSelect);
				}else
				{
					wrLog("公交卡号：%s  状态值为：5   状态：充值失败已确认",gbl.bus_card);
					CDB::update_DGBus_Txn(gbl,"5");
					CDB::update_epos_term(gbl.pos_no,"1");//将终端状态设为"正常"
					TS_OutPutMsg(gbl.dPosInfo, "充值失败\n按【确认】返回", 1, iSelect);
				}
			}
			return -1;
		}
		
    }
	//进行公交卡充值
	bbzero(sendData);
	bbzero(rcvData);
	sendLen=0;
	rcvLen=0;
	if(!strcmp(gbl.fee_type,"0214")){//如果是发卡
		bbzero(gbl.bus_pay_amo);
		memcpy(gbl.bus_pay_amo, "00000BB8", 8);
	}else{
		unsigned long amount;//充值金额
		char amoBuf[4+1];
		bbzero(amoBuf);
		amount = atol(gbl.amount);
		amoBuf[0] = (char)(amount / 0x01000000);
		amount = amount % 0x01000000;
		amoBuf[1] = (char)(amount / 0x010000);
		amount = amount % 0x010000;
		amoBuf[2] = (char)(amount / 0x0100);
		amoBuf[3] = (char)(amount % 0x0100);
		bbzero(gbl.bus_pay_amo);
		CTools::byte_to_hex((const BYTE*)amoBuf, (BYTE*)gbl.bus_pay_amo, 4);
	}

	if(gbl.posInfo.rightType==5 ) //如果是串口读卡器
	{
		memcpy(sendData, "\x0C\x01\x00\x56\x85", 5); 
		sendLen += 5;
	}
	if(gbl.HID_TYPE==1)
	{
		memcpy(sendData, "\xC2\x85", 2); 
		sendLen += 2;

	}

	gbl.bus_card_serial[0] = gbl.bus_card_serial[0] + 1; 
	memcpy(sendData+sendLen, gbl.bus_card_serial, 1);

	sendLen++;
	CTools::hex_to_byte((const BYTE *)gbl.bus_pay_amo, (BYTE *)sendData+sendLen, 8);//充值金额
	sendLen += 4;
	CTools::hex_to_byte((const BYTE *)cz_key, (BYTE *)sendData+sendLen, 80);//密文
	sendLen += 40;
	CTools::hex_to_byte((const BYTE *)bus_key.bus_discharge_key, (BYTE *)sendData+sendLen, 16);//解密密钥
	sendLen += 8;
	CTools::hex_to_byte((const BYTE *)gbl.bus_card, (BYTE *)sendData+sendLen, 8);//卡唯一号
	sendLen += 4;
	memcpy(sendData+sendLen, gbl.bus_conf, 4);//认证码
	sendLen += 4;
	CTools::hex_to_byte((const BYTE *)gbl.bus_old_amo, (BYTE *)sendData+sendLen, 8);//余额
	sendLen += 4;
	CTools::hex_to_byte((const BYTE *)gbl.bus_date, (BYTE *)sendData+sendLen, 8);//充值日期
	sendLen += 4;
	CTools::hex_to_byte((const BYTE *)gbl.bus_time, (BYTE *)sendData+sendLen, 6);//充值时间
	sendLen += 3;
	CTools::hex_to_byte((const BYTE *)gbl.bus_enq_stan, (BYTE *)sendData+sendLen, 12);//流水号
	sendLen += 6;
	CTools::hex_to_byte((const BYTE *)"01", (BYTE *)sendData+sendLen, 2);//充值类型
	sendLen++;
	CTools::hex_to_byte((const BYTE *)"0001", (BYTE *)sendData+sendLen, 4);//商户代码
	sendLen += 2;
	CTools::hex_to_byte((const BYTE *)yj_amount, (BYTE *)sendData+sendLen, 8);//商户代码
	sendLen += 4;

	if(gbl.posInfo.rightType==5)
	{
	
		sendData[sendLen] = xor((const BYTE *)sendData,sendLen);
		sendLen++;

	}

	//充值 

	if(gbl.HID_TYPE==1) //如果是东莞读卡器HID设备
	{
		if( busSndRcvHID_IcData(type, (const BYTE *)sendData, sendLen, (BYTE *)rcvData, rcvLen, gbl.pos_serial) )
		{
			//如果充值过程中出现异常
			CDB::update_epos_term(gbl.pos_no,"1");
		
			//进行读卡操作 三次读卡，如果卡内余额等于原余额+充值金额。则充值成功。如果卡余额不等于，则充值失败。
			char cardMny[8+1];
			bbzero(cardMny);
			char bus_old_mny[8+1];
			char bus_pay_mny[8+1];
			bbzero(bus_old_mny);
			bbzero(bus_pay_mny);
			CTools::sixten_toten(gbl.bus_old_amo,bus_old_mny);
			CTools::sixten_toten(gbl.bus_pay_amo,bus_pay_mny);
			
			for(int i=0;i<3;i++)
			{
				
				iRet=read_IcCardInfo(type,gbl.pos_serial,1,cardMny);
				if (iRet==0)
				{
					break;
				}
				
			}
			
			if (iRet!=0)	//三次读不出卡信息。查询最后一笔终端最后一笔交易
			{
				
				if(busNotEndHdl(type)) 
				{
					TS_HangUp(gbl.dPosInfo);
				}
				
			}
			else
			{
				
				//如果能读出卡余额。比如卡余额信息
				wrLog("充值后余额:%s",cardMny);
				wrLog("充值前余额：%s",bus_old_mny);
				wrLog("充值余额:%s",bus_pay_mny);
				if (atof(cardMny)==atof(bus_pay_mny)+atof(bus_old_mny))
				{
					wrLog("充值成功");
					iRet=busConHdl(type);
					if(iRet!=0)
					{//如果确认不成功则保留状态
						wrLog("公交卡号：%s  状态值为：1   状态：充值成功未确认",gbl.bus_card);
						CDB::update_DGBus_Txn(gbl,"1");
						CDB::update_epos_term(gbl.pos_no, "1");//将终端状态设为"正常"
					}else
					{
						wrLog("公交卡号：%s  状态值为：2   状态：充值成功已确认",gbl.bus_card);
						CDB::update_DGBus_Txn(gbl,"2");	
						CDB::update_epos_term(gbl.pos_no, "1");//将终端状态设为"正常"
						
					}				
					
					char tmp[250];
					bbzero(tmp);
					sprintf(tmp,"交易成功!请按【Enter】返回\n\n卡原有金额：%.2f元\n卡充入金额：%.2f元\n卡现有金额：%.2f元\n\n【注意】尊敬的公交商户：因东莞公交经营主体变更，原汇通公交业务将于2014年停止服务。\n改换新的东莞通公交业务、所有设备更换及押金退还事宜请尽快加QQ：2083267158或拔打23360000咨询。",atof(bus_old_mny)/100,atof(bus_pay_mny)/100,atof(cardMny)/100);
					TS_OutPutMsg(gbl.dPosInfo,tmp,1,iSelect);
					
				}
				else 
				{
					
					wrLog("充值失败，需要退费");
					//充值失败。进行退费
					iRet=busRevHdl(type);
					if(iRet!=0){//如果充正不成功则保留状态
						if(iRet==1){
							wrLog("公交卡号：%s  状态值为：6   状态：充值失败冲正失败",gbl.bus_card);
							CDB::update_DGBus_Txn(gbl,"6");//隔天冲正，只有手工对帐后退费
							busConHdl(type,2);
							CDB::update_epos_term(gbl.pos_no, "1");//将终端状态设为"正常"
							
						}else{
							wrLog("公交卡号：%s  状态值为：3   状态：充值失败未冲正",gbl.bus_card);
							CDB::update_DGBus_Txn(gbl,"3");
							CDB::update_epos_term(gbl.pos_no, "1");//将终端状态设为"正常"
							TS_OutPutMsg(gbl.dPosInfo, "充值失败且冲正失败，请与商服核实是否有冲正次数", 1, iSelect);
						}					
					}else{
						iRet=busConHdl(type,1);
						if(iRet!=0){//如果确认不成功则保留状态
							wrLog("公交卡号：%s  状态值为：4   状态：充值失败未确认",gbl.bus_card);
							CDB::update_DGBus_Txn(gbl,"4");
							CDB::update_epos_term(gbl.pos_no, "1");//将终端状态设为"正常"
							TS_OutPutMsg(gbl.dPosInfo, "充值失败\n充值返回信息提交出错\n请挂机后重新连接系统\n", 1, iSelect);
						}else{
							wrLog("公交卡号：%s  状态值为：5   状态：充值失败已确认",gbl.bus_card);
							CDB::update_DGBus_Txn(gbl,"5");
							CDB::update_epos_term(gbl.pos_no, "1");//将终端状态设为"正常"
							TS_OutPutMsg(gbl.dPosInfo, "充值失败\n按【确认】返回", 1, iSelect);
						}
					}


				}
				
		}

			//return -1;
		}

		else //如果读卡器指令返回
		{
		
		bbzero(dkq_PSAM);
		bbzero(dkq_code); 
		memcpy(dkq_code,rcvData+48+2,4); //机具编号
		CTools::byte_to_hex((const BYTE *)rcvData+52+2, (BYTE *)dkq_PSAM, 8); //psam卡号
		wrLog("【原PSAM：%s】【现PSAM：%s】",(BYTE *)gbl.dkq_PSAM,dkq_PSAM);
		wrHex("[原机具编号] ", (BYTE *)gbl.dkq_code,strlen(gbl.dkq_code));
		wrHex("[现机具编号]",(BYTE *)dkq_code,strlen(dkq_code));
	
		bbzero(gbl.bus_card_info);
		memcpy(gbl.bus_card_info, rcvData+2, 48); //充值记录
		//解析充值记录
		wrHex("公交充值记录",(BYTE *)gbl.bus_card_info,48);
		//卡唯一号
		wrLog("交易结果如下：\n卡唯一号：%s",gbl.bus_card);
		//卡类型
		char cardType[2];
		char old_mny[8+1];
		char old_mny_buff[8+1];
		char current_mny[8+1];
		char current_mny_buff[8+1];
		char charge_mny[8+1];
		char charge_mny_buff[8+1];
		char rent_mny[8+1];
		char rent_mny_buff[8+1];
		char actual_pay[8+1]; //实收金额
		char actual_pay_buff[8+1];
		char chargeTime[7];
		char charge_flag[2]; //充值结果
		bbzero(cardType);
		bbzero(rent_mny);
		bbzero(rent_mny_buff);
		bbzero(current_mny_buff);
		bbzero(current_mny);
		bbzero(charge_mny_buff);
		bbzero(charge_mny);
		bbzero(old_mny_buff);
		bbzero(old_mny);
		bbzero(cardType);
		bbzero(actual_pay_buff);
		bbzero(actual_pay);
		bbzero(chargeTime);
		bbzero(charge_flag);

		CTools::byte_to_hex((BYTE *)gbl.bus_card_info+9,(BYTE *)cardType,1);
		wrLog("卡片类型:%s",cardType);
		//原有金额
		CTools::byte_to_hex((BYTE *)gbl.bus_card_info+11,(BYTE *)old_mny_buff,4);
		CTools::sixten_toten(old_mny_buff,old_mny);
		wrLog("充值前余额为:%.2f元",atof(old_mny)/100);
		//本次充值金额
		CTools::byte_to_hex((BYTE *)gbl.bus_card_info+15,(BYTE *)charge_mny_buff,4);
		CTools::sixten_toten(charge_mny_buff,charge_mny);
		wrLog("充值金额为:%.2f元",atof(charge_mny)/100);
		//当前余额
		CTools::byte_to_hex((BYTE *)gbl.bus_card_info+19,(BYTE *)current_mny_buff,4);
		CTools::sixten_toten(current_mny_buff,current_mny);
		wrLog("当前余额为:%.2f元",atof(current_mny)/100);
		//售卡押金
		CTools::byte_to_hex((BYTE *)gbl.bus_card_info+23,(BYTE *)rent_mny_buff,4);
		CTools::sixten_toten(rent_mny_buff,rent_mny);
		wrLog("押金为:%.2f元",atof(rent_mny)/100);
		//实收金额
		CTools::byte_to_hex((BYTE *)gbl.bus_card_info+27,(BYTE *)actual_pay_buff,4);
		CTools::sixten_toten(actual_pay_buff,actual_pay);
		wrLog("实收金额为:%.2f元",atof(actual_pay)/100);
		//购买时间
		CTools::byte_to_hex((BYTE *)gbl.bus_card_info+34,(BYTE *)chargeTime,6);
		wrLog("购买时间:%s",chargeTime);
		CTools::byte_to_hex((BYTE *)gbl.bus_card_info+40,(BYTE *)charge_flag,1);
		//充值时间
		//充值记录标记，充值是否成功。
		if(charge_flag=='\x00')
		{
		
			wrLog("充值结果：充值成功");
		}
		else
		{
			wrLog("充值结果：充值异常");

		}
		
		bbzero(gbl.bus_new_amo);
		CTools::byte_to_hex((const BYTE *)rcvData+2+19, (BYTE *)gbl.bus_new_amo, 4); //充值后余额

		if( rcvData[0]==0x00 &&rcvData[1]==0x00 &&(atof(current_mny)==atof(charge_mny)+atof(old_mny)))
		{
			//如果充值成功	

			//峰鸣器响一下,表示成功。
			
			if( busSndRcvHID_IcData(type, (const BYTE *)"\x31\x13\x00\x32\x01",5, (BYTE *)rcvData, rcvLen, gbl.pos_serial) ) //充值验卡是读卡器之间的。
			{
				
				return -1;
			}
			if ((unsigned char)(rcvData[0]) != 0x00) //如果第一个状态吗发挥0x81，那么执行指令不成功。
				
			{
				
				returnHIDBusFail(rcvData[1]); 
				return -3;
			}	
			//显示余额信息
			//清空读卡器信息
			bbzero(sndIcData);
			sendLen=0;
			bbzero(rcvData);
			rcvLen=0;
			wrLog("清空读卡器显示信息");
			if( busSndRcvHID_IcData(type, (const BYTE *)"\xF0\x40\x00\x01",4, (BYTE *)rcvData, rcvLen, gbl.pos_serial) ) //充值验卡是读卡器之间的。
			{
				
				return -1;
			}
			if ((unsigned char)(rcvData[0]) != 0x00) //如果第一个状态吗发挥0x81，那么执行指令不成功。
				
			{
				
				returnHIDBusFail(rcvData[1]); 
				return -3;
				
			}
			
			
			//发送读卡器显示余额信息
			wrLog("发送给读卡器显示信息的指令");
			char new_amount[20];//充值后余额（当前余额）
			bbzero(new_amount);
			CTools::sixten_toten(gbl.bus_new_amo,new_amount);
			bbzero(sndIcData);
			sendLen=0;
			bbzero(rcvData);
			rcvLen=0;
			sprintf(outPutMsg,"余额:%.2f元",atof(new_amount)/100); //在读卡器上面显示的
			
			
			memcpy(sndIcData,"\xF0\x41\x01\x01",4); //显示一行信息
			sendLen+=4;

			memcpy(sndIcData+sendLen,outPutMsg,strlen(outPutMsg)); 
			sendLen+=strlen(outPutMsgBuff);
			
			//发信息到终端 
			if( busSndRcvHID_IcData(type, (const BYTE *)sndIcData,sendLen, (BYTE *)rcvData, rcvLen, gbl.pos_serial) ) //充值验卡是读卡器之间的。
			{
				return -1;
			}
			if ((unsigned char)(rcvData[0]) != 0x00) //如果第一个状态吗发挥0x81，那么执行指令不成功。
				
			{
				
				returnHIDBusFail(rcvData[1]); 
				return -3;
				
			}

			iRet=busConHdl(type);
			if(iRet!=0){//如果确认不成功则保留状态
				wrLog("公交卡号：%s  状态值为：1   状态：充值成功未确认",gbl.bus_card);
				CDB::update_DGBus_Txn(gbl,"1");
				CDB::update_epos_term(gbl.pos_no, "1");//将终端状态设为"正常"
			}else{
				wrLog("公交卡号：%s  状态值为：2   状态：充值成功已确认",gbl.bus_card);
				CDB::update_DGBus_Txn(gbl,"2");	
				CDB::update_epos_term(gbl.pos_no, "1");//将终端状态设为"正常"
				
			}				
			if(!strcmp(gbl.fee_type,"0214") ){//如果是发卡  
				
				CDB::update_epos_term(gbl.pos_no, "1");//将终端状态设为"正常"
				TS_OutPutMsg(gbl.dPosInfo, "       开卡成功\n请检查打印机电源及打印线路是否正常,有问题请即与22386220联系\n按【确认】打印发票\n\n【注意】尊敬的公交商户：因东莞公交经营主体变更，原汇通公交业务将于2014年停止服务。\n改换新的东莞通公交业务、所有设备更换及押金退还事宜请尽快加QQ：2083267158或拔打23360000咨询", 1, iSelect);
				CPrint prt;
				prt.set_in_par(gbl);
				prt.print_bus_detail(gbl.bus_card_info,1);					
			}
			else if( !strcmp(gbl.fee_type,"0211")) //充值成功
			{
				char tmp[250];
				bbzero(tmp);
				sprintf(tmp,"充值成功!请按【Enter】返回\n\n卡原有金额：%.2f元\n卡充入金额：%.2f元\n卡现有金额：%.2f元\n\n【注意】尊敬的公交商户：因东莞公交经营主体变更，原汇通公交业务将于2014年停止服务。\n改换新的东莞通公交业务、所有设备更换及押金退还事宜请尽快加QQ：2083267158或拔打23360000咨询。 ",atof(old_mny)/100,atof(charge_mny)/100,atof(current_mny)/100);
				TS_OutPutMsg(gbl.dPosInfo,tmp,1,iSelect);
				
			}
			
		}
		
		else
		{
			bbzero(gbl.bus_failcode);
			CTools::byte_to_hex((const BYTE *)rcvData+1, (BYTE *)gbl.bus_failcode, 1);
			wrLog("【错误代码】%s",gbl.bus_failcode);
			iRet=busRevHdl(type);
			if(iRet!=0){//如果充正不成功则保留状态
				if(iRet==1){
					wrLog("公交卡号：%s  状态值为：6   状态：充值失败冲正失败",gbl.bus_card);
					CDB::update_DGBus_Txn(gbl,"6");//隔天冲正，只有手工对帐后退费
					busConHdl(type,2);
					CDB::update_epos_term(gbl.pos_no, "1");//将终端状态设为"正常"
					
				}else{
					wrLog("公交卡号：%s  状态值为：3   状态：充值失败未冲正",gbl.bus_card);
					CDB::update_DGBus_Txn(gbl,"3");
					CDB::update_epos_term(gbl.pos_no, "1");//将终端状态设为"正常"
					TS_OutPutMsg(gbl.dPosInfo, "充值失败且冲正失败，请与商服核实是否有冲正次数", 1, iSelect);
				}					
			}else{
				iRet=busConHdl(type,1);
				if(iRet!=0){//如果确认不成功则保留状态
					wrLog("公交卡号：%s  状态值为：4   状态：充值失败未确认",gbl.bus_card);
					CDB::update_DGBus_Txn(gbl,"4");
					CDB::update_epos_term(gbl.pos_no, "1");//将终端状态设为"正常"
					TS_OutPutMsg(gbl.dPosInfo, "充值失败\n充值返回信息提交出错\n请挂机后重新连接系统\n", 1, iSelect);
				}else{
					wrLog("公交卡号：%s  状态值为：5   状态：充值失败已确认",gbl.bus_card);
					CDB::update_DGBus_Txn(gbl,"5");
					CDB::update_epos_term(gbl.pos_no, "1");//将终端状态设为"正常"
					TS_OutPutMsg(gbl.dPosInfo, "充值失败\n按【确认】返回", 1, iSelect);
				}
			}

			returnBusFail(rcvData[2]);
		}		
	
	}
	

	}

	else  //如果是串口读卡器，如果读卡器超时情况。提示用户。如果读卡失败之后，提示用户交易不明确。请查询余额，联系在线客服。
	{
		if( busSndRcvIcData(type, (const BYTE *)sendData, sendLen, (BYTE *)rcvData, rcvLen, gbl.pos_serial) )
		{
			CDB::update_epos_term(gbl.pos_no,"1");

			//三次读卡
			char cardMny[8+1];
			char bus_old_mny[8+1];
			char bus_pay_mny[8+1];
			bbzero(bus_old_mny);
			bbzero(bus_pay_mny);
			bbzero(cardMny);
			CTools::sixten_toten(gbl.bus_old_amo,bus_old_mny);
			CTools::sixten_toten(gbl.bus_pay_amo,bus_pay_mny);
			for(int i=0;i<3;i++)
			{
				//三次读卡
				iRet=read_IcCardInfo(type,gbl.pos_serial,0,cardMny);
				if (iRet==0)
				{
					break;
				}
				
			}
			
			if (iRet!=0)
			{
				//三次读不出卡信息。查询最后一笔终端最后一笔交易

				TS_OutPutMsg(gbl.dPosInfo, "串口连接异常\n请检查串口连接\n检查后按【确认】\n读写器将显示卡余额", 0, iSelect);
				if(busNotEndHdl(type))
				{
					busSndRcvIcData(type, (const BYTE *)"\x0C\x01\x00\x02\x81\x00\x8E", 7, (BYTE *)rcvData, rcvLen, gbl.pos_serial);//充值验卡，显示金额
					TS_OutPutMsg(gbl.dPosInfo, "串口连接异常\n请新连接系统\n", 0, iSelect);
					TS_HangUp(gbl.dPosInfo);
				
				}

			}
			else //读卡过程读卡器有返回数据
			{

				//如果能读出卡余额。比如卡余额信息
				wrLog("充值后余额:%s",cardMny);
				wrLog("充值前余额：%s",bus_old_mny);
				wrLog("充值余额:%s",bus_pay_mny);
				if (atof(cardMny)==atof(bus_pay_mny)+atof(bus_old_mny))
				{
					wrLog("充值成功");
					iRet=busConHdl(type);
					if(iRet!=0)
					{//如果确认不成功则保留状态
						wrLog("公交卡号：%s  状态值为：1   状态：充值成功未确认",gbl.bus_card);
						CDB::update_DGBus_Txn(gbl,"1");
						CDB::update_epos_term(gbl.pos_no, "1");//将终端状态设为"正常"
					}else
					{
						wrLog("公交卡号：%s  状态值为：2   状态：充值成功已确认",gbl.bus_card);
						CDB::update_DGBus_Txn(gbl,"2");	
						CDB::update_epos_term(gbl.pos_no, "1");//将终端状态设为"正常"
						
					}				
					
					char tmp[250];
					bbzero(tmp);
					sprintf(tmp,"交易成功!请按【Enter】返回\n\n卡原有金额：%.2f元\n卡充入金额：%.2f元\n卡现有金额：%.2f元\n\n【注意】尊敬的公交商户：因东莞公交经营主体变更，原汇通公交业务将于2014年停止服务。\n改换新的东莞通公交业务、所有设备更换及押金退还事宜请尽快加QQ：2083267158或拔打23360000咨询。 ",atof(bus_old_mny)/100,atof(bus_old_mny)/100,atof(cardMny)/100);
					TS_OutPutMsg(gbl.dPosInfo,tmp,1,iSelect);
					
				}
				else 
				{
					
					wrLog("充值失败，需要退费");
					//充值失败。进行退费
					iRet=busRevHdl(type);
					if(iRet!=0)
					{//如果充正不成功则保留状态
						if(iRet==1)
						{
							wrLog("公交卡号：%s  状态值为：6   状态：充值失败冲正失败",gbl.bus_card);
							CDB::update_DGBus_Txn(gbl,"6");//隔天冲正，只有手工对帐后退费
							busConHdl(type,2);
							CDB::update_epos_term(gbl.pos_no, "1");//将终端状态设为"正常"
							
						}else{
							wrLog("公交卡号：%s  状态值为：3   状态：充值失败未冲正",gbl.bus_card);
							CDB::update_DGBus_Txn(gbl,"3");
							CDB::update_epos_term(gbl.pos_no, "1");//将终端状态设为"正常"
							TS_OutPutMsg(gbl.dPosInfo, "充值失败且冲正失败，请与商服核实是否有冲正次数", 1, iSelect);
						}					
					}else
					{
						iRet=busConHdl(type,1);
						if(iRet!=0){//如果确认不成功则保留状态
							wrLog("公交卡号：%s  状态值为：4   状态：充值失败未确认",gbl.bus_card);
							CDB::update_DGBus_Txn(gbl,"4");
							CDB::update_epos_term(gbl.pos_no, "1");//将终端状态设为"正常"
							TS_OutPutMsg(gbl.dPosInfo, "充值失败\n充值返回信息提交出错\n请挂机后重新连接系统\n", 1, iSelect);
						}else{
							wrLog("公交卡号：%s  状态值为：5   状态：充值失败已确认",gbl.bus_card);
							CDB::update_DGBus_Txn(gbl,"5");
							CDB::update_epos_term(gbl.pos_no, "1");//将终端状态设为"正常"
							TS_OutPutMsg(gbl.dPosInfo, "充值失败\n按【确认】返回", 1, iSelect);
						}
						
					}
					
				}
		
			}
			
		
		}

		else //充值过程中读卡器有返回数据
		{
		
			bbzero(dkq_PSAM);
			bbzero(dkq_code);
			memcpy(dkq_code,rcvData+54,4);
			CTools::byte_to_hex((const BYTE *)rcvData+58, (BYTE *)dkq_PSAM, 8);
			wrLog("【原机具号：%s】【原PSAM：%s】【 现机具号：%s】【现PSAM：%s】",gbl.dkq_code,gbl.dkq_PSAM,dkq_code,dkq_PSAM);
			
			bbzero(gbl.bus_card_info);
			memcpy(gbl.bus_card_info, rcvData+6, 48);
			bbzero(gbl.bus_new_amo);
			CTools::byte_to_hex((const BYTE *)rcvData+25, (BYTE *)gbl.bus_new_amo, 4);

			if( rcvData[5]==0x00 ){//如果充值成功
				
				iRet=busConHdl(type);
				if(iRet!=0){//如果确认不成功则保留状态
					wrLog("公交卡号：%s  状态值为：1   状态：充值成功未确认",gbl.bus_card);
					CDB::update_DGBus_Txn(gbl,"1");
					CDB::update_epos_term(gbl.pos_no, "1");//将终端状态设为"正常"
				}else{
					wrLog("公交卡号：%s  状态值为：2   状态：充值成功已确认",gbl.bus_card);
					CDB::update_DGBus_Txn(gbl,"2");	
					CDB::update_epos_term(gbl.pos_no, "1");//将终端状态设为"正常"
					
				}				
				if(!strcmp(gbl.fee_type,"0214")){//如果是发卡
					
					CDB::update_epos_term(gbl.pos_no, "1");//将终端状态设为"正常"
					TS_OutPutMsg(gbl.dPosInfo, "       开卡成功\n请检查打印机电源及打印线路是否正常,有问题请即与22386220联系\n按【确认】打印发票\n\n【注意】尊敬的公交商户：因东莞公交经营主体变更，原汇通公交业务将于2014年停止服务。\n改换新的东莞通公交业务、所有设备更换及押金退还事宜请尽快加QQ：2083267158或拔打23360000咨询", 1, iSelect);
					CPrint prt;
					prt.set_in_par(gbl);
					prt.print_bus_detail(gbl.bus_card_info,1);					
				}
				else if(!strcmp(gbl.fee_type,"0211"))// 充值成功，显示成功信息
				{
					unsigned long bus_current_amo=0; //当前余额
					unsigned long bus_charge_amo=0; //充值余额
					unsigned long bus_old_amo=0; //充值前余额
					char content[500];
					bbzero(content);
					bus_old_amo=(unsigned char)gbl.bus_card_info[11] + (unsigned char)gbl.bus_card_info[12]*0x0100 + (unsigned char)gbl.bus_card_info[13]*0x010000 + (unsigned char)gbl.bus_card_info[14]*0x01000000;
					bus_charge_amo=(unsigned char)gbl.bus_card_info[15] + (unsigned char)gbl.bus_card_info[16]*0x0100 + (unsigned char)gbl.bus_card_info[17]*0x010000 + (unsigned char)gbl.bus_card_info[18]*0x01000000;
					bus_current_amo=(unsigned char)gbl.bus_card_info[19] + (unsigned char)gbl.bus_card_info[20]*0x0100 + (unsigned char)gbl.bus_card_info[21]*0x010000 + (unsigned char)gbl.bus_card_info[22]*0x01000000;
					sprintf(content+strlen(content), "充值成功!请按【Enter】返回\n\n卡原有金额：%d.%02d元", bus_old_amo/100, bus_old_amo%100);
					sprintf(content+strlen(content), "\n卡充入金额：%d.%02d元", bus_charge_amo/100, bus_charge_amo%100);
					sprintf(content+strlen(content), "\n卡现有金额：%d.%02d元", bus_current_amo/100, bus_current_amo%100);
					strcat(content,"\n\n【注意】尊敬的公交商户：因东莞公交经营主体变更，原汇通公交业务将于2014年停止服务。\n改换新的东莞通公交业务、所有设备更换及押金退还事宜请尽快加QQ：2083267158或拔打23360000咨询。");
					TS_OutPutMsg(gbl.dPosInfo,content,1,iSelect);
				}
			}else
			{
				bbzero(gbl.bus_failcode);
				CTools::byte_to_hex((const BYTE *)rcvData+5, (BYTE *)gbl.bus_failcode, 1);
				wrLog("【错误代码】%s",gbl.bus_failcode);
				iRet=busRevHdl(type);
				if(iRet!=0){//如果充正不成功则保留状态
					if(iRet==1){
						wrLog("公交卡号：%s  状态值为：6   状态：充值失败冲正失败",gbl.bus_card);
						CDB::update_DGBus_Txn(gbl,"6");//隔天冲正，只有手工对帐后退费
						busConHdl(type,2);
						CDB::update_epos_term(gbl.pos_no, "1");//将终端状态设为"正常"
						
					}else{
						wrLog("公交卡号：%s  状态值为：3   状态：充值失败未冲正",gbl.bus_card);
						CDB::update_DGBus_Txn(gbl,"3");
						CDB::update_epos_term(gbl.pos_no, "1");//将终端状态设为"正常"
						TS_OutPutMsg(gbl.dPosInfo, "充值失败且冲正失败，请与商服核实是否有冲正次数", 1, iSelect);
					}					
				}else{
					iRet=busConHdl(type,1);
					if(iRet!=0){//如果确认不成功则保留状态
						wrLog("公交卡号：%s  状态值为：4   状态：充值失败未确认",gbl.bus_card);
						CDB::update_DGBus_Txn(gbl,"4");
						CDB::update_epos_term(gbl.pos_no, "1");//将终端状态设为"正常"
						TS_OutPutMsg(gbl.dPosInfo, "充值失败\n充值返回信息提交出错\n请挂机后重新连接系统\n", 1, iSelect);
					}else
					{
						wrLog("公交卡号：%s  状态值为：5   状态：充值失败已确认",gbl.bus_card);
						CDB::update_DGBus_Txn(gbl,"5");
						CDB::update_epos_term(gbl.pos_no, "1");//将终端状态设为"正常"
						TS_OutPutMsg(gbl.dPosInfo, "充值失败\n按【确认】返回", 1, iSelect);
					
					}

				returnBusFail(rcvData[5]);
			}		
			
		}
	
	
	}

	
}

	return 0;
}




//以旧换新过程中0元充值  仅用于东莞公交清华同方读卡器使用
/*************************************************************/
int CTrade::busChargeZero(const char *feeType,const char *type)
{
	int iRet, flag = 1, rcvLen=0, inqLen=0, iSelect=0,i,sendLen=0;	
	char rcvData[256],inqdata[128],inqdataHex[256];
	char date[8+1];  //8位日期
	char check_date[6+1];
	char check_date_buff[6+1];
	char temp_buff[1024];
	char check_buff[1024];
	char respond_code[4+1],return_le[4+1],cz_key[80+1];
	int length;
	char sendData[256],yj_amount[8+1];
	char dkq_code[4+1],dkq_PSAM[16+1];
	char old_amount[20];
	char sndIcData[256]; //发送给读卡器的数据

	wrLog("0元销卡");
	bbzero(rcvData);
	bbzero(sndIcData);
	bbzero(date);
	bbzero(gbl.bus_failcode);
	bbzero(check_date);
	bbzero(check_date_buff);
	strcpy(gbl.bus_failcode,"01");
	CTools::get_date8(date);
	memcpy(check_date,date+2,6);
	bbzero(gbl.bus_card); //票卡号
	bbzero(gbl.bus_conf); //票卡认证码
	bbzero(gbl.bus_old_amo); //票卡金额（充值前）
	bbzero(gbl.bus_card_type); //公交卡类型
	bbzero(gbl.dkq_code); //机具编号
	bbzero(gbl.dkq_PSAM); //psam卡号

	//充值验卡 需要加判断：如果是HID设备。
	iRet=TS_OutPutMsg(gbl.dPosInfo,"\n正在进行汇通卡销卡，请将汇通卡放在读卡器上,不要移动卡片\n按【Enter】继续",1,iSelect);
	if (iRet!=0 ||iSelect!=0)
	{
		return -1; //销卡失败
		
	}

	if( busSndRcvHID_IcData(type, (const BYTE *)"\xC2\x81",2, (BYTE *)rcvData, rcvLen, gbl.pos_serial) ) //充值验卡是读卡器之间的。
		
	{
		return -1;
	}
		
	if ((unsigned char)(rcvData[0]) == 0x81) //如果第一个状态吗发挥0x81，那么执行指令不成功。

	{
		returnHIDBusFail(rcvData[1]); 
		return -3;
	}
	
	CTools::byte_to_hex((const BYTE *)rcvData+2,(BYTE*)gbl.bus_card,4); //票卡号
	memcpy(gbl.bus_conf,rcvData+6,4); //票卡认证码
	CTools::byte_to_hex((const BYTE *)rcvData+10, (BYTE *)gbl.bus_old_amo, 4); //票卡金额（充值前）
	CTools::byte_to_hex((const BYTE *)rcvData+14, (BYTE *)gbl.bus_card_type, 1); //应用子类型，卡片类型
	CTools::byte_to_hex((const BYTE *)rcvData+17, (BYTE *)check_date_buff, 3); //年审日期

	wrLog("年审日期：%s   系统日期：%s",check_date_buff,check_date);

	/*
	if (strcmp(gbl.bus_card_type,"01")&&strcmp(gbl.bus_card_type,"A4"))
	{
		TS_OutPutMsg(gbl.dPosInfo," \n卡类型错误或卡已过期\n    不能进行充值!\n   按【确认】返回",0,iSelect);
		return -7;
	}
	*///取消任何校验
	
	memcpy(gbl.dkq_code,rcvData+20,4);
	CTools::byte_to_hex((const BYTE *)rcvData+24, (BYTE *)gbl.dkq_PSAM, 8); //psam卡号
	
	wrHex("充值验卡返回机具编号",(BYTE *)gbl.dkq_code,4);
	wrLog("PSAM卡号是:%s",gbl.dkq_PSAM);
	
	bbzero(gbl.bus_card_serial);//交易流水标识
	memcpy(gbl.bus_card_serial, rcvData+15, 1); //交易流水标志

	//黑名单校验向充值服务器发送黑名单交易指令
	wrLog("【校验黑名单】");
	bbzero(gbl.bus_enq_stan);
	iRet = CDB::get_DGBus_stan(gbl.bus_enq_stan);
	if (iRet < 0)
	{
		wrLog("获取公交交易系统参考号失败");
		return -1;
	}

	bbzero(inqdata);
	inqLen = 0;
	inqdata[inqLen++] = 0x00;//城市代码
	inqdata[inqLen++] = 0x00;
	inqdata[inqLen++] = 0x00;//行业代码
	inqdata[inqLen++] = 0x00;
	
	CTools::hex_to_byte((BYTE *)gbl.bus_card,(BYTE *)inqdata+inqLen,8);
	inqLen += 4;
	memset(inqdata+inqLen, 0, 4);//卡应用号
	inqLen += 4;
	CTools::hex_to_byte((const BYTE *)"00000000", (BYTE *)inqdata+inqLen, 8);//卡验证码
	inqLen += 4;
	CTools::hex_to_byte((const BYTE *)"00000000", (BYTE *)inqdata+inqLen, 8);//申请日期
	inqLen += 4;
	CTools::hex_to_byte((const BYTE *)"000000", (BYTE *)inqdata+inqLen, 6);//申请时间
	inqLen += 3;
	CTools::hex_to_byte((const BYTE *)"00000000", (BYTE *)inqdata+inqLen, 8);
	inqLen += 4;
	CTools::hex_to_byte((const BYTE *)"00000000", (BYTE *)inqdata+inqLen, 8);
	inqLen += 4;
	inqdata[inqLen++] = 0x00;//充值类型
	inqdata[inqLen++] = 0x00;//充值点编号
	inqdata[inqLen++] = 0x00;
	CTools::hex_to_byte((const BYTE *)gbl.pos_no+2, (BYTE *)inqdata+inqLen, 6);//充值机编号
	inqLen += 3;
	inqdata[inqLen++] = 0x00;//充值员编号
	inqdata[inqLen++] = 0x00;
	inqdata[inqLen++] = 0x00;
	
	bbzero(temp_buff);
	bbzero(inqdataHex);
	bbzero(check_buff);
	CTools::byte_to_hex((const BYTE *)inqdata, (BYTE *)inqdataHex, inqLen);
	/***********************************************************/
	strncat(temp_buff,"7E7E7E00",8);
	strncat(temp_buff,gbl.pos_no+2,6);
	strncat(temp_buff,"8006",4);
	strncat(temp_buff,&(bus_key.bus_charge_key[2]),2);
	strncat(temp_buff,&(bus_key.bus_charge_key[4]),2);
	strncat(temp_buff,&(bus_key.bus_charge_key[0]),2);
	strncat(temp_buff,"38",2);
	strncat(temp_buff,gbl.bus_enq_stan,12);
	strncat(temp_buff,"002A",4);
	strncat(temp_buff,inqdataHex,inqLen*2);
	
	length = CTools::hex_to_byte((const BYTE *)temp_buff,(BYTE *)check_buff,strlen(temp_buff));
	CTools::crc_cu_16((BYTE *)check_buff,length);
	bbzero(temp_buff);
	CTools::byte_to_hex((const BYTE *)check_buff,(BYTE *)temp_buff,length+2);
	
	for (i=1;i<MAX_BUS_ORDER;i++)
	{
		if (bus_order[i].flag == 0)
		{
			bus_order[i].flag = 1;
			break;
		}
	}
	if (i == MAX_BUS_ORDER)
	{
		wrLog("公交交易内存满");
		return -1;
	}

	bbzero(bus_order[i].data);
	strcpy(bus_order[i].data,temp_buff);
	bbzero(bus_order[i].stan);
	strcpy(bus_order[i].stan,gbl.bus_enq_stan);
	bus_order[i].data_len = strlen(temp_buff);
	time(&(bus_order[i].inTime));
	wrLog("黑名单校验：【内存编号：%d】【STAN：%s】【DATA[%d]：%s】",i,bus_order[i].stan,bus_order[i].data_len,bus_order[i].data);
	/***********************************************************/
    while (1)
    {
		if (bus_order[i].flag == 1 ||bus_order[i].flag == 2)
		{
			Sleep(100*5);
		}else if (bus_order[i].flag == 0)
		{
			wrLog("黑名单校验出错");
			//TS_OutPutMsg(gbl.dPosInfo,"\n\n  黑名单校验出错",1,iSelect);
			return -1;
		}else if (bus_order[i].flag == 3)
		{
			bbzero(respond_code);
			memcpy(respond_code,bus_order[i].data+42,4);
			wrLog("黑名单校验返回码【%s】",respond_code);
			if (memcmp(respond_code,"8000",4)==0)
			{
				wrLog("黑名单卡\n销卡失败");
				//TS_OutPutMsg(gbl.dPosInfo,"黑名单卡\n销卡失败，按【确认】继续换卡交易",0,iSelect);
				return -1;
			}else if (memcmp(respond_code,"7000",4)==0)
			{
				wrLog("销卡失败，不允许充值的POS机\n  请联系东莞公交公司！\n   按【确认】继续换卡");
				//TS_OutPutMsg(gbl.dPosInfo," 销卡失败，请联系东莞公交公司！\n   按【确认】继续换卡",0,iSelect);
				return -1;
			}else if (memcmp(respond_code,"9000",4)==0)
			{
				bus_order[i].flag = 0;
				bus_order[i].data_len = 0;
				bbzero(bus_order[i].data);
				bbzero(bus_order[i].stan);
				break;
			}else
			{
				//TS_OutPutMsg(gbl.dPosInfo,"  \n 销卡失败 \n   按【确认】继续换卡",0,iSelect);
				return -1;
			}
		}else 
			return -1;
    }
	
	//设置金额 0元扣费
	bbzero(gbl.amount);
	strcpy(gbl.amount,"000000000000");

	bbzero(old_amount);
	CTools::sixten_toten(gbl.bus_old_amo,old_amount);
	wrLog("总金额：%d",(atoi(old_amount)+atoi(gbl.amount)));

	bbzero(yj_amount);
	if (!strcmp(feeType,"0214"))
	{
		if (atoi(gbl.amount)==4500)
		{
			strcpy(yj_amount,"000005DC");
		}else if (atoi(gbl.amount)==4800)
		{
			strcpy(yj_amount,"00000708");
		}else if (atoi(gbl.amount)==5500)
		{
			strcpy(yj_amount,"000009C4");
		}else 
			return -1;		
	}else
		strcpy(yj_amount,"00000000");
	bbzero(gbl.bus_yj_amo);
	strcpy(gbl.bus_yj_amo,yj_amount);
	
	//发东莞公交充值报文

	wrLog("【充值】");
	bbzero(inqdata);
	inqLen = 0;
	inqdata[inqLen++] = 0x07;//城市代码
	inqdata[inqLen++] = 0x69;
	inqdata[inqLen++] = 0x00;//行业代码
	inqdata[inqLen++] = 0x01;

	CTools::hex_to_byte((const BYTE *) gbl.bus_card,(BYTE *)inqdata+inqLen,8);//卡唯一号
	inqLen += 4;
	memset(inqdata+inqLen, 0, 4);//卡应用号
	inqLen += 4;
	memcpy(inqdata+inqLen, gbl.bus_conf, 4);
	inqLen += 4;
	// 	bbzero(date);
	// 	CTools::get_date8(date);
	// 	bbzero(dtime);	
	// 	CTools::get_time(dtime);
	CTools::hex_to_byte((const BYTE *)gbl.bus_date, (BYTE *)inqdata+inqLen, 8);//申请日期
	inqLen += 4;
	CTools::hex_to_byte((const BYTE *)gbl.bus_time, (BYTE *)inqdata+inqLen, 6);//申请时间
	inqLen += 3;

	CTools::hex_to_byte((BYTE *)gbl.bus_old_amo,(BYTE *)inqdata+inqLen,8);
	//memcpy(inqdata+inqLen, rcvData+14, 4);//卡上余额
	inqLen += 4;

	//申请充值金额
	if(!strcmp(feeType,"0214")){//如果是发卡，充值30		
		//充值30元
		memcpy(inqdata+inqLen, "\x00\x00\x0B\xB8", 4);
		inqLen += 4;
	}else{
		unsigned long amount;
		amount = atol(gbl.amount);
		inqdata[inqLen++] = (char)(amount / 0x01000000);
		amount = amount % 0x01000000;
		inqdata[inqLen++] = (char)(amount / 0x010000);
		amount = amount % 0x010000;
		inqdata[inqLen++] = (char)(amount / 0x0100);
		inqdata[inqLen++] = (char)(amount % 0x0100);
	}
	inqdata[inqLen++] = 0x01;//充值类型
	inqdata[inqLen++] = 0x00;//充值点编号
	inqdata[inqLen++] = 0x00;
	CTools::hex_to_byte((const BYTE *)gbl.pos_no+2, (BYTE *)inqdata+inqLen, 6);//充值机编号
	inqLen += 3;
	if (!strcmp(feeType,"0214"))
	{
		if (atoi(gbl.amount)==4500)
		{
			inqdata[inqLen++] = 0x0F;//押金
		}
		else if (atoi(gbl.amount)==4800)
		{
			inqdata[inqLen++] = 0x12;//押金
		}else if (atoi(gbl.amount)==5500)
		{
			inqdata[inqLen++] = 0x19;//押金
		}else
		{
			inqdata[inqLen++] = 0x00;//押金
		}
		
	}else
		inqdata[inqLen++] = 0x00;
	inqdata[inqLen++] = 0x00;
	inqdata[inqLen++] = 0x00;
	
	bbzero(temp_buff);
	bbzero(inqdataHex);
	bbzero(check_buff);
	CTools::byte_to_hex((const BYTE *)inqdata, (BYTE *)inqdataHex, inqLen);
	
	/***********************************************************/
	strncat(temp_buff,"7E7E7E00",8);
	strncat(temp_buff,gbl.pos_no+2,6);
	strncat(temp_buff,"8006",4);
	strncat(temp_buff,&(bus_key.bus_charge_key[2]),2);
	strncat(temp_buff,&(bus_key.bus_charge_key[4]),2);
	strncat(temp_buff,&(bus_key.bus_charge_key[0]),2);
	strncat(temp_buff,"37",2);
	strncat(temp_buff,gbl.bus_enq_stan,12);
	strncat(temp_buff,"002A",4);
	strncat(temp_buff,inqdataHex,inqLen*2);
	
	length = CTools::hex_to_byte((const BYTE *)temp_buff,(BYTE *)check_buff,strlen(temp_buff));
	CTools::crc_cu_16((BYTE *)check_buff,length);
	bbzero(temp_buff);
	CTools::byte_to_hex((const BYTE *)check_buff,(BYTE *)temp_buff,length+2);
	
	for (i=1;i<MAX_BUS_ORDER;i++)
	{
		if (bus_order[i].flag == 0)
		{
			bus_order[i].flag = 1;
			break;
		}
	}
	if (i == MAX_BUS_ORDER)
	{
		wrLog("公交交易内存满"); //如果出现公交内存满的情况充值失败
		bbzero(gbl.bus_failcode);
		strcpy(gbl.bus_failcode,"02");
		iRet=busbusConHdl(type,1); //	确认失败
		if(iRet!=0)  //如果确认不成功则保留状态
		{
				wrLog("公交卡号：%s  状态值为：4   状态：销卡失败未确认",gbl.bus_card);
				//TS_OutPutMsg(gbl.dPosInfo, "销卡失败,请按【Enter】继续换卡交易\n\n", 1, iSelect);
		
		}
		else
		{
				wrLog("公交卡号：%s  状态值为：5   状态 销卡失败已确认",gbl.bus_card);
				//TS_OutPutMsg(gbl.dPosInfo, "销卡失败\n按【确认】继续完成换卡交易", 1, iSelect);
		}
		
		return -1;
	}

	bbzero(bus_order[i].data);
	strcpy(bus_order[i].data,temp_buff);
	bbzero(bus_order[i].stan);
	strcpy(bus_order[i].stan,gbl.bus_enq_stan);
	bus_order[i].data_len = strlen(temp_buff);
	time(&(bus_order[i].inTime));
	wrLog("公交交易：【内存编号：%d】【STAN：%s】【DATA[%d]：%s】",i,bus_order[i].stan,bus_order[i].data_len,bus_order[i].data);
	/***********************************************************/
    while (1)
    {
		if (bus_order[i].flag == 1 ||bus_order[i].flag == 2)
		{
			Sleep(100*5);
		}else if (bus_order[i].flag == 0)
		{
			//TS_OutPutMsg(gbl.dPosInfo,"/n/n      充值失败",1,iSelect); //by liuxiao
			bbzero(gbl.bus_failcode);
			strcpy(gbl.bus_failcode,"02");
			iRet=busbusConHdl(type,1);
			if(iRet!=0)
			{//如果确认不成功则保留状态
				wrLog("公交卡号：%s  状态值为：4   状态：销卡失败未确认",gbl.bus_card);
				//TS_OutPutMsg(gbl.dPosInfo, "销卡失败\n请按【Enter】继续交易\n", 1, iSelect);
			}
			else
			{
				wrLog("公交卡号：%s  状态值为：5   状态：销卡失败已确认",gbl.bus_card);
			//	TS_OutPutMsg(gbl.dPosInfo, "销卡失败\n按【确认】继续交易", 1, iSelect);
			}
		
			return -1;

		}
		else if (bus_order[i].flag == 3)
		{
			bbzero(return_le);
			memcpy(return_le,bus_order[i].data+38,4);
			if (memcmp(return_le,"002A",4)==0)
			{
				bbzero(cz_key);
				memcpy(cz_key,bus_order[i].data+42,80);
				bus_order[i].flag = 0;
				bus_order[i].data_len = 0;
				bbzero(bus_order[i].data);
				bbzero(bus_order[i].stan);
				break;
			}else if (memcmp(return_le,"0004",4)==0)
			{
				bbzero(respond_code);
				memcpy(respond_code,bus_order[i].data+58,4);
				wrLog("充值密钥申请返回码【%s】",respond_code);
				if (memcmp(respond_code,"8000",4)==0)
				{
					wrLog("销卡失败，黑名单卡\n   请联系公交公司");
					//TS_OutPutMsg(gbl.dPosInfo,"销卡失败，黑名单卡\n   请联系公交公司！\n   按【确认】继续换卡交易",0,iSelect);
				}else if (memcmp(respond_code,"7000",4)==0)
				{
				//	TS_OutPutMsg(gbl.dPosInfo," 销卡失败，不允许充值的POS机\n 请联系公交公司\n   按【确认】继续换卡交易",0,iSelect);
				}else
				{
					if (memcmp(respond_code,"A000",4)==0)
					{
						wrLog("串口没有打开");
					}else if (memcmp(respond_code,"B000",4)==0)
					{
						wrLog("其他错误");
					}else if (memcmp(respond_code,"1000",4)==0)
					{
						wrLog("CRC16校验错误");
					}else if (memcmp(respond_code,"6000",4)==0)
					{
						wrLog("分散密钥失败");
					}else if (memcmp(respond_code,"5000",4)==0)
					{
						wrLog("寻找SAM卡失败");
					}else if (memcmp(respond_code,"3000",4)==0)
					{
						wrLog("通许平台存储数据失败");
					}
					//TS_OutPutMsg(gbl.dPosInfo,"  \n 销卡失败,充值密钥申请出错\n   按【确认】继续完成换卡交易",0,iSelect);
				}


				bbzero(gbl.bus_failcode);
				strcpy(gbl.bus_failcode,"02");
				iRet=busConHdl(type,1);
				if(iRet!=0){//如果确认不成功则保留状态
					wrLog("公交卡号：%s  状态值为：4   状态：销卡失败未确认",gbl.bus_card);
					//TS_OutPutMsg(gbl.dPosInfo, "销卡失败\n", 1, iSelect);
				}else
				{
						wrLog("公交卡号：%s  状态值为：5   状态：销卡失败已确认",gbl.bus_card);
					//	TS_OutPutMsg(gbl.dPosInfo, "销卡失败\n按【确认】继续换卡交易", 1, iSelect);
			
					return -1;

				}
			}
			else 
			{
				bbzero(gbl.bus_failcode);
				strcpy(gbl.bus_failcode,"02");
				TS_OutPutMsg(gbl.dPosInfo,"  \n  充值密钥申请出错\n   按【确认】返回",0,iSelect);
				iRet=busbusConHdl(type,1);
				if(iRet!=0)
				{//如果确认不成功则保留状态
					wrLog("公交卡号：%s  状态值为：4   状态：销卡失败未确认",gbl.bus_card);
					//TS_OutPutMsg(gbl.dPosInfo, "销卡失败\n", 1, iSelect);
				}
				else
				{
					wrLog("公交卡号：%s  状态值为：5   状态：销卡失败已确认",gbl.bus_card);
					//TS_OutPutMsg(gbl.dPosInfo, "销卡失败\n按【确认】继续换卡交易", 1, iSelect);
				}
					
				return -1;
			}
			
		}else
		{
			bbzero(gbl.bus_failcode);
			strcpy(gbl.bus_failcode,"02");
			iRet=busbusConHdl(type,1);
			if(iRet!=0)
			{//如果确认不成功则保留状态
				wrLog("公交卡号：%s  状态值为：4   状态：充值失败未确认",gbl.bus_card);
				//TS_OutPutMsg(gbl.dPosInfo, "充值失败\n充值返回信息提交出错\n请挂机后重新连接系统\n", 1, iSelect);
			}
			else
			{
				wrLog("公交卡号：%s  状态值为：5   状态：充值失败已确认",gbl.bus_card);
			//	TS_OutPutMsg(gbl.dPosInfo, "充值失败\n按【确认】返回", 1, iSelect);
			}
	
			return -1;
		}
		
    }

	//进行公交卡充值
	bbzero(sendData);
	bbzero(rcvData);
	sendLen=0;
	rcvLen=0;
	if(!strcmp(feeType,"0214")){//如果是发卡
		bbzero(gbl.bus_pay_amo);
		memcpy(gbl.bus_pay_amo, "00000BB8", 8);
	}else{
		unsigned long amount;//充值金额
		char amoBuf[4+1];
		bbzero(amoBuf);
		amount = atol(gbl.amount);
		amoBuf[0] = (char)(amount / 0x01000000);
		amount = amount % 0x01000000;
		amoBuf[1] = (char)(amount / 0x010000);
		amount = amount % 0x010000;
		amoBuf[2] = (char)(amount / 0x0100);
		amoBuf[3] = (char)(amount % 0x0100);
		bbzero(gbl.bus_pay_amo);
		CTools::byte_to_hex((const BYTE*)amoBuf, (BYTE*)gbl.bus_pay_amo, 4);
	}

	memcpy(sendData, "\xC2\x85", 2); 
	sendLen += 2;

	gbl.bus_card_serial[0] = gbl.bus_card_serial[0] + 1; 
	memcpy(sendData+sendLen, gbl.bus_card_serial, 1);

	sendLen++;
	CTools::hex_to_byte((const BYTE *)gbl.bus_pay_amo, (BYTE *)sendData+sendLen, 8);//充值金额
	sendLen += 4;
	CTools::hex_to_byte((const BYTE *)cz_key, (BYTE *)sendData+sendLen, 80);//密文
	sendLen += 40;
	CTools::hex_to_byte((const BYTE *)bus_key.bus_discharge_key, (BYTE *)sendData+sendLen, 16);//解密密钥
	sendLen += 8;
	CTools::hex_to_byte((const BYTE *)gbl.bus_card, (BYTE *)sendData+sendLen, 8);//卡唯一号
	sendLen += 4;
	memcpy(sendData+sendLen, gbl.bus_conf, 4);//认证码
	sendLen += 4;
	CTools::hex_to_byte((const BYTE *)gbl.bus_old_amo, (BYTE *)sendData+sendLen, 8);//余额
	sendLen += 4;
	CTools::hex_to_byte((const BYTE *)gbl.bus_date, (BYTE *)sendData+sendLen, 8);//充值日期
	sendLen += 4;
	CTools::hex_to_byte((const BYTE *)gbl.bus_time, (BYTE *)sendData+sendLen, 6);//充值时间
	sendLen += 3;
	CTools::hex_to_byte((const BYTE *)gbl.bus_enq_stan, (BYTE *)sendData+sendLen, 12);//流水号
	sendLen += 6;
	CTools::hex_to_byte((const BYTE *)"01", (BYTE *)sendData+sendLen, 2);//充值类型
	sendLen++;
	CTools::hex_to_byte((const BYTE *)"0001", (BYTE *)sendData+sendLen, 4);//商户代码
	sendLen += 2;
	CTools::hex_to_byte((const BYTE *)yj_amount, (BYTE *)sendData+sendLen, 8);//商户代码
	sendLen += 4;

	//充值 

	if( busSndRcvHID_IcData(type, (const BYTE *)sendData, sendLen, (BYTE *)rcvData, rcvLen, gbl.pos_serial) )
	
	{
			//	如果充值过程中出现异常。异常作为失败处理//
			return -1;
	}

	else //如果读卡器指令返回
	
	{
		bbzero(dkq_PSAM);
		bbzero(dkq_code); 
		memcpy(dkq_code,rcvData+48+2,4); //机具编号
		CTools::byte_to_hex((const BYTE *)rcvData+52+2, (BYTE *)dkq_PSAM, 8); //psam卡号
		wrLog("【原PSAM：%s】【现PSAM：%s】",(BYTE *)gbl.dkq_PSAM,dkq_PSAM);
		wrHex("[原机具编号] ", (BYTE *)gbl.dkq_code,strlen(gbl.dkq_code));
		wrHex("[现机具编号]",(BYTE *)dkq_code,strlen(dkq_code));
	
		bbzero(gbl.bus_card_info);
		memcpy(gbl.bus_card_info, rcvData+2, 48); //充值记录
		//解析充值记录
		wrHex("公交充值记录",(BYTE *)gbl.bus_card_info,48);
		//卡唯一号
		wrLog("交易结果如下：\n卡唯一号：%s",gbl.bus_card);

		char charge_flag[2]; //充值结果

		bbzero(charge_flag);

		//根据交易结果获取最终交易情况，00表示交易成功，01表示交易失败。

		CTools::byte_to_hex((BYTE *)gbl.bus_card_info+40,(BYTE *)charge_flag,1);

		if( rcvData[0]==0x00 && rcvData[1]==0x00 && strcmp(charge_flag,"00") ==0)
		{
			//如果充值成功	

			iRet=busbusConHdl(type,0);
			if(iRet!=0)
			{//如果确认不成功则保留状态
				wrLog("公交卡号：%s  状态值为：1   状态：销卡成功未确认",gbl.bus_card);
			}else
			{
				wrLog("公交卡号：%s  状态值为：2   状态：销卡成功已确认",gbl.bus_card);
			}	
		
		}
		
		else
		{
			bbzero(gbl.bus_failcode);
			CTools::byte_to_hex((const BYTE *)rcvData+1, (BYTE *)gbl.bus_failcode, 1);
			wrLog("【错误代码】%s",gbl.bus_failcode);
			iRet=busbusConHdl(type,1);
			if(iRet!=0)
			{//如果确认不成功则保留状态
					wrLog("公交卡号：%s  状态值为：4   状态：销卡失败未确认",gbl.bus_card);
					//TS_OutPutMsg(gbl.dPosInfo, "销卡失败\n", 1, iSelect);
			}
			else
			{
					wrLog("公交卡号：%s  状态值为：5   状态：销卡失败已确认",gbl.bus_card);
					CDB::update_DGBus_Txn(gbl,"5");
					CDB::update_epos_term(gbl.pos_no, "1");//将终端状态设为"正常"
					//TS_OutPutMsg(gbl.dPosInfo, "销卡失败\n按【确认】继续完成换卡交易", 1, iSelect);
			}

			return -1;
		}		
	
	}
	
	return 0;
}



/*************************************************************/
//交费
/*************************************************************/
int CTrade::busPayHdl(const char *type)
{
	wrLog("【充值】busPayHdl");
	bbzero(gbl.bus_showId);
	CTools::getDGTM1CardId(gbl.bus_card,gbl.bus_showId);

	int iRet = 0, flag = 0, count=1,b48_len=0,iSelect;
	
	for(int icount=0; icount<MAXTRY;  icount++)
	{
		if(!flag) 
		{
			iRet = mngCard_Hdl(type);
			if(iRet == CANCLE_KEY)
				return CANCLE_KEY;
			else if(iRet != 0){
				TS_OutPutMsg(gbl.dPosInfo,"读取输入数据错误!\n交易失败!\n按【确认】返回",1,iSelect);
				return -1;
			}
			
			if(!memcmp(gbl.card_no,"8828",4))	//若是付费易卡,走付费易卡刷卡流程（多卡交易）
			{
				memset(gbl.xlt_type, 0, sizeof(gbl.xlt_type));
				memcpy(gbl.xlt_type, "01",2);
				iRet = xltMulCard( type, 0);
				return iRet;
			}
		}
		
		pack.wrField(2, gbl);	//写交费域
		
		bbzero(pack.FIELD48);
		memcpy(pack.FIELD48,gbl.fee_type,4);	//4位信息码
		b48_len = 4;
		memcpy(pack.FIELD48+b48_len,"10",2);	
		b48_len +=2;
		memcpy(pack.FIELD48+b48_len, gbl.bus_showId, 10);	//changed by 卡面号
		b48_len += 10;
		pack.Packet_Table[48].Real_Length=b48_len;	
		
		CDB::update_epos_term(gbl.pos_no,"9");//将终端状态设为"公交扣费中"
		
		bbzero(gbl.bus_serial);
		memcpy(gbl.bus_serial, gbl.pos_serial, 6);
		
		iRet = packHdl(2);
		if(iRet == -2){
			CDB::update_epos_term(gbl.pos_no,"1");//将终端状态设为"正常"
			return -2;
		}
		else if(iRet < 0){
			CDB::update_epos_term(gbl.pos_no,"1");//将终端状态设为"正常"
			return -1;
		}
		if( !memcmp(pack.FIELD39, "00", 2) )  //成功
		{
			
			bbzero(gbl.stan_no);
			memcpy(gbl.stan_no, (char *)pack.FIELD37, 12);//读入系统参考号
			if(!strcmp(gbl.fee_type,"0214")){//如果是发卡
				bbzero(gbl.bus_pay_amo);
				memcpy(gbl.bus_pay_amo, "00000BB8", 8);
			}else{
				unsigned long amount;//充值金额
				char amoBuf[4+1];
				bbzero(amoBuf);
				amount = atol(gbl.amount);
				amoBuf[0] = (char)(amount / 0x01000000);
				amount = amount % 0x01000000;
				amoBuf[1] = (char)(amount / 0x010000);
				amount = amount % 0x010000;
				amoBuf[2] = (char)(amount / 0x0100);
				amoBuf[3] = (char)(amount % 0x0100);
				bbzero(gbl.bus_pay_amo);
				CTools::byte_to_hex((const BYTE*)amoBuf, (BYTE*)gbl.bus_pay_amo, 4);
			}
			bbzero(gbl.bus_card_info);			
			bbzero(gbl.bus_serial);
			memcpy(gbl.bus_serial, gbl.pos_serial, 6);
			bbzero(gbl.bus_time);
			bbzero(gbl.bus_date);
			CTools::get_date8(gbl.bus_date);				
			CTools::get_time(gbl.bus_time);
			//插入充值记录表
			CDB::set_DGBus_Txn(gbl);
			//CDB::update_epos_term(gbl.pos_no,"1");//将终端状态设为"正常"
			return 0;
			
		}
		else if(!memcmp(pack.FIELD39, "55", 2))
		{			
			CDB::update_epos_term(gbl.pos_no,"1");//将终端状态设为"正常"
			flag = 1;
			if(reGetPwd(type) == 0) //密码错误，重新输入密码, 2006-10-25
				continue;
			else
				return CANCLE_KEY;
		}
		else
		{
			CDB::update_epos_term(gbl.pos_no,"1");//将终端状态设为"正常"
			bbzero(gbl.stan_no);
			memcpy(gbl.stan_no, (char *)pack.FIELD37, 12);//读入系统参考号
			returnFail((char*)pack.FIELD39);
			return -1;
		}
	}
	return -1;
}

/*************************************************************/
//冲正
/*************************************************************/
int CTrade::busRevHdl(const char *type){
	int b48_len, iRet;

	//获取卡面号
	bbzero(gbl.bus_showId);
	CTools::getDGTM1CardId(gbl.bus_card,gbl.bus_showId);
	
	wrLog("【*******东莞公交冲正*******】");
	//写冲正域
	pack.wrField(5, gbl);
	/************补充48域*********/
	bbzero(pack.FIELD48);
	memcpy(pack.FIELD48,gbl.fee_type,4);	
	b48_len = 4;
	memcpy(pack.FIELD48+b48_len, gbl.bus_serial, 6);	
	b48_len += 6;
	memcpy(pack.FIELD48+b48_len,"10",2);	
	b48_len += 2;
	memcpy(pack.FIELD48+b48_len, gbl.bus_showId, 10);	//changed bus_card by bus_showid
	b48_len += 10;
	pack.Packet_Table[48].Real_Length = b48_len;
	/***********************************/
	//确认包打包
	iRet = packHdl(5);
	if(iRet < 0)
	{
		return -1;
	}
	if (!memcmp(pack.FIELD39,"00",2)) 
	{
		return 0;
	}else if( !memcmp(pack.FIELD39, "89", 2) ){
		wrLog("【冲正】隔天冲正失败");
		return 1;
	}
	else{
		wrLog("【冲正】失败");
		return -2;
	}
}

/*************************************************************/
//确认 flag:1:失败 0:成功 2:冲正确认 4:交易结果不确定按成功处理
/*************************************************************/
int CTrade::busConHdl(const char *type, int flag){
	char bus_card_infoBCD[96+1],inqdata[128];
	int iRet=0,length=0,inqLen;
	int b48_len, b63_len;
	char bus_old_amo[4+1],bus_pay_amo[4+1],bus_yj_amo[4+1],bus_new_amo[4+1];
	char bus_old_amo_buff[12+1],bus_pay_amo_buff[12+1];
	char trade_status[2+1];
	bbzero(trade_status);

	//获取卡面号
	bbzero(gbl.bus_showId);
	CTools::getDGTM1CardId(gbl.bus_card,gbl.bus_showId);

	if (flag==0 || flag==4) //交易成功，及交易结果不明确按成功处理
	{
		strcpy(trade_status,"00");
	}
	else
	{
		strcpy(trade_status,"01");//失败及冲正确认是交易失败的确认
	}


	if (flag ==0 )
	{
		CTools::byte_to_hex((const BYTE*)gbl.bus_card_info,(BYTE*)bus_card_infoBCD,48);
	}else if (flag == 4)
	{
		bbzero(inqdata);
		bbzero(bus_old_amo);
		bbzero(bus_pay_amo);
		bbzero(bus_yj_amo);
		inqLen = 0;
		inqdata[inqLen++] = (char)0xAB;//充值记录
		//memcpy(inqdata+inqLen, gbl.bus_card, 4);
		CTools::hex_to_byte((BYTE *)gbl.bus_card,(BYTE *)inqdata+inqLen,8);
		inqLen += 4;
		memset(inqdata+inqLen, 0, 4);//卡应用号
		inqLen += 4;
		if (gbl.bus_selltype == 0)
		{
			inqdata[inqLen++] = 0x42;//卡类型
		}else
			inqdata[inqLen++] = 0x41;//卡类型
		inqdata[inqLen++] = 0x01;//充值类型
		//		CTools::hex_to_byte((const BYTE *)gbl.bus_old_amo, (BYTE *)inqdata+inqLen, 8);//原有金额
		CTools::bus_money_change(gbl.bus_old_amo,bus_old_amo);
		strcpy(inqdata+inqLen,bus_old_amo);
		inqLen += 4;
		//		CTools::hex_to_byte((const BYTE *)gbl.bus_pay_amo, (BYTE *)inqdata+inqLen, 8);//充值金额
		CTools::bus_money_change(gbl.bus_pay_amo,bus_pay_amo);
		strcpy(inqdata+inqLen,bus_pay_amo);
		inqLen += 4;
		bbzero(bus_old_amo_buff);
		bbzero(bus_pay_amo_buff);
		bbzero(gbl.bus_new_amo);
		bbzero(bus_new_amo);
		CTools::sixten_toten(gbl.bus_old_amo,bus_old_amo_buff);
		CTools::sixten_toten(gbl.bus_pay_amo,bus_pay_amo_buff);
		sprintf(gbl.bus_new_amo,"%08X",atoi(bus_old_amo_buff)+atoi(bus_pay_amo_buff));
		//		CTools::hex_to_byte((const BYTE *)gbl.bus_old_amo, (BYTE *)inqdata+inqLen, 8);//现有金额
		CTools::bus_money_change(gbl.bus_new_amo,bus_new_amo);
		strcpy(inqdata+inqLen,bus_new_amo);
		inqLen += 4;
		//		CTools::hex_to_byte((const BYTE *)gbl.bus_yj_amo, (BYTE *)inqdata+inqLen, 8);//押金
		CTools::bus_money_change(gbl.bus_yj_amo,bus_yj_amo);
		strcpy(inqdata+inqLen,bus_yj_amo);
		inqLen += 4;
		CTools::hex_to_byte((const BYTE *)"00000000", (BYTE *)inqdata+inqLen, 8);//实收金额
		inqLen += 4;
		CTools::hex_to_byte((const BYTE *)"000000", (BYTE *)inqdata+inqLen, 6);//钱包值
		inqLen += 3;
		CTools::hex_to_byte((const BYTE *)gbl.bus_date+2, (BYTE *)inqdata+inqLen, 6);//时间
		inqLen += 3;
		CTools::hex_to_byte((const BYTE *)gbl.bus_time, (BYTE *)inqdata+inqLen, 6);//日期
		inqLen += 3;
		inqdata[inqLen++] = 0x01;//充值情况标志
		CTools::hex_to_byte((const BYTE *)"00000000", (BYTE *)inqdata+inqLen, 8);//交易认证码
		inqLen += 4;
		inqdata[inqLen++] = 0x00;//商户代码
		inqdata[inqLen++] = 0x00;//交易结果
		inqdata[inqLen++] = 0x00;//记录MAC验证码
		CTools::byte_to_hex((const BYTE*)inqdata,(BYTE*)bus_card_infoBCD,inqLen);	
	}else
	{
		bbzero(inqdata);
		bbzero(bus_old_amo);
		bbzero(bus_pay_amo);
		bbzero(bus_yj_amo);
		inqLen = 0;
		inqdata[inqLen++] = (char)0xAB;//充值记录
		//memcpy(inqdata+inqLen, gbl.bus_card, 4);
		CTools::hex_to_byte((BYTE *) gbl.bus_card,(BYTE *)inqdata+inqLen,8); 
		inqLen += 4;
		memset(inqdata+inqLen, 0, 4);//卡应用号
		inqLen += 4;
		if (gbl.bus_selltype == 0)
		{
			inqdata[inqLen++] = 0x42;//卡类型
		}else
			inqdata[inqLen++] = 0x41;//卡类型
		inqdata[inqLen++] = 0x01;//充值类型
		//		CTools::hex_to_byte((const BYTE *)gbl.bus_old_amo, (BYTE *)inqdata+inqLen, 8);//原有金额
		CTools::bus_money_change(gbl.bus_old_amo,bus_old_amo);
		strcpy(inqdata+inqLen,bus_old_amo);
		inqLen += 4;
		//		CTools::hex_to_byte((const BYTE *)gbl.bus_pay_amo, (BYTE *)inqdata+inqLen, 8);//充值金额
		CTools::bus_money_change(gbl.bus_pay_amo,bus_pay_amo);
		strcpy(inqdata+inqLen,bus_pay_amo);
		inqLen += 4;
		//		CTools::hex_to_byte((const BYTE *)gbl.bus_old_amo, (BYTE *)inqdata+inqLen, 8);//现有金额
		CTools::bus_money_change(gbl.bus_old_amo,bus_old_amo);
		strcpy(inqdata+inqLen,bus_old_amo);
		inqLen += 4;
		//		CTools::hex_to_byte((const BYTE *)gbl.bus_yj_amo, (BYTE *)inqdata+inqLen, 8);//押金
		CTools::bus_money_change(gbl.bus_yj_amo,bus_yj_amo);
		strcpy(inqdata+inqLen,bus_yj_amo);
		inqLen += 4;
		CTools::hex_to_byte((const BYTE *)"00000000", (BYTE *)inqdata+inqLen, 8);//实收金额
		inqLen += 4;
		CTools::hex_to_byte((const BYTE *)"000000", (BYTE *)inqdata+inqLen, 6);//钱包值
		inqLen += 3;
		CTools::hex_to_byte((const BYTE *)gbl.bus_date+2, (BYTE *)inqdata+inqLen, 6);//时间
		inqLen += 3;
		CTools::hex_to_byte((const BYTE *)gbl.bus_time, (BYTE *)inqdata+inqLen, 6);//日期
		inqLen += 3;
		inqdata[inqLen++] = 0x01;//充值情况标志
		CTools::hex_to_byte((const BYTE *)"00000000", (BYTE *)inqdata+inqLen, 8);//交易认证码
		inqLen += 4;
		inqdata[inqLen++] = 0x00;//商户代码
		CTools::hex_to_byte((const BYTE *)gbl.bus_failcode, (BYTE *)inqdata+inqLen, 2);//错误代码
		inqdata[inqLen++] = 0x00;//记录MAC验证码
		CTools::byte_to_hex((const BYTE*)inqdata,(BYTE*)bus_card_infoBCD,inqLen);	
		bbzero(gbl.bus_new_amo);
		strcpy(gbl.bus_new_amo,gbl.bus_old_amo);
	}
	for (int i=0;i<3;i++)
	{		
		wrLog("【*******东莞公交PE确认*******】");
		//写确认域
		pack.wrField(4, gbl);
		/************补充48域和63域*********/
		bbzero(pack.FIELD48);
		memcpy(pack.FIELD48,gbl.fee_type,4);  
		b48_len = 4;
		//确认包48域名添加对交易结果的上送 2位 00 成功，01失败
		memcpy(pack.FIELD48+b48_len,trade_status,2);
		b48_len+=2;
		memcpy(pack.FIELD48+b48_len,"10",2);	
		b48_len += 2;
		memcpy(pack.FIELD48+b48_len, gbl.bus_showId, 10);	 //changed bus_card by bus_showId
		b48_len += 10;
		pack.Packet_Table[48].Real_Length = b48_len;
		
		bbzero(pack.FIELD63);
		memcpy(pack.FIELD63, gbl.bus_enq_stan, 12);
		b63_len = 12;
		memcpy(pack.FIELD63 + b63_len, gbl.bus_serial, 6);
		b63_len += 6;
		memcpy(pack.FIELD63 + b63_len, bus_card_infoBCD , 96);
		b63_len += 96;
		pack.Packet_Table[63].Real_Length = b63_len;
		/***********************************/
		//确认包打包
		iRet = packHdl(4);
		if(iRet < 0)
			//如果确认包超时的话。怎么处理。
			return -1;
		if (!memcmp(pack.FIELD39,"00",2)) 
		{
			if (flag ==1)
			{
				wrLog("公交卡号：%s  状态值为：7   状态：充值失败PE已确认",gbl.bus_card);
				CDB::update_DGBus_Txn(gbl,"7");
			}else if (flag == 0 || flag == 4)
			{
				wrLog("公交卡号：%s  状态值为：8   状态：充值成功PE已确认",gbl.bus_card);
				CDB::update_DGBus_Txn(gbl,"8");
			}else
			{
				wrLog("公交卡号：%s  状态值为：9   状态：冲正失败PE已确认",gbl.bus_card);
				CDB::update_DGBus_Txn(gbl,"9");
			}
			iRet = busbusConHdl(type,flag); //公交确认。
			if (iRet ==0)
			{
				return 0;
			}else
				return 2;
		}
		else
		{
			; 
		}
	}
	return -3;
	
}



int CTrade::busbusConHdl(const char *type, int flag){
	char bus_card_infoBCD[96+1],inqdata[128];
	int iRet=0,length=0,i,j,inqLen;
	char temp_buff[1024],check_buff[1024];
	char respond_code[4+1];
	char bus_old_amo[4+1],bus_pay_amo[4+1],bus_yj_amo[4+1],bus_new_amo[4+1];
	char bus_old_amo_buff[12+1],bus_pay_amo_buff[12+1];
	
	bbzero(temp_buff);
	bbzero(check_buff);
	bbzero(bus_card_infoBCD);
	if (flag ==0 )
	{
		CTools::byte_to_hex((const BYTE*)gbl.bus_card_info,(BYTE*)bus_card_infoBCD,48);
	}else if (flag == 4)
	{
		bbzero(inqdata);
		bbzero(bus_old_amo);
		bbzero(bus_pay_amo);
		bbzero(bus_yj_amo);
		inqLen = 0;
		inqdata[inqLen++] = (char)0xAB;//充值记录
		CTools::hex_to_byte((BYTE *) gbl.bus_card,(BYTE *)inqdata+inqLen,8);
		inqLen += 4;
		memset(inqdata+inqLen, 0, 4);//卡应用号
		inqLen += 4;
		if (gbl.bus_selltype == 0)
		{
			inqdata[inqLen++] = 0x42;//卡类型
		}else
			inqdata[inqLen++] = 0x41;//卡类型
		inqdata[inqLen++] = 0x01;//充值类型
		//		CTools::hex_to_byte((const BYTE *)gbl.bus_old_amo, (BYTE *)inqdata+inqLen, 8);//原有金额
		CTools::bus_money_change(gbl.bus_old_amo,bus_old_amo);
		strcpy(inqdata+inqLen,bus_old_amo);
		inqLen += 4;
		//		CTools::hex_to_byte((const BYTE *)gbl.bus_pay_amo, (BYTE *)inqdata+inqLen, 8);//充值金额
		CTools::bus_money_change(gbl.bus_pay_amo,bus_pay_amo);
		strcpy(inqdata+inqLen,bus_pay_amo);
		inqLen += 4;
		bbzero(bus_old_amo_buff);
		bbzero(bus_pay_amo_buff);
		bbzero(gbl.bus_new_amo);
		bbzero(bus_new_amo);
		CTools::sixten_toten(gbl.bus_old_amo,bus_old_amo_buff);
		CTools::sixten_toten(gbl.bus_pay_amo,bus_pay_amo_buff);
		sprintf(gbl.bus_new_amo,"%08X",atoi(bus_old_amo_buff)+atoi(bus_pay_amo_buff));
		//		CTools::hex_to_byte((const BYTE *)gbl.bus_old_amo, (BYTE *)inqdata+inqLen, 8);//现有金额
		CTools::bus_money_change(gbl.bus_new_amo,bus_new_amo);
		strcpy(inqdata+inqLen,bus_new_amo);
		inqLen += 4;
		//		CTools::hex_to_byte((const BYTE *)gbl.bus_yj_amo, (BYTE *)inqdata+inqLen, 8);//押金
		CTools::bus_money_change(gbl.bus_yj_amo,bus_yj_amo);
		strcpy(inqdata+inqLen,bus_yj_amo);
		inqLen += 4;
		CTools::hex_to_byte((const BYTE *)"00000000", (BYTE *)inqdata+inqLen, 8);//实收金额
		inqLen += 4;
		CTools::hex_to_byte((const BYTE *)"000000", (BYTE *)inqdata+inqLen, 6);//钱包值
		inqLen += 3;
		CTools::hex_to_byte((const BYTE *)gbl.bus_date+2, (BYTE *)inqdata+inqLen, 6);//时间
		inqLen += 3;
		CTools::hex_to_byte((const BYTE *)gbl.bus_time, (BYTE *)inqdata+inqLen, 6);//日期
		inqLen += 3;
		inqdata[inqLen++] = 0x01;//充值情况标志
		CTools::hex_to_byte((const BYTE *)"00000000", (BYTE *)inqdata+inqLen, 8);//交易认证码
		inqLen += 4;
		inqdata[inqLen++] = 0x00;//商户代码
		inqdata[inqLen++] = 0x00;//交易结果
		inqdata[inqLen++] = 0x00;//记录MAC验证码
		CTools::byte_to_hex((const BYTE*)inqdata,(BYTE*)bus_card_infoBCD,inqLen);	
	}else
	{
		bbzero(inqdata);
		bbzero(bus_old_amo);
		bbzero(bus_pay_amo);
		bbzero(bus_yj_amo);
		inqLen = 0;
		inqdata[inqLen++] = (char)0xAB;//充值记录
		//memcpy(inqdata+inqLen, gbl.bus_card, 4);
		CTools::hex_to_byte((BYTE *)gbl.bus_card,(BYTE *)inqdata+inqLen,8);
		inqLen += 4;
		memset(inqdata+inqLen, 0, 4);//卡应用号
		inqLen += 4;
		if (gbl.bus_selltype == 0)
		{
			inqdata[inqLen++] = 0x42;//卡类型
		}else
			inqdata[inqLen++] = 0x41;//卡类型
		inqdata[inqLen++] = 0x01;//充值类型
		//		CTools::hex_to_byte((const BYTE *)gbl.bus_old_amo, (BYTE *)inqdata+inqLen, 8);//原有金额
		CTools::bus_money_change(gbl.bus_old_amo,bus_old_amo);
		strcpy(inqdata+inqLen,bus_old_amo);
		inqLen += 4;
		//		CTools::hex_to_byte((const BYTE *)gbl.bus_pay_amo, (BYTE *)inqdata+inqLen, 8);//充值金额
		CTools::bus_money_change(gbl.bus_pay_amo,bus_pay_amo);
		strcpy(inqdata+inqLen,bus_pay_amo);
		inqLen += 4;
		//		CTools::hex_to_byte((const BYTE *)gbl.bus_old_amo, (BYTE *)inqdata+inqLen, 8);//现有金额
		CTools::bus_money_change(gbl.bus_old_amo,bus_old_amo);
		strcpy(inqdata+inqLen,bus_old_amo);
		inqLen += 4;
		//		CTools::hex_to_byte((const BYTE *)gbl.bus_yj_amo, (BYTE *)inqdata+inqLen, 8);//押金
		CTools::bus_money_change(gbl.bus_yj_amo,bus_yj_amo);
		strcpy(inqdata+inqLen,bus_yj_amo);
		inqLen += 4;
		CTools::hex_to_byte((const BYTE *)"00000000", (BYTE *)inqdata+inqLen, 8);//实收金额
		inqLen += 4;
		CTools::hex_to_byte((const BYTE *)"000000", (BYTE *)inqdata+inqLen, 6);//钱包值
		inqLen += 3;
		CTools::hex_to_byte((const BYTE *)gbl.bus_date+2, (BYTE *)inqdata+inqLen, 6);//时间
		inqLen += 3;
		CTools::hex_to_byte((const BYTE *)gbl.bus_time, (BYTE *)inqdata+inqLen, 6);//日期
		inqLen += 3;
		inqdata[inqLen++] = 0x01;//充值情况标志
		CTools::hex_to_byte((const BYTE *)"00000000", (BYTE *)inqdata+inqLen, 8);//交易认证码
		inqLen += 4;
		inqdata[inqLen++] = 0x00;//商户代码
		CTools::hex_to_byte((const BYTE *)gbl.bus_failcode, (BYTE *)inqdata+inqLen, 2);//错误代码
		//		inqdata[inqLen++] = 0x01;
		inqdata[inqLen++] = 0x00;//记录MAC验证码
		CTools::byte_to_hex((const BYTE*)inqdata,(BYTE*)bus_card_infoBCD,inqLen);		
	}
	
	j=0;
	for (j=0;j<3;j++)
	{
		/***********************************************************/
		length = 0;
		strncat(temp_buff,"7E7E7E00",8);
		length += 8;
		strncat(temp_buff,gbl.pos_no+2,6);
		length += 6;
		strncat(temp_buff,"8006",4);
		length += 4;
		strncat(temp_buff,&(bus_key.bus_charge_key[0]),2);
		length += 2;
		strncat(temp_buff,&(bus_key.bus_charge_key[4]),2);
		length += 2;
		strncat(temp_buff,&(bus_key.bus_charge_key[2]),2);
		length += 2;
		strncat(temp_buff,"36",2);
		length += 2;
		strncat(temp_buff,gbl.bus_enq_stan,12);
		length += 12;
		strncat(temp_buff,"0032",4);
		length += 4;
		strncat(temp_buff,bus_card_infoBCD,96);
		length += 96;
		
		length = CTools::hex_to_byte((const BYTE *)temp_buff,(BYTE *)check_buff,length);
		CTools::crc_cu_16((BYTE *)check_buff,length);
		bbzero(temp_buff);
		CTools::byte_to_hex((const BYTE *)check_buff,(BYTE *)temp_buff,length+2);
		
		for (i=1;i<MAX_BUS_ORDER;i++)
		{
			if (bus_order[i].flag == 0)
			{
				bus_order[i].flag = 1;
				break;
			}
		}
		if (i == MAX_BUS_ORDER)
		{
			wrLog("公交交易内存满");
			return -1;
		}
		bbzero(bus_order[i].data);
		strcpy(bus_order[i].data,temp_buff);
		bbzero(bus_order[i].stan);
		strcpy(bus_order[i].stan,gbl.bus_enq_stan);
		bus_order[i].data_len = 2*(length+2);
		time(&(bus_order[i].inTime));
		wrLog("公交交易：【内存编号：%d】【STAN：%s】【DATA[%d]：%s】",i,gbl.bus_enq_stan,2*(length+2),temp_buff);
		/***********************************************************/
		while (1)
		{
			if (bus_order[i].flag == 1 ||bus_order[i].flag == 2)
			{
				Sleep(100*5);
			}else if (bus_order[i].flag == 0)
			{
				break;
			}else if (bus_order[i].flag == 3)
			{
				bbzero(respond_code);
				memcpy(respond_code,bus_order[i].data+42,4);
				wrLog("充值确认返回码【%s】",respond_code);
				if (memcmp(respond_code,"9000",4)==0)
				{
					wrLog("充值确认成功");
					if (flag ==1)
					{
						wrLog("公交卡号：%s  状态值为：5   状态：充值失败已完全确认",gbl.bus_card);
						CDB::update_DGBus_Txn(gbl,"5");
					}else if(flag == 0 || flag == 4)
					{
						wrLog("公交卡号：%s  状态值为：2   状态：充成功已完全确认",gbl.bus_card);
						CDB::update_DGBus_Txn(gbl,"2");

					}else
					{
						wrLog("公交卡号：%s  状态值为：10   状态：冲正失败已完全确认",gbl.bus_card);
						CDB::update_DGBus_Txn(gbl,"10");
					}
					bus_order[i].flag = 0;
					bus_order[i].data_len = 0;
					bbzero(bus_order[i].data);
					bbzero(bus_order[i].stan);
					return 0;
				}else
				{
					wrLog("充值确认失败%d",j);
					break;
				}				
			}else{ 
				break;
			}
		}		
	}
	return -2;
}


/*************************************************************/
//查看是否有未结束交易
/*************************************************************/
int CTrade::busNotEndHdl(const char *type)
{
	char status[2+1],rcvData[256];
	char ic_bus_card[8+1], ic_bus_old_amo[8+1], ic_bus_pay_amo[8+1],ic_bus_new_amo[8+1], ic_bus_date[6+1], ic_bus_time[6+1], ic_amo_tem[4+1];
	char tmp_buf[200];
	char trade_yn_flag[2+1];
	int i=0,ret=0,rcvLen=0,iSelect;
	char dkq_PSAM[16+1],dkq_code[4+1];
	char card_txn[48+1];
	char ic_bus_old_amo_temp[8+1];
	char ic_bus_pay_amo_temp[8+1];
	char ic_bus_new_amo_temp[8+1];
	char bus_date[8+1]; 
	char bus_time[6+1];
	bbzero(bus_date);
	bbzero(bus_time);
	bbzero(ic_bus_new_amo_temp);
	bbzero(ic_bus_old_amo_temp);
	bbzero(ic_bus_pay_amo_temp);
	bbzero(status);
	bbzero(card_txn);
	bbzero(gbl.bus_failcode);
	bbzero(ic_bus_new_amo);
	if(CDB::get_DGBus_Txn_NotEnd(gbl,status)==0)
	{

		//有未确认交易
		wrLog("【存在未结束交易】busNotEndHdl");
		wrLog("status[%s]",status);
		wrLog("不完整交易公交卡号:%s",gbl.car_no);
		wrLog("不完整交易日期:%s",gbl.bus_date);
		wrLog("不完整交易的时间:%s",gbl.bus_time);

		//检查是否存在交易记录，如果有交易记录，则进行
		if( memcmp(gbl.bus_card_info,"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00",48) )
		{
			bbzero(gbl.pos_serial);
			CTools::get_time(gbl.pos_serial); 
			wrHex("bus_card_info", (BYTE *)gbl.bus_card_info, 48);
		}
		else //如果数据库中不存在交易记录，读取卡最后一笔交易
		{
			//取最后一笔交易
			if(gbl.HID_TYPE==1)
			{
				if( busSndRcvHID_IcData(type, (const BYTE *)"\xC2\xA7", 2, (BYTE *)rcvData, rcvLen, gbl.pos_serial) )
				{
					return -1;
				}
				if ((unsigned char)(rcvData[0]) != 0x00)
				{
					returnBusFail(rcvData[1]);
				}
				
				
				//解析最后一笔交易
				memcmp(card_txn,rcvData+2,48);
				wrHex("最后一笔交易记录",(BYTE *)card_txn,48);
				bbzero(dkq_PSAM);
				bbzero(dkq_code);
				bbzero(trade_yn_flag);
				memcpy(dkq_code,rcvData+48+2,4);  //机具编号
			
				bbzero(ic_bus_card);
				CTools::byte_to_hex((const BYTE *)rcvData+2+1,(BYTE *)ic_bus_card,4); 	//取公交卡号
				CTools::byte_to_hex((const BYTE *)rcvData+52+2, (BYTE *)dkq_PSAM, 8); //psam卡号
				CTools::byte_to_hex((const BYTE *)rcvData+60+2, (BYTE *)trade_yn_flag, 1); //最后一笔交易状态
				//充值时间及充值日期
				bbzero(bus_date);
				bbzero(bus_time);

				CTools::byte_to_hex((const BYTE *)rcvData+34+2,(BYTE *)bus_date,3);
				CTools::byte_to_hex((const BYTE *) rcvData+37+2,(BYTE *)bus_time,3);

				wrLog("【解析读卡器最近一笔交易查询返回报文\n原PSAM：%s】【现PSAM：%s】【交易状态：%s】",gbl.dkq_PSAM,dkq_PSAM,trade_yn_flag);	
				wrHex("[原机具编号：%s\n] ",(BYTE *)gbl.dkq_code,strlen(gbl.dkq_code));
				wrHex("[现机具编号:%s\n]",(BYTE *)dkq_code,strlen(dkq_code));
				wrLog("公交卡号:%s",ic_bus_card);
				wrLog("充值日期:%s",bus_date);
				wrLog("充值时间:%s",bus_time);
				
				
				if ( memcmp(gbl.bus_card,ic_bus_card,8) ==0 && memcmp(gbl.bus_date+2,bus_date,6) ==0 && memcmp(gbl.bus_time,bus_time,6) ==0 ) //如果这张卡不是在这个终端这个时间进行的交易，不予处理，暂时不通过机具编号和psam。默认这笔交易状态为成功。暂时不判断PSAM卡号机机具编号是否一致
				{
			
					bbzero(gbl.bus_card_info);
					memcpy(gbl.bus_card_info, rcvData+2, 48);
					wrHex("new bus_card_info", (BYTE *)gbl.bus_card_info, 48);
				}
				else
				{

					if(atoi(status)==0)
					{
						wrLog("交易结果不明确");
						CDB::update_DGBus_Txn(gbl,"11");
						bbzero(tmp_buf);
						sprintf(tmp_buf,"您有一笔公交充值交易结果不明确，系统参考号为：%s,请留意IPOS账户余额变化",gbl.stan_no);
						TS_OutPutMsg(gbl.dPosInfo,tmp_buf,0,iSelect);
						return 0;
						
					}
					else
					{
						TS_OutPutMsg(gbl.dPosInfo, "有未确认交易，请勿更新读卡器", 0, iSelect);
						return -1;
					}

				}
				
			}

			else  //如果是串口读卡器
			{
 				if( busSndRcvIcData(type, (const BYTE *)"\x0C\x01\x00\x02\xA7\x00\xA8", 7, (BYTE *)rcvData, rcvLen, gbl.pos_serial) ) 
				{
					return -1;
				}
				if ((unsigned char)(rcvData[4]) == 0xA1)
				{
					returnBusFail(rcvData[5]);
				}
			
		
				bbzero(dkq_PSAM);
				bbzero(dkq_code);
				bbzero(trade_yn_flag);
				memcpy(dkq_code,rcvData+54,4);
				//取公交卡号及其交易时间
				
				bbzero(ic_bus_card);
				bbzero(bus_time);
				bbzero(bus_date);
				CTools::byte_to_hex((const BYTE *)rcvData+7, (BYTE *)ic_bus_card, 4);
				CTools::byte_to_hex((const BYTE *)rcvData+40, (BYTE *)bus_date, 3);
				CTools::byte_to_hex((const BYTE *)rcvData+43, (BYTE *)bus_time, 3);

				CTools::byte_to_hex((const BYTE *)rcvData+58, (BYTE *)dkq_PSAM, 8);
				CTools::byte_to_hex((const BYTE *)rcvData+66, (BYTE *)trade_yn_flag, 1);

				wrLog("【解析读卡器最近一笔交易\n原机具号：%s】【原PSAM：%s】【 现机具号：%s】【现PSAM：%s】【交易状态：%s】",gbl.dkq_code,gbl.dkq_PSAM,dkq_code,dkq_PSAM,trade_yn_flag);		
				wrLog("公交卡号:%s",ic_bus_card);
				wrLog("充值日期:%s",bus_date);
				wrLog("充值时间:%s",bus_time);

				if (memcmp(gbl.bus_card,ic_bus_card,8)==0 && memcmp(gbl.bus_date+2,bus_date,6)==0 && memcmp(gbl.bus_time,bus_time,6)==0) //如果上次充值不是在这台机器上面进行的。不完整交易不予处理。暂时不考虑机具编号和psam卡号是否一致
				{
				
				
					bbzero(gbl.bus_card_info);
					memcpy(gbl.bus_card_info, rcvData+6, 48);
					wrHex("new bus_card_info", (BYTE *)gbl.bus_card_info, 48);
				
				}
				else
				{
				
					if(atoi(status)==0)
					{
				
						wrLog("交易结果不明确");
						CDB::update_DGBus_Txn(gbl,"11");
						bbzero(tmp_buf);
						sprintf(tmp_buf,"您有一笔公交充值交易结果不明确，系统参考号为：%s,请留意IPOS账户余额变化",gbl.stan_no);
						TS_OutPutMsg(gbl.dPosInfo,tmp_buf,0,iSelect);
						return 0;
						
					}
					else
					{
						TS_OutPutMsg(gbl.dPosInfo, "您有一笔未确认交易的公交交易,请咨询在线客服或致电400-80-11888", 0, iSelect);
						return -1;
						
					}
				
				}

				
			}

		}


		bbzero(ic_bus_card); 
		CTools::byte_to_hex((const BYTE *)gbl.bus_card_info+1, (BYTE *)ic_bus_card, 4);
		wrLog("ic_bus_card[%s]", (BYTE *)ic_bus_card); //公交卡号
	    CTools::byte_to_hex((const BYTE *) gbl.bus_card_info+40,(BYTE *)trade_yn_flag,1);

		if(gbl.HID_TYPE==1) //如果是新的读卡器
		{
		   CTools::byte_to_hex((const BYTE *)gbl.bus_card_info+11, (BYTE *)ic_bus_old_amo, 4);
		   CTools::byte_to_hex((const BYTE *)gbl.bus_card_info+15, (BYTE *)ic_bus_pay_amo, 4);
		   CTools::byte_to_hex((const BYTE *)gbl.bus_card_info+19, (BYTE *)ic_bus_new_amo, 4);
	
		}
		else
		{

			bbzero(ic_amo_tem);
			ic_amo_tem[3] = (gbl.bus_card_info)[11];
			ic_amo_tem[2] = (gbl.bus_card_info)[12];
			ic_amo_tem[1] = (gbl.bus_card_info)[13];
			ic_amo_tem[0] = (gbl.bus_card_info)[14];
			CTools::byte_to_hex((const BYTE *)ic_amo_tem, (BYTE *)ic_bus_old_amo, 4);

			bbzero(ic_amo_tem);
			ic_amo_tem[3] = (gbl.bus_card_info)[15];
			ic_amo_tem[2] = (gbl.bus_card_info)[16];
			ic_amo_tem[1] = (gbl.bus_card_info)[17];
			ic_amo_tem[0] = (gbl.bus_card_info)[18];
			CTools::byte_to_hex((const BYTE *)ic_amo_tem, (BYTE *)ic_bus_pay_amo, 4);

			bbzero(ic_amo_tem);
			ic_amo_tem[3] = (gbl.bus_card_info)[19];
			ic_amo_tem[2] = (gbl.bus_card_info)[20];
			ic_amo_tem[1] = (gbl.bus_card_info)[21];
			ic_amo_tem[0] = (gbl.bus_card_info)[22];
			CTools::byte_to_hex((const BYTE *)ic_amo_tem, (BYTE *)gbl.bus_new_amo, 4); 
			CTools::byte_to_hex((const BYTE *)ic_amo_tem, (BYTE *)ic_bus_new_amo, 4);



		}


	
		wrLog("ic_bus_old_amo[%s]", (BYTE *)ic_bus_old_amo); //原有金额
		CTools::sixten_toten(ic_bus_old_amo,ic_bus_old_amo_temp);
		wrLog("原有金额:%.2f",atof(ic_bus_old_amo_temp)/100);

		wrLog("ic_bus_pay_amo[%s]", (BYTE *)ic_bus_pay_amo); //本次充值金额
		CTools::sixten_toten(ic_bus_pay_amo,ic_bus_pay_amo_temp);
		wrLog("本次充值金额:%.2f",atof(ic_bus_pay_amo_temp)/100);
	
		wrLog("ic_bus_new_amo[%s]", (BYTE *)ic_bus_new_amo); //当前余额
		CTools::sixten_toten(ic_bus_new_amo,ic_bus_new_amo_temp);
		wrLog("当前余额:%.2f",atof(ic_bus_new_amo_temp)/100);
		
		CTools::byte_to_hex((const BYTE *)(gbl.bus_card_info)+34, (BYTE *)ic_bus_date, 3);
		wrLog("ic_bus_date[%s]", (BYTE *)ic_bus_date); //充值日期
		
		CTools::byte_to_hex((const BYTE *)(gbl.bus_card_info)+37, (BYTE *)ic_bus_time, 3);
		wrLog("ic_bus_time[%s]", (BYTE *)ic_bus_time); //充值时间
		wrLog("trade_yn_flag:%s",trade_yn_flag);

		if (memcmp(trade_yn_flag,"01",2)==0) //交易失败的流程需要优化
		{

			ret=busRevHdl(type);
			if(ret!=0){//如果充正不成功则保留状态
				if(ret==1){
					wrLog("公交卡号：%s  状态值为：6   状态：充值失败冲正失败",gbl.bus_card);
					CDB::update_DGBus_Txn(gbl,"6");//隔天冲正，只有手工对帐后退费
					ret=busConHdl(type,1);
				}else{
					wrLog("公交卡号：%s  状态值为：3   状态：充值失败未冲正",gbl.bus_card);
					CDB::update_DGBus_Txn(gbl,"3");
					sprintf(tmp_buf, "上次充值失败且冲正失败，请与商服核实是否有冲正次数\n请联系在线客服中心【Ctrl+H】  400-80-11888，参考号\n%s", gbl.stan_no);
					CDB::update_epos_term(gbl.pos_no,"1"); //设置状态为正常
					TS_OutPutMsg(gbl.dPosInfo, tmp_buf, 1, iSelect);
				}				
			}else{
				if (atoi(status) == 7)
				{
					ret=busbusConHdl(type,1);
					if(ret!=0){//如果确认不成功则保留状态
						sprintf(tmp_buf, "上次充值失败\n充值返回信息提交失败\n请联系在线客服中心【Ctrl+H】  400-80-11888，参考号\n%s", gbl.stan_no);
						TS_OutPutMsg(gbl.dPosInfo, tmp_buf, 1, iSelect);
						wrLog("公交卡号：%s  状态值为：7   状态：充值失败未确认",gbl.bus_card);
						CDB::update_DGBus_Txn(gbl,"7");
						CDB::update_epos_term(gbl.pos_no,"1"); //设置状态为正常
					}else{
						wrLog("公交卡号：%s  状态值为：5   状态：充值失败已确认",gbl.bus_card);
						CDB::update_DGBus_Txn(gbl,"5");
						CDB::update_epos_term(gbl.pos_no,"1"); //设置状态为正常
						TS_OutPutMsg(gbl.dPosInfo, "上次充值失败\n", 1, iSelect);
					}
				}else{
					ret=busConHdl(type,1);
					if(ret==2){//如果确认不成功则保留状态
						sprintf(tmp_buf, "上次充值失败\n充值返回信息提交失败\n请联系在线客服中心【Ctrl+H】  400-80-11888，参考号\n%s", gbl.stan_no);
						TS_OutPutMsg(gbl.dPosInfo, tmp_buf, 1, iSelect);
						wrLog("公交卡号：%s  状态值为：7  状态：充值失败未确认",gbl.bus_card);
						CDB::update_DGBus_Txn(gbl,"7");
						CDB::update_epos_term(gbl.pos_no,"1"); //设置状态为正常
					}else if(ret<0){//如果确认不成功则保留状态
						sprintf(tmp_buf, "上次充值失败\n充值返回信息提交失败\n请联系在线客服中心【Ctrl+H】  400-80-11888，参考号\n%s", gbl.stan_no);
						TS_OutPutMsg(gbl.dPosInfo, tmp_buf, 1, iSelect);
						wrLog("公交卡号：%s  状态值为：4   状态：充值失败未确认",gbl.bus_card);
						CDB::update_DGBus_Txn(gbl,"4");
						CDB::update_epos_term(gbl.pos_no,"1"); //设置状态为正常
					}else{
						wrLog("公交卡号：%s  状态值为：5   状态：充值失败已确认",gbl.bus_card);
						CDB::update_DGBus_Txn(gbl,"5");
						CDB::update_epos_term(gbl.pos_no,"1"); //设置状态为正常
						TS_OutPutMsg(gbl.dPosInfo, "上次充值失败\n", 1, iSelect);
					}
				}
				
			}
		}

		//返回状态为00 且充值后余额等于充值前余额+充值余额
		
		else if( (gbl.bus_card_info)[40]==0x00 && !memcmp(gbl.bus_card, ic_bus_card, 8) && (atof(ic_bus_new_amo_temp)==atof(ic_bus_old_amo_temp)+atof(ic_bus_pay_amo_temp))) 
		{//如果充值成功


			TS_OutPutMsg(gbl.dPosInfo,"上笔交易成功，请按确认继续交易",1,iSelect);

			if (atoi(status) == 8)
			{
				ret=busbusConHdl(type);
				if(ret!=0){//如果确认不成功则保留状态
					wrLog("公交卡号：%s  状态值为：8   状态：充值成功PE已确认",gbl.bus_card);
					CDB::update_DGBus_Txn(gbl,"8");
					CDB::update_epos_term(gbl.pos_no,"1"); //设置状态为正常
					return ret;
				}else{
					wrLog("公交卡号：%s  状态值为：2   状态：充值成功已完全确认",gbl.bus_card);
					CDB::update_DGBus_Txn(gbl,"2");	
					CDB::update_epos_term(gbl.pos_no,"1"); //设置状态为正常
				}
			}else{
				ret=busConHdl(type);
				if(ret==2){//如果确认不成功则保留状态
					wrLog("公交卡号：%s  状态值为：8   状态：充值成功PE已确认",gbl.bus_card);
					CDB::update_DGBus_Txn(gbl,"8");
					CDB::update_epos_term(gbl.pos_no,"1"); //设置状态为正常
					return ret;
				}else if(ret!=0){//如果确认不成功则保留状态
					wrLog("公交卡号：%s  状态值为：1   状态：充值成功未确认",gbl.bus_card);
					CDB::update_DGBus_Txn(gbl,"1");
					CDB::update_epos_term(gbl.pos_no,"1"); //设置状态为正常
					return ret;
				}else{
					wrLog("公交卡号：%s  状态值为：2   状态：充值成功已完全确认",gbl.bus_card);
					CDB::update_DGBus_Txn(gbl,"2");		
					CDB::update_epos_term(gbl.pos_no,"1"); //设置状态为正常
					
				}
			}
			
			if(!strcmp(gbl.fee_type,"0214")){//如果是发卡					
				TS_OutPutMsg(gbl.dPosInfo, "      开卡成功\n请检查打印机电源及打印线路是否正常,有问题请即与22386220联系\n按【确认】打印发票\n\n【注意】尊敬的公交商户：因东莞公交经营主体变更，原汇通公交业务将于2014年停止服务。\n改换新的东莞通公交业务、所有设备更换及押金退还事宜请尽快加QQ：2083267158或拔打23360000咨询", 1, iSelect);
				CPrint prt;
				prt.set_in_par(gbl);
				prt.print_bus_detail(gbl.bus_card_info,1);					
			}
			/*else
			{
			if(TS_OutPutMsg(gbl.dPosInfo, "      充值成功\n请检查打印机电源及打印线路是否正常,有问题请即与22386220联系\n按【确认】打印发票", 1, iSelect)==SUCC){
			CPrint prt;
			prt.set_in_par(gbl);
			prt.print_bus_detail(gbl.bus_card_info,2);
			}
		}*/
		}else
		{
			if ((atoi(status)!=3)&&(atoi(status)!=0))
			{
				if (atoi(status) == 6)
				{
					busConHdl(type,2);
				}else if (atoi(status) == 9)
				{
					busbusConHdl(type,2);
				}else if (atoi(status) == 7)
				{
					ret=busbusConHdl(type,1);
					if(ret!=0){//如果确认不成功则保留状态
						sprintf(tmp_buf, "上次充值失败\n充值返回信息提交失败\n请联系在线客服中心【Ctrl+H】  400-80-11888，参考号\n%s", gbl.stan_no);
						TS_OutPutMsg(gbl.dPosInfo, tmp_buf, 1, iSelect);
						wrLog("公交卡号：%s  状态值为：7   状态：充值失败未确认",gbl.bus_card);
						CDB::update_DGBus_Txn(gbl,"7");
						CDB::update_epos_term(gbl.pos_no,"1"); //设置状态为正常
					}else{
						wrLog("公交卡号：%s  状态值为：5   状态：充值失败已确认",gbl.bus_card);
						CDB::update_DGBus_Txn(gbl,"5");
						CDB::update_epos_term(gbl.pos_no,"1"); //设置状态为正常
						TS_OutPutMsg(gbl.dPosInfo, "上次充值失败\n", 1, iSelect);
					}
				}else{
					ret=busConHdl(type,1);
					if(ret==2){//如果确认不成功则保留状态
						sprintf(tmp_buf, "上次充值失败\n充值返回信息提交失败\n请联系在线客服中心【Ctrl+H】  400-80-11888，参考号\n%s", gbl.stan_no);
						TS_OutPutMsg(gbl.dPosInfo, tmp_buf, 1, iSelect);
						wrLog("公交卡号：%s  状态值为：7  状态：充值失败未确认",gbl.bus_card);
						CDB::update_DGBus_Txn(gbl,"7");
						CDB::update_epos_term(gbl.pos_no,"1"); //设置状态为正常
					}else if(ret<0){//如果确认不成功则保留状态
						sprintf(tmp_buf, "上次充值失败\n充值返回信息提交失败\n请联系在线客服中心【Ctrl+H】  400-80-11888，参考号\n%s", gbl.stan_no);
						TS_OutPutMsg(gbl.dPosInfo, tmp_buf, 1, iSelect);
						wrLog("公交卡号：%s  状态值为：4   状态：充值失败未确认",gbl.bus_card);
						CDB::update_DGBus_Txn(gbl,"4");
						CDB::update_epos_term(gbl.pos_no,"1"); //设置状态为正常
					}else{
						wrLog("公交卡号：%s  状态值为：5   状态：充值失败已确认",gbl.bus_card);
						CDB::update_DGBus_Txn(gbl,"5");
						CDB::update_epos_term(gbl.pos_no,"1"); //设置状态为正常
						TS_OutPutMsg(gbl.dPosInfo, "上次充值失败\n", 1, iSelect);
					}
				}
			}else
			{
				ret=busRevHdl(type);
				if(ret!=0){//如果充正不成功则保留状态
					if(ret==1){
						wrLog("公交卡号：%s  状态值为：6   状态：充值失败冲正失败",gbl.bus_card);
						CDB::update_DGBus_Txn(gbl,"6");//隔天冲正，只有手工对帐后退费
						ret=busConHdl(type,1);
					}else{
						wrLog("公交卡号：%s  状态值为：3   状态：充值失败未冲正",gbl.bus_card);
						CDB::update_DGBus_Txn(gbl,"3");
						sprintf(tmp_buf, "上次充值失败且冲正失败，请与商服核实是否有冲正次数\n请联系在线客服中心【Ctrl+H】  400-80-11888，参考号\n%s", gbl.stan_no);
						CDB::update_epos_term(gbl.pos_no,"1"); //设置状态为正常
						TS_OutPutMsg(gbl.dPosInfo, tmp_buf, 1, iSelect);
					}				
				}else{
					if (atoi(status) == 7)
					{
						ret=busbusConHdl(type,1);
						if(ret!=0){//如果确认不成功则保留状态
							sprintf(tmp_buf, "上次充值失败\n充值返回信息提交失败\n请联系在线客服中心【Ctrl+H】  400-80-11888，参考号\n%s", gbl.stan_no);
							TS_OutPutMsg(gbl.dPosInfo, tmp_buf, 1, iSelect);
							wrLog("公交卡号：%s  状态值为：7   状态：充值失败未确认",gbl.bus_card);
							CDB::update_DGBus_Txn(gbl,"7");
							CDB::update_epos_term(gbl.pos_no,"1"); //设置状态为正常
						}else{
							wrLog("公交卡号：%s  状态值为：5   状态：充值失败已确认",gbl.bus_card);
							CDB::update_DGBus_Txn(gbl,"5");
							CDB::update_epos_term(gbl.pos_no,"1"); //设置状态为正常
							TS_OutPutMsg(gbl.dPosInfo, "上次充值失败\n", 1, iSelect);
						}
					}else{
						ret=busConHdl(type,1);
						if(ret==2){//如果确认不成功则保留状态
							sprintf(tmp_buf, "上次充值失败\n充值返回信息提交失败\n请联系在线客服中心【Ctrl+H】  400-80-11888，参考号\n%s", gbl.stan_no);
							TS_OutPutMsg(gbl.dPosInfo, tmp_buf, 1, iSelect);
							wrLog("公交卡号：%s  状态值为：7  状态：充值失败未确认",gbl.bus_card);
							CDB::update_DGBus_Txn(gbl,"7");
							CDB::update_epos_term(gbl.pos_no,"1"); //设置状态为正常
						}else if(ret<0){//如果确认不成功则保留状态
							sprintf(tmp_buf, "上次充值失败\n充值返回信息提交失败\n请联系在线客服中心【Ctrl+H】  400-80-11888，参考号\n%s", gbl.stan_no);
							TS_OutPutMsg(gbl.dPosInfo, tmp_buf, 1, iSelect);
							wrLog("公交卡号：%s  状态值为：4   状态：充值失败未确认",gbl.bus_card);
							CDB::update_DGBus_Txn(gbl,"4");
							CDB::update_epos_term(gbl.pos_no,"1"); //设置状态为正常
						}else{
							wrLog("公交卡号：%s  状态值为：5   状态：充值失败已确认",gbl.bus_card);
							CDB::update_DGBus_Txn(gbl,"5");
							CDB::update_epos_term(gbl.pos_no,"1"); //设置状态为正常
							TS_OutPutMsg(gbl.dPosInfo, "上次充值失败\n", 1, iSelect);
						}
					}
				}
			}
		}			
	}		
	return ret;
}


void CTrade::returnBusFail(char stat)
{
	int iSelect;
	unsigned int return_failcode = stat;
	switch(return_failcode)
	{
	case 0x10:
	case 0x11:
	case 0x12:
	case 0x13:
	case 0x14:
	case 0x15:
	case 0x16:
	case 0x17:
	case 0x18:
	case 0x19:
	case 0x20:
		TS_OutPutMsg(gbl.dPosInfo, " \n     内部错误!\n  请关闭电源重新启动!", 1, iSelect);
		break;
	case 0x31:
	case 0x32:
	case 0x33:
	case 0x34:
	case 0x35:
	case 0x36:
	case 0x37:
	case 0x38:
	case 0x39:
	case 0x3A:
	case 0x3B:
	case 0x3C:
	case 0x85:
	case 0x8B:
	case 0x8C:
		TS_OutPutMsg(gbl.dPosInfo, " \n  操作出错，请重新操作!", 1, iSelect);
		break;
	case 0x41:
	case 0x42:
	case 0x43:
	case 0x44:
	case 0x45:
	case 0x46:
	case 0x47:
	case 0x48:
	case 0x49:
	case 0x4A:
	case 0x4B:
	case 0x4C:
	case 0x4D:
	case 0x4E:
	case 0x77:
	case 0x7A:
	case 0x7B:
	case 0x7C:
	case 0x7D:
	case 0x82:
	case 0x83:
	case 0x84:
	case 0x88:
		TS_OutPutMsg(gbl.dPosInfo, " \n  读卡出错，请放好卡!", 1, iSelect);
		break;
	case 0x6A:
		TS_OutPutMsg(gbl.dPosInfo, " \n    启用标志不正确!", 1, iSelect);
		break;
	case 0x6B:
		TS_OutPutMsg(gbl.dPosInfo, " \n     发行区错误!", 1, iSelect);
		break;
	case 0x6C:
		TS_OutPutMsg(gbl.dPosInfo, " \n     城市代码无效!", 1, iSelect);
		break;
	case 0x6D:
		TS_OutPutMsg(gbl.dPosInfo, " \n     学校代码无效!", 1, iSelect);
		break;
	case 0x6E:
		TS_OutPutMsg(gbl.dPosInfo, " \n超过当前天最大的消费次数!", 1, iSelect);
		break;
	case 0x6F:
		TS_OutPutMsg(gbl.dPosInfo, " \n    空间满，不能收费!", 1, iSelect);
		break;
	case 0x70:
		TS_OutPutMsg(gbl.dPosInfo, " \n    操作出错，请重新操作!", 1, iSelect);
		break;
	case 0x71:
	case 0x72:
	case 0x74:
	case 0x7E:
	case 0x7F:
	case 0x81:
		TS_OutPutMsg(gbl.dPosInfo, " \n    该卡无效，请换卡!", 1, iSelect);
		break;
	case 0x73:
		TS_OutPutMsg(gbl.dPosInfo, " \n       卡过期!", 1, iSelect);
		break;
	case 0x76:
		TS_OutPutMsg(gbl.dPosInfo, " \n    操作出错，请重新操作!", 1, iSelect);
		break;
	case 0x75:
	case 0x78:
	case 0x79:
	case 0x80:
	case 0x86:
	case 0x87:
		TS_OutPutMsg(gbl.dPosInfo, " \n    非法卡，请换卡!", 1, iSelect);
		break;
	case 0x8D:
	case 0x8E:
		TS_OutPutMsg(gbl.dPosInfo, " \n 交易成功，但发生未知错误!", 1, iSelect);
		break;
	case 0x8F:
		TS_OutPutMsg(gbl.dPosInfo, " \n    非法卡，请换卡!", 1, iSelect);
		break;
	case 0x9B:
		TS_OutPutMsg(gbl.dPosInfo, " \n      票卡被锁!", 1, iSelect);
		break;
	default:
		TS_OutPutMsg(gbl.dPosInfo, " \n      未知错误!", 1, iSelect);
		break;
	}
}

//HID设备错误信息返回码
void CTrade::returnHIDBusFail(char stat)
{
	int iSelect;
	unsigned int return_failcode = stat;
	switch(return_failcode)
	{
	case 0x01:
		TS_OutPutMsg(gbl.dPosInfo, " \n     PSAM卡初始化失败!", 1, iSelect);
		break;
	case 0x02:
		TS_OutPutMsg(gbl.dPosInfo, " \n     无卡!", 1, iSelect);
		break;
	case 0x03:
		TS_OutPutMsg(gbl.dPosInfo, " \n    获取keyA错误", 1, iSelect);
		break;
	case 0x04:
		TS_OutPutMsg(gbl.dPosInfo, " \n    读块错误", 1, iSelect);
		break;
	case 0x05:
		TS_OutPutMsg(gbl.dPosInfo, " \n    写块错误", 1, iSelect);
		break;
	case 0x06:
		TS_OutPutMsg(gbl.dPosInfo, " \n    PSAM错误", 1, iSelect);
		break;
	case 0x07:
		TS_OutPutMsg(gbl.dPosInfo, " \n    认证错误", 1, iSelect);
		break;
	case 0x08:
		TS_OutPutMsg(gbl.dPosInfo, " \n    卡过期", 1, iSelect);
		break;
	case 0x09:
		TS_OutPutMsg(gbl.dPosInfo, " \n    卡未启用", 1, iSelect);
		break;
	case 0x0A:
		TS_OutPutMsg(gbl.dPosInfo, " \n    卡已经停用", 1, iSelect);
		break;
	case 0x0B:
		TS_OutPutMsg(gbl.dPosInfo, " \n    已经退卡", 1, iSelect);
		break;
	case 0x0C:
		TS_OutPutMsg(gbl.dPosInfo, " \n    黑名单卡", 1, iSelect);
		break;
	case 0x0D:
		TS_OutPutMsg(gbl.dPosInfo, " \n    卡号不一致", 1, iSelect);
		break;
	case 0x0E:
		TS_OutPutMsg(gbl.dPosInfo, " \n    卡认证码不一致", 1, iSelect);
		break;
	case 0x0F:
		TS_OutPutMsg(gbl.dPosInfo, " \n    交易类型错", 1, iSelect);
		break;
	case 0x10:
		TS_OutPutMsg(gbl.dPosInfo, " \n    卡结构错误", 1, iSelect);
		break;
	case 0x11:
		TS_OutPutMsg(gbl.dPosInfo, " \n    加值错误", 1, iSelect);
		break;
	case 0x13:
		TS_OutPutMsg(gbl.dPosInfo, " \n    读flash错误", 1, iSelect);
		break;
	case 0x14:
		TS_OutPutMsg(gbl.dPosInfo, " \n    写flash错误", 1, iSelect);
		break;
	default:
		TS_OutPutMsg(gbl.dPosInfo, " \n      未知错误!", 1, iSelect);
		break;
	}
}


//向莞城通读卡器发送和接收数据
int CTrade::busSndRcvIcData(const char *title, const BYTE *downData, const int downLen, BYTE *upData, int &upLen, char * pos_serial)
{
	int ret, iSelect;
	TSIcReaderCommand icCmd;
	
	memset(&icCmd, 0, sizeof(icCmd));
	strcpy(icCmd.acTitle, title);
	icCmd.com = m_com;
	icCmd.comType = m_comType;
	icCmd.uDownLen = downLen;	//下发数据的长度
	memcpy(icCmd.uDownData, downData, downLen);//下发的数据, 与提示串的总长度不得超过 240 字节
	wrHex("下发读卡器数据", icCmd.uDownData, icCmd.uDownLen);
	ret = TS_IcReaderCommand(gbl.dPosInfo, &icCmd);  //下发命令
	if( ret ) //错误，返回出错信息
	{
		upLen = 0;
		wrLog("错误返回值: [%d]", ret);
		if(ret == 7)
			TS_OutPutMsg(gbl.dPosInfo, " \n 与读卡器交互出错!请连接好读卡器", 1, iSelect);
		else
			TS_OutPutMsg(gbl.dPosInfo, " \n 与终端交互出错!请连接好读卡器", 1, iSelect);
		return ret;
	}
	wrHex("读卡器返回数据", icCmd.uUpData, icCmd.uUpLen);
	if( icCmd.uUpLen < 6 ){
		wrLog("读卡器返回数据小于6");
		return 9;
	}
	if( (icCmd.uUpData)[icCmd.uUpLen-1] != xor(icCmd.uUpData, icCmd.uUpLen-1) ) //校验
	{
		wrLog("校验码错误");
		TS_OutPutMsg(gbl.dPosInfo, " \n 与读卡器校验出错!", 1, iSelect);
		return 8;
	}
	memcpy(upData, icCmd.uUpData, icCmd.uUpLen);//上送的数据
	upLen = icCmd.uUpLen;	//上送数据的长度
	
	bbzero( pos_serial );
	CTools::get_time(pos_serial); 
	//strcpy( pos_serial, (char *)icCmd.uTradeID );
	return 0;
}

//向东莞HID读卡器发送和接收数据：
/**************************************************************
参数：
title:标题名称
downData:下传数据域
downLen:下传数据域
upData:上传数据
upLen:上传数据长度
pos_serial:终端流水号

***************************************************************/
int CTrade::busSndRcvHID_IcData(const char *title, const BYTE *downData, const int downLen, BYTE *upData, int &upLen, char * pos_serial)
{
	int ret, iSelect;
	TSHID_IcReaderCommand icCmd;
	memset(&icCmd, 0, sizeof(icCmd));
	strcpy(icCmd.acTitle, title);
	icCmd.uDownLen=downLen+5;
	//打包函数
	CDGBusTrade::Package0203((BYTE *)icCmd.uDownData,(BYTE *)downData,downLen);
	wrHex("下发读卡器数据", icCmd.uDownData, icCmd.uDownLen); //下传读卡器的报文及报文长度
	ret = TS_HID_IcReaderCommand(gbl.dPosInfo, &icCmd);  
	if( ret ) //错误，返回出错信息
	{
		upLen = 0;
		wrLog("错误返回值: [%d]", ret);
		TS_OutPutMsg(gbl.dPosInfo, " \n 与终端交互出错!请连接好读卡器", 1, iSelect);
		return ret;
	}

	wrHex("读卡器返回数据", icCmd.uUpData, icCmd.uUpLen);
	if( icCmd.uUpLen < 6 )
	{
		wrLog("读卡器返回数据小于6");
		return 9;
	}
	//解包函数
	ret=CDGBusTrade::unPackage0203(icCmd.uUpData,upData,&upLen);
	if(ret==-1)
	{
		wrLog("报文有问题");
		return 9;
			
	}
	if(ret==-2)
	{
		wrLog("校验码错误");
		TS_OutPutMsg(gbl.dPosInfo, " \n 与读卡器校验出错!", 1, iSelect);
		return 8;
	}

	bbzero( pos_serial );
	CTools::get_time(pos_serial); 
	return 0;
}


//计算校验码, 0, 一致; 其他, 不符
BYTE CTrade::xor(const BYTE *data, int dataLen)
{
	BYTE c = (BYTE)0x00;
	for(int i=0; i<dataLen; i++)	
		c ^= data[i];
	return c;
}

//com: 使用串口
//comType:串口类型
int CTrade::getComPar(unsigned char leftType, unsigned char rightType, unsigned char inType, int *com, int *comType)
{
	int flag = 0; //初始化
	//内置串口
	if(inType==5 || inType==8)
	{
		*comType = inType;
		*com  = 0x03;
		flag = 1;
	}
	//左串口
	else if(leftType==5 || leftType==8)
	{
		*comType = leftType;
		*com  = 0x01;
		flag = 1;
	}
	//右串口
	else if(rightType==5 || rightType==8)
	{
		*comType = rightType;
		*com  = 0x02;
		flag = 1;
	}
	if(flag)
		return 0;
	else
		return -1;
}
//////////////////////////////////////////东莞公交///////////////////////////////////////////////////

int CTrade::Credit_Card_Repayments(const char *title)
{
	int iRet,iSelect;
	int iRetB=0;	
	char mark_card[30+1];
	bbzero(mark_card);
	strncpy(mark_card, gbl.card_no, sizeof(mark_card)-1);
	
	iRet = Credit_Card_Repayments_Hdl(title);
	if( gbl.get_card == MNG_ONE_BIND_E || gbl.get_card == MNG_MUL_BIND_E )//还原原先刷的卡
	{
		iRetB = bindcard(mark_card, gbl.card_no, &gbl.card_no_len);
		if(iRetB != 0)
		{
			TS_OutPutMsg(gbl.dPosInfo,"绑定原卡号出错!请挂机重连!",0,iSelect);
			TS_HangUp(gbl.dPosInfo);
			return -1;
		}
	}
	return iRet;
}
int CTrade::Credit_Card_Repayments_Hdl(const char *title)
{
	int  iRet,iSelect,flag,curTry,credit_card_no_len;
	char credit_card_no[30+1];
	char card_info[200],money[20+1],temp[1024],len_buff[2+1];
	
	
	wrLog("【信用款还款业务】【业务代码:%s】",gbl.fee_type);
	
	
	/**************取得信用卡卡号*******************/
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv; 
	for(curTry=0; curTry<MAXTRY; curTry++)
	{
		
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
		
		strcpy(tradeInfoSend.acMainTitle, title);
		tradeInfoSend.uTotalContents = 1;	
		tradeInfoSend.uHasTradeID = 1;
		
		tradeInfoSend.Contents[0].uCount = 1;
		tradeInfoSend.Contents[0].uDesMode = TS_NO_ENC;		//不加密
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
		
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入（或刷卡）要转入的信用卡号：");
		tradeInfoSend.Contents[0].uCommand = TS_MAG_INPUT_CARD;	//刷卡或输卡号
		tradeInfoSend.Contents[0].uMaxLen = 19;
		tradeInfoSend.Contents[0].uMinLen = 6;
		
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		
		if(iRet != 0)
		{
			wrLog("#TS_TradeControl返回错误[%d]", iRet);
			wrMonitorLog(2, 1, iRet, gbl, pack);	//监控日志
			if(iRet == 1)
				return CANCLE_KEY;
			else if (iRet == RE_MNG_CARD)
				continue;				
		}
		
		memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
		strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
		
		//平台测试整改(不记录磁道信息)
		//wrLog("磁道信息tradeInfoRecv[%d]：[%s]", tradeInfoRecv.Contents[0].uMsgLen, tradeInfoRecv.Contents[0].uMsg);
		
		bbzero(card_info);
		if(tradeInfoRecv.Contents[0].uMsgLen != 142)	//手输卡号
			strcpy(card_info, (char *)tradeInfoRecv.Contents[0].uMsg);
		else		//刷卡
			memcpy(card_info, tradeInfoRecv.Contents[0].uMsg, tradeInfoRecv.Contents[0].uMsgLen);
		
		iRet = getCardNum(card_info,2);
		if (iRet == 0)
			break;
	}
	bbzero(credit_card_no);
	strcpy(credit_card_no,gbl.card_no);
	credit_card_no_len = strlen(gbl.card_no);
	
	int input_flag=0;
	while (input_flag == 0)
	{
		/********************输入还款金额****************/
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
		
		strcpy(tradeInfoSend.acMainTitle, title);
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents = 1;
		
		
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入还款金额");	
		tradeInfoSend.Contents[0].uMinLen = 1;		
		tradeInfoSend.Contents[0].uMaxLen = 8;
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_MONEY;	//数字
		tradeInfoSend.Contents[0].uCount = 0;		//输入1次		
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
		
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		if(iRet != 0)
		{
			if(iRet == 1 || iRet ==2)
				wrLog("【信用卡还款】输入金额用户取消或超时");
			else
				wrLog("【信用卡还款】输入金额失败");
			wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
			return -1;
		}
		bbzero(gbl.amount);
		strcpy(gbl.amount, (char *)tradeInfoRecv.Contents[0].uMsg);	//读入金额
		
		if (atoi(gbl.amount)<100)
		{
			TS_OutPutMsg(gbl.dPosInfo,"还款额不得低于1元，按【确认】后请重新输入还款金额",0,iSelect);
			
		}else 
		{
			input_flag = 1;
			break;
		}
	}
	
	
	bbzero(money);
	CTools::chgToMny(gbl.amount,money);
	bbzero(temp);
	sprintf(temp,"信用卡号：\n%s\n还款金额：%s\n提示：招行、广发行、兴业银行和平安银行信用卡还款实时到账，其他行信用卡还款入帐非当日,详情请咨询发卡行！\n      按【确认】继续",credit_card_no,money);
	iRet = TS_OutPutMsg(gbl.dPosInfo,temp,0,iSelect);
	if (iSelect != 0 || iRet != 0)
	{
		return -1;
	}
	
	iRet = TS_OutPutMsg(gbl.dPosInfo,"请按【确认】后，刷用于还款的银行借记卡",0,iSelect);
	if (iSelect != 0 || iRet != 0)
	{
		return -1;
	}
	
	flag = 0;	//重输密码标识
	/********************请求刷卡****************/
	for(curTry=0; curTry<MAXTRY; curTry++)
	{
		if(!flag) 
		{
			iRet = mngCard_Hdl(title, "", 0, 1);//只能刷卡，多次刷卡模式
			if(iRet == CANCLE_KEY)
				return CANCLE_KEY;
			else if(iRet != 0){
				TS_OutPutMsg(gbl.dPosInfo,"读取输入数据错误!\n交易失败!\n按【确认】返回",1,iSelect);
				return -1;
			}
			
			if(!memcmp(gbl.card_no,"8828",4))	//若是付费易卡,走付费易卡刷卡流程（多卡交易）
			{
				memset(gbl.xlt_type, 0, sizeof(gbl.xlt_type));
				memcpy(gbl.xlt_type, "01",2);
				iRet = xltMulCard( title, 0);
				return iRet;
			}
		}
		
		pack.wrField(2, gbl);	//写交费域
		/***********修改一些域信息*********/
		bbzero(pack.FIELD48);
		memcpy(pack.FIELD48, gbl.fee_type,4);
		pack.Packet_Table[48].Real_Length = 4;
		bbzero(len_buff);
		sprintf(len_buff,"%02d",credit_card_no_len);
		memcpy(pack.FIELD48+4, len_buff ,2);
		pack.Packet_Table[48].Real_Length += 2;
		memcpy(pack.FIELD48+6, credit_card_no,credit_card_no_len);
		pack.Packet_Table[48].Real_Length += credit_card_no_len;
		
		/**********************************/
		
		//交费包处理
		iRet = packHdl(2);
		if(iRet < 0)
			return -1;
		
		if (!memcmp(pack.FIELD39,"00",2)) 
		{
			
			iRet = TS_OutPutMsg(gbl.dPosInfo,"\n\n  信用卡还款成功！\n请按【确认】打印凭证",0,iSelect);	
			if (iRet<0 || iSelect == 0)
			{
				CPrint prt;
				prt.set_in_par(gbl);
				iRet = prt.print_credit_payment(credit_card_no);	 //打印明细
			}
			return 0;
		}// end if (!memcmp(pack.FIELD39,"00",2))
		else if(!memcmp(pack.FIELD39,"55",2))
		{
			flag = 1;
			if(reGetPwd( title) == 0) //密码错误，重新输入密码, 2006-10-25
				continue;
			else
				return CANCLE_KEY;
		}	
		else
			returnFail((char *)pack.FIELD39);		
		return -1;
	}// end for(int curTry=0; curTry<MAXTRY; curTry++)
	return -1;
}

int CTrade::eCard_Trans(const char *title,int tag)
{
	int iRet=0, iRetB=0, iSelect=0;	
	char mark_card[30+1];
	bbzero(mark_card);
	strncpy(mark_card, gbl.card_no, sizeof(mark_card)-1);
	
	if(atoi(gbl.dPosInfo.prmVer)>=9000)
	{
		iRet = checkPEPwd_Hdl(title);
		if(iRet!=0)
			if(iRet==CANCLE_KEY)
				return CANCLE_KEY;
			else
			{	
				info("老板密码校验错误\n\n请联系在线客服中心【Ctrl+H】  400-80-11888\n\n按【Enter】确认返回主菜单。");
				return iRet;
				
			}
	}
	
	iRet = eCard_Trans_Hdl(title,tag);
	if( gbl.get_card == MNG_ONE_BIND_E || gbl.get_card == MNG_MUL_BIND_E )//还原原先刷的卡
	{
		iRetB = bindcard(mark_card, gbl.card_no, &gbl.card_no_len);
		if(iRetB != 0)
		{
			TS_OutPutMsg(gbl.dPosInfo,"绑定原卡号出错!请挂机重连!",0,iSelect);
			TS_HangUp(gbl.dPosInfo);
		}
	}
	return iRet;
}

int CTrade::eCard_Trans_Hdl(const char *title,int tag)
{
	int  iRet=0 , flag = 1 ,ecard_in_len, nums=0;
	int  iSelect, mngCard_count = 1;
	char money[20];
	char card_info[200];
	char respone_info[500];
	char temp_buff[512];
	char trasn_pos[8+1],ecard_in[30+1],business_name[60+1];
	
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	bbzero(business_name);
	wrLog("【e卡卡内转账】");
	if(tag==1){
		if(memcmp(gbl.city_no,"0769",4)==0){
			strcpy(gbl.fee_type, "0075");
		}else{
			strcpy(gbl.fee_type, "0074");
		}

	//判断是否转账母卡
		iRet=CDB::isTransferParentTerm(gbl.pos_no);
		if(iRet!=0)
		{
			TS_OutPutMsg(gbl.dPosInfo,"本终端无转账权限\n按【确认】返回",0,iSelect);
			return -1;
		}
	

    }
	
	while((strcmp(gbl.mer_ecard,gbl.card_no)!=0)||(strcmp(gbl.mer_ecard,"")==0)||(strcmp(gbl.card_no,"")==0)){
		
		TS_OutPutMsg(gbl.dPosInfo,"e卡卡号与终端机绑定的卡号不一致，请重新刷e卡。\n按【确认】继续",0,iSelect);
		
		/**************取得卡号*******************/
		for(int curTry=0; curTry<MAXTRY; curTry++)
		{
			bbzero(card_info);
			iRet = getCardInfo(title, card_info, MNG_OR_INPUT, gbl.get_card, "请刷或输入e卡卡号", 6, 19);
			if( iRet == 0 )
				iRet = getCardNum(card_info, MNG_OR_INPUT);//取得卡号
			if( (iRet == CANCLE_KEY) )
				return CANCLE_KEY;
			else if( (iRet == RE_MNG_CARD) )
				continue;
			else if(iRet != 0)
				return -1;
			else
				break;
		}	 
	}	
	
	TSTxnLogs txnLogs;
	wrLog("%s【查询】",title);
	
	//全省交罚优化
	memset(&txnLogs, 0, sizeof(txnLogs));
	iRet = CDB::getSonCard(gbl.pos_no, &txnLogs);
    //iRet = CDB::pep_getSonCard(gbl.mer_ecard, gbl.pos_no, business_name, &txnLogs);
	if(iRet)
	{
		TS_OutPutMsg(gbl.dPosInfo, "无法获取可转账终端，请稍候再试。", 0, iSelect);
		return -1;
	}
	
	iRet = TS_ShowTxnLogs(gbl.dPosInfo, &txnLogs);
	if(iRet)
	{
		TS_OutPutMsg(gbl.dPosInfo, "网络繁忙，请稍候再试。", 0, iSelect);
		return -1;
	}
	
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, title);
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入要转入的终端号：");	
	tradeInfoSend.Contents[0].uMinLen = 8;		
	tradeInfoSend.Contents[0].uMaxLen = 8;
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
	tradeInfoSend.Contents[0].uCount = 0;		//输入1次		
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		return -1;
	}
	bbzero(trasn_pos);
	strcpy(trasn_pos, (char *)tradeInfoRecv.Contents[0].uMsg);
	bbzero(ecard_in);
	bbzero(business_name);
	iRet = CDB::getEcard(trasn_pos,ecard_in,business_name);
	if (iRet != 0)
	{
		TS_OutPutMsg(gbl.dPosInfo,"找不到您输入的终端号所绑定的e卡卡号，请查证输入的终端号是否正确！",0,iSelect);
		return -1;
	}
	ecard_in_len = strlen(ecard_in);
    
	//删除是否判断是转账子卡
	if(tag==1){
		iRet=CDB::isTransferSonCard(gbl.card_no,ecard_in);
		if(iRet!=0){
			TS_OutPutMsg(gbl.dPosInfo,"该转入终端号无效。\n按【确认】返回",0,iSelect);
			return -1;
		}
    }

	bbzero(temp_buff);
	sprintf(temp_buff,"您输入的转入终端号为：%s\n e卡卡号为：%s\n商户名为：%s\n\n按【确认】继续",trasn_pos,ecard_in,business_name);
	TS_OutPutMsg(gbl.dPosInfo,temp_buff,0,iSelect);
	if (iSelect!=0)
	{
		return -1;
	}
	
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, title);
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入转账金额");	
	tradeInfoSend.Contents[0].uMinLen = 1;		
	tradeInfoSend.Contents[0].uMaxLen = 8;
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_MONEY;	//数字
	tradeInfoSend.Contents[0].uCount = 0;		//输入1次		
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
	
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		if(iRet == 1 || iRet ==2)
			wrLog("【e卡充值】输入金额用户取消或超时");
		else
			wrLog("【e卡充值】输入金额失败");
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return -1;
	}
	bbzero(gbl.amount);
	strcpy(gbl.amount, (char *)tradeInfoRecv.Contents[0].uMsg);	//读入金额
	memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
	strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
	
	bbzero(temp_buff);
	bbzero(money);
	CTools::chgToMny(gbl.amount,money);
	sprintf(temp_buff,"您输入的转账金额为：%s\n\n按【确认】后请输入交易密码",money);
	TS_OutPutMsg(gbl.dPosInfo,temp_buff,0,iSelect);
	if (iSelect!=0)
	{
		return -1;
	}
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{
		iRet = getCardPwd(title);	//取得密码
		if( (iRet == CANCLE_KEY) )
			return CANCLE_KEY;
		else if( (iRet == RE_MNG_CARD) )
			return RE_MNG_CARD;
		else if(iRet != 0)
			return -1;
		bbzero(gbl.phone_no);   //e卡卡号
		strcpy(gbl.phone_no, ecard_in);
		gbl.phone_len = ecard_in_len;
		pack.wrField(2, gbl);	//写交费域
		
		
		/*-打8583包-*/
		iRet = packHdl(2);
		if(iRet < 0)
			return -1;
		
		if (!memcmp(pack.FIELD39,"00",2)) 
		{ 
			char eAmount[20];
			char eBalance[20];
			char eMnyBuf[13];
			bbzero(eAmount);
			bbzero(eBalance);
			bbzero(eMnyBuf);
			memcpy(eMnyBuf,pack.FIELD63,12);
            CTools::chgToMny(eMnyBuf,eAmount,0);
			wrLog("转账金额:%s",eAmount);
			bbzero(eMnyBuf);
			memcpy(eMnyBuf,pack.FIELD63+13,12);
            CTools::chgToMny(eMnyBuf,eBalance,0);
			wrLog("转入卡内余额:%s",eBalance);
			
			sprintf(respone_info,"资金转入成功！\n转账金额:%s\n转入终端:%s \n当前余额:%s元\n按【确认】退出",eAmount,trasn_pos,eBalance);
			TS_OutPutMsg(gbl.dPosInfo,respone_info, 0, iSelect);
			return 0;
		}
		else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
			if (iSelect!=0)
			{
				return -1;
			}else
				continue;
		}
		else
			iRet = returnFail((char *)pack.FIELD39);
		return -1;
	}
	return 0;
}

int CTrade::cardPayTelOne(const char *type, char *amount, char *fee_type, char *sell_card_type, char *cardpwd)
{
	int  iRet=0, flag = 0;
	int  iSelect;
	int  b48_len;
	char len_tmp[2+1];
	char response_code[3];
	char correct_code[3],party_code[7];
	char cardpwdEnc[20+1];
	
	strcpy(gbl.amount, amount);
	strcpy(gbl.card_amount, amount);
	strcpy(gbl.fee_type, fee_type);
	strcpy(gbl.sell_card_type, sell_card_type);
	
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{	
		if(!flag)
		{   
			iRet = 1;
			while(iRet)
			{
				iRet = mngCard_Hdl(type);
				if(iRet == CANCLE_KEY)
					return CANCLE_KEY;
				else if(iRet != 0)
					return -1;
				//东莞移动30元，联通30元，小灵通30元、电信充值付费卡20元;
				if(atoi(gbl.sell_card_type)==207 || atoi(gbl.sell_card_type)==310||atoi(gbl.sell_card_type)==127||atoi(gbl.sell_card_type)==128)
				{
					if( memcmp(gbl.card_no, "1088", 4) )
					{
						TS_OutPutMsg(gbl.dPosInfo, " \n\n      请刷e卡！", 1, iSelect);
						return -1;
					}
				}
			}
		}
        
		pack.wrField(2, gbl);	//写交费域
		/*************48bit****************/
		b48_len = 0;
		bbzero(pack.FIELD48);
		memcpy(pack.FIELD48, gbl.fee_type, 4);
		b48_len += 4;
		bbzero(len_tmp);
		memcpy(len_tmp, "04", 2);
		memcpy(pack.FIELD48 + b48_len, len_tmp, 2);
		b48_len += 2;
		memcpy(pack.FIELD48+b48_len, gbl.sell_card_type, 4);
		b48_len += 4;
		pack.Packet_Table[48].Real_Length=b48_len;
		/*************end 48bit****************/
		
		iRet = packHdl(2);
		if(iRet < 0)
			return -1;
		
		memset(response_code,0,sizeof(response_code));
		memcpy(response_code,pack.FIELD39,2);
		if (!memcmp(response_code,"00",2)) 
		{
			bbzero(cardpwdEnc);
			memcpy(cardpwdEnc, pack.FIELD63+4, 18);
			CTools::Encrypt(cardpwdEnc, cardpwd, 1);
			return 0;
		}
		else if(!memcmp(response_code,"55",2))
		{
			flag = 1;
			if(reGetPwd( type) == 0) //密码错误，重新输入密码, 2006-10-25，lihk
				continue;
			else
				return CANCLE_KEY;
		}
		else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n",1,iSelect);
			return -1;
		}
		else
		{		
			memset(party_code,0,sizeof(party_code));
			memset(correct_code,0,sizeof(correct_code));
			
			memcpy(party_code,&pack.FIELD62[1],6);
			memcpy(correct_code,&pack.FIELD62[1+6],2);
			returnFail(response_code);
			return 1;
		}
	}
	return 0;
}

//latn_id_list:区号 广州020; dest_list: 0:固话 1:小灵通 2:手机 3:ADSL; charge_num_list:电话号码
int CTrade::cardPayTel(const char *type, char *latn_id_list, char *dest_list, char *charge_num_list, char *amount, char *fee_type)
{
	int iRet=0, iSelect=0, cardno=0, i=0;
	long lamount=0;//lamount剩下要交的钱
	char amoBuf[12+1], mny[20], realmny[20], password[18+1], formData[1024], getData[1024], tmp[4096];//mny应缴费用, realmny实缴费用
	char cardpwd[200][20+1];
	long amounts[200];
	
	wrLog("【cardPayTel】");
	if( atoi(gbl.dPosInfo.prmVer)>=9000 && ( strstr(CT10000_TERM, "00000000")!=NULL || strstr(CT10000_TERM, gbl.pos_no)!=NULL ) )
	{
		wrLog("type：[%s]", type);
		wrLog("latn_id_list[%s]", latn_id_list);
		wrLog("dest_list[%s]", dest_list);
		wrLog("charge_num_list[%s]", charge_num_list);
		wrLog("amount[%s]", amount);
		wrLog("fee_type[%s]", fee_type);
	}
	else
	{
		wrLog("prmVer：[%s]", gbl.dPosInfo.prmVer);
		wrLog("CT10000_TERM[%s]", CT10000_TERM);
		wrLog("pos_no[%s]", gbl.pos_no);
		TS_OutPutMsg(gbl.dPosInfo, "本功能暂未开通", 0,iSelect);		
		return 0;
	}
	
	if(strcmp(dest_list, "9")==0)
	{
		TSMENULIST menuList;		
		memset(&menuList,0,sizeof(menuList));
		menuList.iTotalNum = 2;
		strcpy(menuList.acTitle, "请选择号码类型");
		strcpy(menuList.menuItem[0], "固话");
		strcpy(menuList.menuItem[1], "小灵通");
		
		iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
		if(iRet)
			return -1;
		
		switch (iSelect)
		{
		case 1:
			strcpy(dest_list, "0");
			break;
		case 2:
			strcpy(dest_list, "1");
			break;	
		default:
			return -1;
		}
	}	
	
	for(i=0; i<200; i++)
	{
		bbzero(cardpwd[i]);
		amounts[i] = 0;
	}
	
	lamount = atoi(amount);
	
	if(lamount%1000!=0)
	{
		TS_OutPutMsg(gbl.dPosInfo, " \n\n总充值额不是10元的倍数，无法充值", 1, iSelect);
		return -1;
	}
	else
	{
		NULL;
	}
	
	for(i = 0; i < sell_card_amo.size() && sell_card_amo[i].amount != 0 && lamount > 0; i++)
	{
		//如果　业务类别不同　剩下的金额比卡面额小，继续找下一种卡
		if( memcmp(sell_card_amo[i].biz_type, fee_type, 4)!=0 || lamount<sell_card_amo[i].amount )
		{
			continue;
		}
		else
		{
			for(int j=0; j<1000; j++)
			{
				bbzero(amoBuf);
				sprintf(amoBuf, "%012d", sell_card_amo[i].amount);
				bbzero(password);
				iRet = cardPayTelOne(type, amoBuf, fee_type, sell_card_amo[i].card_type, password);
				if(iRet==0)
				{
					bbzero(cardpwd[cardno]);
					strcpy(cardpwd[cardno], password);
					amounts[cardno] = sell_card_amo[i].amount;
					cardno++;
					bbzero(getData);
					bbzero(formData);
					strcpy(formData, "charge_type=dz&card_pwd_num=1&charge_num_total=1&card_pwd=");
					strcat(formData, password);
					strcat(formData, "&dest_list=");
					strcat(formData, dest_list);
					strcat(formData, "&latn_id_list=");
					strcat(formData, latn_id_list);
					strcat(formData, "&charge_num_list=");
					strcat(formData, charge_num_list);
					strcat(formData, "&charge_amount_list=0&objType=5BC");
					iRet=TS_FillCt10000(gbl.dPosInfo, "gd.ct10000.com", "/webChargeAction.do", formData, getData);
					if(iRet==0)
					{
						if(strstr(getData, "充值成功")!=NULL)
						{
							TS_OutPutMsg(gbl.dPosInfo, "充值成功！", 0,iSelect);
						}
						else
						{
							wrLog("gd.ct10000.com getData[%s]", getData);
							bbzero(tmp);
							sprintf(tmp,"充值付费卡[%s]充值超时，结果未知\n请联系“交费易”客服热线400-80-11888\n", password);
							TS_OutPutMsg(gbl.dPosInfo, tmp, 0,iSelect);
							i = sell_card_amo.size();
							j = 1000;
						}
					}
					else
					{
						wrLog("gd.ct10000.com getData[%s]", getData);
						i = sell_card_amo.size();
						j = 1000;
						bbzero(tmp);
						sprintf(tmp,"充值付费卡[%s]充值超时，结果未知\n请联系“交费易”客服热线400-80-11888\n", password);
						TS_OutPutMsg(gbl.dPosInfo, tmp, 0,iSelect);
					}
					
					if(i < sell_card_amo.size())
					{
						lamount = lamount - sell_card_amo[i].amount;
					}
					
					if(lamount<=0)
					{
						i = sell_card_amo.size();
						j = 1000;
					}
					else if(i < sell_card_amo.size() && lamount < sell_card_amo[i].amount)
					{
						j = 1000;
					}
					else
					{
						NULL;
					}
				}
				else
				{
					i = sell_card_amo.size();
					j = 1000;
				}
			}			
		}
	}
	//提示已交多少钱
	bbzero(amoBuf);
	sprintf(amoBuf, "%012d", atoi(amount)-lamount );
	bbzero(realmny);
	CTools::chgToMny(amoBuf, realmny);
	bbzero(mny);
	CTools::chgToMny(amount, mny);
	
	CPrint prt;
	prt.set_in_par(gbl);
	bbzero(tmp);
	sprintf(tmp,"号码：%s\n\n已经成功充值：%s", charge_num_list, realmny);
	prt.print_func(tmp, strlen(tmp));
	
	bbzero(tmp);
	strcpy(tmp,"充值付费卡帐号列表如下：\n");
	for(i=0; i<cardno; i++)
	{
		strcat(tmp, cardpwd[i]);
		bbzero(amoBuf);
		sprintf(amoBuf, "%012d", amounts[i]);
		bbzero(mny);
		CTools::chgToMny(amoBuf, mny);
		strcat(tmp, "(");
		strcat(tmp, mny);
		strcat(tmp, ")\n");
		if( (i+1)%20==0 )
		{
			prt.print_func(tmp, strlen(tmp));
			bbzero(tmp);
			strcpy(tmp,"充值付费卡帐号列表如下：\n");
		}
		else
		{
			NULL;
		}
	}
	if(strcmp(tmp, "充值付费卡帐号列表如下：\n")!=0)
	{
		prt.print_func(tmp, strlen(tmp));
	}
	else
	{
		NULL;
	}
	
	bbzero(mny);
	CTools::chgToMny(amount, mny);
	
	bbzero(tmp);
	sprintf(tmp,"应买充值付费卡%s\n\n实买充值付费卡%s", mny, realmny);
	TS_OutPutMsg(gbl.dPosInfo, tmp, 0,iSelect);
	
	return 0;
}

//latn_id_list:区号 广州020; dest_list: 0:固话 1:小灵通 2:手机 3:ADSL; charge_num_list:电话号码
int CTrade::MyCoolPayEasy_cardPayTel(const char *type, char *latn_id_list, char *dest_list, char *charge_num_list, char *amount, char *fee_type)
{
	int iRet=0, iSelect=0, cardno=0, i=0;
	long lamount=0;//lamount剩下要交的钱
	char amoBuf[12+1], mny[20], realmny[20], password[18+1], formData[1024], getData[1024], tmp[4096];//mny应缴费用, realmny实缴费用
	char cardpwd[200][20+1];
	long amounts[200];
	
	wrLog("【cardPayTel】");
	// 	if( atoi(gbl.dPosInfo.prmVer)>=9000 && ( strstr(CT10000_TERM, "00000000")!=NULL || strstr(CT10000_TERM, gbl.pos_no)!=NULL ) )
	// 	{
	wrLog("type：[%s]", type);
	wrLog("latn_id_list[%s]", latn_id_list);
	wrLog("dest_list[%s]", dest_list);
	wrLog("charge_num_list[%s]", charge_num_list);
	wrLog("amount[%s]", amount);
	wrLog("fee_type[%s]", fee_type);
	// 	}
	// 	else
	// 	{
	// 		wrLog("prmVer：[%s]", gbl.dPosInfo.prmVer);
	// 		wrLog("CT10000_TERM[%s]", CT10000_TERM);
	// 		wrLog("pos_no[%s]", gbl.pos_no);
	// 		TS_OutPutMsg(gbl.dPosInfo, "本功能暂未开通", 0,iSelect);		
	// 		return 0;
	// 	}
	
	if(strcmp(dest_list, "9")==0)
	{
		TSMENULIST menuList;		
		memset(&menuList,0,sizeof(menuList));
		menuList.iTotalNum = 2;
		strcpy(menuList.acTitle, "请选择号码类型");
		strcpy(menuList.menuItem[0], "固话");
		strcpy(menuList.menuItem[1], "小灵通");
		
		iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
		if(iRet)
			return -1;
		
		switch (iSelect)
		{
		case 1:
			strcpy(dest_list, "0");
			break;
		case 2:
			strcpy(dest_list, "1");
			break;	
		default:
			return -1;
		}
	}	
	
	for(i=0; i<200; i++)
	{
		bbzero(cardpwd[i]);
		amounts[i] = 0;
	}
	
	lamount = atoi(amount);
	
	if(lamount%1000!=0)
	{
		TS_OutPutMsg(gbl.dPosInfo, " \n\n总充值额不是10元的倍数，无法充值", 1, iSelect);
		return -1;
	}
	else
	{
		NULL;
	}
	
	for(i = 0; i < sell_card_amo.size() && sell_card_amo[i].amount != 0 && lamount > 0; i++)
	{
		//如果　业务类别不同　剩下的金额比卡面额小，继续找下一种卡
		if( memcmp(sell_card_amo[i].biz_type, fee_type, 4)!=0 || lamount<sell_card_amo[i].amount )
		{
			continue;
		}
		else
		{
			for(int j=0; j<1000; j++)
			{
				bbzero(amoBuf);
				sprintf(amoBuf, "%012d", sell_card_amo[i].amount);
				bbzero(password);
				iRet = cardPayTelOne(type, amoBuf, fee_type, sell_card_amo[i].card_type, password);
				if(iRet==0)
				{
					bbzero(cardpwd[cardno]);
					strcpy(cardpwd[cardno], password);
					amounts[cardno] = sell_card_amo[i].amount;
					cardno++;
					bbzero(getData);
					bbzero(formData);
					strcpy(formData, "charge_type=dz&card_pwd_num=1&charge_num_total=1&card_pwd=");
					strcat(formData, password);
					strcat(formData, "&dest_list=");
					strcat(formData, dest_list);
					strcat(formData, "&latn_id_list=");
					strcat(formData, latn_id_list);
					strcat(formData, "&charge_num_list=");
					strcat(formData, charge_num_list);
					strcat(formData, "&charge_amount_list=0&objType=5BC");
					iRet=TS_FillCt10000(gbl.dPosInfo, "gd.ct10000.com", "/webChargeAction.do", formData, getData);
					if(iRet==0)
					{
						if(strstr(getData, "充值成功")!=NULL)
						{
							TS_OutPutMsg(gbl.dPosInfo, "     充值成功！\n请按【确认】打印票据", 0,iSelect);
						}
						else
						{
							wrLog("gd.ct10000.com getData[%s]", getData);
							bbzero(tmp);
							sprintf(tmp,"充值付费卡[%s]充值超时，结果未知\n请联系“交费易”客服热线400-80-11888\n", password);
							TS_OutPutMsg(gbl.dPosInfo, tmp, 0,iSelect);
							i = sell_card_amo.size();
							j = 1000;
						}
					}
					else
					{
						wrLog("gd.ct10000.com getData[%s]", getData);
						i = sell_card_amo.size();
						j = 1000;
						bbzero(tmp);
						sprintf(tmp,"充值付费卡[%s]充值超时，结果未知\n请联系“交费易”客服热线400-80-11888\n", password);
						TS_OutPutMsg(gbl.dPosInfo, tmp, 0,iSelect);
					}
					if(i < sell_card_amo.size())
					{
						lamount = lamount - sell_card_amo[i].amount;
					}
					
					if(lamount<=0)
					{
						i = sell_card_amo.size();
						j = 1000;
					}
					else if(i < sell_card_amo.size() && lamount < sell_card_amo[i].amount)
					{
						j = 1000;
					}
					else
					{
						NULL;
					}
				}
				else
				{
					i = sell_card_amo.size();
					j = 1000;
				}
			}			
		}
	}
	//提示已交多少钱
	bbzero(amoBuf);
	sprintf(amoBuf, "%012d", atoi(amount)-lamount );
	bbzero(realmny);
	CTools::chgToMny(amoBuf, realmny);
	bbzero(mny);
	CTools::chgToMny(amount, mny);
	
	//至少买了一张卡才会出票
	if(cardno>0)
	{
		CPrint prt;
		prt.set_in_par(gbl);
		prt.MyCoolPayEasy_print_card_detail(type);
	}
	return 0;
}

int CTrade::MyCoolPayEasy(const char *title)
{
	int iSelect, iRet = 0, iRetB = 0;
	char mark_card[30+1];
	
	wrLog("【MyCoolPayEasy】");
	
	bbzero(mark_card);
	strncpy(mark_card, gbl.card_no, sizeof(mark_card)-1);
	iRet = MyCoolPayEasy_Hdl(title);
	if( gbl.get_card == MNG_ONE_BIND_E || gbl.get_card == MNG_MUL_BIND_E )//还原原先刷的卡
	{
		iRetB = bindcard(mark_card, gbl.card_no, &gbl.card_no_len);
		if(iRetB != 0)
		{
			TS_OutPutMsg(gbl.dPosInfo,"绑定原卡号出错!请挂机重连!",0,iSelect);
			TS_HangUp(gbl.dPosInfo);
		}
	}
	return iRet;
}

//含递归调用
int CTrade::MyCoolPayEasy_Hdl(const char *title, int input_flag)
{
	int iRet=0, iSelect=0, b48_len=0, mny_flag=0, i=0, return_flag=0, biz_flag=0;
	char temp_buff[512], amoMny[13] ,advise_amount[12+1],advise_amoMny[12+1],phone_amount[12+1];
	char paper_data[10+1],paper_time[8+1],bit_map1[1+1],phone_no_buff[30+1];
	int data_len;
	char buff[512];
	car_paper_info car_paperinfo[10];
	TSMENULIST menuList;
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	wrLog("【MyCoolPayEasy_Hdl】");
	
	if(input_flag == 0)//需要输入
	{
		strcpy(tradeInfoSend.acMainTitle, title);
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents = 1;
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入号码：");	
		tradeInfoSend.Contents[0].uMinLen = 1;		
		tradeInfoSend.Contents[0].uMaxLen = 20;
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//全字符
		tradeInfoSend.Contents[0].uCount = 0;		//输入1次		
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME + 10;	//超时30秒
		
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		
		if(iRet != 0)
		{
			wrLog("TS_TradeControl返回错误[%d]", iRet);
			wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
			return iRet;
		}
		memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
		strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
		gbl.phone_len = tradeInfoRecv.Contents[0].uMsgLen;
		memset( gbl.phone_no,0,sizeof(gbl.phone_no) );
		strcpy( gbl.phone_no,(char *)tradeInfoRecv.Contents[0].uMsg );
	}
	else
	{
		NULL;//Q币充值iRet返回7
	}
	
	wrLog("gbl.phone_no:[%s]", gbl.phone_no);
	
	bbzero(gbl.fee_type);
	bbzero(advise_amoMny);
	bbzero(advise_amount);
	bbzero(temp_buff);
	bbzero(bit_map1);
	memcpy(bit_map1,gbl.phone_no,1);
	//首位为0并且长度大于6　电信固话
	if ((memcmp(gbl.phone_no,"0",1)==0)&&(gbl.phone_len>6))
	{

		if (CTools::IsDigit(gbl.phone_no)==0)
		{
			iRet = DX_AirPay_D("电信固话充值",9,1);
			return iRet;
		}
		else
		{
			bbzero(phone_no_buff);
			memcpy(phone_no_buff,gbl.phone_no,gbl.phone_len);
			bbzero(gbl.phone_no);
			memcpy(gbl.phone_no,phone_no_buff,gbl.phone_len-1);
			gbl.phone_len -= 1;
			if ((CTools::IsDigit(gbl.phone_no)==0)&&((memcmp((char*)phone_no_buff+gbl.phone_len,"d",1)==0)||(memcmp((char*)phone_no_buff+gbl.phone_len,"D",1)==0)))
			{
				iRet = DX_AirPay_D("电信宽带充值",3,1);
				return iRet;
			}else if ((CTools::IsDigit(gbl.phone_no)==0)&&((memcmp((char*)phone_no_buff+gbl.phone_len,"z",1)==0)||(memcmp((char*)phone_no_buff+gbl.phone_len,"Z",1)==0)))
			{
				iRet = DX_AirPay_D("固话+宽带充值",4,1);
				return iRet;
			}else{
				bbzero(temp_buff);
				sprintf(temp_buff,"您输入的号码【%s】长度为【%d位】\n\n无效号码！",phone_no_buff,strlen(phone_no_buff));
				iRet = TS_OutPutMsg(gbl.dPosInfo,temp_buff,0,iSelect);
				return -1;
			}
			
		}
	}
	//全部为数字并且第一位为1且长度大于等于11位 为手机直充（或售卡）
	else if ((CTools::IsDigit(gbl.phone_no)==0) &&(memcmp(gbl.phone_no,"1",1)==0)&&(gbl.phone_len >= 11))
	{
		bbzero(phone_no_buff);
		strcpy(phone_no_buff,gbl.phone_no);
		bbzero(gbl.phone_no);
		bbzero(phone_amount);
		memcpy(gbl.phone_no,phone_no_buff,11);
		memcpy(phone_amount,phone_no_buff+11,gbl.phone_len-11);
		gbl.phone_len = 11;
		bbzero(advise_amount);
		sprintf(advise_amount,"%010d00",atoi(phone_amount));//取得手机后面的金额，若不输则为0
		
		//从数据库表中查手机号码头，得到手机号码归属 1:电信 2:移动 3:联通
		for (i = 0; i < epos_mobile.size(); i++)
		{
			if (memcmp(gbl.phone_no,epos_mobile[i].mobile_field,3)==0)
				break;
		}
		if (i == epos_mobile.size())
		{
			iRet = TS_OutPutMsg(gbl.dPosInfo,"输入的手机号码不存在！",0,iSelect);
			return -1;
		}
		else
		{
			biz_flag = epos_mobile[i].mobile_owner;
		}	
		
		if (biz_flag == 2)
		{
			if (gbl.menu_group_mbl_flag==2)
			{
				TS_OutPutMsg(gbl.dPosInfo,"暂未开通，敬请关注!",0,iSelect);
				return -1;
			}
			
		}
		
		if ( biz_flag==1 )//电信直充
		{
			if (atoi(advise_amount)==3000)
			{
				bbzero(gbl.amount);
				strcpy(gbl.amount,"000000003000");
				iRet = DX_AirPay_D("电信手机充值",2,1,1);
				return iRet;
			}else if (atoi(advise_amount)==5000)
			{
				bbzero(gbl.amount);
				strcpy(gbl.amount,"000000005000");
				iRet = DX_AirPay_D("电信手机充值",2,1,2);
				return iRet;
			}else if (atoi(advise_amount)==10000)
			{
				bbzero(gbl.amount);
				strcpy(gbl.amount,"000000010000");
				iRet = DX_AirPay_D("电信手机充值",2,1,3);
				return iRet;
			}else if (atoi(advise_amount)==20000)
			{
				bbzero(gbl.amount);
				strcpy(gbl.amount,"000000020000");
				iRet = DX_AirPay_D("电信手机充值",2,1,4);
				return iRet;
			}else if (atoi(advise_amount)==50000)
			{
				bbzero(gbl.amount);
				strcpy(gbl.amount,"000000050000");
				iRet = DX_AirPay_D("电信手机充值",2,1,5);
				return iRet;
			}else if (strlen(phone_amount)==0) {
				iRet = DX_AirPay_D("电信手机充值",2,1,0);
				return iRet;
			}else 
			{
				TS_OutPutMsg(gbl.dPosInfo,"您输入的金额不正确。\n输入规则为：手机号+金额。\n常用金额为：30元，50元，100元，200元，500元。\n例如：输入1330000000030 即为号码13300000000充值30元",0,iSelect);
				return -1;
			}		
			
		}else if ( ( biz_flag==2 ) && ( YiDong_Turn==1 ) )//移动售卡, YiDong_Turn:移动直充与售卡开关。0：直充；1：售卡
		{
			iRet = get_area_biz(BIZ_AREA_BIZ_SELLCARD, gbl.city_no, gbl.acc_city_no, gbl.fee_type);
			if( iRet==0 )
			{
				wrLog("gbl.fee_type = [%s]", gbl.fee_type);
			}
			else
			{
				return -1;
			}
			
			bbzero(gbl.sell_card_type);
			strcpy(gbl.sell_card_type, "020");
			
			if (atoi(advise_amount)==3000)
			{
				CTools::chgToMny(advise_amount,advise_amoMny);
				sprintf(temp_buff,"号码：%s\n推荐业务：移动充值卡\n\n充值金额：%s\n\n【请认真核对交费号码及金额】",gbl.phone_no,advise_amoMny);
				TS_OutPutMsg(gbl.dPosInfo, temp_buff, 0,iSelect);
				if (iSelect != 0)
				{
					return -1;
				}
				iRet = sellCardTrade("移动充值卡", 1,1);
			}else if (atoi(advise_amount)==5000)
			{
				CTools::chgToMny(advise_amount,advise_amoMny);
				sprintf(temp_buff,"号码：%s\n推荐业务：移动充值卡\n\n充值金额：%s\n\n【请认真核对交费号码及金额】",gbl.phone_no,advise_amoMny);
				TS_OutPutMsg(gbl.dPosInfo, temp_buff, 0,iSelect);
				if (iSelect != 0)
				{
					return -1;
				}
				iRet = sellCardTrade("移动充值卡", 2,1);
			}else if (atoi(advise_amount)==10000)
			{
				CTools::chgToMny(advise_amount,advise_amoMny);
				sprintf(temp_buff,"号码：%s\n推荐业务：移动充值卡\n\n充值金额：%s\n\n【请认真核对交费号码及金额】",gbl.phone_no,advise_amoMny);
				TS_OutPutMsg(gbl.dPosInfo, temp_buff, 0,iSelect);
				if (iSelect != 0)
				{
					return -1;
				}
				iRet = sellCardTrade("移动充值卡", 3,1);
			}else if (strlen(phone_amount)==0)
			{
				iRet = sellCardTrade("移动充值卡", 0,1);
			}else 
			{
				TS_OutPutMsg(gbl.dPosInfo,"您输入的金额不正确。\n输入规则为：手机号+金额。\n常用金额为：30元，50元，100元。\n例如：输入1330000000030 即为号码13300000000充值30元",0,iSelect);
				return -1;
			}
		}else if ( ( biz_flag==3 ) && ( LianTong_Turn==1 ) )//联通售卡 LianTong_Turn:联通直充与售卡开关。0：直充；1：售卡
		{
			iRet = get_area_biz(BIZ_AREA_BIZ_SELLCARD, gbl.city_no, gbl.acc_city_no, gbl.fee_type);
			if( iRet==0 )
			{
				wrLog("gbl.fee_type = [%s]", gbl.fee_type);
			}
			else
			{
				return -1;
			}
			
			bbzero(gbl.sell_card_type);
			strcpy(gbl.sell_card_type, "030");
			
			if (atoi(advise_amount)==3000)
			{
				CTools::chgToMny(advise_amount,advise_amoMny);
				sprintf(temp_buff,"号码：%s\n推荐业务：联通充值卡\n\n充值金额：%s\n\n【请认真核对交费号码及金额】",gbl.phone_no,advise_amoMny);
				TS_OutPutMsg(gbl.dPosInfo, temp_buff, 0,iSelect);
				if (iSelect != 0)
				{
					return -1;
				}
				iRet = sellCardTrade("联通一卡充", 1,1);
			}else if (atoi(advise_amount)==5000)
			{
				CTools::chgToMny(advise_amount,advise_amoMny);
				sprintf(temp_buff,"号码：%s\n推荐业务：联通充值卡\n\n充值金额：%s\n\n【请认真核对交费号码及金额】",gbl.phone_no,advise_amoMny);
				TS_OutPutMsg(gbl.dPosInfo, temp_buff, 0,iSelect);
				if (iSelect != 0)
				{
					return -1;
				}
				iRet = sellCardTrade("联通一卡充", 2,1);
			}else if (atoi(advise_amount)==10000)
			{
				CTools::chgToMny(advise_amount,advise_amoMny);
				sprintf(temp_buff,"号码：%s\n推荐业务：联通充值卡\n\n充值金额：%s\n\n【请认真核对交费号码及金额】",gbl.phone_no,advise_amoMny);
				TS_OutPutMsg(gbl.dPosInfo, temp_buff, 0,iSelect);
				if (iSelect != 0)
				{
					return -1;
				}
				iRet = sellCardTrade("联通一卡充", 3,1);
			}else if (strlen(phone_amount)==0)
			{
				iRet = sellCardTrade("联通一卡充", 0,1);
			}else 
			{
				TS_OutPutMsg(gbl.dPosInfo,"您输入的金额不正确。\n输入规则为：手机号+金额。\n常用金额为：30元，50元，100元。\n例如：输入1330000000030 即为号码13300000000充值30元",0,iSelect);
				return -1;
			}
			
		}else if ( biz_flag==2 || biz_flag==3 )//移动直充　或　联通直充
		{
			
			if (atoi(advise_amount)==3000)//输入了30
			{
				CTools::chgToMny(advise_amount,advise_amoMny);
				if ( biz_flag==2 )
				{
					sprintf(temp_buff,"号码：%s\n推荐业务：充值\n\n充值金额：%s\n\n【请认真核对交费号码及金额】",gbl.phone_no,advise_amoMny);
					
				}
				else if ( biz_flag==3 )
				{
					sprintf(temp_buff,"号码：%s\n推荐业务：联通手机直充\n\n充值金额：%s\n\n【请认真核对交费号码及金额】",gbl.phone_no,advise_amoMny);
					
				}else 
					return -1;
				TS_OutPutMsg(gbl.dPosInfo, temp_buff, 0,iSelect);
				if (iSelect != 0)
				{
					return -1;
				}
				else
				{
					NULL;
				}
				
				if( biz_flag==2 )
				{
					iRet = mblAirPay("充值", biz_flag, 30, 1);
				}
				else if( biz_flag==3 )
				{
					iRet = mblAirPay("联通手机直充", biz_flag, 30, 1);
				}
				else
				{
					TS_OutPutMsg(gbl.dPosInfo,"网络故障，交易失败，请联系在线客服中心【Ctrl+H】  400-80-11888",0,iSelect);
					return -1;
				}
			}
			else if (atoi(advise_amount)==5000)//输入了50
			{
				CTools::chgToMny(advise_amount,advise_amoMny);
				if ( biz_flag ==2 )//移动
				{
					sprintf(temp_buff,"号码：%s\n推荐业务：充值\n\n充值金额：%s\n\n【请认真核对交费号码及金额】",gbl.phone_no,advise_amoMny);
					
				}
				else if ( biz_flag==3 )//联通
				{
					sprintf(temp_buff,"号码：%s\n推荐业务：联通手机直充\n\n充值金额：%s\n\n【请认真核对交费号码及金额】",gbl.phone_no,advise_amoMny);
					
				}else
				{
					return -1;
				}
				
				TS_OutPutMsg(gbl.dPosInfo, temp_buff, 0,iSelect);
				if (iSelect != 0)
				{
					return -1;
				}
				else
				{
					NULL;
				}
				
				if( biz_flag==2 )
				{
					iRet = mblAirPay("充值", biz_flag, 50, 1);
				}
				else if( biz_flag==3 )
				{
					iRet = mblAirPay("联通手机直充", biz_flag, 50, 1);
				}
				else
				{
					TS_OutPutMsg(gbl.dPosInfo,"网络故障，交易失败，请联系在线客服中心【Ctrl+H】  400-80-11888",0,iSelect);
					return -1;
				}
				
				
			}
			else if (atoi(advise_amount)==10000)//输入了100
			{
				CTools::chgToMny(advise_amount,advise_amoMny);
				if ( biz_flag ==2 )//移动
				{
					sprintf(temp_buff,"号码：%s\n推荐业务：充值\n\n充值金额：%s\n\n【请认真核对交费号码及金额】",gbl.phone_no,advise_amoMny);
					
				}
				else if ( biz_flag==3 )//联通
				{
					sprintf(temp_buff,"号码：%s\n推荐业务：联通手机直充\n\n充值金额：%s\n\n【请认真核对交费号码及金额】",gbl.phone_no,advise_amoMny);
					
				}else
				{
					return -1;
				}
				TS_OutPutMsg(gbl.dPosInfo, temp_buff, 0,iSelect);
				if (iSelect != 0)
				{
					return -1;
				}
				else
				{
					NULL;
				}
				
				if( biz_flag==2 )
				{
					iRet = mblAirPay("充值", biz_flag, 100, 1);
				}
				else if( biz_flag==3 )
				{
					iRet = mblAirPay("联通手机直充", biz_flag, 100, 1);
				}
				else
				{
					TS_OutPutMsg(gbl.dPosInfo,"网络故障，交易失败，请联系在线客服中心【Ctrl+H】  400-80-11888",0,iSelect);
					return -1;
				}
				
			}
			else if (strlen(phone_amount)==0)//没有输金额
			{
				if( biz_flag==2 )
				{
					iRet = mblAirPay("充值", biz_flag, 0, 1);
				}
				else if( biz_flag==3 )
				{
					iRet = mblAirPay("联通手机直充", biz_flag, 0, 1);
				}
				else
				{
					TS_OutPutMsg(gbl.dPosInfo,"网络故障，交易失败，请联系在线客服中心【Ctrl+H】  400-80-11888",0,iSelect);
					return -1;
				}				
			}else
			{
				TS_OutPutMsg(gbl.dPosInfo,"您输入的金额不正确。\n输入规则为：手机号+金额。\n常用金额为：30元，50元，100元。\n例如：输入1330000000030 即为号码13300000000充值30元",0,iSelect);
				return -1;
			}			
		}
		else
		{
			iRet = TS_OutPutMsg(gbl.dPosInfo,"您输入的手机号码不存在！",0,iSelect);
			return -1;
		}
		
		return iRet;
	}
	//全部为数字并且长度大于2小于5 售卡代码
	else if ((CTools::IsDigit(gbl.phone_no)==0) &&(2<gbl.phone_len)&&(gbl.phone_len<5))//售卡代码
	{
		iRet = get_area_biz(BIZ_AREA_BIZ_SELLCARD, gbl.city_no, gbl.acc_city_no, gbl.fee_type);
		if( iRet==0 )
		{
			wrLog("gbl.fee_type = [%s]", gbl.fee_type);
		}
		else
		{
			return -1;
		}
		bbzero(gbl.sell_card_type);
		switch (atoi(gbl.phone_no))
		{
		case 130:
			strcpy(gbl.sell_card_type, "040");
			iRet = sellCardTrade("电信充值付费卡", 2);
			break;
		case 150:
			strcpy(gbl.sell_card_type, "040");
			iRet = sellCardTrade("电信充值付费卡", 3);
			break;
		case 1100:
			strcpy(gbl.sell_card_type, "040");
			iRet = sellCardTrade("电信充值付费卡", 4);
			break;
		case 230:
			if (gbl.menu_group_mbl_flag==2)
			{
				TS_OutPutMsg(gbl.dPosInfo,"暂未开通，敬请关注!",0,iSelect);
				return -1;
			}
			strcpy(gbl.sell_card_type, "020");
			iRet = sellCardTrade("移动充值卡", 1);
			break;
		case 250:
			if (gbl.menu_group_mbl_flag==2)
			{
				TS_OutPutMsg(gbl.dPosInfo,"暂未开通，敬请关注!",0,iSelect);
				return -1;
			}
			strcpy(gbl.sell_card_type, "020");
			iRet = sellCardTrade("移动充值卡", 2);
			break;
		case 2100:
			if (gbl.menu_group_mbl_flag==2)
			{
				TS_OutPutMsg(gbl.dPosInfo,"暂未开通，敬请关注!",0,iSelect);
				return -1;
			}
			strcpy(gbl.sell_card_type, "020");
			iRet = sellCardTrade("移动充值卡", 3);
			break;
		case 330:
			strcpy(gbl.sell_card_type, "030");
			iRet = sellCardTrade("联通一卡充", 1);
			break;
		case 350:
			strcpy(gbl.sell_card_type, "030");
			iRet = sellCardTrade("联通一卡充", 2);
			break;
		case 3100:
			strcpy(gbl.sell_card_type, "030");
			iRet = sellCardTrade("联通一卡充", 3);
			break;
		default:
			bbzero(temp_buff);
			sprintf(temp_buff,"【%s】 售卡代码无效！\n\n编码规则：类型+金额  例如：移动100元卡为2100\n类型：1电信、2移动、3联通\n常用金额： 30元、50元、100元、200元、300元、500元",gbl.phone_no);
			iRet = TS_OutPutMsg(gbl.dPosInfo,temp_buff,0,iSelect);
			break;
		}
		return iRet;
	}
	//全部为数字并且长度大于5小于11 Q币充值
	else if ((CTools::IsDigit(gbl.phone_no)==0) &&((5<gbl.phone_len)&&(gbl.phone_len<11)))
	{
		iRet = get_area_biz(BIZ_AREA_BIZ_QQB, gbl.city_no, gbl.acc_city_no, gbl.fee_type);
		if( iRet==0 )
		{
			wrLog("gbl.fee_type = [%s]", gbl.fee_type);
		}
		else
		{
			return -1;
		}
		bbzero(gbl.QQrate);
		strcpy(gbl.QQrate,"100"); //有腾讯qq充值切换为广禄qq充值
		bbzero(gbl.glQQPayInfo.ACCTCODE);
		strcpy(gbl.glQQPayInfo.ACCTCODE,gbl.phone_no);
		//iRet=GLQQTrade("Q币充值",0,1);

		iRet = QQPayHdl("Q币充值", 0, 1);
		
		if (iRet == 7)
		{
			bbzero(phone_no_buff);
			strcpy(phone_no_buff,gbl.phone_no);
			bbzero(gbl.phone_no);
			sprintf(gbl.phone_no,"%s%s",gbl.city_no,phone_no_buff);
			gbl.phone_len = strlen(gbl.phone_no);
			iRet = MyCoolPayEasy_Hdl(title,1);
		}
		
		return iRet;
		
	}
	//长度为5或者6位，并且首位为字母 汽车
	else if ((gbl.phone_len == 5 )|| ((gbl.phone_len == 6)&&(CTools::IsDigit(bit_map1)!=0)))//汽车
	{
		gbl.mycoolpayeasy_return = 1;
		for(i = 0; i < gbl.phone_len; i++)	//小写转换成大写
		{
			if((gbl.phone_no[i] >= 97) && (gbl.phone_no[i] <= 122) )
				gbl.phone_no[i] = gbl.phone_no[i] - 32; 
		}
		int cartax_return,carnum_return,carnp_return;
		bbzero(gbl.car_no);
		strcpy(gbl.car_no,gbl.phone_no);
		memset(car_paperinfo,0,sizeof(car_paperinfo));
		carnum_return = MyCoolPayEasy_CarNum_traffic_inq(title,gbl.phone_no,car_paperinfo);
		memset(&menuList,0,sizeof(menuList));		
		menuList.iTotalNum = 3;
		if (carnum_return<=0)
		{
			strcpy(menuList.menuItem[0], "交通罚款 无罚单");
		}else
			sprintf(menuList.menuItem[0],"交通罚款 %d张",carnum_return);
		
		bbzero(gbl.car_no);
		strcpy(gbl.car_no,gbl.phone_no);
		carnp_return = car_np_Trade(title,1);
		if ((strlen(gbl.phone_no)==6)&&(memcmp(gbl.phone_no,"A",1)!=0)&&(memcmp(gbl.phone_no,"a",1)!=0))
		{
			strcpy(menuList.menuItem[1], "汽车年票 暂未开通");
		}else if (carnp_return < 0)
		{
			strcpy(menuList.menuItem[1], "汽车年票 已交纳");
		}else
			strcpy(menuList.menuItem[1], "汽车年票 未交纳");
		
		bbzero(amoMny);
		bbzero(gbl.car_no);
		strcpy(gbl.car_no,gbl.phone_no);
		cartax_return = MyCoolPayEasy_CarTax_inq(title,gbl.phone_no,amoMny);
		if ((strlen(gbl.phone_no)==6)&&(memcmp(gbl.phone_no,"A",1)!=0)&&(memcmp(gbl.phone_no,"a",1)!=0))
		{
			strcpy(menuList.menuItem[2], "车船税 暂未开通");
		}else if (cartax_return < 0)
		{
			strcpy(menuList.menuItem[2], "车船税 已交纳");
		}else
			sprintf(menuList.menuItem[2], "车船税%s 未交纳",amoMny);
		
		if (strlen(gbl.phone_no)==5)
		{
			sprintf(menuList.acTitle, "车牌号:粤A%s 车主:%s",gbl.phone_no,gbl.user_name);
		}else 
			sprintf(menuList.acTitle, "车牌号:粤%s 车主:%s",gbl.phone_no,gbl.user_name);
		
		gbl.mycoolpayeasy_return = 0;
		iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
		if(iRet)
			return -1;
		
		switch (iSelect)
		{
		case 1:
			bbzero(gbl.car_no);
			strcpy(gbl.car_no,gbl.phone_no);
			if (carnum_return<=0)
			{
				return -1;
			}
			for (i=0;i<carnum_return;i++)
			{
				bbzero(paper_data);
				bbzero(paper_time);
				bbzero(buff);
				data_len = 2;
				memcpy(buff,car_paperinfo[i].data+data_len,2);
				strcat(paper_data,buff);
				data_len += 2;
				strcat(paper_data,"/");
				bbzero(buff);
				memcpy(buff,car_paperinfo[i].data+data_len,2);
				strcat(paper_data,buff);
				data_len += 2;
				strcat(paper_data,"/");
				bbzero(buff);
				memcpy(buff,car_paperinfo[i].data+data_len,2);
				strcat(paper_data,buff);
				data_len += 2;
				bbzero(buff);
				memcpy(buff,car_paperinfo[i].data+data_len,2);
				strcat(paper_time,buff);
				data_len += 2;
				strcat(paper_time,":");
				bbzero(buff);
				memcpy(buff,car_paperinfo[i].data+data_len,2);
				strcat(paper_time,buff);
				data_len += 2;
				strcat(paper_time,":");
				bbzero(buff);
				memcpy(buff,car_paperinfo[i].data+data_len,2);
				strcat(paper_time,buff);
				
				bbzero(temp_buff);
				if (carnum_return == i+1)
				{
					if (strlen(gbl.phone_no)==5)
					{
						sprintf(temp_buff,"粤A%s      %d/%d张\n文书类型:%s\n文号:%s\n日期%s %s\n地点:%s\n行为:%s\n\n\n【确认】缴纳罚款\n【返回】退出"
							,gbl.phone_no,i+1,carnum_return,car_paperinfo[i].paper_type,car_paperinfo[i].paper_num,paper_data,paper_time,car_paperinfo[i].area,car_paperinfo[i].behavior);
						
					}else
						sprintf(temp_buff,"粤%s      %d/%d张\n文书类型:%s\n文号:%s\n日期%s %s\n地点:%s\n行为:%s\n\n\n【确认】缴纳罚款\n【返回】退出"
						,gbl.phone_no,i+1,carnum_return,car_paperinfo[i].paper_type,car_paperinfo[i].paper_num,paper_data,paper_time,car_paperinfo[i].area,car_paperinfo[i].behavior);
					
				}
				else{
					if (strlen(gbl.phone_no)==5)
					{
						sprintf(temp_buff,"粤A%s      %d/%d张\n文书类型:%s\n文号:%s\n日期%s %s\n地点:%s\n行为:%s\n\n\n【确认】缴纳罚款\n【返回】查看下一张"
							,gbl.phone_no,i+1,carnum_return,car_paperinfo[i].paper_type,car_paperinfo[i].paper_num,paper_data,paper_time,car_paperinfo[i].area,car_paperinfo[i].behavior);
						
					}else
						sprintf(temp_buff,"粤%s      %d/%d张\n文书类型:%s\n文号:%s\n日期%s %s\n地点:%s\n行为:%s\n\n\n【确认】缴纳罚款\n【返回】查看下一张"
						,gbl.phone_no,i+1,carnum_return,car_paperinfo[i].paper_type,car_paperinfo[i].paper_num,paper_data,paper_time,car_paperinfo[i].area,car_paperinfo[i].behavior);
				}
				iRet = TS_OutPutMsg(gbl.dPosInfo,temp_buff,0,iSelect);
				if (iSelect == 0)
					iRet = traffic_pay("交通罚款",car_paperinfo[i].paper_type,car_paperinfo[i].paper_num);
			}
			break;
		case 2:
			if ((carnp_return < 0)||((strlen(gbl.phone_no)==6)&&(memcmp(gbl.phone_no,"A",1)!=0)&&(memcmp(gbl.phone_no,"a",1)!=0)))
			{	
				return -1;
			}
			bbzero(gbl.car_no);
			strcpy(gbl.car_no,gbl.phone_no);
			iRet = car_np_Trade("汽车年票", 2);
			break;
		case 3:
			if ((cartax_return < 0)||((strlen(gbl.phone_no)==6)&&(memcmp(gbl.phone_no,"A",1)!=0)&&(memcmp(gbl.phone_no,"a",1)!=0)))
			{
				return -1;
			}
			bbzero(gbl.car_no);
			strcpy(gbl.car_no,gbl.phone_no);
			iRet = taxTrade("车船税", 1);
			break;
		default:
			return -1;
		}
		return iRet;
	}else{
		bbzero(temp_buff);
		sprintf(temp_buff,"您输入的号码【%s】长度为【%d位】\n\n无效号码！",gbl.phone_no,gbl.phone_len);
		iRet = TS_OutPutMsg(gbl.dPosInfo,temp_buff,0,iSelect);
	}
	return -1;
}


int CTrade::MyCoolPayEasy_CarNum_traffic_inq(const char *title, char *incarnum, car_paper_info *car_paperinfo)
{
	int iRet = 0,iSelect;
	int b48_len = 0;
	int b63_len = 0;
	int paper_count = 0;
	int data_len = 0;
	char buff[4+1];
	char paper_count_buff[4+1],area[20+1],paper_data[10+1],paper_time[8+1],behavior[20+1];
	char enqFIELD48[42+1], enqFIELD63[999+1], enqStan[12+1];
	char trafficType[4+1], trafficNo[16+1];
	char carType[2+1];
	char carnum[6+1];
	char response_code[3];
	char temp[4096],paper_no_buff[16+1];
	
	bbzero(area);
	bbzero(behavior);
	bbzero(paper_count_buff);
	bbzero(response_code);
	bbzero(carnum);
	bbzero(enqStan);
	bbzero(carType);
	bbzero(enqFIELD48);
	bbzero(enqFIELD63);
	bbzero(trafficNo);
	bbzero(trafficType);
	
	strcpy(gbl.fee_type,"0233");
	wrLog("超爽交费易【按车牌号查询】");
	
	
	//取得罚单文书类型
	strcpy(carType,"02");
	if (strlen(incarnum)==5)
	{
		sprintf( carnum, "A%s", incarnum);
	}else
		sprintf( carnum, "%s", incarnum);
	wrLog("车辆类型：【%s】车牌号码是：【粤%s】",carType,carnum);
	
	//写查询域
	pack.wrField(1, gbl);
	bbzero(pack.FIELD48);
	memcpy(pack.FIELD48,gbl.fee_type,4);	//4位信息码
	b48_len = 4;
	sprintf((char *)pack.FIELD48+b48_len,"%02d", 14);	//总长度
	b48_len +=2;
	sprintf((char *)pack.FIELD48+b48_len,"%02d", 2);	//长度
	b48_len +=2;
	memcpy(pack.FIELD48+b48_len, "粤",2);	//车辆所属区域
	b48_len +=2;
	sprintf((char *)pack.FIELD48+b48_len,"%02d", 6);	//长度
	b48_len +=2;
	sprintf((char *)pack.FIELD48+b48_len,"%s", carnum);	//车号
	b48_len +=6;
	memcpy(pack.FIELD48+b48_len, carType, 2);	//车辆类型
	b48_len += 2;
	pack.Packet_Table[48].Real_Length=b48_len;
	
	//查询包打包   
	iRet = packHdl(1);
	if(iRet < 0)
		return -1;
	
	memcpy(enqFIELD48, pack.FIELD48, pack.Packet_Table[48].Real_Length);
	memcpy(enqFIELD63, pack.FIELD63, pack.Packet_Table[63].Real_Length);
	memcpy(enqStan, pack.FIELD37, 12);
	memcpy(response_code,pack.FIELD39,2);
	
	if (!memcmp(response_code,"00",2))
	{
		if (strlen(enqFIELD63) == 0)
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n\n     数据包错误\n   请按【确认】返回",1,iSelect);
			return -1;
		}
		memcpy(paper_count_buff,enqFIELD63+b63_len,4);
		b63_len+=4;
		paper_count = atoi(paper_count_buff);
		for (int i=0;i<paper_count;i++)
		{
			memcpy(car_paperinfo[i].data,enqFIELD63+b63_len,14);
			b63_len+=14;
			memcpy(car_paperinfo[i].behavior,enqFIELD63+b63_len,32);
			b63_len+=32;
			memcpy(car_paperinfo[i].area,enqFIELD63+b63_len,32);
			b63_len+=32;
			memcpy(car_paperinfo[i].paper_type,enqFIELD63+b63_len,4);
			b63_len+=4;
			bbzero(paper_no_buff);
			memcpy(paper_no_buff,enqFIELD63+b63_len,16);
			b63_len+=16;
			trim(paper_no_buff,16);//如果末尾有空格则去掉空格
			strcpy(car_paperinfo[i].paper_num,paper_no_buff);
			bbzero(paper_data);
			bbzero(paper_time);
			bbzero(buff);
			data_len = 2;
			memcpy(buff,car_paperinfo[i].data+data_len,2);
			strcat(paper_data,buff);
			data_len += 2;
			strcat(paper_data,"/");
			bbzero(buff);
			memcpy(buff,car_paperinfo[i].data+data_len,2);
			strcat(paper_data,buff);
			data_len += 2;
			strcat(paper_data,"/");
			bbzero(buff);
			memcpy(buff,car_paperinfo[i].data+data_len,2);
			strcat(paper_data,buff);
			data_len += 2;
			bbzero(buff);
			memcpy(buff,car_paperinfo[i].data+data_len,2);
			strcat(paper_time,buff);
			data_len += 2;
			strcat(paper_time,":");
			bbzero(buff);
			memcpy(buff,car_paperinfo[i].data+data_len,2);
			strcat(paper_time,buff);
			data_len += 2;
			strcat(paper_time,":");
			bbzero(buff);
			memcpy(buff,car_paperinfo[i].data+data_len,2);
			strcat(paper_time,buff);
			data_len += 2;
			bbzero(temp);
			for (int k = 31;k >= 0;k --)
			{
				if (car_paperinfo[i].behavior[k]==' ')
				{
					car_paperinfo[i].behavior[k] = 0;
				}else if (k == 31)
				{
					memcpy(car_paperinfo[i].behavior+k+1,"..." ,3);
					break;
				}
			}
			for (k = 31;k >= 0;k --)
			{
				if (car_paperinfo[i].area[k]==' ')
				{
					car_paperinfo[i].area[k] = 0;
				}else if (k == 31)
				{
					memcpy(car_paperinfo[i].area+k+1,"..." ,3);
					break;
				}
			}
		}
		return paper_count;
		
	}else{
		return -1;
	}
	
	return -1;
}
int CTrade::MyCoolPayEasy_CarTax_inq(const char *title, char *carnum, char *mny)
{
	int  iRet;
	int  b48_len;
	
	wrLog("超爽交费易【车船税查询】");
	bbzero(gbl.fee_type);
	strcpy(gbl.fee_type,"0065");
	bbzero(gbl.car_type);
	memcpy(gbl.car_type, "A2", 2);
	memset( gbl.car_no,0,sizeof(gbl.car_no) );
	if (strlen(carnum)==5)
	{
		strcpy(gbl.car_no, "01A");
	}else
		strcpy(gbl.car_no, "01");
	strcat( gbl.car_no,carnum);
	for(int i = 3; i < 8; i++)	//小写转换成大写
	{
		if((gbl.car_no[i] >= 97) && (gbl.car_no[i] <= 122) )
			gbl.car_no[i] = gbl.car_no[i] - 32; 
	}
	wrLog("车牌号码：[%s]", gbl.car_no);
	//写查询域
	pack.wrField(1, gbl);
	/************修改一些域*********/
	bbzero(pack.FIELD48);
	memcpy(pack.FIELD48,gbl.fee_type,4);	//4位信息码
	b48_len =4;
	memcpy(pack.FIELD48+b48_len, "10", 2);	//后面的长度:车类型(2) + 车牌号(8)
	b48_len +=2;
	memcpy(pack.FIELD48+b48_len, gbl.car_type, 2);
	b48_len +=2;
	memcpy(pack.FIELD48+b48_len, gbl.car_no, 8);
	b48_len +=8;
	pack.Packet_Table[48].Real_Length=b48_len;
	/*******************************/
	//  查询包打包
	iRet = packHdl(1);
	if(iRet < 0)
		return -1;
	if (!memcmp(pack.FIELD39,"00",2)) 
	{
		CPrint prt;
		prt.set_in_par(gbl);
		iRet = prt.rdField63(gbl);
		if(iRet)
			return -1;
		memset(mny,0,sizeof(mny));
		CTools::chgToMny(gbl.amount,mny);
		return 0;
	}
	else
	{
		return -1;
	}
	return -1;
}

//酬金结转
int CTrade::Customer_Trade()
{
	int  iRet, flag = 0,input_flag=0;
	int  iSelect, mngCard_count = 1;
	char tmp[512],response_code[3];
	char mny[12+1],type[80+1],yj_amount[12+1],yj_buff[12+1],ecard_amount[12+1],ecard_mny[12+1],tax_amount[12+1],tax_mny[12+1],zr_amount[12+1],zr_mny[12+1];
	
	if(atoi(gbl.dPosInfo.prmVer)>=9000)
	{
		iRet = checkPEPwd_Hdl("酬金结转");
		if(iRet!=0)
			if(iRet==CANCLE_KEY)
				return CANCLE_KEY;
			else
			{
				info("老板密码校验错误\n\n请联系在线客服中心【Ctrl+H】  400-80-11888\n\n按【Enter】确认返回主菜单。");
				return iRet;
			}
			
	}
    //if((CDB::isSonCard(gbl.mer_ecard))==0)
	//20130105修改-yyx
	if((CDB::pep_isSonCard(gbl.dPosInfo.pos_no))==1)
	{
		TS_OutPutMsg(gbl.dPosInfo,"该e卡为资金池的子卡\n不能结转酬金\n按【确认】返回",0,iSelect);
		return -1;
	}
	bbzero(gbl.fee_type);
	strcpy(gbl.fee_type,"0083");
	mngCard_count = 1;
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{
		if(!flag)
		{
			iRet = 1;
			while(iRet > 0)	//刷卡错误，重新刷卡
			{
				if(atoi(gbl.dPosInfo.prmVer)<9000)
					strcpy(type, "e卡余额查询");
				else
					sprintf(type, "终端号: %s", gbl.pos_no);
				if(mngCard_count==1)
					iRet = mngCard( type, 0, gbl.get_card);//gbl.get_card:0要刷卡；1：不用刷卡
				else
					iRet = mngCard( type, 0, MNG_MUL);
				mngCard_count = mngCard_count + 1 ;//标志着不是第一次刷卡
				if(iRet == CANCLE_KEY)
					return CANCLE_KEY;
				if(iRet == RE_MNG_CARD)
					continue;
				else if(iRet != 0)
					return -1;
			}
		}
		pack.wrField(2, gbl);
		/*******************修改部分包内容****************/
		memset(pack.FIELD3, 0, sizeof(pack.FIELD3));
		CTools::hex_to_byte((BYTE *)"310060", pack.FIELD3, 6);
		//bit48
		memset(pack.FIELD48, 0, sizeof(pack.FIELD48) );
		memcpy(pack.FIELD48, gbl.fee_type, 4);
		strncat((char *)pack.FIELD48, "00", 2);
		pack.Packet_Table[48].Real_Length = 6;
		/**************************************************/
		//  查询包打包   
		iRet = packHdl(1);
		if(iRet < 0)
			return -1;
		//返回数据给终端
		memset(response_code, 0, sizeof(response_code));
		memcpy(response_code, pack.FIELD39, 2);
		if (!memcmp(response_code,"00",2)) 
		{
			bbzero(yj_amount);
			bbzero(yj_buff);
			
			memcpy(yj_amount, pack.FIELD63 + 1 + 12 + 2 + 8 + 1, 12);
			CTools::chgToMny(yj_amount,yj_buff);
			
			TSTradeInfoSend tradeInfoSend;
			TSTradeInfoRecv tradeInfoRecv;
			while (input_flag == 0)
			{
				memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
				memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
				
				sprintf(tradeInfoSend.acMainTitle, "酬金结转  可转:%s",yj_buff);
				tradeInfoSend.uHasTradeID = 1;
				tradeInfoSend.uTotalContents = 1;
				
				strcpy(tradeInfoSend.Contents[0].acTitle, "请输入结转金额：");
				tradeInfoSend.Contents[0].uCommand = TS_INPUT_MONEY;	//数字
				tradeInfoSend.Contents[0].uCount = 0;		//输入1次		
				tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME + 10;	//超时30秒
				tradeInfoSend.Contents[0].uMinLen = 1;		
				tradeInfoSend.Contents[0].uMaxLen = 8;	
				
				iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
				
				if(iRet != 0)
				{
					wrLog("TS_TradeControl返回错误[%d]", iRet);
					wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
					return iRet;
				}
				
				memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
				strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
				bbzero(gbl.amount);
				strcpy(gbl.amount,(char*)tradeInfoRecv.Contents[0].uMsg );
				if ((atoi(gbl.amount)>atoi(yj_amount))||(atoi(gbl.amount)>=100000))
				{
					iRet = TS_OutPutMsg(gbl.dPosInfo,"\n请确认您有足够的酬金结转,并且结转金额小于1000元，请重新输入",0,iSelect);
					if ((iRet < 0 ) || (iSelect != 0))
					{
						return -1;
					}else
					{
						continue;
					}
					
				}else
					break;
			}
			
			bbzero(gbl.fee_type);
			strcpy(gbl.fee_type,"0170");
			pack.wrField(2, gbl);
			//bit48
			memset(pack.FIELD48, 0, sizeof(pack.FIELD48) );
			memcpy(pack.FIELD48, gbl.fee_type, 4);
			bbzero(tmp);
			sprintf(tmp,"%02d",gbl.card_no_len);
			memcpy(pack.FIELD48+4, tmp, 2);
			memcpy(pack.FIELD48+6,gbl.card_no,gbl.card_no_len);
			pack.Packet_Table[48].Real_Length = 6+gbl.card_no_len;
			iRet = packHdl(2);
			if(iRet < 0)
				return -1;
			memset(response_code, 0, sizeof(response_code));
			memcpy(response_code, pack.FIELD39, 2);
			if (!memcmp(response_code,"00",2)) 
			{
				bbzero(ecard_mny);
				bbzero(ecard_amount);
				bbzero(mny);
				bbzero(zr_amount);
				bbzero(zr_mny);
				bbzero(tax_mny);
				bbzero(tax_amount);
				memcpy(ecard_amount, pack.FIELD54 + 1, 12);
				memcpy(tax_amount, pack.FIELD63 + 12, 12);
				sprintf(zr_amount,"%12d",atoi(gbl.amount)-atoi(tax_amount));
				CTools::chgToMny(zr_amount,zr_mny);
				CTools::chgToMny(tax_amount,tax_mny);
				CTools::chgToMny(gbl.amount,mny);
				CTools::chgToMny(ecard_amount,ecard_mny);
				bbzero(tmp);
				sprintf(tmp,"   酬金结转成功！\n结转金额【%s】 = 钱包充值【%s】 + 代收税金【%s】\n钱包余额：%s",mny,zr_mny,tax_mny,ecard_mny);
				TS_OutPutMsg(gbl.dPosInfo,tmp,0,iSelect);
				return 0;
			}else
			{
				iRet = returnFail(response_code);
				return iRet;
			}
		}else if(!memcmp(pack.FIELD39,"55",2))
		{
			flag = 1;
			if(!memcmp(gbl.fee_type, "0094", 4))
				iRet = reGetPwd( "小灵通付费易卡查询");
			else
				iRet = reGetPwd( "e卡查询");
			
			if(iRet == 0) //密码错误，重新输入密码, 2006-10-25
				continue;
			else
				return CANCLE_KEY;
		}
		else
		{
			iRet = returnFail(response_code);
		}
		return iRet;
	}
	
	return 0;
}

// gbl.fee_type
// gbl.phone_no
// gbl.phone_len
// gbl.pos_serial
int CTrade::nameInqHdl(char *user_name, int *user_name_len,char *amount)
{
	int  iRet=0, iSelect=0;
	int  b48_len=0, phone_len=0;
	char tmp[20],party_code[7],correct_code[3];
	
	wrLog("【nameInqHdl】");
	if(memcmp("020",gbl.phone_no,3)==0){
		bbzero(tmp);
		sprintf(tmp,"0%s",gbl.phone_no);
		strcpy(gbl.phone_no,tmp); 
	}
	gbl.phone_len=strlen(gbl.phone_no);
	wrLog("phone[%d]: [%s]", gbl.phone_len, gbl.phone_no);
	
	/*---------------------------------------*/
	
	//写查询域
	pack.wrField(1, gbl);
	/************修改一些域*********/
	bbzero(pack.FIELD48);
	b48_len = 0;
	memcpy(pack.FIELD48+b48_len, gbl.fee_type, 4);
	b48_len += 4;
	sprintf((char *)pack.FIELD48+b48_len, "%02d", gbl.phone_len);
	b48_len += 2;
	memcpy(pack.FIELD48+b48_len, gbl.phone_no, gbl.phone_len);
	b48_len += gbl.phone_len;
	pack.Packet_Table[48].Real_Length = b48_len;
	/*******************************/
	//  查询包打包   
	iRet = packHdl(1);
	if(iRet < 0)
		return -1;
	bbzero(party_code);
	bbzero(correct_code);
    memcpy(party_code,&pack.FIELD62[1],6);
	memcpy(correct_code,&pack.FIELD62[1+6],2);
	wrLog("【nameInqHdl】respone_code:[%s],correct_code:[%s]",pack.FIELD39,correct_code);
	if (!memcmp(pack.FIELD39,"00",2)||(!memcmp(pack.FIELD39,"80",2)&&!memcmp(correct_code,"82",2))) 
	{
		//用户名
		sscanf((char *)pack.FIELD63, "%02d", user_name_len);
		memcpy(user_name, (char *)pack.FIELD63+2, *user_name_len);
		//总金额
		bbzero(amount);
		CTools::byte_to_hex(pack.FIELD4, (BYTE *)amount, 6);
		memcpy(pack.FIELD39,"00",2);
		return 0;
	}	
	else
	{
		return -2;
	}	
}

int CTrade::newAirPay(const char *title, int type_flag)
{
	int iSelect,iRet,flag,iRet2;
	char trade_type[2+1],fee_amount[12+1],fee_mny[12+1],fee_type[1+1],response_code[2+1];
	char temp[512],phone_mny[12+1],len_buff[2+1];
	char amoMny[12+1],amount[12+1];
	char phone_no_mark[20], fee_type_mark[4+1],buff[80+1],phone_buff[15], phone_area[10];
	int phone_owner=0,check_flag=0;
	
	iRet = get_area_biz(BIZ_AREA_BIZ_DX_ENQ, gbl.city_no, gbl.acc_city_no, gbl.fee_type);
	if( iRet==0 )
	{
		wrLog("gbl.fee_type = [%s]", gbl.fee_type);
	}
	else   
	{
		return -1;
	}
	
	bbzero(trade_type);
	if (type_flag ==1)
	{
		strcpy(trade_type,"01");
	}else if (type_flag ==2)
	{
		strcpy(trade_type,"03");
	}else if (type_flag ==3)
	{
		strcpy(trade_type,"04");
	}else 
		return -1;
	
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, title);
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入号码：");	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//全字符
	tradeInfoSend.Contents[0].uCount = 0;		//输入1次
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
	tradeInfoSend.Contents[0].uMinLen = 8;	
	tradeInfoSend.Contents[0].uMaxLen = 15;	
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	
	memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
	bbzero(gbl.phone_no);
	strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);	
	strcpy(gbl.phone_no,(char *)tradeInfoRecv.Contents[0].uMsg );
	gbl.phone_len = tradeInfoRecv.Contents[0].uMsgLen;
	
	if ((gbl.phone_no[0]=='1') && (type_flag==2))
	{
		TS_OutPutMsg(gbl.dPosInfo,"\n此业务只受理固话绑定的ADSL交费业务！",1,iSelect);
		return -1;
	}
	
	bbzero(phone_area);
	
	if(gbl.phone_no[0]=='1')//如果是手机
	{

		iRet=CDB::phone_district_qry(gbl.phone_no,gbl.phone_province,gbl.city_no,&gbl.phone_owner);
		if(iRet != 0)
		{

			TS_OutPutMsg(gbl.dPosInfo,"\n\n该号码不属于广东地区\n   请更换号码再试",0,iSelect);
			return -1;
		}

		strcpy(phone_area, gbl.phone_city);
	}
	
	if(gbl.phone_no[0]=='1')//如果是手机
	{
	
		if ( gbl.phone_owner != 1)
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n   输入的手机号错误\n 请确认输入的手机号码\n   为CDMA手机号！",1,iSelect);
			return -1;
		}
	}
	else if (gbl.phone_no[0]!='0')//如果不是手机且没输区号
	{
		char phone_no[20];
		bbzero(phone_no);
		strcpy(phone_no, gbl.phone_no);
		bbzero(gbl.phone_no);
		strcpy(gbl.phone_no, gbl.city_no);
		strcat(gbl.phone_no, phone_no);
		gbl.phone_len = strlen(gbl.phone_no);
	}
	
	//////////////////////////////////////////////////////////////////////////
	strcpy(fee_type_mark, gbl.fee_type);
	if(type_flag ==1){
		strcpy(gbl.fee_type, "0291");
    }else if (type_flag ==2)
	{
		strcpy(gbl.fee_type, "0291");//单独ADSL费用只取0291交易查到的用户名，不取金额
	}else if (type_flag ==3)
	{
		strcpy(gbl.fee_type, "0291");
	}else 
		return -1;
	
	strcpy(phone_no_mark, gbl.phone_no);	
	if(gbl.phone_no[0]=='1')//如果是手机
	{
		strcpy(gbl.phone_no, gbl.city_no);
		strcat(gbl.phone_no, phone_no_mark);
	}
	else
	{
		NULL;
	}
	
	bbzero(gbl.user_name);
	gbl.user_name_len = 0;
	bbzero(amount);
	gbl.timeout=10;
	iRet2=nameInqHdl(gbl.user_name, &(gbl.user_name_len),amount);
	
    gbl.timeout=0;
	strcpy(gbl.phone_no, phone_no_mark);
	strcpy(gbl.fee_type, fee_type_mark);
	gbl.phone_len = strlen(gbl.phone_no);
	CTools::get_time(gbl.pos_serial);
	//////////////////////////////////////////////////////////////////////////
	pack.wrField(1, gbl);	//写查询域
	/*----------------------------------*/
	bbzero(pack.FIELD3);
	CTools::hex_to_byte((BYTE *)"310000", pack.FIELD3, 6);
	
	bbzero(pack.FIELD63);
	memcpy(pack.FIELD63, trade_type, 2);
	pack.Packet_Table[63].Real_Length = 2;
	
	if(gbl.posInfo.enyFlag)	//加密改造
	{
		bbzero(pack.FIELD46);
		pack.FIELD46[0] = 0x39;
		pack.FIELD46[1] = 0x39;
		pack.Packet_Table[46].Real_Length = 2;
		
	}else{
		memcpy((char *)pack.FIELD46,"1",1);
		pack.Packet_Table[46].Real_Length=1;
	}
	
	/*----------------------------------*/
	//打查询包
	iRet = packHdl(1);
	if(iRet < 0)
		return -1;
	if (!memcmp(pack.FIELD39,"00",2)) 
	{   
		bbzero(fee_mny);
		bbzero(fee_amount);
		bbzero(fee_type);
		memcpy(fee_type,pack.FIELD63,1);
		memcpy(fee_amount,pack.FIELD63 + 1,12);
		CTools::chgToMny(fee_amount,fee_mny);
		
		flag=0;
		while (flag != 1)
		{
			memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
			memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
			
			bbzero(temp);
			if(atoi(gbl.dPosInfo.prmVer)>=9000){
				if(strlen(gbl.user_name)!=0)
				{   
					sprintf(temp, "用户名:%s 号码:%s ", gbl.user_name, gbl.phone_no);
				}
				else
				{
					sprintf(temp, "号码:%s ", gbl.phone_no);
				}	
			}
			else{  
				if(strlen(gbl.user_name)!=0&&strlen(gbl.user_name)<=16)
					sprintf(temp, "户名:%s ", gbl.user_name);
				else
					sprintf(temp, "号码:%s ", gbl.phone_no);	
			}
			strcpy(tradeInfoSend.acMainTitle,temp);
			tradeInfoSend.uHasTradeID = 1;
			tradeInfoSend.uTotalContents = 1;
			
			bbzero(temp);
			bbzero(buff);
			if (gbl.user_name_len>8)
			{
				memcpy(buff,gbl.user_name,6);
				strcat(buff,"*");
			}else
				strcpy(buff,gbl.user_name);
			
			if (memcmp(fee_type,"D",1)==0)
			{
				sprintf(temp, "欠费%s %s %s 请输金额",fee_mny,buff,gbl.phone_no);
			}else
				sprintf(temp, "余额%s %s %s 请输金额",fee_mny,buff,gbl.phone_no);
			if(atoi(gbl.dPosInfo.prmVer)>=9000)
			{
				strcpy(tradeInfoSend.Contents[0].acTitle,temp);
			}
			else{
				strcpy(tradeInfoSend.Contents[0].acTitle,tradeInfoSend.acMainTitle);
				strcat(tradeInfoSend.Contents[0].acTitle,temp);
			}
			
			tradeInfoSend.Contents[0].uCommand = TS_INPUT_MONEY;	//数字
			tradeInfoSend.Contents[0].uCount = 0;		//输入1次
			tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
			tradeInfoSend.Contents[0].uMinLen = 1;	
			tradeInfoSend.Contents[0].uMaxLen = 8;	
			
			iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
			if(iRet != 0)
			{
				wrLog("TS_TradeControl返回错误[%d]", iRet);
				wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
				return iRet;
			}
			
			memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
			bbzero(gbl.amount);
			strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);	
			strcpy(gbl.amount,(char *)tradeInfoRecv.Contents[0].uMsg );
			
			if ((atoi(gbl.amount)<3000) ||(atoi(gbl.amount)>50000) )
			{
				TS_OutPutMsg(gbl.dPosInfo,"充值金额为30元到500元之间，请重新输入金额",0,iSelect);
				if (iSelect!=0)
				{
					return -1;
				}else
					
					continue;
			}else
				break;
		}
		
		if(atoi(gbl.dPosInfo.prmVer)>=9000)
		{
			bbzero(amoMny);
			CTools::chgToMny(gbl.amount,amoMny);
			bbzero(temp);
			if (memcmp(gbl.phone_no,"1",1)==0)
			{
				bbzero(phone_buff);
				memcpy(phone_buff,gbl.phone_no,3);
				strcat(phone_buff,"-");
				memcpy(phone_buff+4,gbl.phone_no+3,4);
				strcat(phone_buff,"-");
				memcpy(phone_buff+9,gbl.phone_no+7,4);
				sprintf(temp, "%s\n\n号码：%s\t%s\n\n充值金额：%s\n\n【是 Enter】  【否 Esc】", title, phone_buff, phone_area, amoMny);
			}else if (memcmp(gbl.phone_no,"0",1)==0)
			{
				if ((memcmp(gbl.phone_no,"02",2)==0) || (memcmp(gbl.phone_no,"01",2)==0))
				{
					bbzero(phone_buff);
					memcpy(phone_buff,gbl.phone_no,3);
					memcpy(phone_buff+3,"-",1);
					memcpy(phone_buff+4,gbl.phone_no+3,gbl.phone_len-3);
					
				}else{
					bbzero(phone_buff);
					memcpy(phone_buff,gbl.phone_no,4);
					memcpy(phone_buff+4,"-",1);
					memcpy(phone_buff+5,gbl.phone_no+4,gbl.phone_len-4);
				}
				sprintf(temp, "%s\n\n号码：%s\t%s\n\n充值金额：%s\n\n【是 Enter】  【否 Esc】", title, phone_buff, phone_area, amoMny);
			}else
			{
				sprintf(temp, "%s\n\n号码：%s\t%s\n\n充值金额：%s\n\n【是 Enter】  【否 Esc】", title, gbl.phone_no, phone_area, amoMny);
			}
			iRet = TS_OutPutMsg(gbl.dPosInfo, temp, 0, iSelect);
			if(iSelect)
			{
				return -1;
			}
		}else{
			bbzero(amoMny);
			CTools::chgToMny(gbl.amount,amoMny);
			bbzero(temp);
			sprintf(temp, "%s\n号码：%s\t%s\n充值金额：%s\n按【确认】继续", title, gbl.phone_no, phone_area, amoMny);
			iRet = TS_OutPutMsg(gbl.dPosInfo, temp, 0, iSelect);
			if(iSelect)
			{
				return -1;
			}
		}
		
		/************刷卡****************/
		flag = 0;
		for(int curTry=0; curTry<MAXTRY; curTry++)
		{
			if(!flag)
			{
				iRet = mngCard_Hdl(title);
				if(iRet == CANCLE_KEY)
					return CANCLE_KEY;
				else if(iRet != 0)
					return -1;
			}
			pack.wrField(2, gbl);	//写交费域
			
			memcpy(pack.FIELD63+8, trade_type, 2);
			pack.Packet_Table[63].Real_Length = 10;
			
			//交费包
			iRet = packHdl(2);
			if(iRet < 0)
				return -1;
			
			memset(response_code,0,sizeof(response_code));
			memcpy(response_code,pack.FIELD39,2);
			if (!memcmp(response_code,"00",2)) 
			{
				bbzero(gbl.phone_amount);
				bbzero(phone_mny);
				bbzero(len_buff);
				memcpy(len_buff,pack.FIELD63,2);
				memcpy(gbl.phone_amount,pack.FIELD63+2+atoi(len_buff),12);
				
				bbzero(temp);
				if (atoi(gbl.phone_amount)>0)
				{
					CTools::chgToMny(gbl.phone_amount,phone_mny);					
					sprintf(temp,"      充值成功！\n号码余额：%s\n 按【确认】打印凭证",phone_mny);
				}else
					strcpy(temp,"\n      充值成功！\n 按【确认】打印凭证");
				iRet = TS_OutPutMsg(gbl.dPosInfo,temp,0,iSelect);
				if(iRet!=0 || iSelect==0)
				{
					CPrint prt;
					prt.set_in_par(gbl);
				//	prt.print_detail(2, title);	
					prt.print_pre_detail(pack,title);
				}
				
			}
			else if(!memcmp(response_code,"55",2))
			{
				
				flag = 1;
				if(reGetPwd(title) == 0) //密码错误，重新输入密码, 2006-10-25
					continue;
				else
					return CANCLE_KEY;
			}
			else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
			{
				TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
				if (iSelect!=0)
				{
					return -1;
				}else
					continue;
			}
			else
				returnFail(response_code);
			return 1;	
		}
		
	}else
		iRet = returnFail((char *)pack.FIELD39);
	return -1;
}


int CTrade::phone_pay_trade(const char *title)
{

	int iRet,iSelect;
	char showMsg[500];
	char errMsg[500];
	char phone_buff[20];
	bbzero(errMsg);
	bbzero(showMsg);
	char biz_name[20];
	bbzero(biz_name);
	char showPhoneNo[20];

	bbzero(showPhoneNo);


	//选择充值金额
 	iRet=selectAmount();

	if(iRet == CANCLE_KEY)
		return CANCLE_KEY;
	else if(iRet < 0)
		return -1;

	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, title);
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;

	strcpy(tradeInfoSend.Contents[0].acTitle,"请输入手机号码 本业务不支持冲正"); 
	tradeInfoSend.Contents[0].uCommand=TS_INPUT_MATH;
	tradeInfoSend.Contents[0].uTimeOut=EPOS_OVER_TIME;
	tradeInfoSend.Contents[0].uCount = 0;		//输入1次		
	tradeInfoSend.Contents[0].uMinLen = 11;//手机号码长度11 		
	tradeInfoSend.Contents[0].uMaxLen = 11;//手机号码长度11
		
	iRet=TS_TradeControl(&gbl.dPosInfo,&tradeInfoSend,&tradeInfoRecv);		
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		return iRet;
	}
	

	memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
	strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
	bbzero(gbl.phone_no);
	strcpy(gbl.phone_no,(char *) tradeInfoRecv.Contents[0].uMsg);

	bbzero(phone_buff);
	memcpy(phone_buff,gbl.phone_no,3);
	strcat(phone_buff,"-");
	memcpy(phone_buff+4,gbl.phone_no+3,4);
	strcat(phone_buff,"-");
	memcpy(phone_buff+9,gbl.phone_no+7,4);
	//获取手机归属地。
	//查询号码所在的运营商
	

	iRet=CDB::phone_district_qry(gbl.phone_no,gbl.phone_province,gbl.phone_city,&gbl.phone_owner);
	if (iRet==-1)
	{
		bbzero(showMsg);
		TS_OutPutMsg(gbl.dPosInfo,"查无此号码，请查证后再输入!",0,iSelect);
		return -1;

	}

	
	CTools::shildWords(gbl.phone_no,3,4,showPhoneNo);
	wrLog("输入号码为:%s",showPhoneNo);


	switch (atoi(gbl.fee_type))
	{
		case 367:

			bbzero(biz_name);
			strcpy(biz_name,"电信");
			if (gbl.phone_owner!=1)
			{
				bbzero(showMsg);
				TS_OutPutMsg(gbl.dPosInfo,"本业务支持电信手机号充值，请输入电信号码",0,iSelect);
				return -1;
			}

			sprintf(showMsg,"\n\n号码:%s  %s\n充值金额:%.2f元\n应付金额:%.2f元\n\n\n【提示】本充值不支持冲正，请核对充值手机号码、充值金额，确认充值信息无误 \n\n是【Enter】 否【Esc】",phone_buff,gbl.phone_city,atof(gbl.origAmount)/100,atof(gbl.amount)/100);
			break;
		case 370:

			bbzero(biz_name);
			strcpy(biz_name,"联通");

			if (gbl.phone_owner!=3)
			{
				bbzero(showMsg);
				TS_OutPutMsg(gbl.dPosInfo,"本业务支持联通手机号充值，请输入联通号码",0,iSelect);
				return -1;
			}
			sprintf(showMsg,"\n充值手机号:%s  %s\n充值面值:%.2f元\n应付金额:%.2f元\n\n【提示】本充值不支持冲正，请核对充值手机号码、充值金额，确认充值信息无误 \n\n按【Esc】返回　按【Enter】继续 ",phone_buff,gbl.phone_city,atof(gbl.origAmount)/100,atof(gbl.amount)/100);
			break;

		case 369:

			bbzero(biz_name);
			strcpy(biz_name,"移动");

			if (gbl.phone_owner!=2)
			{
				bbzero(showMsg);
				TS_OutPutMsg(gbl.dPosInfo,"本业务支持移动手机号充值，请输入移动号码",0,iSelect);
				return -1;
			}
			sprintf(showMsg,"\n充值手机号:%s  %s\n充值面值:%.2f元\n应付金额:%.2f元\n\n【提示】本充值不支持冲正，请核对充值手机号码、充值金额，确认充值信息无误 \n\n按【Esc】返回　按【Enter】继续 ",phone_buff,gbl.phone_city,atof(gbl.origAmount)/100,atof(gbl.amount)/100);
			break;
		default:
			return CANCLE_KEY;

	}

	iRet=TS_OutPutMsg(gbl.dPosInfo,showMsg,1,iSelect);
	if (iSelect ==CANCLE_KEY || iRet!=0)
	{
		return CANCLE_KEY;
	}

	//判断同一号码是否有限制
	if(CDB::chKChinaUnicom(gbl.fee_type, gbl.phone_no, atoi(gbl.amount))==0)
	{
		NULL;
	}

	else
	{
		bbzero(showMsg);
		sprintf(showMsg, "业务运营商规定：\n同一号码%s\n同一金额%d元\n%d分钟内不能连续充值\n请稍后再试", gbl.phone_no, atoi(gbl.amount)/100,FORBID_TIME);
		TS_OutPutMsg(gbl.dPosInfo, showMsg, 1, iSelect);

		return -1;
	}


	iRet=pay(title,errMsg);

	if (iRet!=0)
	{
		if (iRet==-5) 
		{

			bbzero(showMsg);
			sprintf(showMsg,"\n%s系统繁忙，请稍后再试!\n如果交易结果不明确请使用[821]查询最后一笔交易",biz_name); //界面提示，如果交易结果不明确，请做最后一笔交易查询
			TS_OutPutMsg(gbl.dPosInfo,showMsg,0,iSelect);
			return CANCLE_KEY;

		}
		else
		{
		
			bbzero(showMsg);
			sprintf(showMsg," %s",errMsg); //界面提示，如果交易结果不明确，请做最后一笔交易查询
			TS_OutPutMsg(gbl.dPosInfo,showMsg,0,iSelect);
			return CANCLE_KEY;
		}

	}
	
	bbzero(showMsg);
	sprintf(showMsg,"业务受理成功!\n\n系统参考号:%s\n手机号码:%s\n充值面值:%.2f元\n\n\n按确认打印凭证 【Enter】是 【Esc】否\n\n 【注意】由于电信账务系统话费信息暂未实现实时更新，充值成功后话费明细可能与实际不一致，建议充值成功10分钟后再查询明细",gbl.stan_no,gbl.phone_no,atof(gbl.origAmount)/100);
	iRet=TS_OutPutMsg(gbl.dPosInfo,showMsg,0,iSelect);
	
	if (iSelect!=0)
	{
		return 0;
	}
	
	//打印信息
	CPrint print;
	print.set_in_par(gbl);
	print.print_phonePay_detail(title);

	return 0;
}


//type_flag 单号号码充值为1，2 adsl ；3是综合充值 。

int CTrade::DZDBAirPay(const char *title, int type_flag, int functype)
{

	int iSelect,iRet,flag, phone_len_bak, print_type;
	long print_fee;
	char trade_type[2+1],fee_amount[12+1],fee_mny[12+1],fee_type[1+1],response_code[2+1];
	char temp[512],phone_mny[12+1],len_buff[2+1];
	char amoMny[15+1],amount[12+1];
	char  phone_no_bak[30], city_no_bak[5];
	char fee_type_mark[4+1],buff[80+1],phone_buff[15],phone_mark[16], phone_area[10];
	int phone_owner=0;
	int print_flag=0,telphone_flag=0, prepay_flag;
	char userName[61];//asdl 用户名
	char errMsg[500];

	bbzero(errMsg);

	iRet = get_area_biz(BIZ_AREA_BIZ_DX_DZDB_ENQ, gbl.city_no, gbl.acc_city_no, gbl.fee_type);

	if( iRet==0 )
	{
		wrLog("gbl.fee_type = [%s]", gbl.fee_type);
	}
	else   
		
	{
		TS_OutPutMsg(gbl.dPosInfo, "\n【温馨提示】\n本地区电信直充暂未开通，请选择【221】电信充值付费卡进行电信号码充值",0,iSelect);
		return -1;
	}

	bbzero(trade_type);
	bbzero(temp);
	//保存区号
	bbzero(city_no_bak);
	strcpy(city_no_bak, gbl.city_no); //区号默认是终端对应地区
	
	if (type_flag ==1)
	{
		strcpy(trade_type,"01");
		strcpy(temp, "请输入号码：（固话需先输入区号）");
	}else if (type_flag ==2)
	{
		strcpy(trade_type,"03");
		strcpy(temp, "请输入号码：（若有字母不区分大小写，固话需先输入区号）");
	}else if (type_flag ==3)
	{
		strcpy(trade_type,"04");
		strcpy(temp, "请输入号码：（固话需先输入区号）");
	}else 
		return -1;
	
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	
	if(functype == 0)	//第一次进入函数，输入号码并显示列表
	{
	
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
		
		strcpy(tradeInfoSend.acMainTitle, title);
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents = 1;
		
		strcpy(tradeInfoSend.Contents[0].acTitle, temp);	
		if (type_flag==1) //如果是电信单个号码充值
		{
			tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//全是数字
			tradeInfoSend.Contents[0].uCount = 0;		//输入1次
			tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
			tradeInfoSend.Contents[0].uMinLen = 7;	
			tradeInfoSend.Contents[0].uMaxLen = 12;	
		}
		else
		{
			tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//全字符
			tradeInfoSend.Contents[0].uCount = 0;		//输入1次
			tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
			tradeInfoSend.Contents[0].uMinLen = 7;	
			tradeInfoSend.Contents[0].uMaxLen = 50;	

		}

		gbl.phone_len = 0;
		while(gbl.phone_len < 7)
		{
			iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
			if(iRet != 0)
			{
				wrLog("TS_TradeControl返回错误[%d]", iRet);
				wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
				return iRet;
			}
			
			memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
			bbzero(gbl.phone_no);
			strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);	
			memcpy(gbl.phone_no,(char *)tradeInfoRecv.Contents[0].uMsg, tradeInfoRecv.Contents[0].uMsgLen);
			CTools::trim(gbl.phone_no);
			gbl.phone_len = strlen(gbl.phone_no);
			bbzero(userName);//初始化userName
			
		}
		
		//针对中山地区做号码转换，从t_num_chg_list获取 ，针对按照ASDL业务
		if(type_flag == 2 && strcmp(gbl.city_no, "0760")==0 &&(CTools::isAllNum(gbl.phone_no))==1) //限制为中山地区 0760 
		{
			char phone_no[50];
			iRet = CDB::getRealNum(gbl.phone_no, phone_no,userName); //获取真实的电话号码及用户姓名
			
			if(!iRet)
			{
				
				strcpy(gbl.phone_no, phone_no);
				gbl.phone_len = strlen(gbl.phone_no);
				bbzero(phone_no_bak);
				memcpy(phone_no_bak, gbl.phone_no, gbl.phone_len);
				phone_len_bak = gbl.phone_len;
				wrLog("gbl.phone_no:%s",gbl.phone_no);//输出电话号码
				
				wrLog("userName:%s",userName);			
				
			}
			
			else
				
			{
				TS_OutPutMsg(gbl.dPosInfo, "对不起,充值号码不存在", 0, iSelect); //界面上显示不成功的信息
				return -1;
				
			}
		}
		
		
		if ((gbl.phone_no[0]=='1') && (type_flag==2))
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n此业务只受理固话绑定的ADSL交费业务！",1,iSelect);
			return -1;
		}
		
		bbzero(phone_area);
		
		if(gbl.phone_no[0]=='1' )//如果是手机 单个号码充值才可以进行全国充值，其他暂时只支持广东省内的充值缴费
		{	
			
			bbzero(gbl.phone_city);
			bbzero(gbl.phone_province);
			iRet =CDB::phone_district_qry(gbl.phone_no,gbl.phone_province,gbl.phone_city,&gbl.phone_owner); //如果 不是广东省的，走全国话费充值接口
			
			if (gbl.phone_owner!=1)
			{
				TS_OutPutMsg(gbl.dPosInfo,"\n本业务支持电信号码充值，请更换号码重试",1,iSelect);
				return -1;

			}

			if (iRet!=0 ) //如果查询不到手机号码对应的归属地。去全国充值接口充值
			{
				if (gbl.phone_owner==1) //电信号码 进入全国充值
				{
					
					TS_OutPutMsg(gbl.dPosInfo,"该号码不属于广东省内号码，请更改号码重试",1,iSelect);
					return -1;

				}
				else // 省外非广东号码或者未知运营商的号码
					{
						TS_OutPutMsg(gbl.dPosInfo,"本业务支持电信号码充值，请更改号码再试!",1,iSelect);
						return -1;

					}
			}
			
			strcpy(phone_area, gbl.phone_city); 
			//电信直充低费率
			//0321才可以转换为低费率
			if(!strcmp(gbl.fee_type, "0321")) 
			{
				if(!strcmp(phone_area, "汕头") || !strcmp(phone_area, "揭阳") || !strcmp(phone_area, "潮州")
					|| !strcmp(phone_area, "梅州"))
				{
					strcpy(gbl.fee_type, "0344");
					wrLog("低酬金地区fee_type change [%s]", gbl.fee_type);
				}
			}
		}
	
		else if (gbl.phone_no[0] == '0' && strlen(gbl.phone_no) > 9)//如果不是手机且输区号
		{
			char phone_no[20];
			bbzero(phone_no);
			strcpy(phone_no, gbl.phone_no);
			//三位区号//北京：010 广州：020 上海：021 天津：022 重庆：023 辽宁：024 
			//	南京：025 	武汉：027 	成都：028 西安：029
			if( strncmp(gbl.phone_no, "02", 2) == 0 || strncmp(gbl.phone_no,"01",2)==0 ) 
			{
				bbzero(city_no_bak);
				bbzero(gbl.phone_no);
				memcpy(city_no_bak, phone_no, 3);
				memcpy(gbl.phone_no, phone_no + 3, strlen(phone_no) - 3);
			}
			else //四位的终端号
			{
				bbzero(city_no_bak);
				bbzero(gbl.phone_no);
				memcpy(city_no_bak, phone_no, 4);
				memcpy(gbl.phone_no, phone_no + 4, strlen(phone_no) - 4);
			}

			
		}
		
		if(type_flag == 2 && strlen(gbl.phone_no) < 9)	//如果是固话+D形式则在固话去D
		{
			bbzero(temp);
			memcpy(temp, gbl.phone_no + strlen(gbl.phone_no) - 1, 1);
			if(strcmp("D", temp) == 0)
			{
				bbzero(temp);
				strcpy(temp, gbl.phone_no);
				bbzero(gbl.phone_no);
				strncpy(gbl.phone_no, temp, strlen(temp) - 1);
			}
		}
		
		gbl.phone_len = strlen(gbl.phone_no);
		
		bbzero(phone_no_bak);
		memcpy(phone_no_bak, gbl.phone_no, gbl.phone_len);
		phone_len_bak = gbl.phone_len;
		
	}
	
	//////////////////////////////////////////////////////////////////////////
	
	if (gbl.phone_no[0] != '1')//如果不是手机且没输区号
	{
		char phone_no[20];
		bbzero(phone_no);
		strcpy(phone_no, gbl.phone_no);
		bbzero(gbl.phone_no);
		strcpy(gbl.phone_no, city_no_bak);
		strcat(gbl.phone_no, phone_no);
		gbl.phone_len = strlen(gbl.phone_no);
	}
	
	//对固话进行控制，如果是省外固话，不允许充值
	if (gbl.phone_no[0] !='1' )
	{

		bbzero(gbl.phone_city);
		bbzero(phone_area);
		iRet=CDB::is_gd_district(city_no_bak,phone_area); //判断是是否是广东地区的固话。
		if(iRet!=0) 
		{
		
			TS_OutPutMsg(gbl.dPosInfo,"\n对不起，本业务固话充值仅支持广东省内固话号码,请更换号码重试",1,iSelect);
			return -1;
		}
		
	}
	/*
	//地区限制：揭阳：0663，潮州：0768，汕头：0754 和 0661，梅州：0753
	if(strcmp(gbl.city_no, "0663") && strcmp(gbl.city_no, "0768") && strcmp(gbl.city_no, "0754") 
	&& strcmp(gbl.city_no, "0661") && strcmp(gbl.city_no, "0753"))
	{
	if(!strcmp(city_no_bak, "0663") || !strcmp(city_no_bak, "0768") || !strcmp(city_no_bak, "0754")
	|| !strcmp(city_no_bak, "0661") || !strcmp(city_no_bak, "0753"))
	{
	TS_OutPutMsg(gbl.dPosInfo, "本终端暂不支持此号码地区", 0, iSelect);
	return -1;
	}
	}
	*/
	
	
	//以下地区酬金较低：揭阳：0663，潮州：0768，汕头：0754 和 0661，梅州：0753。
	//0321才能转换为低费率
	if(!strcmp(gbl.fee_type, "0321")) 
	{
		if(!strcmp(city_no_bak, "0663") || !strcmp(city_no_bak, "0768") || !strcmp(city_no_bak, "0754")
			|| !strcmp(city_no_bak, "0661") || !strcmp(city_no_bak, "0753"))
		{
			strcpy(gbl.fee_type, "0344");
			wrLog("低酬金地区fee_type change [%s]", gbl.fee_type);
		}
	}
	
	CTools::get_time(gbl.pos_serial);
	//////////////////////////////////////////////////////////////////////////
	pack.wrField(1, gbl);	//写查询域
	/*----------------------------------*/
	bbzero(pack.FIELD3);
	CTools::hex_to_byte((BYTE *)"310000", pack.FIELD3, 6);
	
	bbzero(pack.FIELD63);
	memcpy(pack.FIELD63, trade_type, 2);
	pack.Packet_Table[63].Real_Length = 2;
	
	/*
	//ASDL 电信直充
	if(type_flag == 2)
	{
	bbzero(pack.FIELD48);
	memcpy(pack.FIELD48, "0321", 4);
	bbzero(temp);
	sprintf(temp, "%02d", strlen(gbl.city_no) + strlen(gbl.phone_no));
	memcpy(pack.FIELD48 + 4, temp, 2);
	memcpy(pack.FIELD48 + 6, gbl.city_no, strlen(gbl.city_no));
	memcpy(pack.FIELD48 + 6 + strlen(gbl.city_no), gbl.phone_no, gbl.phone_len);
	pack.Packet_Table[48].Real_Length = 6 + strlen(gbl.city_no) + strlen(gbl.phone_no);
	wrLog((char*)pack.FIELD48);
	}
	*/
	/*----------------------------------*/
	//打查询包
	iRet = packHdl(1);
	if(iRet < 0)
		return -1;
	if (!memcmp(pack.FIELD39,"00",2)) 
	{   
		bbzero(fee_mny);
		bbzero(fee_amount);
		bbzero(fee_type);
		memcpy(fee_type,pack.FIELD63,1);
		memcpy(fee_amount,pack.FIELD63 + 1,12);
		CTools::chgToMny(fee_amount,fee_mny);
		print_fee = atol(fee_amount);
		if (memcmp(fee_type,"D",1)==0)
		{	
			print_fee = -print_fee;
		}
		
		bbzero(gbl.user_name);
		gbl.user_name_len = 0;
		bbzero(amount);
		
		bbzero(fee_type_mark);
		strcpy(fee_type_mark,gbl.fee_type);
		bbzero(gbl.fee_type);
		strcpy(gbl.fee_type,"0326");
		
		if (gbl.phone_no[0]=='1')
		{
			bbzero(phone_mark);
			strcpy(phone_mark,gbl.phone_no);
			bbzero(gbl.phone_no);
			strcpy(gbl.phone_no, city_no_bak);
			strcat(gbl.phone_no, phone_mark);
			gbl.phone_len = strlen(gbl.phone_no);
			telphone_flag = 1;
		}
		
		pack.wrField(1, gbl);	//写查询域
		/*----------------------------------*/
		bbzero(pack.FIELD3);
		CTools::hex_to_byte((BYTE *)"310000", pack.FIELD3, 6);
		
		bbzero(pack.FIELD63);
		memcpy(pack.FIELD63, "000000", 6);
		if (type_flag == 3)
		{
			memcpy(pack.FIELD63+6, "1", 1);
		}else
			memcpy(pack.FIELD63+6, "0", 1);
		pack.Packet_Table[63].Real_Length = 7;
		
		
		/*----------------------------------*/
		//打查询包
		iRet = packHdl(1);
		if(iRet < 0)
			return -1;
		
		if (!memcmp(pack.FIELD39,"00",2)) 
		{
			if( DZDBRdField63() )	//保留查询返回信息供打印和显示信息用
				
				print_flag = 1;

		}else
		{
			print_flag = 1;
		}
		
		iRet = -1;

		if (strlen(gbl.user_name)!=0) //修改 by liuxiao 20130423
		{
			prepay_flag = 0; //后付费标志
		}
		else
		{
			prepay_flag = 1; //预付费
			
		}
		if (type_flag == 3)
		{
			iRet = pep_query_hdl(city_no_bak, phone_no_bak, "0", "1", type_flag);
		}
		else if (type_flag == 2)
		{
			if(strlen(phone_no_bak) < 10 && CTools::IsDigit(phone_no_bak) == 0 )
			{
				strcat(phone_no_bak, "D");
				//strcat(gbl.phone_no, "D");
				//gbl.phone_len += 1;
			}
			iRet = pep_query_hdl(city_no_bak, phone_no_bak, "0", "0", type_flag);
		}
		else
		{
			iRet = pep_query_hdl(city_no_bak, phone_no_bak, "0", "0", type_flag);		
		}
		
		if (telphone_flag == 1)
		{
			bbzero(gbl.phone_no);
			strcpy(gbl.phone_no,phone_mark);
			gbl.phone_len = strlen(gbl.phone_no);
		}
		
		bbzero(gbl.fee_type);
		strcpy(gbl.fee_type,fee_type_mark);
		
		//TS_OutPutMsg(gbl.dPosInfo, gbl.phone_no, 0, iSelect);
		
		if(phone_len_bak < 10)
		{
			bbzero(temp);
			strcpy(temp, phone_no_bak);
			bbzero(phone_no_bak);
			strcpy(phone_no_bak, city_no_bak);
			strcat(phone_no_bak, temp);
			phone_len_bak = strlen(phone_no_bak);
		}
		
		if(gbl.posInfo.leftType ==  12)
		{
			print_type = 1;
			iRet = TS_OutPutMsg(gbl.dPosInfo, "【温馨提示】\n1.必须一次缴清当前欠费，否则不打印明细发票，只打印实际充值金额；\n2.若当前实际欠费为零，不打印明细发票，只打印实际充值金额。", 0, iSelect);
			if(iRet != 0)
			{
				return -1;
			}
		}
		
		
		flag=0;
		while (flag != 1)
		{
			memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
			memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
			
			bbzero(temp);
			
			if(atoi(gbl.dPosInfo.prmVer)>=9000)
			{
				
				if(strlen(gbl.user_name)!=0) //如果用户名存在
					
				{   
					sprintf(temp, "用户名:% s号码:%s ", gbl.user_name, phone_no_bak);
					
				}
				
				else
					
				{ 
					
					if(type_flag == 2 && strcmp(gbl.city_no, "0760")==0 &&strlen(userName)!=0) //限制为中山地区ASDL
					{
						
						wrLog("userName:%s",userName);
						strcpy(gbl.user_name,userName);//赋值给gbl.user_name
						
						sprintf(temp,"用户名:%s 号码:%s",gbl.user_name,phone_no_bak);
						
					}
					
					else 
						
					{
						sprintf(temp,"号码：%s",phone_no_bak);
						
						
					}
					
					
				}	
				
				
			}
			
			else 
				
			{  
				
				if(strlen(gbl.user_name)!=0&&strlen(gbl.user_name)<=16) //如果gbl.username有返回
					
				{
					
					sprintf(temp, "户名:%s ",gbl.user_name);
				}
				
				else
					
				{
					
					if(type_flag == 2 && strcmp(gbl.city_no, "0760")==0 &&strlen(userName)!=0&&strlen(userName)<=16) //限制为中山地区ASDL充值
					{
						wrLog("userName:%s",userName);
						strcpy(gbl.user_name,userName);
						sprintf(temp,"户名:%s",gbl.user_name);
					}
					
					else
						
					{
						sprintf(temp,"号码：%s",phone_no_bak);
						
					}
					
				}
						
				
			}
			
			strcpy(tradeInfoSend.acMainTitle,temp);
			tradeInfoSend.uHasTradeID = 1;
			tradeInfoSend.uTotalContents = 1;
			
			bbzero(temp);
			bbzero(buff);
			if (gbl.user_name_len>8)
			{
				memcpy(buff,gbl.user_name,6); //username
				strcat(buff,"*");
			}else
				strcpy(buff,gbl.user_name);
			
			if(atoi(gbl.dPosInfo.prmVer)>=9000)
			{
				if (memcmp(fee_type,"D",1)==0)
				{
					sprintf(temp, "欠费%s %s %s 请输金额",fee_mny,buff,phone_no_bak);
				}else
				{
					sprintf(temp, "余额%s %s %s 请输金额",fee_mny,buff,phone_no_bak);
				}
				if(prepay_flag == 1)
				{
					strcat(temp, "(范围：30元-500元)");
				}
				else
				{
					strcat(temp, "(范围：10元-500元)");
				}
				strcpy(tradeInfoSend.Contents[0].acTitle,temp);
			}
			else
			{
				if (memcmp(fee_type,"D",1)==0)
				{
					sprintf(temp, "欠费%s 请输金额",fee_mny);
				}else
				{
					sprintf(temp, "余额%s 请输金额",fee_mny);
				}
				if(prepay_flag == 1)
				{
					strcat(temp, "(范围：30元-500元)");
				}
				else
				{
					strcat(temp, "(范围：10元-500元)");
				}
				strcpy(tradeInfoSend.Contents[0].acTitle,tradeInfoSend.acMainTitle);
				strcat(tradeInfoSend.Contents[0].acTitle,temp);
			}
			
			tradeInfoSend.Contents[0].uCommand = TS_INPUT_MONEY;	//数字
			tradeInfoSend.Contents[0].uCount = 0;		//输入1次
			tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+20;	//超时50秒
			tradeInfoSend.Contents[0].uMinLen = 1;	
			tradeInfoSend.Contents[0].uMaxLen = 8;	
			
			iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
			if(iRet != 0)
			{
				wrLog("TS_TradeControl返回错误[%d]", iRet);
				wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
				return iRet;
			}
			
			memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
			bbzero(gbl.amount);
			strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);	
			strcpy(gbl.amount,(char *)tradeInfoRecv.Contents[0].uMsg );
			
			if ( prepay_flag == 1 && ((atoi(gbl.amount)<3000) ||(atoi(gbl.amount)>50000))) //修改充值范围为500元
			{
				continue;
			}
			else if((atoi(gbl.amount)<1000) ||(atoi(gbl.amount)>50000))  //修改充值范围为500元
			{
				continue;
			}
			else if(atoi(gbl.amount) + print_fee < 0 && gbl.posInfo.leftType ==  12 && gbl.bill_list_len != 0)
			{
				iRet = TS_OutPutMsg(gbl.dPosInfo, "【温馨提示】尊敬的用户，您的充值金额少于欠费金额，如果选择继续，打印发票将无欠费明细。\n 【确认】继续  【取消】重新输入充值金额", 0, iSelect);
				if(iRet != 0)
				{
					return -1;
				}
				if(iSelect != 0)
				{
					continue;
				}
				else
				{
					wrLog("【未交齐欠费，发票不打印明细】");
					gbl.bill_list_len = 0;
					break;
				}
			}
			else
				break;
			}
			
			if(CDB::chKChinaUnicom(gbl.fee_type, gbl.phone_no, atoi(gbl.amount))==0)
			{
				NULL;
			}
			else
			{
				bbzero(temp);
				sprintf(temp, "业务运营商规定：\n同一号码%s\n同一金额%d元\n%d分钟内不能连续充值\n请稍后再试", gbl.phone_no, atoi(gbl.amount)/100,FORBID_TIME);
				TS_OutPutMsg(gbl.dPosInfo, temp, 1, iSelect);

				return -1;
			}
			/*
			//如果多个账期，交费未交齐，发票不打印明细，gbl.bill_list_len = 0;
			if(print_type == 2 && atol(gbl.amount) < -print_fee)
			{
			wrLog("【多个账期并且未交齐欠费，发票不打印明细】");
			gbl.bill_list_len = 0;
			}*/
			
			if(atoi(gbl.dPosInfo.prmVer)>=9000)
			{
				bbzero(amoMny);
				CTools::chgToMny(gbl.amount,amoMny);
				bbzero(temp);
				if (memcmp(gbl.phone_no,"1",1)==0)
				{
					bbzero(phone_buff);
					memcpy(phone_buff,gbl.phone_no,3);
					strcat(phone_buff,"-");
					memcpy(phone_buff+4,gbl.phone_no+3,4);
					strcat(phone_buff,"-");
					memcpy(phone_buff+9,gbl.phone_no+7,4);
					sprintf(temp, "%s\n\n号码：%s\t%s\n\n充值金额：%s\n\n", title, phone_buff,  phone_area, amoMny);
					if(type_flag == 1 || type_flag == 2)
					{
						strcat(temp, "提示：仅对单个号码充值，未包含e家套餐的其他号码。\n其他号码仍可能欠费，如需缴纳e家套餐费用请选用【223】\n\n");
					}
					else
					{
						strcat(temp, "您使用的是绑定业务充值，可抵扣套餐下所有号码费用。\n");
					}
					strcat(temp, "【是 Enter】  【否 Esc】");
				}else if (memcmp(gbl.phone_no,"0",1)==0)
				{
					if ((memcmp(gbl.phone_no,"02",2)==0) || (memcmp(gbl.phone_no,"01",2)==0))
					{
						bbzero(phone_buff);
						memcpy(phone_buff,gbl.phone_no,3);
						memcpy(phone_buff+3,"-",1);
						memcpy(phone_buff+4,gbl.phone_no+3,gbl.phone_len-3);
						
					}else{
						bbzero(phone_buff);
						memcpy(phone_buff,gbl.phone_no,4);
						memcpy(phone_buff+4,"-",1);
						memcpy(phone_buff+5,gbl.phone_no+4,gbl.phone_len-4);
					}
					sprintf(temp, "%s\n\n号码：%s\t%s\n\n充值金额：%s\n\n", title, phone_buff, phone_area, amoMny);
					if(type_flag == 1 || type_flag == 2)
					{
						strcat(temp, "提示：仅对单个号码充值，未包含e家套餐的其他号码。\n其他号码仍可能欠费，如需缴纳e家套餐费用请选用【223】\n\n");
					}
					else
					{
						strcat(temp, "您使用的是绑定业务充值，可抵扣套餐下所有号码费用。\n");
					}
					strcat(temp, "【是 Enter】  【否 Esc】");
				}else
				{
					sprintf(temp, "%s\n\n号码：%s\t%s\n\n充值金额：%s\n\n", title, gbl.phone_no, phone_area, amoMny);
					if(type_flag == 1 || type_flag == 2)
					{
						strcat(temp, "提示：仅对单个号码充值，未包含e家套餐的其他号码。\n其他号码仍可能欠费，如需缴纳e家套餐费用请选用【223】\n\n");
					}
					else
					{
						strcat(temp, "您使用的是绑定业务充值，可抵扣套餐下所有号码费用。\n");
					}
					strcat(temp, "【是 Enter】  【否 Esc】");
				}
				iRet = TS_OutPutMsg(gbl.dPosInfo, temp, 0, iSelect);
				if(iSelect)
				{
					return -1;
				}
			}else{
				bbzero(amoMny);
				CTools::chgToMny(gbl.amount,amoMny);
				bbzero(temp);
				sprintf(temp, "%s\n号码：%s\t%s\n充值金额：%s\n", title, gbl.phone_no, phone_area, amoMny);
				if(type_flag == 1 || type_flag == 2)
				{
					strcat(temp, "提示：仅对单个号码充值，未包含e家套餐的其他号码。\n");
				}
				else
				{
					strcat(temp, "您使用的是绑定业务充值，可抵扣套餐下所有号码费用。\n");
				}
				strcat(temp, "按【确认】继续");
				
				iRet = TS_OutPutMsg(gbl.dPosInfo, temp, 0, iSelect);
				if(iSelect)
				{
					return -1;
				}
			}
			
			/************刷卡****************/
			flag = 0;
			for(int curTry=0; curTry<MAXTRY; curTry++)
			{
				if(!flag)
				{
					iRet = mngCard_Hdl(title);
					if(iRet == CANCLE_KEY)
						return CANCLE_KEY;
					else if(iRet != 0)
						return -1;
				}
				pack.wrField(2, gbl);	//写交费域
				
				memcpy(pack.FIELD63+8, trade_type, 2);
				pack.Packet_Table[63].Real_Length = 10;
				
				//交费包
				iRet = packHdl(2);
				if(iRet < 0)
					return -1;
				
				bbzero(gbl.stan_no);
				memcpy(gbl.stan_no,(char *)pack.FIELD37,12);
				
				memset(response_code,0,sizeof(response_code));
				memcpy(response_code,pack.FIELD39,2);
				if (!memcmp(response_code,"00",2)) 
				{
					bbzero(gbl.phone_amount);
					bbzero(phone_mny);
					bbzero(len_buff);
					memcpy(len_buff,pack.FIELD63,2);
					memcpy(gbl.phone_amount,pack.FIELD63+2+atoi(len_buff),12);
					
					bbzero(temp);
					if (atoi(gbl.phone_amount)>0)
					{
						CTools::chgToMny(gbl.phone_amount,phone_mny);					
						sprintf(temp,"      充值成功！\n号码余额：%s\n\n 按【确认】打印凭证\n\n\n\n\n\n\n\n\n\n【注意】由于电信帐务系统话费信息暂未实现实时更新，充值成功后查询话费明细可能与实际不一致，建议充值成功10分钟后再查询明细。",phone_mny);
					}else
						strcpy(temp,"\n      充值成功！\n\n 按【确认】打印凭证\n\n\n\n\n\n\n\n\n\n【注意】由于电信帐务系统话费信息暂未实现实时更新，充值成功后查询话费明细可能与实际不一致，建议充值成功10分钟后再查询明细。");

					iRet = TS_OutPutMsg(gbl.dPosInfo,temp,0,iSelect);
					
					if(!iRet && !iSelect)
					{
						CPrint prt;
						prt.set_in_par(gbl);

						if(gbl.posInfo.leftType ==  12)
						{
							if(strcmp(gbl.city_no,"0763")==0)//如果是清远市city_no 0763。则用新版的发票
							{
								
								prt.print_new_pep_detail(print_fee,print_type);//使用新版的发票
							}
							else if (strcmp(gbl.city_no,"0752")==0) //惠州地区发票 0752
							{
								prt.print_huizhou_pep_detail(print_fee,print_type);

							}
							else
							{
								
								prt.print_pep_detail(print_fee, print_type);//使用旧版的发票
								
							}
							
							
						}
						else
						{
						//	prt.print_detail(2, title); 
							prt.print_pre_detail(pack,title);
							
						}
					}
					
				}
				else if(!memcmp(response_code,"55",2))
				{
					
					flag = 1;
					if(reGetPwd(title) == 0) //密码错误，重新输入密码, 2006-10-25
						continue;
					else
						return CANCLE_KEY;
				}
				else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
				{
					TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
					if (iSelect!=0)
					{
						return -1;
					}else
						continue;
				}
				else
					returnFail(response_code);
				return 1;	
			}
			
	}else
		iRet = returnFail((char *)pack.FIELD39);
	return -1;
	
}



//重打印最后一张发票
int CTrade::print_last(const char *title,int mbl_flag)
{
	int iseny,iSelect, num;
	char pMsg[1][2048];	
	
	CPrint print;
	print.set_in_par(gbl);
	
	
	if(CDB::getRePrint("000000000000",gbl.pos_no,gbl.card_no,iseny,pMsg,gbl.dPosInfo.prmVer, &num, mbl_flag)==0)
	{
		print.print_fail(iseny,pMsg[0],0);
	}
	
	else
	{
		TS_OutPutMsg(gbl.dPosInfo, "\n无打印失败信息，有疑问请致电400-80-11888\n   按【确认】返回", 0,iSelect);
		return -1;
	}
	return 0;
}

//重打印最后一张发票
int CTrade::revAppli(const char *title)
{
	int iseny=0,iSelect=0,iRet=0;
	char m_stan[12+1], msg[1024],temp[1024],input_amount[13];
	wrLog("【revAppli】");
	
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, title);
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入号码：");	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//全字符
	tradeInfoSend.Contents[0].uCount = 0;		//输入1次
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
	tradeInfoSend.Contents[0].uMinLen = 8;	
	tradeInfoSend.Contents[0].uMaxLen = 15;	
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	
	bbzero(gbl.pos_serial);
	strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
	bbzero(m_stan);
	strcpy(m_stan,(char *)tradeInfoRecv.Contents[0].uMsg );
	wrLog("m_stan:[%s]", m_stan);
	
	
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, "日交易查询/冲正");
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "<号码欠费等原因,可能冲正失败> 冲正请输该笔交易金额:");	
	tradeInfoSend.Contents[0].uMinLen = 1;		
	tradeInfoSend.Contents[0].uMaxLen = 8;
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_MONEY;	//数字
	tradeInfoSend.Contents[0].uCount = 0;		//输入1次		
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	
	bbzero(input_amount);
	strcpy(input_amount, (char *)tradeInfoRecv.Contents[0].uMsg);
	
	bbzero(msg);
	if(CDB::revAppliChk(m_stan,input_amount,msg,&gbl)==0)
	{
		bbzero(temp);
		sprintf(temp,"【请再次确认冲正申请信息】\n【风险提示】用户号码欠费等原因，可能引起冲正失败，导致不能退费，损失由商户承担。\n如果确认要冲正申请，请保证号码余额超过冲正金额。\n小技巧：让客户查询余额，发现不够时，就要客户先补足。\n充值成功短信可能会延时，但交费易一定会保证【充值到账】\n\n%s",msg);
		strcat(msg, "\n【风险提示】用户号码欠费等原因，可能引起冲正失败，导致不能退费，损失由商户承担。\n如果确认要冲正申请，请保证号码余额超过冲正金额。\n小技巧：让客户查询余额，发现不够时，就要客户先补足。\n充值成功短信可能会延时，但交费易一定会保证【充值到账】\n\n按【确认】冲正申请 按【返回】取消");
		iRet = TS_OutPutMsg(gbl.dPosInfo, msg, 0,iSelect);
		if (iSelect == 0)
		{
			strcat(temp, "\n按【确认】冲正 按【返回】取消");
			iRet = TS_OutPutMsg(gbl.dPosInfo, temp, 0,iSelect);
		}else
			return -1;
		if(iSelect == 0)
		{
			bbzero(msg);
			if(CDB::revAppli(m_stan, msg,gbl)==0)
			{
				strcat(msg, "\n冲正申请已受理\n\n【825】可确认冲正成功与否\n【815】可查询资金到账情况\n(请在24小时后操作)\n按【确认】返回");
			}
			else
			{
				strcat(msg, "\n冲正申请失败\n按【确认】返回");
			}
		}
		else
		{
			strcpy(msg, "\n冲正已取消\n按【确认】返回");
		}
		iRet = TS_OutPutMsg(gbl.dPosInfo, msg, 0,iSelect);
		return 0;
	}
	else
	{
		strcat(msg, "\n冲正申请失败\n按【确认】返回");
		iRet = TS_OutPutMsg(gbl.dPosInfo, msg, 0,iSelect);
		return -1;
	}
}

int CTrade::SetTitle()
{
	int iRet,iSelect;
	
	char temp[512];
	TSMENULIST menuList;
	iRet = checkPEPwd_Hdl("标题设置修改");
	if(iRet!=0)
		if(iRet==CANCLE_KEY)
			return CANCLE_KEY;
		else
		{	
			info("老板密码校验错误\n\n请联系在线客服中心【Ctrl+H】  400-80-11888\n\n按【Enter】确认返回主菜单。");
			return iRet;
			
		}
	memset(&menuList,0,sizeof(menuList));
	menuList.iTotalNum = 2;  //修改不显示酬金
	strcpy(menuList.acTitle, "请选择标题种类");
	strcpy(menuList.menuItem[0], "显示余额");
	strcpy(menuList.menuItem[1], "不显示余额");
	
	iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
	if(iRet)
		return -1;
	bbzero(temp);
	switch(iSelect)
	{
	case 1:
		strcpy(temp,"您选择的标题显示形式是：显示余额\n\n按【确认】确认修改  按【返回】取消");
		gbl.title_flag = 0;
		break;
	case 2:
		strcpy(temp,"您选择的标题显示形式是：不显示余额\n\n按【确认】确认修改 按【返回】取消");
		gbl.title_flag = 1;
		break;
	default: 
		return CANCLE_KEY;
	}
	iRet = TS_OutPutMsg(gbl.dPosInfo,temp,0,iSelect);
	if (iSelect!=0)
	{
		return -1;
	}
	iRet = CDB::update_title_flag(gbl);
	if (iRet == 0)
	{
		TS_OutPutMsg(gbl.dPosInfo,"\n设置成功，设置将在重新登录后生效！",0,iSelect);
		return 0;
	}else{
		TS_OutPutMsg(gbl.dPosInfo,"\n设置出错，请稍后重试！",1,iSelect);
		return -2;
	}
}

int CTrade::GetNewMessage(int flag)
{
	int iRet,iSelect;
	char temp[2048];
	char my_message[1024];
	int find_flag=0;
	for (int i = 0; i < new_message.size(); i++)
	{
		if (gbl.tgroup == new_message[i].my_group)
		{
			bbzero(my_message);
			strcpy(my_message,new_message[i].sys_new_message);
			find_flag = 1;
			break;
		}
	}
	if (find_flag == 0)
	{
		for (int i = 0; i < new_message.size(); i++)
		{
			if (new_message[i].my_group == 29)
			{
				bbzero(my_message);
				strcpy(my_message,new_message[i].sys_new_message);
				break;
			}
		}
	}
	bbzero(temp);
	if(flag==1)
	{
        sprintf(temp,"【最新消息提示】\n%s\n\n【确认】进入交费易菜单",my_message);
		iRet = TS_OutPutMsg(gbl.dPosInfo,temp,0,iSelect);
		
	}
	else
	{
		sprintf(temp,"【最新消息提示】\n%s\n\n【确认】进入最新活动消息   【返回】退出",my_message);
		iRet = TS_OutPutMsg(gbl.dPosInfo,temp,0,iSelect);
		
		if (iSelect == 0)
		{
			OpenKF(1); //直接进入在线客服
		}
	}
	return 0;
}
int CTrade::new_DG_ADSL_XC(const char*title)
{
	int iRet,iSelect,flag,b63_len,b_len,adsl_count,i,b63len;
	char response_code[2+1],len_buff[2+1],count_buff[2+1];
	char my_bit63[1024],temp[1024],amoMny[15+1];
	
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, title);
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入宽带接入号或绑定的固话号码：");	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//全字符
	tradeInfoSend.Contents[0].uCount = 0;		//输入1次
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
	tradeInfoSend.Contents[0].uMinLen = 6;	
	tradeInfoSend.Contents[0].uMaxLen = 15;	
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	
	bbzero(gbl.pos_serial);
	strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
	bbzero(gbl.phone_no);
	strcpy(gbl.phone_no,(char *)tradeInfoRecv.Contents[0].uMsg );
	gbl.phone_len = tradeInfoRecv.Contents[0].uMsgLen;
	
	pack.wrField(1, gbl);
	/*******************修改部分包内容****************/
	//bit48
	bbzero(gbl.fee_type);
	strcpy(gbl.fee_type,"0311");
	memset(pack.FIELD48, 0, sizeof(pack.FIELD48) );
	memcpy(pack.FIELD48, gbl.fee_type, 4);
	bbzero(len_buff);
	sprintf(len_buff,"%02d",gbl.phone_len);
	strncat((char *)pack.FIELD48, len_buff, 2);
	strncat((char *)pack.FIELD48, gbl.phone_no, gbl.phone_len);
	pack.Packet_Table[48].Real_Length = 6 + gbl.phone_len;
	/**************************************************/
	//  查询包打包   
	iRet = packHdl(1);
	if(iRet < 0)
		return -1;
	//返回数据给终端
	memset(response_code, 0, sizeof(response_code));
	memcpy(response_code, pack.FIELD39, 2);
	if (!memcmp(pack.FIELD39,"00",2)) 
	{
		bbzero(my_bit63);
		memcpy(my_bit63,(char *)(pack.FIELD63),strlen((char *)pack.FIELD63));
		
		b63_len = 0;
		
		bbzero(len_buff);
		memcpy(len_buff,my_bit63+b63_len,2);
		b63_len += 2;
		b_len = atoi(len_buff);
		bbzero(gbl.user_name);
		memcpy(gbl.user_name,my_bit63+b63_len,b_len);
		b63_len += b_len;
		
		bbzero(len_buff);
		memcpy(len_buff,my_bit63+b63_len,2);
		b63_len += 2;
		b_len = atoi(len_buff);
		bbzero(gbl.adsl_number);
		memcpy(gbl.adsl_number,my_bit63+b63_len,b_len);
		b63_len += b_len;
		
		bbzero(count_buff);
		memcpy(count_buff,my_bit63+b63_len,2);
		b63_len += 2;
		adsl_count = atoi(count_buff);
		
		for (i=0;i<adsl_count;i++)
		{
			bbzero(len_buff);
			memcpy(len_buff,my_bit63+b63_len,2);
			b63_len += 2;
			b_len = atoi(len_buff);
			bbzero(gbl.adsl_code);
			memcpy(gbl.adsl_code,my_bit63+b63_len,b_len);
			b63_len += b_len;
			
			bbzero(len_buff);
			memcpy(len_buff,my_bit63+b63_len,2);
			b63_len += 2;
			b_len = atoi(len_buff);
			bbzero(gbl.adsl_name);
			memcpy(gbl.adsl_name,my_bit63+b63_len,b_len);
			b63_len += b_len;
			
			bbzero(len_buff);
			memcpy(len_buff,my_bit63+b63_len,2);
			b63_len += 2;
			b_len = atoi(len_buff);
			bbzero(gbl.adsl_speed);
			memcpy(gbl.adsl_speed,my_bit63+b63_len,b_len);
			b63_len += b_len;
			
			bbzero(len_buff);
			memcpy(len_buff,my_bit63+b63_len,2);
			b63_len += 2;
			b_len = atoi(len_buff);
			bbzero(gbl.adsl_date_long);
			memcpy(gbl.adsl_date_long,my_bit63+b63_len,b_len);
			b63_len += b_len;
			
			bbzero(len_buff);
			memcpy(len_buff,my_bit63+b63_len,2);
			b63_len += 2;
			b_len = atoi(len_buff);
			bbzero(gbl.adsl_money);
			memcpy(gbl.adsl_money,my_bit63+b63_len,b_len);
			b63_len += b_len;
			
			bbzero(len_buff);
			memcpy(len_buff,my_bit63+b63_len,2);
			b63_len += 2;
			b_len = atoi(len_buff);
			bbzero(gbl.adsl_date_end);
			memcpy(gbl.adsl_date_end,my_bit63+b63_len,b_len);
			b63_len += b_len;
			
			bbzero(temp);
			bbzero(amoMny);
			bbzero(gbl.amount);
			sprintf(gbl.amount,"%012d",atoi(gbl.adsl_money));
			CTools::chgToMny(gbl.amount,amoMny);
			if (i == adsl_count-1)
			{
				sprintf(temp,"用户名：%s ADSL接入号：%s\n 共有套餐数量：%d个，请选择其中一个进行续存：\n%d.套餐名称：%s\n速率：%s\n时长：%s个月\n套餐金额：%s\n套餐到期时间：%s\n【确认】选择续存本套餐\n【返回】返回",gbl.user_name,gbl.adsl_number,adsl_count,i+1,gbl.adsl_name,gbl.adsl_speed,gbl.adsl_date_long,amoMny,gbl.adsl_date_end);		
			}else
				sprintf(temp,"用户名：%s ADSL接入号：%s\n 共有套餐数量：%d个，请选择其中一个进行续存：\n%d.套餐名称：%s\n速率：%s\n时长：%s个月\n套餐金额：%s\n套餐到期时间：%s\n【确认】选择续存本套餐\n【返回】查看该用户下一套餐",gbl.user_name,gbl.adsl_number,adsl_count,i+1,gbl.adsl_name,gbl.adsl_speed,gbl.adsl_date_long,amoMny,gbl.adsl_date_end);
			iRet = TS_OutPutMsg(gbl.dPosInfo,temp,0,iSelect);
			if (iRet == 0)
			{
				if (iSelect == 0)
				{
					memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
					memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
					
					strcpy(tradeInfoSend.acMainTitle, title);
					tradeInfoSend.uHasTradeID = 1;
					tradeInfoSend.uTotalContents = 1;
					
					strcpy(tradeInfoSend.Contents[0].acTitle, "请输入手机号码：");	
					tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//全字符
					tradeInfoSend.Contents[0].uCount = 0;		//输入1次
					tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
					tradeInfoSend.Contents[0].uMinLen = 11;	
					tradeInfoSend.Contents[0].uMaxLen = 11;	
					
					iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
					if(iRet != 0)
					{
						wrLog("TS_TradeControl返回错误[%d]", iRet);
						wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
						return iRet;
					}
					
					bbzero(gbl.pos_serial);
					strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
					bbzero(gbl.telphone);
					strcpy(gbl.telphone,(char *)tradeInfoRecv.Contents[0].uMsg );
					
					bbzero(temp);
					bbzero(amoMny);
					CTools::chgToMny(gbl.amount,amoMny);
					sprintf(temp,"确认是否要对\n用户姓名：%s ADSL接入号：%s\n进行 套餐名称：%s \n速率：%s \n时长：%s个月\n套餐金额：%s\n的续存\n按【确认】缴费续存\n按【返回】返回",gbl.user_name,gbl.adsl_number,gbl.adsl_name,gbl.adsl_speed,gbl.adsl_date_long,amoMny);
					iRet = TS_OutPutMsg(gbl.dPosInfo,temp,0,iSelect);
					if (iSelect == 0 && iRet == 0)
					{
						flag = 0;
						for(int curTry=0; curTry<MAXTRY; curTry++)
						{
							if(!flag)
							{
								iRet = mngCard_Hdl(title, "", 0, gbl.get_card);
								if(iRet == CANCLE_KEY)
									return CANCLE_KEY;
								else if(iRet != 0)
									return -1;
							}
							pack.wrField(2, gbl);
							/*******************修改部分包内容****************/
							bbzero(pack.FIELD3);
							CTools::hex_to_byte((BYTE *)"000000", pack.FIELD3, 6);
							//bit48
							memset(pack.FIELD48, 0, sizeof(pack.FIELD48) );
							memcpy(pack.FIELD48, gbl.fee_type, 4);
							bbzero(len_buff);
							sprintf(len_buff,"%02d",gbl.phone_len);
							strncat((char *)pack.FIELD48, len_buff, 2);
							strncat((char *)pack.FIELD48, gbl.phone_no, gbl.phone_len);
							pack.Packet_Table[48].Real_Length = 6 + gbl.phone_len;
							//bit63
							b63len = 8;
							
							bbzero(len_buff);
							sprintf(len_buff,"%02d",strlen(gbl.adsl_number));
							memcpy((char *)pack.FIELD63+b63len,len_buff,2);
							b63len += 2;
							memcpy((char *)pack.FIELD63+b63len,gbl.adsl_number,strlen(gbl.adsl_number));
							b63len += strlen(gbl.adsl_number);
							
							bbzero(len_buff);
							sprintf(len_buff,"%02d",strlen(gbl.adsl_code));
							memcpy((char *)pack.FIELD63+b63len,len_buff,2);
							b63len += 2;
							memcpy((char *)pack.FIELD63+b63len,gbl.adsl_code,strlen(gbl.adsl_code));
							b63len += strlen(gbl.adsl_code);
							
							memcpy((char *)pack.FIELD63+b63len,gbl.telphone,11);
							b63len += 11;
							
							bbzero(len_buff);
							sprintf(len_buff,"%02d",strlen(gbl.adsl_name));
							memcpy((char *)pack.FIELD63+b63len,len_buff,2);
							b63len += 2;
							memcpy((char *)pack.FIELD63+b63len,gbl.adsl_name,strlen(gbl.adsl_name));
							b63len += strlen(gbl.adsl_name);
							
							bbzero(len_buff);
							sprintf(len_buff,"%02d",strlen(gbl.adsl_speed));
							memcpy((char *)pack.FIELD63+b63len,len_buff,2);
							b63len += 2;
							memcpy((char *)pack.FIELD63+b63len,gbl.adsl_speed,strlen(gbl.adsl_speed));
							b63len += strlen(gbl.adsl_speed);
							
							bbzero(len_buff);
							sprintf(len_buff,"%02d",strlen(gbl.adsl_date_long));
							memcpy((char *)pack.FIELD63+b63len,len_buff,2);
							b63len += 2;
							memcpy((char *)pack.FIELD63+b63len,gbl.adsl_date_long,strlen(gbl.adsl_date_long));
							b63len += strlen(gbl.adsl_date_long);
							
							bbzero(len_buff);
							sprintf(len_buff,"%02d",strlen(gbl.adsl_money));
							memcpy((char *)pack.FIELD63+b63len,len_buff,2);
							b63len += 2;
							memcpy((char *)pack.FIELD63+b63len,gbl.adsl_money,strlen(gbl.adsl_money));
							b63len += strlen(gbl.adsl_money);
							
							pack.Packet_Table[63].Real_Length = b63len;
							/**************************************************/
							//  查询包打包   
							iRet = packHdl(2);
							if(iRet < 0)
								return -1;
							//返回数据给终端
							if (!memcmp(pack.FIELD39,"00",2)) 
							{								
								iRet = TS_OutPutMsg(gbl.dPosInfo, "交易成功,系统在3个工作日内到账\n请按【确认】打印票据\n拨打400-80-11888可确认交易成功情况", 0,iSelect);
								if (iSelect == 0 || iRet !=0)
								{
									CPrint prt;
									prt.set_in_par(gbl);
									prt.print_new_dg_adsl_xc(title);
									return 0;
								}
							}
							else if(!memcmp(pack.FIELD39,"55",2))
							{
								flag = 1;
								iRet = reGetPwd(title);
								if(iRet == 0) //密码错误，重新输入密码, 2006-10-25
									continue;
								else
									return CANCLE_KEY;
							}
							else
							{
								iRet = returnFail((char*)pack.FIELD39);
							}
							
							return iRet;
						}
					}else{
						return -1;
					}
					
				}
			}else{
				return -1;
			}
		}
	}else
	{
		iRet = returnFail((char*)pack.FIELD39);
	}
	return 0;
}
int CTrade::DG_ADSL_xc(const char *title, int type_flag)
{
	int iRet,iSelect,flag,b63_len,b_len;
	char response_code[2+1],len_buff[2+1];
	char my_bit63[1024],temp[1024],adsl_type[2+1];
	
	TSMENULIST menuList;
	memset(&menuList,0,sizeof(menuList));
	menuList.iTotalNum = 2;
	strcpy(menuList.acTitle, "请选择付费类型");
	strcpy(menuList.menuItem[0], "个人后付费");
	strcpy(menuList.menuItem[1], "个人预付费");
	
	iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
	if(iRet)
		return -1;
	bbzero(temp);
	bbzero(gbl.fee_type);
	switch(iSelect)
	{
	case 1:
		strcpy(gbl.fee_type,"0299");
		break;
	case 2:
		strcpy(gbl.fee_type,"0303");
		break;
	default: 
		return CANCLE_KEY;
	}
	
	bbzero(adsl_type);
	if (type_flag == 1)
	{
		strcpy(adsl_type,"01");
	}else if (type_flag == 2)
	{
		strcpy(adsl_type,"02");
	}else if (type_flag == 3)
	{
		strcpy(adsl_type,"03");
	}else if (type_flag == 4)
	{
		strcpy(adsl_type,"04");
	}else 
		return -1;
	
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, title);
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入宽带绑定的固话号码：");	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//全字符
	tradeInfoSend.Contents[0].uCount = 0;		//输入1次
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
	tradeInfoSend.Contents[0].uMinLen = 8;	
	tradeInfoSend.Contents[0].uMaxLen = 8;	
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	
	bbzero(gbl.pos_serial);
	strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
	bbzero(gbl.phone_no);
	strcpy(gbl.phone_no,(char *)tradeInfoRecv.Contents[0].uMsg );
	gbl.phone_len = tradeInfoRecv.Contents[0].uMsgLen;
	
	pack.wrField(1, gbl);
	/*******************修改部分包内容****************/
	//bit48
	memset(pack.FIELD48, 0, sizeof(pack.FIELD48) );
	memcpy(pack.FIELD48, gbl.fee_type, 4);
	bbzero(len_buff);
	sprintf(len_buff,"%02d",gbl.phone_len);
	strncat((char *)pack.FIELD48, len_buff, 2);
	strncat((char *)pack.FIELD48, gbl.phone_no, gbl.phone_len);
	strncat((char *)pack.FIELD48, adsl_type, 2);
	pack.Packet_Table[48].Real_Length = 8 + gbl.phone_len;
	/**************************************************/
	//  查询包打包   
	iRet = packHdl(1);
	if(iRet < 0)
		return -1;
	//返回数据给终端
	memset(response_code, 0, sizeof(response_code));
	memcpy(response_code, pack.FIELD39, 2);
	if (!memcmp(pack.FIELD39,"00",2)) 
	{
		bbzero(my_bit63);
		bbzero(gbl.user_name);
		bbzero(len_buff);
		bbzero(gbl.adsl_xc_type);
		memcpy(gbl.adsl_xc_type,pack.FIELD63,5);
		memcpy(len_buff,pack.FIELD63+5,2);
		memcpy(gbl.user_name,pack.FIELD63+7,atoi(len_buff));
		strcpy(my_bit63,(char*)pack.FIELD63+7+atoi(len_buff));
		
		bbzero(temp);
		switch (atoi(gbl.adsl_xc_type))
		{
		case 86431:
			bbzero(gbl.amount);
			strcpy(gbl.amount,"000000135000");
			sprintf(temp,"用户将要对\n用户名：%s\n%s固话关联的宽带进行 存1350包15个月512K（个人后付费） 套餐续存。\n\n【确认】确认交费\n【返回】退出",gbl.user_name,gbl.phone_no);
			break;
		case 86443:
			bbzero(gbl.amount);
			strcpy(gbl.amount,"000000140000");
			sprintf(temp,"用户将要对\n用户名：%s\n%s固话关联的宽带进行 存1400包14个月2M(个人后付费） 套餐续存。\n\n【确认】确认交费\n【返回】退出",gbl.user_name,gbl.phone_no);
			break;
		case 86434:
			bbzero(gbl.amount);
			strcpy(gbl.amount,"000000180000");
			sprintf(temp,"用户将要对\n用户名：%s\n%s固话关联的宽带进行 存1800包12个月3M（个人后付费） 套餐续存。\n\n【确认】确认交费\n【返回】退出",gbl.user_name,gbl.phone_no);
			break;
		case 86433:
			bbzero(gbl.amount);
			strcpy(gbl.amount,"000000195000");
			sprintf(temp,"用户将要对\n用户名：%s\n%s固话关联的宽带进行 存1950包15个月2M（个人后付费） 套餐续存。\n\n【确认】确认交费\n【返回】退出",gbl.user_name,gbl.phone_no);
			break;
		case 86422:
			bbzero(gbl.amount);
			strcpy(gbl.amount,"000000135000");
			sprintf(temp,"用户将要对\n用户名：%s\n%s固话关联的宽带进行 存1350包15个月512K（个人预付费 ） 套餐续存。\n\n【确认】确认交费\n【返回】退出",gbl.user_name,gbl.phone_no);
			break;
		case 86445:
			bbzero(gbl.amount);
			strcpy(gbl.amount,"000000140000");
			sprintf(temp,"用户将要对\n用户名：%s\n%s固话关联的宽带进行 存1400包14个月2M(个人预付费） 套餐续存。\n\n【确认】确认交费\n【返回】退出",gbl.user_name,gbl.phone_no);
			break;
		case 86420:
			bbzero(gbl.amount);
			strcpy(gbl.amount,"000000180000");
			sprintf(temp,"用户将要对\n用户名：%s\n%s固话关联的宽带进行 存1800包12个月3M（个人预付费） 套餐续存。\n\n【确认】确认交费\n【返回】退出",gbl.user_name,gbl.phone_no);
			break;
		case 86423:
			bbzero(gbl.amount);
			strcpy(gbl.amount,"000000195000");
			sprintf(temp,"用户将要对\n用户名：%s\n%s固话关联的宽带进行 存1950包15个月2M（个人预付费） 套餐续存。\n\n【确认】确认交费\n【返回】退出",gbl.user_name,gbl.phone_no);
			break;
		default:
			TS_OutPutMsg(gbl.dPosInfo,"ADSL套餐类型错误！",1,iSelect);
			return -1;
		}
		iRet = TS_OutPutMsg(gbl.dPosInfo,temp,0,iSelect);
		if (iSelect == 0)
		{
			flag = 0;
			for(int curTry=0; curTry<MAXTRY; curTry++)
			{
				if(!flag)
				{
					iRet = mngCard_Hdl(title, "", 0, gbl.get_card);
					if(iRet == CANCLE_KEY)
						return CANCLE_KEY;
					else if(iRet != 0)
						return -1;
				}
				pack.wrField(2, gbl);
				/*******************修改部分包内容****************/
				bbzero(pack.FIELD3);
				CTools::hex_to_byte((BYTE *)"000000", pack.FIELD3, 6);
				//bit48
				memset(pack.FIELD48, 0, sizeof(pack.FIELD48) );
				memcpy(pack.FIELD48, gbl.fee_type, 4);
				bbzero(len_buff);
				sprintf(len_buff,"%02d",gbl.phone_len);
				strncat((char *)pack.FIELD48, len_buff, 2);
				strncat((char *)pack.FIELD48, gbl.phone_no, gbl.phone_len);
				strncat((char *)pack.FIELD48, adsl_type, 2);
				pack.Packet_Table[48].Real_Length = 8 + gbl.phone_len;
				//bit63
				b63_len = 8;
				memcpy((char *)pack.FIELD63+b63_len, gbl.adsl_xc_type, 5);
				b63_len += 5;
				memcpy((char *)pack.FIELD63+b63_len, my_bit63, strlen(my_bit63));
				b63_len += strlen(my_bit63);
				pack.Packet_Table[63].Real_Length = b63_len;
				/**************************************************/
				//  查询包打包   
				iRet = packHdl(2);
				if(iRet < 0)
					return -1;
				//返回数据给终端
				if (!memcmp(pack.FIELD39,"00",2)) 
				{
					
					bbzero(len_buff);
					memcpy(len_buff,pack.FIELD63,2);
					b_len = 2;
					b_len += atoi(len_buff);
					
					bbzero(len_buff);
					memcpy(len_buff,pack.FIELD63+b_len,2);
					b_len += 2;
					b_len += atoi(len_buff);
					
					bbzero(len_buff);
					memcpy(len_buff,pack.FIELD63+b_len,2);
					b_len += 2;
					b_len += atoi(len_buff);
					
					bbzero(len_buff);
					memcpy(len_buff,pack.FIELD63+b_len,2);
					b_len += 2;
					bbzero(gbl.adsl_xc_code);
					memcpy(gbl.adsl_xc_code,pack.FIELD63+b_len,atoi(len_buff));
					b_len += atoi(len_buff);
					
					iRet = TS_OutPutMsg(gbl.dPosInfo, " \n 宽带套餐续存成功！\n按【确认】打印发票！", 0,iSelect);
					if (iSelect == 0 || iRet !=0)
					{
						CPrint prt;
						prt.set_in_par(gbl);
						prt.print_dg_adsl_xc(title);
						return 0;
					}
				}
				else if(!memcmp(pack.FIELD39,"55",2))
				{
					flag = 1;
					iRet = reGetPwd(title);
					if(iRet == 0) //密码错误，重新输入密码, 2006-10-25
						continue;
					else
						return CANCLE_KEY;
				}
				else
				{
					iRet = returnFail((char*)pack.FIELD39);
				}
				
				return iRet;
			}
		}else
			return -1;
	}else
	{
		iRet = returnFail((char*)pack.FIELD39);
	}
	return 0;
}
//1.固话 2.CDMA手机 3.ADSL 4.综合收费 9.固话或者小灵通
int CTrade::DX_AirPay_D(const char *title, int type_flag, int input_flag, int select_flag)
{
	int iSelect,iRet,flag;
	char trade_type[2+1],fee_amount[12+1],fee_mny[12+1],fee_type[1+1],response_code[2+1];
	char temp[512],phone_mny[12+1],len_buff[2+1];
	char amoMny[12+1],phone_buff[15];
	int  phone_owner =0;
	char camount[12+1],advise_amount[12+1],advise_amoMny[12+1],city_no_buff[4+1],phone_no_buff[30+1],temp_buff[1024], phone_area[10];
	if (gbl.DianXin_Turn == 0)
	{
		iRet = get_area_biz(BIZ_AREA_BIZ_DX_ENQ, gbl.city_no, gbl.acc_city_no, gbl.fee_type);
		if( iRet==0 )
		{
			wrLog("gbl.fee_type = [%s]", gbl.fee_type);
		}
		else
		{
			return -1;
		}
		
		bbzero(trade_type);
		if ((type_flag ==0) ||(type_flag ==1) ||(type_flag ==2)||(type_flag ==9) )
		{
			strcpy(trade_type,"01");
		}
		else if (type_flag ==3)
		{
			strcpy(trade_type,"03");
		}
		else if (type_flag ==4)
		{
			strcpy(trade_type,"04");
		}
		else
		{
			return -1;
		}
		
		TSTradeInfoSend tradeInfoSend;
		TSTradeInfoRecv tradeInfoRecv;
		
		if(input_flag==0)
		{
			memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
			memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
			
			strcpy(tradeInfoSend.acMainTitle, title);
			tradeInfoSend.uHasTradeID = 1;
			tradeInfoSend.uTotalContents = 1;
			
			strcpy(tradeInfoSend.Contents[0].acTitle, "请输入号码：");	
			tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//全字符
			tradeInfoSend.Contents[0].uCount = 0;		//输入1次
			tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
			tradeInfoSend.Contents[0].uMinLen = 8;	
			tradeInfoSend.Contents[0].uMaxLen = 15;	
			
			iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
			if(iRet != 0)
			{
				wrLog("TS_TradeControl返回错误[%d]", iRet);
				wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
				return iRet;
			}
			
			memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
			bbzero(gbl.phone_no);
			strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);	
			strcpy(gbl.phone_no,(char *)tradeInfoRecv.Contents[0].uMsg );
			gbl.phone_len = tradeInfoRecv.Contents[0].uMsgLen;
			bbzero(city_no_buff);
			strcpy(city_no_buff,gbl.city_no);//默认为终端所在地区
			
		}
		
		bbzero(phone_area);

		if(gbl.phone_no[0]=='1')//如果是手机
		{
	

			//判断是否是广东电信号码
			bbzero(gbl.phone_province);
			bbzero(gbl.city_no);
			iRet=CDB::phone_district_qry(gbl.phone_no,gbl.phone_province,gbl.phone_city,&gbl.phone_owner);
			if(iRet != 0 ) //如果不是广东地区号码 。
			{
				if(atof(gbl.dPosInfo.prmVer)>=9000 &&type_flag==2) //对应ipos
				{
				
					bbzero(gbl.fee_type);
					strcpy(gbl.fee_type,"0367");
					iRet=phone_pay_trade("单个号码充值(全国)"); 
					if (iRet==0) //充值成功
					{
						ecardInqHdl();
						return 0;
					}
					else
					{
						
						return -1;//充值失败
					}

				}
				else //如果是epos
				{
				
					TS_OutPutMsg(gbl.dPosInfo,"本业务支持广东省号码充值，请更换号码再试",1,iSelect);
					return -1;
				}
			
			}

			strcpy(phone_area, gbl.phone_city);
		}

		else if (gbl.phone_no[0]!='0')//如果不是手机且没输区号 默认手机号码是加终端所在地区的区号
		{

			char phone_no[20];
			bbzero(phone_no);
			strcpy(phone_no, gbl.phone_no);
			bbzero(gbl.phone_no);
			strcpy(gbl.phone_no, gbl.city_no);
			strcat(gbl.phone_no, phone_no);
			gbl.phone_len = strlen(gbl.phone_no); 
			
		}
		else //如果是加区号了。获取区号
		{
			if(strncmp(gbl.phone_no,"01",2)==0 || strncmp(gbl.phone_no,"02",2)==0) //区号为2位
			{
				bbzero(city_no_buff);
				memcpy(city_no_buff,gbl.phone_no,3);

			}
			else
			{
			
				bbzero(city_no_buff);
				memcpy(city_no_buff,gbl.phone_no,4);

			}
		

		}

		if (gbl.phone_no[0] =='0') //如果是固话
		{
			iRet=CDB::is_gd_district(city_no_buff,phone_area);

		}

		if (iRet!=0)
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n本业务固话充值 仅支持广东省内固话号码，请更换号码再试",1,iSelect);
			return -1;
		}

		
		pack.wrField(1, gbl);	//写查询域
		/*----------------------------------*/
		bbzero(pack.FIELD3);
		CTools::hex_to_byte((BYTE *)"310000", pack.FIELD3, 6);
		
		bbzero(pack.FIELD63);
		memcpy(pack.FIELD63, trade_type, 2);
		pack.Packet_Table[63].Real_Length = 2;
		
		if(gbl.posInfo.enyFlag)	//加密改造
		{
			bbzero(pack.FIELD46);
			pack.FIELD46[0] = 0x39;
			pack.FIELD46[1] = 0x39;
			pack.Packet_Table[46].Real_Length = 2;
			
		}else{
			memcpy((char *)pack.FIELD46,"1",1);
			pack.Packet_Table[46].Real_Length=1;
		}
		
		/*----------------------------------*/
		//打查询包
		iRet = packHdl(1);
		if(iRet < 0)
			return -1;
		if (!memcmp(pack.FIELD39,"00",2)) 
		{
			bbzero(fee_mny);
			bbzero(fee_amount);
			bbzero(fee_type);
			memcpy(fee_type,pack.FIELD63,1);
			memcpy(fee_amount,pack.FIELD63 + 1,12);
			CTools::chgToMny(fee_amount,fee_mny);		
			
			
			bbzero(gbl.amount);
			TSMENULIST menuList;
			memset(&menuList,0,sizeof(menuList));
			
			menuList.iTotalNum = 5;
			if (memcmp(fee_type,"D",1)==0)
			{
				sprintf(temp, "欠费%s 请选金额：",fee_mny);
			}else
				sprintf(temp, "余额%s 请选金额：",fee_mny);
			strcpy(menuList.acTitle, temp);
			strcpy(menuList.menuItem[0], "30元");
			strcpy(menuList.menuItem[1], "50元");
			strcpy(menuList.menuItem[2], "100元");
			strcpy(menuList.menuItem[3], "200元");
			strcpy(menuList.menuItem[4], "500元");
			
			if( select_flag==0 )
			{
				iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
			}
			else
			{
				iRet = 0;
				iSelect = select_flag;
			}
			
			if(iRet)
				return -1;
			
			switch(iSelect)
			{
			case 1:
				strcpy(gbl.amount,"000000003000");
				break;
			case 2:
				strcpy(gbl.amount,"000000005000");
				break;
			case 3:
				strcpy(gbl.amount,"000000010000");
				break;
			case 4:
				strcpy(gbl.amount,"000000020000");
				break;
			case 5:
				strcpy(gbl.amount,"000000050000");
				break;
			default: 
				return CANCLE_KEY;
			}
			
			if ((memcmp(gbl.phone_no,"02",2)==0) || (memcmp(gbl.phone_no,"01",2)==0))
			{
				bbzero(phone_no_buff);
				memcpy(phone_no_buff,gbl.phone_no,3);
				memcpy(phone_no_buff+3,"-",1);
				memcpy(phone_no_buff+4,gbl.phone_no+3,gbl.phone_len-3);
				
			}else if (memcmp(gbl.phone_no,"0",1)==0)
			{
				bbzero(phone_no_buff);
				memcpy(phone_no_buff,gbl.phone_no,4);
				memcpy(phone_no_buff+4,"-",1);
				memcpy(phone_no_buff+5,gbl.phone_no+4,gbl.phone_len-4);
			}else
			{
				bbzero(phone_no_buff);
				memcpy(phone_no_buff,gbl.phone_no,gbl.phone_len);
			}
			if(atoi(gbl.dPosInfo.prmVer)>=9000)
			{
				bbzero(amoMny);
				CTools::chgToMny(gbl.amount,amoMny);
				bbzero(temp);
				if (memcmp(gbl.phone_no,"1",1)==0)
				{
					bbzero(phone_buff);
					memcpy(phone_buff,gbl.phone_no,3);
					strcat(phone_buff,"-");
					memcpy(phone_buff+4,gbl.phone_no+3,4);
					strcat(phone_buff,"-");
					memcpy(phone_buff+9,gbl.phone_no+7,4);
					sprintf(temp, "%s\n\n号码：%s\t%s\n\n充值金额：%s\n\n【是 Enter】  【否 Esc】", title, phone_buff, phone_area, amoMny);
				}else
					sprintf(temp, "%s\n\n号码：%s\t%s\n\n充值金额：%s\n\n【是 Enter】  【否 Esc】", title, phone_no_buff,phone_area, amoMny);
				iRet = TS_OutPutMsg(gbl.dPosInfo, temp, 0, iSelect);
				if(iSelect)
				{
					return -1;
				}
			}else{
				bbzero(amoMny);
				CTools::chgToMny(gbl.amount,amoMny);
				bbzero(temp);
				sprintf(temp, "%s\n号码：%s\n充值金额：%s\n按【确认】继续", title, phone_no_buff, amoMny);
				iRet = TS_OutPutMsg(gbl.dPosInfo, temp, 0, iSelect);
				if(iSelect)
				{
					return -1;
				}
			}

			//
			if (type_flag==1 || type_flag==2 || type_flag==9) //如果是固话或者电信号码充值，规定不能重复充值
			{
				if(CDB::chKChinaUnicom(gbl.fee_type, gbl.phone_no, atoi(gbl.amount))==0)
				{
					NULL;
				}
				else
				{
					bbzero(temp);
					sprintf(temp, "业务运营商规定：\n同一号码%s\n同一金额%d元\n%d分钟内不能连续充值\n请稍后再试", gbl.phone_no, atoi(gbl.amount)/100,FORBID_TIME);
					TS_OutPutMsg(gbl.dPosInfo, temp, 1, iSelect);
					return -1;
				}

			}

			/************刷卡****************/
			flag = 0;
			for(int curTry=0; curTry<MAXTRY; curTry++)
			{
				if(!flag)
				{
					iRet = mngCard_Hdl(title);
					if(iRet == CANCLE_KEY)
						return CANCLE_KEY;
					else if(iRet != 0)
						return -1;
				}
				pack.wrField(2, gbl);	//写交费域
				
				memcpy(pack.FIELD63+8, trade_type, 2);
				pack.Packet_Table[63].Real_Length = 10;
				
				//交费包
				iRet = packHdl(2);
				if(iRet < 0)
					return -1;
				
				memset(response_code,0,sizeof(response_code));
				memcpy(response_code,pack.FIELD39,2);
				if (!memcmp(response_code,"00",2)) 
				{
					bbzero(gbl.phone_amount);
					bbzero(phone_mny);
					bbzero(len_buff);
					memcpy(len_buff,pack.FIELD63,2);
					memcpy(gbl.phone_amount,pack.FIELD63+2+atoi(len_buff),12);
					
					bbzero(temp);
					if (atoi(gbl.phone_amount)>0)
					{
						CTools::chgToMny(gbl.phone_amount,phone_mny);					
						sprintf(temp,"      充值成功！\n号码余额：%s\n 按【确认】打印凭证",phone_mny);
					}else
						strcpy(temp,"\n      充值成功！\n 按【确认】打印凭证");
					iRet = TS_OutPutMsg(gbl.dPosInfo,temp,0,iSelect);
					if(iRet!=0 || iSelect==0)
					{
						CPrint prt;
						prt.set_in_par(gbl);
					//	prt.print_detail(2, title);	
						prt.print_pre_detail(pack,title);
					}
					
				}
				else if(!memcmp(response_code,"55",2))
				{
					flag = 1;
					if(reGetPwd(title) == 0) //密码错误，重新输入密码, 2006-10-25
						continue;
					else
						return CANCLE_KEY;
				}
				else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
				{
					TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
					if (iSelect!=0)
					{
						return -1;
					}else
						continue;
				}
				else
					returnFail(response_code);
				return 1;	
			}		
		}else
			iRet = returnFail((char *)pack.FIELD39);
		return -1;
	}else{
		TSTradeInfoSend tradeInfoSend;
		TSTradeInfoRecv tradeInfoRecv;
		
		if(input_flag==0)
		{
			memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
			memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
			
			strcpy(tradeInfoSend.acMainTitle, title);
			tradeInfoSend.uHasTradeID = 1;
			tradeInfoSend.uTotalContents = 1;
			
			strcpy(tradeInfoSend.Contents[0].acTitle, "请输入号码：");	
			tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//全字符
			tradeInfoSend.Contents[0].uCount = 0;		//输入1次
			tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
			tradeInfoSend.Contents[0].uMinLen = 8;	
			tradeInfoSend.Contents[0].uMaxLen = 15;	
			
			iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
			if(iRet != 0)
			{
				wrLog("TS_TradeControl返回错误[%d]", iRet);
				wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
				return iRet;
			}
			
			memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
			bbzero(gbl.phone_no);
			strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);	
			strcpy(gbl.phone_no,(char *)tradeInfoRecv.Contents[0].uMsg );
			gbl.phone_len = tradeInfoRecv.Contents[0].uMsgLen;
			
		}
		int b48_len,return_flag;
		char correct_code[2+1];
		bbzero(gbl.fee_type);
		if ((type_flag ==0) ||(type_flag ==1) ||(type_flag ==2)||(type_flag ==9) )
		{
			strcpy(gbl.fee_type,"0291");//全省后付费查询接口业务代码;
		}else if (type_flag ==3)
		{
			strcpy(gbl.fee_type,"0292");//全省ADSL查询接口业务代码;
		}else if (type_flag ==4)
		{
			TS_OutPutMsg(gbl.dPosInfo,"网厅不支持综合收费，请使用普通模式里的“电信直充”-“按合同号充值”进行综合缴费",1,iSelect);
			return -1;
		}else
			return -1;
		
		//写查询域
		pack.wrField(1, gbl);
		/************修改一些域*********/
		bbzero(pack.FIELD48);
		b48_len = 0;
		memcpy(pack.FIELD48+b48_len, gbl.fee_type, 4);
		b48_len += 4;
		if (memcmp(gbl.phone_no,"020",3)==0)
		{
			sprintf((char *)pack.FIELD48+b48_len, "%02d", gbl.phone_len+1);
			b48_len += 2;
			bbzero(phone_no_buff);
			sprintf(phone_no_buff,"0%s",gbl.phone_no);
			memcpy(pack.FIELD48+b48_len, phone_no_buff, gbl.phone_len+1);
			b48_len += gbl.phone_len+1;
		}else{
			sprintf((char *)pack.FIELD48+b48_len, "%02d", gbl.phone_len);
			b48_len += 2;
			memcpy(pack.FIELD48+b48_len, gbl.phone_no, gbl.phone_len);
			b48_len += gbl.phone_len;
		}
		pack.Packet_Table[48].Real_Length = b48_len;
		/*******************************/
		
		//  查询包打包   
		iRet = packHdl(1);
		if(iRet < 0)
			return -1;
		//返回终端数据
		memset(response_code,0,sizeof(response_code));
		memcpy(response_code,pack.FIELD39,2);
		
		if (!memcmp(response_code,"00",2)) //电信固话
		{
			return_flag = 0;
			if( foshanRdField63() )	//保留查询返回信息供打印和显示信息用
			{
				TS_OutPutMsg(gbl.dPosInfo,"您输入的号码欠费月过多！",1,iSelect);
				return -1;
			}
		}else{
			bbzero(correct_code);
			memcpy(correct_code,&pack.FIELD62[1+6],2);
			if ((memcmp(response_code,"80",2)==0)&&(memcmp(correct_code,"81",2)==0))
			{
				TS_OutPutMsg(gbl.dPosInfo,"您输入的号码不存在！",1,iSelect);
				return -1;
			}
			if ((memcmp(response_code,"80",2)==0)&&(memcmp(correct_code,"82",2)==0))
			{
				if( foshanRdField63() )	//保留查询返回信息供打印和显示信息用
				{
					TS_OutPutMsg(gbl.dPosInfo,"您输入的号码欠费月过多！",1,iSelect);
					return -1;
				}
			}
			return_flag = 1;
		}
		
		
		memset(gbl.overdraft_amount,0,sizeof(gbl.overdraft_amount));
		memset(gbl.amount,0,sizeof(gbl.amount));
		CTools::byte_to_hex(pack.FIELD4, (BYTE *)gbl.amount, 6);
		strcpy(gbl.overdraft_amount,gbl.amount);
		memset(amoMny,0,sizeof(amoMny));
		CTools::chgToMny(gbl.amount,amoMny);
		
		bbzero(gbl.amount);
		if(select_flag==0)
		{
			TSMENULIST menuList;
			memset(&menuList,0,sizeof(menuList));
			
			menuList.iTotalNum = 5;
			sprintf(menuList.acTitle, "欠费%s  选金额",amoMny);
			strcpy(menuList.menuItem[0], "30元");
			strcpy(menuList.menuItem[1], "50元");
			strcpy(menuList.menuItem[2], "100元");
			strcpy(menuList.menuItem[3], "200元");
			strcpy(menuList.menuItem[4], "500元");
			
			iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);					
			if(iRet)
				return -1;
			
			switch(iSelect)
			{
			case 1:
				strcpy(gbl.amount,"000000003000");
				break;
			case 2:
				strcpy(gbl.amount,"000000005000");
				break;
			case 3:
				strcpy(gbl.amount,"000000010000");
				break;
			case 4:
				strcpy(gbl.amount,"000000020000");
				break;
			case 5:
				strcpy(gbl.amount,"000000050000");
				break;
			default: 
				return CANCLE_KEY;
			}
		}
		bbzero(camount);
		sprintf(camount, "%012d", ((atoi(gbl.amount)-1)/1000+1)*1000);
		bbzero(advise_amount);
		strcpy(advise_amount,camount);
		bbzero(advise_amoMny);
		CTools::chgToMny(advise_amount,advise_amoMny);
		if ((memcmp(gbl.phone_no,"02",2)==0) || (memcmp(gbl.phone_no,"01",2)==0))
		{
			bbzero(phone_no_buff);
			memcpy(phone_no_buff,gbl.phone_no,3);
			memcpy(phone_no_buff+3,"-",1);
			memcpy(phone_no_buff+4,gbl.phone_no+3,gbl.phone_len-3);
			
		}else if (memcmp(gbl.phone_no,"0",1)==0)
		{
			bbzero(phone_no_buff);
			memcpy(phone_no_buff,gbl.phone_no,4);
			memcpy(phone_no_buff+4,"-",1);
			memcpy(phone_no_buff+5,gbl.phone_no+4,gbl.phone_len-4);
		}else
		{
			bbzero(phone_no_buff);
			memcpy(phone_no_buff,gbl.phone_no,gbl.phone_len);
		}
		
		sprintf(temp_buff,"号码：%s  户名：%s\n推荐业务：电信充值付费卡\n\n欠费金额：%s\n充值金额：%s\n\n【请认真核对交费号码及金额】",phone_no_buff,gbl.user_name,amoMny,advise_amoMny);				
		
		TS_OutPutMsg(gbl.dPosInfo, temp_buff, 0,iSelect);
		if (iSelect != 0)
		{
			return -1;
		}
		char type_flag_buff[1+1];
		bbzero(type_flag_buff);
		sprintf(type_flag_buff,"%d",type_flag);
		if ((memcmp(gbl.phone_no,"02",2)==0) || (memcmp(gbl.phone_no,"01",2)==0))
		{
			bbzero(phone_no_buff);
			bbzero(city_no_buff);
			memcpy(city_no_buff,gbl.phone_no,3);
			memcpy(phone_no_buff,gbl.phone_no+3,gbl.phone_len-3);
			iRet = MyCoolPayEasy_cardPayTel("使用充值付费卡缴费", city_no_buff, type_flag_buff, phone_no_buff, camount, "0089");
		}else if (memcmp(gbl.phone_no,"0",2)==0)
		{
			bbzero(phone_no_buff);
			bbzero(city_no_buff);
			memcpy(city_no_buff,gbl.phone_no,4);
			memcpy(phone_no_buff,gbl.phone_no+4,gbl.phone_len-4);
			iRet = MyCoolPayEasy_cardPayTel("使用充值付费卡缴费", city_no_buff, type_flag_buff, phone_no_buff, camount, "0089");
		}else {
			iRet = MyCoolPayEasy_cardPayTel("使用充值付费卡缴费", gbl.city_no, type_flag_buff, phone_no_buff, camount, "0089");
		}
		return iRet;
		
	}
	
}

//深圳电信
int CTrade::sz_dx_trade(const char *title)
{
	int  iRet,iSelect,flag;
	int  b48_len=0;
	char len_buff[10],qf_amount[12+1],ss_amount[12+1],qf_mny[24+1],ss_mny[24+1],temp_buff[512], m_user_name[61];;
	
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	if( strcmp(gbl.city_no, "0755")==0 )
	{
		NULL;
	}
	else
	{
		TS_OutPutMsg(gbl.dPosInfo,"本功能只针对深圳用户开放，请使用电信直充",0,iSelect);
		return -1;
	}
	
	strcpy(tradeInfoSend.acMainTitle, title);
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入交费号码：");
	tradeInfoSend.Contents[0].uMinLen = 1;		
	tradeInfoSend.Contents[0].uMaxLen = 19;
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//字符
	tradeInfoSend.Contents[0].uCount = 0;		//输入1次		
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	
	bbzero(gbl.pos_serial);
	strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
	bbzero(gbl.phone_no);
	strcpy(gbl.phone_no,(char *)tradeInfoRecv.Contents[0].uMsg);
	for(int i=0; gbl.phone_no[i]!=0x00; i++)
	{
		if( gbl.phone_no[i]>='a' && gbl.phone_no[i]>='z' )
		{
			gbl.phone_no[i] = gbl.phone_no[i] - ( 'a' - 'A' );
		}
		else
		{
			NULL;
		}
	}
	gbl.phone_len = strlen(gbl.phone_no);	
	
	wrLog("电话号码：[%s]", gbl.phone_no);
	bbzero(gbl.fee_type);
	strcpy(gbl.fee_type,"0282");
	//写查询域
	pack.wrField(1, gbl);
	
	bbzero(pack.FIELD48);
	memcpy(pack.FIELD48,gbl.fee_type,4);	//4位信息码
	b48_len = 4;
	memset(len_buff,0,sizeof(len_buff));
	sprintf(len_buff,"%02d",gbl.phone_len);	//电话号码长度
	memcpy(pack.FIELD48+b48_len,len_buff,2);	
	b48_len +=2;
	memcpy(pack.FIELD48+b48_len, gbl.phone_no, gbl.phone_len);	//电话号码
	b48_len += gbl.phone_len;
	pack.Packet_Table[48].Real_Length=b48_len;	
	//查询包打包   
	iRet = packHdl(1);
	if(iRet < 0)
		return -1;
	
	if (!memcmp(pack.FIELD39,"00",2))
	{
		bbzero(qf_amount);
		bbzero(ss_amount);
		bbzero(gbl.amount);
		bbzero(gbl.user_name);
		memcpy(gbl.user_name,pack.FIELD63,30);
		gbl.user_name_len = trim(gbl.user_name, 30);
		memcpy(qf_amount,pack.FIELD63+30,12);
		memcpy(ss_amount,pack.FIELD63+42,12);
		CTools::byte_to_hex( pack.FIELD4, (BYTE *)gbl.amount, 6 );
		
		bbzero(qf_mny);
		bbzero(ss_mny);
		CTools::chgToMny(qf_amount,qf_mny);
		CTools::chgToMny(ss_amount,ss_mny);
		
		bbzero(m_user_name);
		if(strlen(gbl.user_name)>2)
		{
			strcpy(m_user_name, "*");
			strcat(m_user_name, gbl.user_name+2);
		}
		else
		{
			strcpy(m_user_name, gbl.user_name);
		}		
		bbzero(temp_buff);
		sprintf(temp_buff,"用户名：%s\n电话号码：%s\n欠费金额：%s\n实时金额：%s\n【确认】交费\n【返回】返回", m_user_name,gbl.phone_no,qf_mny,ss_mny);
		iRet = TS_OutPutMsg(gbl.dPosInfo,temp_buff,0,iSelect);
		if (iRet != 0 || iSelect != 0)
		{
			return -1;
		}
		flag = 0;
		for(int curTry=0; curTry<MAXTRY; curTry++)
		{
			if(!flag) 
			{
				iRet = mngCard_Hdl(title);
				if(iRet == CANCLE_KEY)
					return CANCLE_KEY;
				else if(iRet != 0){
					TS_OutPutMsg(gbl.dPosInfo,"读取输入数据错误!\n交易失败!\n按【确认】返回",1,iSelect);
					return -1;
				}
				
				if(!memcmp(gbl.card_no,"8828",4))	//若是付费易卡,走付费易卡刷卡流程（多卡交易）
				{
					memset(gbl.xlt_type, 0, sizeof(gbl.xlt_type));
					memcpy(gbl.xlt_type, "01",2);
					iRet = xltMulCard( title, 0);
					return iRet;
				}
			}
			
			pack.wrField(2, gbl);	//写交费域
			
			bbzero(pack.FIELD48);
			memcpy(pack.FIELD48,gbl.fee_type,4);	//4位信息码
			b48_len = 4;
			memset(len_buff,0,sizeof(len_buff));
			sprintf(len_buff,"%02d",gbl.phone_len);	//电话号码长度
			memcpy(pack.FIELD48+b48_len,len_buff,2);	
			b48_len +=2;
			memcpy(pack.FIELD48+b48_len, gbl.phone_no, gbl.phone_len);	//电话号码
			b48_len += gbl.phone_len;
			pack.Packet_Table[48].Real_Length=b48_len;	
			
			bbzero(pack.FIELD63);
			memcpy(pack.FIELD63+8,qf_amount,12);
			memcpy(pack.FIELD63+20,ss_amount,12);
			pack.Packet_Table[63].Real_Length=32;
			
			iRet = packHdl(2);
			if(iRet < 0)
				return -1;
			if (!memcmp(pack.FIELD39,"00",2))
			{
				bbzero(gbl.stan_no);
				memcpy(pack.FIELD63,(char *)pack.FIELD37,12);
				iRet = TS_OutPutMsg(gbl.dPosInfo,"     交费成功！\n    谢谢您的使用\n请按【确认】打印凭证",0,iSelect);
				if (iRet<0 || iSelect == 0)
				{
					CPrint prt;
					prt.set_in_par(gbl);
					iRet = prt.print_SZDXTrade_detail(qf_mny,ss_mny);	 //打印明细
				}
				return 0;
			}
			else if(!memcmp(pack.FIELD39,"55",2))
			{
				flag = 1;
				if(reGetPwd( title) == 0) //密码错误，重新输入密码, 2006-10-25
					continue;
				else
					return CANCLE_KEY;
			}
			else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
			{
				TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
				if (iSelect!=0)
				{
					return -1;
				}else
					continue;
			}else
				returnFail((char *)pack.FIELD39);		
			return -1;
		}
		
	}else{
		returnFail((char *)pack.FIELD39);
		return -1;
	}
	return 0;
}

void CTrade::getHeadPage(int tgroup, int term_level, vector<Epos_new_message> &pNew_message, int title_flag, char *pos_no, char *mny, char *yj_buff, char *headPaye)
{
	char my_message[30+1], maintitle[20];
	bbzero(my_message);
	for (int i = 0; i < pNew_message.size(); i++)
	{
		if ( pNew_message[i].my_group==tgroup )
		{
			
			strcpy(my_message,pNew_message[i].title_message);
			break;
		}
	}
	
	if (gbl.menu_group_mbl_flag == 1)
	{
		if (title_flag == 0)
		{
			sprintf((char *)headPaye, "移动业务 － 终端【%s】余额【%s】", pos_no, mny);
		}
		else if (title_flag == 1)
		{
			sprintf((char *)headPaye, "移动业务 － 终端【%s】", pos_no);
		}
	
	
	}else{
		
		bbzero(maintitle);
		strcpy(maintitle, "交费易");
		
		if (title_flag == 0)
		{
			sprintf((char *)headPaye, "%s － 终端【%s】余额【%s】", maintitle, pos_no, mny);
		}
		else if (title_flag == 1)
		{
			sprintf((char *)headPaye, "%s － 终端【%s】", maintitle, pos_no);
		}
	
	}
	
	switch(term_level)
	{
	case 1:
		strcat((char *)headPaye, "一星级");
		break;
	case 2:
		strcat((char *)headPaye, "二星级");
		break;
	case 3:
		strcat((char *)headPaye, "三星级");
		break;
	case 4:
		strcat((char *)headPaye, "四星级");
		break;
	case 5:
		strcat((char *)headPaye, "五星级");
		break;
	case 0:
		strcat((char *)headPaye, "体验商户");
		break;
	default:
		strcat((char *)headPaye, "一星级");
		break;
	}

	strcat((char *)headPaye, "-- 消息:");
	if(strlen(my_message)==0)
		strcat((char *)headPaye,"欢迎您的使用");
	else
		strcat((char *)headPaye, my_message);
}

int CTrade::OpenKF(int flag)
{
	char url[200];
	
	char term_id16[16+1], date8[8+1], date16[16+1], pwd[16+1];
	
	bbzero(term_id16);
	bbzero(date8);
	bbzero(date16);
	bbzero(pwd);
	
	bbzero(url);
	CTools::getDate(date8);
	CTools::byte_to_hex((unsigned char *)gbl.pos_no, (unsigned char *)term_id16, 8);
	CTools::byte_to_hex((unsigned char *)date8, (unsigned char *)date16, 8);
	CDes::GetDesOutput((char *)term_id16, date16, (char *)pwd);
	if (flag == 1) //修改在线客服sessionID参数值为guestid一致
	{
		
		sprintf(url,"%s/zhij/imsystem/im/im_client.jsp?queueId=1021&guestId=%s&sessionId=%s&keyword=&conduitId=9737&inFlag=0&inType=0", gbl.CS_URL, gbl.pos_no,gbl.pos_no);
		TS_OpenIE(gbl.dPosInfo, url); 
	}
	else
	{		
		
		//sprintf(url,"%s/ipos/ipos_goto.jsp?name=%s&pwd=%s", gbl.DIY_URL, gbl.pos_no, pwd); //跳转到子服务门户上面
		CTrade::selfService_online(0);

	}
	
	return 0;
}

int CTrade::Submission(const char*type)
{
	char url[200];
	char term_id16[16+1], date8[8+1], date16[16+1], pwd[16+1];
	int iRet,iSelect;
	
	bbzero(term_id16);
	bbzero(date8);
	bbzero(date16);
	bbzero(pwd);
	
	CDB db;
	iRet = db.checkBatch(gbl.pos_no);
	
	if (iRet == 1)
	{
		TS_OutPutMsg(gbl.dPosInfo,"你还有在处理中的订单\n请稍等片刻\n待所有订单处理完毕再重新上传！",0,iSelect);
		return -1;
	}
	
	CTools::getDate(date8);
	CTools::byte_to_hex((unsigned char *)gbl.pos_no, (unsigned char *)term_id16, 8);
	CTools::byte_to_hex((unsigned char *)date8, (unsigned char *)date16, 8);
	CDes::GetDesOutput((char *)term_id16, date16, (char *)pwd);
	bbzero(url);
	sprintf(url,"https://www.payeasy.com.cn/payeasy/ipos_goto.jsp?name=%s&pwd=%s&m=aa",gbl.pos_no,pwd); //子服务门户
	TS_OpenIE(gbl.dPosInfo, url); 
	return 0;
}

int CTrade::Checkmission(const char*type)
{
	int iRet,iSelect,my_select;
	int batch_value_cnt;
	char msg[1024];
	TSMENULIST menuList;
	CDB db;
	TSTxnLogs txnLogs;
	Batch_Value_Info batch_value_info[MAX_BATCH_VALUE_INFO];
	
	wrLog("大客户批量缴费――查询");
	memset(batch_value_info,0,sizeof(batch_value_info));
	iRet = db.getBatch_value(gbl.pos_no,batch_value_info);
	if (iRet <= 0)
	{
		bbzero(msg);
		sprintf(msg, "没有找到交易记录!\n\n请确认是否已经提交号码表!");
		TS_OutPutMsg(gbl.dPosInfo, msg, 0, iSelect);
		return iRet;
	}
	batch_value_cnt = iRet;
	memset(&menuList,0,sizeof(menuList));
	menuList.iTotalNum = batch_value_cnt;
	strcpy(menuList.acTitle, "请选择需要显示的批次号");
	for(int j=0; j<menuList.iTotalNum; j++)
	{
		memset(menuList.menuItem[j], 0, sizeof(menuList.menuItem[j]));
		strcpy(menuList.menuItem[j],batch_value_info[j].batch_value);
	}
	iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
	if(iRet)
		return -1;
	my_select = iSelect - 1;
	wrLog("批次号：【%d】",batch_value_info[my_select].batch_value );
	
	memset(&txnLogs, 0, sizeof(txnLogs));
	db.getBatchList(batch_value_info[my_select].batch_value,batch_value_info[my_select].pay_money,&txnLogs,batch_value_info[my_select].pay_count);
	if(iRet!=0)
	{
		if( batch_value_info[my_select].pay_count>MAX_TXN_LOG )
		{
			bbzero(msg);
			sprintf(msg, "查找的结果共 %d 条, 已超出最大查找条数 %d 条!\n\n请重新选择条件进行查找!", batch_value_info[my_select].pay_count, MAX_TXN_LOG);
			TS_OutPutMsg(gbl.dPosInfo, msg, 0, iSelect);
		}
		else if( batch_value_info[my_select].pay_count<=0 )
		{
			bbzero(msg);
			sprintf(msg, "没有找到交易记录!\n\n请重新选择进行查找!");
			TS_OutPutMsg(gbl.dPosInfo, msg, 0, iSelect);
		}
		else
		{
			TS_OutPutMsg(gbl.dPosInfo, "网络繁忙，查找出错!\n\n请稍后再查!", 0, iSelect);
		}
		return iRet;
	}
	iRet = TS_ShowTxnLogs(gbl.dPosInfo, &txnLogs);
	if(iRet != 0)
	{
		wrLog("TS_ShowTxnLogs返回错误[%d]", iRet); 
		return iRet;
	}
	return 0;
}

int CTrade::Paymission(const char*type)
{
	int iRet,iSelect,my_select,i=0,action_select;
	int batch_value_cnt;
	char msg[1024];
	char amount[12+1],seri[20+1];
	CDB db;
	Batch_Value_Info batch_value_info[MAX_BATCH_VALUE_INFO];
	TSMENULIST menuList;
	
	wrLog("大客户批量缴费―交费");
	memset(batch_value_info,0,sizeof(batch_value_info));
	iRet = db.getBatch_value(gbl.pos_no,batch_value_info);
	
	if (iRet <= 0)
	{
		bbzero(msg);
		sprintf(msg, "没有找到交易记录!\n\n请确认是否已经提交号码表!");
		TS_OutPutMsg(gbl.dPosInfo, msg, 0, iSelect);
		return iRet;
	}
	batch_value_cnt = iRet;
	
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, type);
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入序列号：");	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//全字符
	tradeInfoSend.Contents[0].uCount = 0;		//输入1次
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
	tradeInfoSend.Contents[0].uMinLen = 20;	
	tradeInfoSend.Contents[0].uMaxLen = 20;	
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	
	memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
	bbzero(seri);
	strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);	
	strcpy(seri,(char *)tradeInfoRecv.Contents[0].uMsg );
	
	for (i=0;i<batch_value_cnt;i++)
	{
		if (memcmp(batch_value_info[i].batch_value,seri,20)==0)
		{
			my_select = i;
			break;
		}
	}
	if (i==batch_value_cnt)
	{
		TS_OutPutMsg(gbl.dPosInfo,"没有查询到相应的订单号，请重新选择！",0,iSelect);
		return -1;
	}
	
	memset(&menuList,0,sizeof(menuList));
	menuList.iTotalNum = 2;
	strcpy(menuList.acTitle, "请选择你要进行的操作：");
	strcpy(menuList.menuItem[0], "删除充值表");
	strcpy(menuList.menuItem[1], "确认交费");
	
	iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
	if(iRet)
		return -1;
	action_select = 0;
	
	switch(iSelect)
	{
	case 1:
		action_select = 1;
		break;
	case 2:
		action_select = 2;
		break;
	default:
		return -1;
	}
	
	if (action_select == 1)
	{
		iRet = db.deleteBatch(batch_value_info[my_select].batch_value);
		if (iRet == 0)
		{
			TS_OutPutMsg(gbl.dPosInfo,"删除充值表成功！",0,iSelect);
			return 0;
		}else if (iRet == 1)
		{
			TS_OutPutMsg(gbl.dPosInfo,"你还有在处理中的订单\n请稍等片刻\n待所有订单处理完毕再重新上传！",0,iSelect);
			return -2;
		}else
		{
			TS_OutPutMsg(gbl.dPosInfo,"删除充值表失败！请稍后重试",0,iSelect);
			return -1;
		}
	}else if (action_select == 2)
	{
		NULL;
	}else
		return -1;
	
	memset(gbl.fee_type, 0, sizeof(gbl.fee_type));
	memcpy(gbl.fee_type, "0083", 4);
	
	iRet = cardInqHdl(amount);
	if (iRet != 0)
	{
		return iRet;
	}
	
	if (atoi(amount)<atoi(batch_value_info[my_select].pay_money))
	{
		TS_OutPutMsg(gbl.dPosInfo,"钱包中余额不足，请充值后再试！",0,iSelect);
		return -1;
	}
	bbzero(gbl.amount);
	bbzero(gbl.fee_type);
	strcpy(gbl.amount,batch_value_info[my_select].pay_money);
	strcpy(gbl.fee_type,"0312");
	
	bbzero(gbl.phone_no);
	strcpy(gbl.phone_no,batch_value_info[my_select].batch_value);
	gbl.phone_len = 20;
	pack.wrField(2, gbl);	//写交费域
	
	memset(pack.FIELD3, 0, sizeof(pack.FIELD3));
	CTools::hex_to_byte((BYTE *)"310060", pack.FIELD3, 6);
	
	bbzero(pack.FIELD46);
	pack.FIELD46[0] = 0x39;
	pack.FIELD46[1] = 0x35;
	pack.Packet_Table[46].Real_Length = 2;
	//交费包
	iRet = packHdl(1);
	if(iRet < 0)
		return -1;
	if (!memcmp(pack.FIELD39,"00",2)) 
	{
		TS_OutPutMsg(gbl.dPosInfo,"受理成功！",1,iSelect);
		return 0;
	}else
		returnFail((char *)pack.FIELD39);
	return -1;
}

int CTrade::Sell_blank_phonecard(const char*title, int type)
{
	int  iRet,iSelect,b48_len,len,b63_len;
	char m_name[50+1],m_telphone[12+1],m_sell_count[12+1],m_address[512];
	char buff[1024],len_buff[1024];
	
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	
	for (int i=0;i<MAXTRY;i++)
	{
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));		
		strcpy(tradeInfoSend.acMainTitle, title);
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents = 1;		
		strcpy(tradeInfoSend.Contents[0].acTitle, "白卡单价20元/张(至少采购5张以上,含5张),请输入采购数量:");	
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
		tradeInfoSend.Contents[0].uCount = 0;		//输入1次		
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME + 10;	//超时40秒
		tradeInfoSend.Contents[0].uMinLen = 1;		
		tradeInfoSend.Contents[0].uMaxLen = 5;
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		if(iRet != 0)
		{
			wrLog("TS_TradeControl返回错误[%d]", iRet);
			wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
			return iRet;
		}
		memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
		strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
		bbzero(m_sell_count);
		strcpy(m_sell_count,(char *)tradeInfoRecv.Contents[0].uMsg );
		
		if (atoi(m_sell_count)>=5)
		{
			break;
		}else{
			TS_OutPutMsg(gbl.dPosInfo,"采购数量不足，必须至少采购5张以上（含5张）\n\n【确认】重新输入\n【返回】退出",0,iSelect);
			if (iSelect==0)
			{
				continue;
			}else
				return -1;
		}
	}
	bbzero(gbl.amount);
	sprintf(gbl.amount,"%010d00",atoi(m_sell_count)*20);
	
	bbzero(gbl.fee_type);
	if(type == 0)	//东莞电信空中放号
	{
		strcpy(gbl.fee_type,"0329");
	}
	else if(type == 1)	//联通空中放号
	{
		strcpy(gbl.fee_type,"0353");
	}
	else
	{
		return -1;
	}
	
	//写查询域
	pack.wrField(1, gbl);
	bbzero(pack.FIELD48);
	memcpy(pack.FIELD48,gbl.fee_type,4);
	b48_len = 4;
	memcpy(pack.FIELD48+b48_len,"0",1);
	b48_len += 1;
	bbzero(buff);
	bbzero(len_buff);
	len = strlen(m_sell_count);
	sprintf(len_buff,"%02d",len);
	sprintf(buff,"%s%s%s",len_buff,m_sell_count,gbl.city_no);
	len = strlen(buff);
	bbzero(len_buff);
	sprintf(len_buff,"%02d",len);
	memcpy(pack.FIELD48+b48_len,len_buff,2);
	b48_len += 2;
	memcpy(pack.FIELD48+b48_len,buff,len);
	b48_len += len;
	
	pack.Packet_Table[48].Real_Length=b48_len;
	
	//  查询包打包
	iRet = packHdl(1);
	if(iRet < 0)
		return -1;
	
	if (memcmp(pack.FIELD39,"00",2)==0)
	{
		NULL;
	}else
	{
		returnFail((char*)pack.FIELD39);
		return -1;
	}
	
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));		
	strcpy(tradeInfoSend.acMainTitle, title);
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;		
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入联系人姓名：");	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//全字符
	tradeInfoSend.Contents[0].uCount = 0;		//输入1次		
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME + 30;	//超时40秒
	tradeInfoSend.Contents[0].uMinLen = 2;		
	tradeInfoSend.Contents[0].uMaxLen = 25;
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	bbzero(m_name);
	strcpy(m_name,(char *)tradeInfoRecv.Contents[0].uMsg );	
	
	
	
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));		
	strcpy(tradeInfoSend.acMainTitle, title);
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;		
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入联系电话：");	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
	tradeInfoSend.Contents[0].uCount = 1;		//输入1次		
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME + 10;	//超时40秒
	tradeInfoSend.Contents[0].uMinLen = 7;		
	tradeInfoSend.Contents[0].uMaxLen = 12;		
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}		
	bbzero(m_telphone);
	strcpy(m_telphone,(char *)tradeInfoRecv.Contents[0].uMsg );
	
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));		
	strcpy(tradeInfoSend.acMainTitle, title);
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;		
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入配送地址：");	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//全字符
	tradeInfoSend.Contents[0].uCount = 0;		//输入1次		
	tradeInfoSend.Contents[0].uTimeOut = 60;	//超时40秒
	tradeInfoSend.Contents[0].uMinLen = 2;		
	tradeInfoSend.Contents[0].uMaxLen = 60;
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv,255);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}		
	bbzero(m_address);
	strcpy(m_address,(char *)tradeInfoRecv.Contents[0].uMsg );
	
	bbzero(buff);
	sprintf(buff,"订单信息：\n  白卡单价：20元/张；\n  下单数量：%s张；\n  付款总额：%d元；\n配送信息：\n  终端号：%s\n  联系人：%s\n  联系电话：%s\n  配送地址：%s\n\n【温馨提示】请确认以上信息，由于以上信息不正确或不完整导致的一切损失由商户承担。\n 【确认】继续 【返回】取消",m_sell_count,atoi(m_sell_count)*20,gbl.pos_no,m_name,m_telphone,m_address);
	
	iRet = TS_OutPutMsg(gbl.dPosInfo,buff,0,iSelect);
	if(iRet != 0)
	{
		TS_OutPutMsg(gbl.dPosInfo, "网络繁忙，请稍候再试", 0, iSelect);
		return -1;
	}
	else if (iSelect!=0)
	{
		return -2;
	}
	
	bbzero(gbl.phone_no);
	strcpy(gbl.phone_no,m_telphone);
	gbl.phone_len = strlen(gbl.phone_no);
	int flag = 0;
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{
		if(!flag)
		{
			iRet = mngCard_Hdl(title);
			if(iRet == CANCLE_KEY)
				return CANCLE_KEY;
			else if(iRet != 0)
				return -1;
		}
		pack.wrField(2, gbl);	//写交费域
		/***************修改一些域****************/
		
        b63_len=8;
		memcpy(pack.FIELD63+b63_len,m_sell_count,strlen(m_sell_count));       //购卡数量
		b63_len+=strlen(m_sell_count);
		memcpy(pack.FIELD63+b63_len,"|",1);       //分隔符
		b63_len+=1;
		memcpy(pack.FIELD63+b63_len,gbl.city_no, strlen(gbl.city_no));	//联系人姓名
		b63_len += strlen(gbl.city_no);
		memcpy(pack.FIELD63+b63_len,"|",1);       //分隔符
		b63_len+=1;
		memcpy(pack.FIELD63+b63_len,m_name, strlen(m_name));	//联系人姓名
		b63_len += strlen(m_name);
		memcpy(pack.FIELD63+b63_len,"|",1);       //分隔符
		b63_len+=1;
		memcpy(pack.FIELD63+b63_len,m_address, strlen(m_address));	//联系人地址
		b63_len += strlen(m_address);
		memcpy(pack.FIELD63+b63_len,"|",1);       //分隔符
		b63_len+=1;
		
		pack.Packet_Table[63].Real_Length=b63_len;
		/*****************************************/
		
		iRet = packHdl(2);
		if(iRet < 0)
			return -1;
		
		if (!memcmp(pack.FIELD39,"00",2)) 
		{
			iRet = TS_OutPutMsg(gbl.dPosInfo,"     白卡购买成功！\n请耐心等待我们的配送\n",0,iSelect);
			
			return 0;
		}
		else if(!memcmp(pack.FIELD39,"55",2))
		{
			flag = 1;
			if(reGetPwd(title) == 0) //密码错误，重新输入密码, 2006-10-25
				continue;
			else
				return CANCLE_KEY;
		}
		else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
			if (iSelect!=0)
			{
				return -1;
			}else
				continue;
		}
		else
			returnFail((char*)pack.FIELD39);
		return -1;
	}
	
	return 0;
}

int CTrade::Sell_phoneno(const char*title)
{
	int iRet,iSelect,type_flag=0,no_num;
	char phone_part[4+1];
	TSMENULIST menuList;
	char phone_head[7+1];
	
	PHONE_HEAD_NO phone_part_no[8];
	
	TSTxnLogs txnLogs;
	memset(&txnLogs, 0, sizeof(txnLogs));
	
	memset(&menuList,0,sizeof(menuList));
	menuList.iTotalNum = 3;
	strcpy(menuList.acTitle, "请选择挑选规则：");
	strcpy(menuList.menuItem[0], "号码分类选择");
	strcpy(menuList.menuItem[1], "吉祥号码选择");
	strcpy(menuList.menuItem[2], "自主号码选择");
	
	iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
	if(iRet)
		return -1;
	
	
	switch(iSelect)
	{
	case 1:
		type_flag = 1;
		break;
	case 2:
		type_flag = 2;
		break;
	case 3:
		type_flag = 3;
		break;
	default:
		return -1;
	}
	
	if (type_flag == 1)
	{
		memset(&menuList,0,sizeof(menuList));
		menuList.iTotalNum = 4;
		strcpy(menuList.acTitle, "请选择挑选号码类型：");
		strcpy(menuList.menuItem[0], "普通号码");
		strcpy(menuList.menuItem[1], "连号/顺号/孪生号");
		strcpy(menuList.menuItem[2], "连号/顺号/孪生号(含靓号)");
		strcpy(menuList.menuItem[3], "三连号/双孪生号(含靓号)");
		
		iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
		if(iRet)
			return -1;
		
		
		switch(iSelect)
		{
		case 1:
			iRet = CDB::getTEL_STOCKS(1,&txnLogs,gbl.city_no);
			break;
		case 2:
			iRet = CDB::getTEL_STOCKS(2,&txnLogs,gbl.city_no);
			break;
		case 3:
			iRet = CDB::getTEL_STOCKS(3,&txnLogs,gbl.city_no);
			break;
		case 4:
			iRet = CDB::getTEL_STOCKS(4,&txnLogs,gbl.city_no);
			break;
		default:
			return -1;
		}
		
	}else if (type_flag == 2)
	{
		iRet = CDB::getTEL_STOCKS(5,&txnLogs,gbl.city_no);
	}else if (type_flag == 3)
	{
		
		for (int j=0;j<8;j++)
		{
			memset(&phone_part_no[j],0,sizeof(phone_part_no[j]));
		}
		no_num = CDB::getTel_part(phone_part_no,gbl.city_no);
		memset(&menuList,0,sizeof(menuList));
		if(no_num <= 0)
		{
			TS_OutPutMsg(gbl.dPosInfo, "\n暂时没有可供选择的号码，如有问题请与客服联系\n  【确认】", 0, iSelect);
			return -1;
		}
		
		menuList.iTotalNum = no_num;
		strcpy(menuList.acTitle, "请选择挑选号码类型：");
		for (int i=0;i<no_num;i++)
		{
			strcpy(menuList.menuItem[i],phone_part_no[i].phone_head_no);
		}
		
		iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
		if(iRet)
			return -1;
		bbzero(phone_head);
		if (iSelect>0&&iSelect<=menuList.iTotalNum)
		{
			strcpy(phone_head,phone_part_no[iSelect-1].phone_head_no);
		}else
			return CANCLE_KEY;
		
		bbzero(phone_part);
		TSTradeInfoSend tradeInfoSend;
		TSTradeInfoRecv tradeInfoRecv;
		
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
		
		strcpy(tradeInfoSend.acMainTitle, title);
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents = 1;
		
		sprintf(tradeInfoSend.Contents[0].acTitle, "请输入选号条件：%s",phone_head);	
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//全字符
		tradeInfoSend.Contents[0].uCount = 0;		//输入1次
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
		tradeInfoSend.Contents[0].uMinLen = 4;	
		tradeInfoSend.Contents[0].uMaxLen = 4;
		
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		if(iRet != 0)
		{
			wrLog("TS_TradeControl返回错误[%d]", iRet);
			wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
			return iRet;
		}
		
		bbzero(gbl.pos_serial);
		strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
		strcpy(phone_part,(char *)tradeInfoRecv.Contents[0].uMsg );
		for (i=0;i<4;i++)
		{
			if (phone_part[i]<'0' || phone_part[i]>'9')
			{
				phone_part[i] = '%';
			}
		}
		iRet = CDB::getTEL_STOCKS(6,&txnLogs,gbl.city_no,phone_head,phone_part);
	}else
		return -1;
	if (iRet != 0)
	{
		TS_OutPutMsg(gbl.dPosInfo,"没有符合查询内容的手机号码，请重新输入条件",0,iSelect);
		return -1;
	}
	iRet = TS_ShowTxnLogs(gbl.dPosInfo, &txnLogs);
	return 0;
}

int CTrade::Sell_phoneno_hdl(const char*title)
{
	int iRet,iSelect,b48_len;
	char buff[512];
	char iccid_buff[30+1],mny[15+1],fee[12+1],type[2+1],len_buff[2+1];
	
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, title);
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入手机号码：");	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//全字符
	tradeInfoSend.Contents[0].uCount = 0;		//输入1次
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
	tradeInfoSend.Contents[0].uMinLen = 11;	
	tradeInfoSend.Contents[0].uMaxLen = 11;
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	
	bbzero(gbl.phone_no);
	strcpy(gbl.phone_no,(char *)tradeInfoRecv.Contents[0].uMsg );
	gbl.phone_len = tradeInfoRecv.Contents[0].uMsgLen;
	
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, title);
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入白卡ICCID号：");	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//全字符
	tradeInfoSend.Contents[0].uCount = 0;		//输入1次
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
	tradeInfoSend.Contents[0].uMinLen = 20;	
	tradeInfoSend.Contents[0].uMaxLen = 20;
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	
	bbzero(gbl.pos_serial);
	strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
	bbzero(gbl.ICCID_no);
	strcpy(gbl.ICCID_no,(char *)tradeInfoRecv.Contents[0].uMsg );
	
	bbzero(buff);
	bbzero(iccid_buff);
	
	for (int i=0;i<strlen(gbl.ICCID_no);i+=4)
	{
		strncat(iccid_buff,gbl.ICCID_no+i,4);
		strcat(iccid_buff," ");
	}
	bbzero(fee);
	bbzero(type);
	iRet = CDB::getTEL_STOCKS_detail(gbl.phone_no,fee,type);
	if (iRet<0)
	{
		TS_OutPutMsg(gbl.dPosInfo,"您查找的手机号码不存在!请重新选择号码",0,iSelect);
		return -1;
	}
	CTools::chgToMny(fee, mny);
	sprintf(buff,"入网城市：东莞；\n套餐类型：天翼华厦风；\n选定号码：%s；\n价格：%s；\n白卡卡号：%s\n\n 【确认】继续 【返回】取消",gbl.phone_no,mny,iccid_buff);
	iRet = TS_OutPutMsg(gbl.dPosInfo,buff,0,iSelect);
	if (iSelect != 0)
	{
		return -1;
	}
	bbzero(gbl.fee_type);
	strcpy(gbl.fee_type,"0330");
	bbzero(gbl.amount);
	sprintf(gbl.amount,"%012d",atoi(fee)/5-2000);
	
	pack.wrField(1, gbl);	//写交费域
	/***************修改一些域****************/
	bbzero(pack.FIELD48);
	memcpy(pack.FIELD48,gbl.fee_type,4);
	b48_len = 4;
	bbzero(len_buff);
	sprintf(len_buff,"%02d",gbl.phone_len);
	memcpy(pack.FIELD48+b48_len,len_buff,2);
	b48_len += 2;
	memcpy(pack.FIELD48+b48_len,gbl.phone_no,gbl.phone_len);
	b48_len += gbl.phone_len;
	memcpy(pack.FIELD48+b48_len,"01",2);
	b48_len += 2;
	pack.Packet_Table[48].Real_Length += b48_len;
	/*****************************************/
	
	iRet = packHdl(1);
	if(iRet < 0)
		return -1;
	
	if (!memcmp(pack.FIELD39,"00",2)) 
	{
		NULL;
	}else{
		returnFail((char*)pack.FIELD39);
		return -1;
	}
	
	int flag = 0;
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{
		if(!flag)
		{
			iRet = mngCard_Hdl(title);
			if(iRet == CANCLE_KEY)
				return CANCLE_KEY;
			else if(iRet != 0)
				return -1;
		}
		pack.wrField(2, gbl);	//写交费域
		/***************修改一些域****************/
		memcpy(pack.FIELD63+8,gbl.ICCID_no,strlen(gbl.ICCID_no));       //ICCID
		memcpy(pack.FIELD63+strlen(gbl.ICCID_no)+8,gbl.city_no,strlen(gbl.city_no));       //ICCID
		
		pack.Packet_Table[63].Real_Length=strlen(gbl.ICCID_no)+strlen(gbl.city_no)+8;
		/*****************************************/
		
		iRet = packHdl(2);
		if(iRet < 0)
			return -1;
		
		if (!memcmp(pack.FIELD39,"00",2)) 
		{
			iRet = TS_OutPutMsg(gbl.dPosInfo,"     号码购买成功！\n请按【确认】打印凭证",0,iSelect);
			bbzero(gbl.amount);
			strcpy(gbl.amount,fee);
			CPrint prt;
			prt.set_in_par(gbl);
			prt.print_sell_phone("空中放号");
			return 0;
		}
		else if(!memcmp(pack.FIELD39,"55",2))
		{
			flag = 1;
			if(reGetPwd(title) == 0) //密码错误，重新输入密码, 2006-10-25
				continue;
			else
				return CANCLE_KEY;
		}
		else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
			if (iSelect!=0)
			{
				return -1;
			}else
				continue;
		}
		else
			returnFail((char*)pack.FIELD39);
		return -1;
	}
	return 0;
}

int CTrade::Confirm_blank_phonecard(const char*title, int type)
{
	int iRet,iSelect;
	TSTxnLogs txnLogs;
	memset(&txnLogs, 0, sizeof(txnLogs));
	iRet = CDB::getUimLog(gbl.pos_no,&txnLogs, type);
	if (iRet != 0)
	{
		TS_OutPutMsg(gbl.dPosInfo,"没有交易记录，如有疑问请【Ctrl+H】联系客服",0,iSelect);
		return -1;
	}
	iRet = TS_ShowTxnLogs(gbl.dPosInfo, &txnLogs);
	return 0;
}

int CTrade::Confirm_blank_phonecard_hdl(const char*title, int type)
{
	int iRet,iSelect,b48_len;
	char m_stan[12+1];
	char m_amount[12+1],m_total_fee[12+1],m_name[60+1],m_telphone[16],m_address[500+1];
	char mny[16],buff[1024];
	
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, title);
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入订单号：");	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//全字符
	tradeInfoSend.Contents[0].uCount = 0;		//输入1次
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
	tradeInfoSend.Contents[0].uMinLen = 12;	
	tradeInfoSend.Contents[0].uMaxLen = 12;	
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	
	bbzero(gbl.pos_serial);
	strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
	bbzero(m_stan);
	strcpy(m_stan,(char *)tradeInfoRecv.Contents[0].uMsg );
	
	bbzero(m_name);
	bbzero(m_address);
	bbzero(m_amount);
	bbzero(m_name);
	bbzero(m_total_fee);
	CDB::getUimLog_detail(m_stan,m_amount,m_total_fee,m_name,m_telphone,m_address);
	
	bbzero(mny);
	CTools::chgToMny(m_total_fee, mny);
	
	bbzero(buff);
	sprintf(buff,"订单信息：\n  白卡单价：20元/张；\n  下单数量：%d张；\n  付款总额：%s；\n配送信息：\n  终端号：%s\n  联系人：%s\n  联系电话：%s\n  配送地址：%s\n\n 【确认】提交确认申请 【返回】取消",atoi(m_amount),mny,gbl.pos_no,m_name,m_telphone,m_address);
	
	TS_OutPutMsg(gbl.dPosInfo,buff,0,iSelect);
	if (iSelect!=0)
	{
		return -2;
	}
	
	bbzero(gbl.fee_type);
	if(type == 0)	//东莞电信空中放号
	{
		strcpy(gbl.fee_type,"0329");
	}
	else if(type == 1)	//联通空中放号
	{
		strcpy(gbl.fee_type,"0353");
	}
	else
	{
		return -1;
	}
	
	//写查询域
	pack.wrField(1, gbl);
	bbzero(pack.FIELD48);
	memcpy(pack.FIELD48,gbl.fee_type,4);
	b48_len = 4;
	memcpy(pack.FIELD48+b48_len,"1",1);
	b48_len += 1;
	memcpy(pack.FIELD48+b48_len,"12",2);
	b48_len += 2;
	memcpy(pack.FIELD48+b48_len,m_stan,12);
	b48_len += 12;
	
	pack.Packet_Table[48].Real_Length=b48_len;
	
	//  查询包打包
	iRet = packHdl(1);
	if(iRet < 0)
		return -1;
	
	if (memcmp(pack.FIELD39,"00",2)==0)
	{
		TS_OutPutMsg(gbl.dPosInfo,"白卡到货确认完毕！",0,iSelect);
		return 0;
	}else
	{
		returnFail((char*)pack.FIELD39);
		return -1;
	}
	return 0;
}


//电信业务预受理
int CTrade::telaffair_preaccept(const char* title)
{
	//定义数据区
	int iRet, iSelect, tradeType;
	char telno[15], homeno[12], identity_card[19], name[20], address[100], fee_type[30], install_type[30], temp[512], message[512];
	
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	
	TSMENULIST menuList;
	memset(&menuList, 0, sizeof(menuList));
	
	menuList.iTotalNum = 2;
	strcpy(menuList.acTitle, "电信业务预受理：");
	strcpy(menuList.menuItem[0], "1、ADSL报装");
	strcpy(menuList.menuItem[1], "2、ADSL加装");
	
	iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
	if(iRet == -1)
		return -1;
	
	switch(iSelect){
	case 1:
		tradeType = 1;
		break;
	case 2:
		tradeType = 2;
		break;
	}
	
	//选择计费类型
	memset(&menuList, 0, sizeof(menuList));
	menuList.iTotalNum = 3;
	strcpy(menuList.acTitle, "请选择宽带计费类型：");
	strcpy(menuList.menuItem[0], "1.100元可用60小时");
	strcpy(menuList.menuItem[1], "2.60元可用30小时");
	strcpy(menuList.menuItem[2], "3.138元包月(预存720元)");
	
	iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
	if(iRet == -1)
		return -1;
	
	bbzero(fee_type);
	switch(iSelect){
	case 1:
		strcpy(fee_type, "100元可用60小时");
		break;
	case 2:
		strcpy(fee_type, "60元可用30小时");
		break;
	case 3:
		strcpy(fee_type, "138元包月（需预存720元）");
		break;
	default:
		return -1;
	}
	
	//选择MODEN类型
	memset(&menuList, 0, sizeof(menuList));
	menuList.iTotalNum = 2;
	strcpy(menuList.acTitle, "请选择ADSL MODEM类型：");
	strcpy(menuList.menuItem[0], "1、单口以太网MODEM");
	strcpy(menuList.menuItem[1], "2、自备MODEM");
	
	iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
	if(iRet == -1)
		return -1;
	
	bbzero(install_type);
	switch(iSelect){
	case 1:
		strcpy(install_type, "单口以太网MODEM");
		break;
	case 2:
		strcpy(install_type, "自备MODEM");
		break;
	default:
		return -1;
	}
	
	//输入装机地址
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
				
	strcpy(tradeInfoSend.acMainTitle, "电信业务预受理");
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
				
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入装机地址：");	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;
	tradeInfoSend.Contents[0].uCount = 0;		//输入1次
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
	tradeInfoSend.Contents[0].uMinLen = 2;	
	tradeInfoSend.Contents[0].uMaxLen = 100;
				
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0){
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	bbzero(address);
	strcpy(address, (char *)tradeInfoRecv.Contents[0].uMsg);
	
	//输入联系人姓名
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
				
	strcpy(tradeInfoSend.acMainTitle, "电信业务预受理");
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
				
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入联系人姓名：");	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;
	tradeInfoSend.Contents[0].uCount = 0;		//输入1次
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
	tradeInfoSend.Contents[0].uMinLen = 2;	
	tradeInfoSend.Contents[0].uMaxLen = 20;
				
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0){
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	bbzero(name);
	strcpy(name, (char *)tradeInfoRecv.Contents[0].uMsg);
	
	//ADSL报装
	if(tradeType == 1){
		//输入联系电话
		while(1){
			memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
			memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
			
			strcpy(tradeInfoSend.acMainTitle, "电信业务预受理");
			tradeInfoSend.uHasTradeID = 1;
			tradeInfoSend.uTotalContents = 1;
			
			strcpy(tradeInfoSend.Contents[0].acTitle, "请输入联系电话：");	
			tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;
			tradeInfoSend.Contents[0].uCount = 0;		//输入1次
			tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
			tradeInfoSend.Contents[0].uMinLen = 8;	
			tradeInfoSend.Contents[0].uMaxLen = 15;
			
			iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
			if(iRet != 0){
				wrLog("TS_TradeControl返回错误[%d]", iRet);
				wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
				return iRet;
			}
			bbzero(telno);
			strcpy(telno, (char *)tradeInfoRecv.Contents[0].uMsg);
			memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
			memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
			
			strcpy(tradeInfoSend.acMainTitle, "电信业务预受理");
			tradeInfoSend.uHasTradeID = 1;
			tradeInfoSend.uTotalContents = 1;
			
			strcpy(tradeInfoSend.Contents[0].acTitle, "请再次输入手机号：");	
			tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;
			tradeInfoSend.Contents[0].uCount = 0;		//输入1次
			tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
			tradeInfoSend.Contents[0].uMinLen = 8;	
			tradeInfoSend.Contents[0].uMaxLen = 15;
			
			iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
			if(iRet != 0){
				wrLog("TS_TradeControl返回错误[%d]", iRet);
				wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
				return iRet;
			}
			bbzero(temp);
			strcpy(temp, (char *)tradeInfoRecv.Contents[0].uMsg);
			
			if(strcmp(telno, temp) != 0){
				TS_OutPutMsg(gbl.dPosInfo, "两次输入的电话号码不一致 \n\n【确认】重新输入  【返回】退出", 0, iSelect);
				if(iSelect != 0)
					return -1;
			}
			else
				break; 
		}
	}
	//ADSL加装
	else{
		//输入固话号码
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
		
		strcpy(tradeInfoSend.acMainTitle, "电信业务预受理");
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents = 1;
		
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入加装固话号码：");	
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;
		tradeInfoSend.Contents[0].uCount = 0;		//输入1次
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
		tradeInfoSend.Contents[0].uMinLen = 8;	
		tradeInfoSend.Contents[0].uMaxLen = 8;
		
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		if(iRet != 0){
			wrLog("TS_TradeControl返回错误[%d]", iRet);
			wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
			return iRet;
		}
		bbzero(homeno);
		strcpy(homeno, (char *)tradeInfoRecv.Contents[0].uMsg);
		
		//输入手机号码
		while(1){
			memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
			memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
			
			strcpy(tradeInfoSend.acMainTitle, "电信业务预受理：");
			tradeInfoSend.uHasTradeID = 1;
			tradeInfoSend.uTotalContents = 1;
			
			strcpy(tradeInfoSend.Contents[0].acTitle, "请输入手机号码：");	
			tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;
			tradeInfoSend.Contents[0].uCount = 0;		//输入1次
			tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
			tradeInfoSend.Contents[0].uMinLen = 8;	
			tradeInfoSend.Contents[0].uMaxLen = 15;
			
			iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
			if(iRet != 0){
				wrLog("TS_TradeControl返回错误[%d]", iRet);
				wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
				return iRet;
			}
			bbzero(telno);
			strcpy(telno, (char *)tradeInfoRecv.Contents[0].uMsg);
			memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
			memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
			
			strcpy(tradeInfoSend.acMainTitle, "电信业务预受理");
			tradeInfoSend.uHasTradeID = 1;
			tradeInfoSend.uTotalContents = 1;
			
			strcpy(tradeInfoSend.Contents[0].acTitle, "请再次输入手机号码：");	
			tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;
			tradeInfoSend.Contents[0].uCount = 0;		//输入1次
			tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
			tradeInfoSend.Contents[0].uMinLen = 8;	
			tradeInfoSend.Contents[0].uMaxLen = 15;
			
			iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
			if(iRet != 0){
				wrLog("TS_TradeControl返回错误[%d]", iRet);
				wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
				return iRet;
			}
			bbzero(temp);
			strcpy(temp, (char *)tradeInfoRecv.Contents[0].uMsg);
			
			if(strcmp(telno, temp) != 0){
				TS_OutPutMsg(gbl.dPosInfo, "两次输入的手机号码不一致 \n\n【确认】重新输入  【返回】退出", 0, iSelect);
				if(iSelect != 0)
					return -1;
			}
			else
				break; 
		}
	}
	
	//输入联系人身份证号码
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, "电信业务预受理");
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入联系人身份证号码：");	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_CH;
	tradeInfoSend.Contents[0].uCount = 0;		//输入1次
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
	tradeInfoSend.Contents[0].uMinLen = 15;	
	tradeInfoSend.Contents[0].uMaxLen = 18;
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0){
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	bbzero(identity_card);
	strcpy(identity_card, (char *)tradeInfoRecv.Contents[0].uMsg);
	
	
	//显示确认信息
	if(tradeType == 1){
		bbzero(message);
		bbzero(temp);
		sprintf(message, "     确认信息：\n您预订的是新装ADSL业务。\n宽带计费类型：%s\n您的姓名：%s\n您的联系电话：%s\n您的身份证号码：%s\n您的装机地址是：%s\n 【确认】继续\n 【返回】返回", fee_type, name, telno, identity_card, address);
		sprintf(temp, "您预订的是新装ADSL业务。\n宽带计费类型：%s\n您的姓名：%s\n您的联系电话：%s\n您的身份证号码：%s\n您的装机地址是：%s", fee_type, name, telno, identity_card, address);
		TS_OutPutMsg(gbl.dPosInfo, message, 0, iSelect);
		if(iSelect != 0)
			return -1;
	}
	else{
		bbzero(message);
		bbzero(temp);
		sprintf(message, "     确认信息：\n您预订的是加装ADSL业务。\n宽带计费类型：%s\n您的姓名：%s\n您需加装ADSL的固话：%s\n您的联系电话：%s\n您的身份证号码：%s\n您的装机地址是：%s\n 【确认】继续\n 【返回】返回", fee_type, name, homeno, telno, identity_card, address);
		sprintf(temp, "您预订的是加装ADSL业务。\n宽带计费类型：%s\n您的姓名：%s\n您需加装ADSL的固话：%s\n您的联系电话：%s\n您的身份证号码：%s\n您的装机地址是：%s", fee_type, name, homeno, telno, identity_card, address);
		
		TS_OutPutMsg(gbl.dPosInfo, message, 0, iSelect);
		if(iSelect != 0)
			return -1;
	}
	
	//预订成功，打印凭条
	pack.wrField(1, gbl);
	
	CPrint prt;
	prt.set_in_par(gbl);
	
	prt.print_telaffair_preaccept(tradeType, temp);
	
	TS_OutPutMsg(gbl.dPosInfo, "预订成功,打印凭条...", 0, iSelect);
	
	return 0;
}

int CTrade::pep_query_hdl(char* areacode, char* phonenum, char* month, char* feetype, int flag)
{
	int iRet, rspcode, item_num, sLen, pos, i, j;
	long allfee = 0;
	char returnstring[10240], num[6], username[40], len[5], totalfee[20];
	memset(returnstring, 0, 10240);
	rspcode = pep_query(areacode, phonenum, month, feetype, returnstring);
	if(rspcode == -2)
	{
		return -2;
	}
	else if(rspcode == -1)
	{
		return -2;
	}
	
	pos = 4;
	bbzero(len);
	memcpy(len, returnstring + pos, 2); //请求结果说明长度
	pos = pos + atoi(len) + 2;
	bbzero(len);
	memcpy(len, returnstring + pos, 1);//总费用长度
	pos = pos + 1;
	bbzero(totalfee);
	memcpy(totalfee, returnstring + pos, atoi(len));
	pos = pos + atoi(len);
	bbzero(len);
	memcpy(len, returnstring + pos, 1);//帐期标识长度
	pos = pos + atoi(len) + 1;
	bbzero(len);
	memcpy(len, returnstring + pos, 2);//用户名长度
	sLen = atoi(len);
	pos = pos + 2;
	bbzero(username);
	memcpy(username, returnstring + pos, sLen);//用户名
	pos = pos + sLen;
	bbzero(num);
	memcpy(num, returnstring + pos, 4);//发票项个数
	pos = pos + 4;
	item_num = atoi(num);
	
	if(item_num <= 0)
	{
		gbl.bill_list_len = 0;
		//delete[] returnstring;
		return -1;
	}
	else if(item_num > 50)
	{
		//TS_OutPutMsg(gbl.dPosInfo, "您的账单明细过长，不能正常显示", 0, iSelect);
		wrLog("账单明细项过多，无法正常显示");
		gbl.bill_list_len = 0;
		//delete[] returnstring;
		return -1;
	}
	
	for(i = 0; i < item_num; i++)
	{
		//将记录读入Bill_Item
		bbzero(len);
		memcpy(len, returnstring + pos, 2);				//发票项名称
		sLen = atoi(len);
		pos = pos + 2;
		bbzero(gbl.bill_item_list[i].item_name);
		memcpy(gbl.bill_item_list[i].item_name, returnstring + pos, sLen);
		pos = pos + sLen;
		bbzero(len);
		memcpy(len, returnstring + pos, 2);				//发票项号码
		sLen = atoi(len);
		pos = pos + 2;
		bbzero(gbl.bill_item_list[i].phone);
		memcpy(gbl.bill_item_list[i].phone, returnstring + pos, sLen);
		pos = pos + sLen;
		bbzero(len);
		memcpy(len, returnstring + pos, 2);				//发票项费用
		sLen = atoi(len);
		pos = pos + 2;
		memcpy(gbl.bill_item_list[i].fee, returnstring + pos, sLen);
		pos = pos + sLen;
		bbzero(gbl.bill_item_list[i].month);
		memcpy(gbl.bill_item_list[i].month, returnstring + pos, 8);		//账期标识
		pos = pos + 8;
		gbl.bill_item_list[i].flag = 0;
		
	}
	
	gbl.bill_list_len = 0;
	for(i = 0; i < item_num; i++)
	{
		//将Bill_item分类存入Bill
		if(gbl.bill_item_list[i].flag != 0)
		{
			continue;
		}
		memset(&gbl.bill_list[gbl.bill_list_len], 0, sizeof(Bill));
		strcpy(gbl.bill_list[gbl.bill_list_len].username, username);
		strcpy(gbl.bill_list[gbl.bill_list_len].mainphone, phonenum);
		strcpy(gbl.bill_list[gbl.bill_list_len].phone, gbl.bill_item_list[i].phone);
		strcpy(gbl.bill_list[gbl.bill_list_len].month, gbl.bill_item_list[i].month);
		gbl.bill_list[gbl.bill_list_len].print_flag = 0;
		gbl.bill_list[gbl.bill_list_len].item_num = 1;
		gbl.bill_list[gbl.bill_list_len].item_index[0] = i;
		gbl.bill_item_list[i].flag = 1;
		gbl.bill_list_len++;
		
		for(j = i + 1; j < item_num; j++)
		{
			
			if(gbl.bill_item_list[j].flag != 0)
			{
				continue;
			}
			if(strcmp(gbl.bill_list[gbl.bill_list_len-1].phone, gbl.bill_item_list[j].phone) == 0 && strcmp(gbl.bill_list[gbl.bill_list_len-1].month, gbl.bill_item_list[j].month) == 0)
			{
				gbl.bill_list[gbl.bill_list_len-1].item_index[gbl.bill_list[gbl.bill_list_len-1].item_num] = j;
				gbl.bill_list[gbl.bill_list_len-1].item_num++;
				gbl.bill_item_list[j].flag = 1;
			}
			
		}
	}
	
	//使用list显示所有bill
	bbzero(totalfee);
	for(i = 0; i < gbl.bill_list_len; i++)
	{
		for(j = 0; j < gbl.bill_list[i].item_num; j++)
		{
			allfee += atol(gbl.bill_item_list[gbl.bill_list[i].item_index[j]].fee);	
		}
	}
	sprintf(totalfee, "%ld", allfee);
	iRet = pep_show_bill(totalfee, areacode, flag);
	if(iRet == -1)
	{
		return -1;
	}

	
	return 0;
}

int CTrade::pep_query(char* areacode, char* num, char* month, char* feetype, char* returnstring)
{
	
	int iRet=0, sLen=0, rLen=0, iSelect=0, itotal=0;
	SOCKET sd=0;
	char rspcode[4+1], scont[512], rcont[10240], temp[1025], date[15], len[9], totallen[10];
	CConnect con;
	long ii;
	struct tm *tim;
	
	//132.97.117.165:7830 测试
	//132.97.117.189:7830 生产
	//con.conToHost("132.97.117.189", atoi("6345"), &sd)==0
    if(con.conToHost(PE_IP, PE_PORT, &sd)==0)
	//if(con.conToHost("132.97.117.165", atoi("7830"), &sd)==0)
	{
		bbzero(scont);
		//写包头
		sLen = 0;
		//包开始标志 日期时间+终端号
		strcpy(scont, "FFFF");
		//包标识号
		bbzero(date);
		time(&ii);
		tim=localtime(&ii);
		sprintf(date,"%04d%02d%02d%02d%02d%02d",tim->tm_year+1900,tim->tm_mon+1,tim->tm_mday,tim->tm_hour,tim->tm_min,tim->tm_sec);
		strcat(scont, date);
		strcat(scont, gbl.pos_no);
		//包总长
		strcat(scont, "00000000");
		//包类型
		strcat(scont, "PEP00010");
		//写包体
		//目标地区编码
		bbzero(len);
		sprintf(len, "%d", strlen(areacode));
		strcat(scont, len);
		strcat(scont, areacode);
		//号码
		bbzero(len);
		sprintf(len, "%02d", strlen(num));
		strcat(scont, len);
		strcat(scont, num);
		//帐期月份
		bbzero(len);
		sprintf(len, "%d", strlen(month));
		strcat(scont, len);
		strcat(scont, month);
		//费用类型
		strcat(scont, feetype);
		sLen = strlen(scont);
		sprintf(len, "%08d", sLen);
		memcpy(scont + 4 + 22, len, 8);
		//发送数据包
		wrLog("发送PEP0001请求明细到ACC:[%s]", scont);
		iRet = con.sndMsg(sd, scont, sLen);
		if( iRet!=0 )
		{
			closesocket(sd);
			return -1;
		}
		//-----------------------------------------------
		memset(temp, 0, 1025);
		iRet = con.rcvMsg(sd, temp, &rLen, 42);
		if(rLen != 42 || iRet != 0)
		{
			closesocket(sd);
			return -1;
		}
		bbzero(totallen);
		memcpy(totallen, temp+26, 8);
		
		itotal = atoi(totallen);
		if(itotal >= 10240)
		{
			wrLog("超过包内容最大长度[%d]", itotal);
			closesocket(sd);
			return -1;
		}
		
		itotal -= 42;
		
		bbzero(rcont);
		wrLog("申请堆空间[%d]", itotal+1);
		while(1)
		{
			memset(temp, 0, 1025);
			iRet = con.rcvMsg(sd, temp, &rLen, 1024);
			strcat(rcont, temp);
			
			if(iRet)
			{
				closesocket(sd);
				return -1;
			}
			if(itotal - rLen > 0)
			{
				itotal = itotal - rLen;
				continue;
			}
			break;
		}
		
		wrLog("接收FASACC明细内容长度:[%d]", strlen(rcont));
		if(strlen(rcont) < 8192)
		{
			wrLog("接收FASACC明细内容:[%s]", rcont);
		}
		else
		{
			wrLog("【明细过长，无法写LOG】");
		}
		closesocket(sd);
		if(rLen < 0 || iRet != 0)
		{
			return -1;
		}
		
		bbzero(rspcode);
		memcpy(rspcode, rcont, 4);
		//失败
		if(atoi(rspcode) != 0)
		{
			bbzero(len);
			bbzero(returnstring);
			memcpy(len, rcont + 4, 2);
			memcpy(returnstring, rcont + 6, atoi(len));
			return -2;
		}
		//成功
		bbzero(returnstring);
		memcpy(returnstring, rcont, strlen(rcont));
	}
	else
	{
		return -1;
	}
	
	return 0;
}


int CTrade::pep_show_bill(char* totalfee, char* area_code, int flag)
{
	int i, j, iRet;
	long lfee;
	char index[3], month[20], temp[50], fee[20];
	char city_no[5];
	bbzero(city_no);
	strcpy(city_no, area_code);
	
	TSTxnLogs txnLogs;
	memset(&txnLogs, 0, sizeof(txnLogs));
	
	if(gbl.bill_list_len <= 0)
	{
		return -1;
	}
	
	txnLogs.colsnum = 6;
	txnLogs.colsWidth[0] = 120;
	txnLogs.colsWidth[1] = 120;
	txnLogs.colsWidth[2] = 60;
	txnLogs.colsWidth[3] = 60;
	txnLogs.colsWidth[4] = 0;
	txnLogs.colsWidth[5] = 0;
	txnLogs.colsNameLen = 43;
	memcpy(txnLogs.colsName, "号码\x00账期\x00费用项目\x00金额(元)\x00菜单ID\x00菜单内容", txnLogs.colsNameLen);
	
	bbzero(fee);
	CTools::longToMny(atol(totalfee), fee);
	
	if(flag == 3)
	{
		sprintf(temp, "绑定业务查询 欠费总额:%s元", fee);
	}
	else
	{
		sprintf(temp, "单一号码查询 欠费总额:%s元", fee);
	}
	
	sprintf(txnLogs.top, "户名:%s ", gbl.bill_list[0].username);
	if(strlen(gbl.bill_list[0].mainphone) < 10)
		sprintf(txnLogs.hint, "号码:%s%s %s  ", city_no, gbl.bill_list[0].mainphone, temp);
	else
		sprintf(txnLogs.hint, "号码:%s %s  ", gbl.bill_list[0].mainphone, temp);
	strcpy(txnLogs.bottom, "【<-】【->】翻页 【确认】下一步");
	
	//复制数据到list
	for(i = 0; i < gbl.bill_list_len; i++)
	{
		if( txnLogs.itemsLen+strlen(gbl.bill_list[i].phone) < MAX_INTERM_BUF )
		{
			bbzero(temp);
			if(strlen(gbl.bill_list[i].phone) < 10)
				sprintf(temp, "%s%s", city_no, gbl.bill_list[i].phone);
			else
				strcpy(temp, gbl.bill_list[i].phone);
			strcpy(txnLogs.items+txnLogs.itemsLen, temp);
			txnLogs.itemsLen = txnLogs.itemsLen + strlen(txnLogs.items+txnLogs.itemsLen) + 1;
		}
		else
		{
			break;
		}
		
		bbzero(month);
		bbzero(temp);
		memcpy(temp, gbl.bill_list[i].month, 4);
		strcpy(month, temp);
		strcat(month, "年");
		bbzero(temp);
		memcpy(temp, gbl.bill_list[i].month + 4, 2);
		strcat(month, temp);
		strcat(month, "月");
		
		if( txnLogs.itemsLen+strlen(month) < MAX_INTERM_BUF )
		{
			strcpy(txnLogs.items+txnLogs.itemsLen, month);
			txnLogs.itemsLen = txnLogs.itemsLen + strlen(txnLogs.items+txnLogs.itemsLen) + 1;
		}
		else
		{
			break;
		}
		txnLogs.itemsLen++;
		txnLogs.itemsLen++;
		if( txnLogs.itemsLen+strlen("684") < MAX_INTERM_BUF )
		{
			strcpy(txnLogs.items+txnLogs.itemsLen, "684");
			txnLogs.itemsLen = txnLogs.itemsLen + strlen("684") + 1;
		}
		else
		{
			break;
		}
		sprintf(index, "%d", i);
		if( txnLogs.itemsLen+strlen(index) < MAX_INTERM_BUF )
		{
			strcpy(txnLogs.items+txnLogs.itemsLen, index);
			txnLogs.itemsLen = txnLogs.itemsLen + strlen(txnLogs.items+txnLogs.itemsLen) + 1;
		}
		else
		{
			break;
		}
		lfee = 0;
		for(j = 0; j < gbl.bill_list[i].item_num; j++)
		{
			txnLogs.itemsLen++;
			txnLogs.itemsLen++;
			if( txnLogs.itemsLen+strlen(gbl.bill_item_list[gbl.bill_list[i].item_index[j]].item_name) < MAX_INTERM_BUF )
			{
				strcpy(txnLogs.items+txnLogs.itemsLen, gbl.bill_item_list[gbl.bill_list[i].item_index[j]].item_name);
				txnLogs.itemsLen = txnLogs.itemsLen + strlen(txnLogs.items+txnLogs.itemsLen) + 1;
			}
			else
			{
				break;
			}
			lfee += atol(gbl.bill_item_list[gbl.bill_list[i].item_index[j]].fee);
			bbzero(temp);
			CTools::longToMny(atol(gbl.bill_item_list[gbl.bill_list[i].item_index[j]].fee), temp);
			if( txnLogs.itemsLen+strlen(temp) < MAX_INTERM_BUF )
			{
				strcpy(txnLogs.items+txnLogs.itemsLen, temp);
				txnLogs.itemsLen = txnLogs.itemsLen + strlen(txnLogs.items+txnLogs.itemsLen) + 1;
			}
			else
			{
				break;
			}
			if( txnLogs.itemsLen+strlen("684") < MAX_INTERM_BUF )
			{
				strcpy(txnLogs.items+txnLogs.itemsLen, "684");
				txnLogs.itemsLen = txnLogs.itemsLen + strlen("684") + 1;
			}
			else
			{
				break;
			}
			sprintf(index, "%d", i);
			if( txnLogs.itemsLen+strlen(index) < MAX_INTERM_BUF )
			{
				strcpy(txnLogs.items+txnLogs.itemsLen, index);
				txnLogs.itemsLen = txnLogs.itemsLen + strlen(txnLogs.items+txnLogs.itemsLen) + 1;
			}
			else
			{
				break;
			}
		}
		bbzero(totalfee);
		CTools::longToMny(lfee, totalfee);
		txnLogs.itemsLen++;
		txnLogs.itemsLen++;
		if( txnLogs.itemsLen+strlen("小计") < MAX_INTERM_BUF )
		{
			strcpy(txnLogs.items+txnLogs.itemsLen, "小计");
			txnLogs.itemsLen = txnLogs.itemsLen + strlen(txnLogs.items+txnLogs.itemsLen) + 1;
		}
		else
		{
			break;
		}
		if( txnLogs.itemsLen+strlen(totalfee) < MAX_INTERM_BUF )
		{
			strcpy(txnLogs.items+txnLogs.itemsLen, totalfee);
			txnLogs.itemsLen = txnLogs.itemsLen + strlen(txnLogs.items+txnLogs.itemsLen) + 1;
		}
		else
		{
			break;
		}
		if( txnLogs.itemsLen+strlen("684") < MAX_INTERM_BUF )
		{
			strcpy(txnLogs.items+txnLogs.itemsLen, "684");
			txnLogs.itemsLen = txnLogs.itemsLen + strlen("684") + 1;
		}
		else
		{
			break;
		}
		sprintf(index, "%d", i);
		if( txnLogs.itemsLen+strlen(index) < MAX_INTERM_BUF )
		{
			strcpy(txnLogs.items+txnLogs.itemsLen, index);
			txnLogs.itemsLen = txnLogs.itemsLen + strlen(txnLogs.items+txnLogs.itemsLen) + 1;
		}
		else
		{
			break;
		}
	}
	//显示list
	iRet = TS_ShowTxnLogs(gbl.dPosInfo, &txnLogs);
	
	return iRet;
}

int CTrade::show_sdmBills(CGlobal gbl) //显示水电煤账单信息
{
	TSTxnLogs txnLogs;
	int iRet;
	long bill_delay=0;
	long  bill_amount=0; //交单缴费
	long bill_totalfee=0;
	bbzero(gbl.sdm_totalFee);
	bbzero(gbl.sdm_CUSTOMERNAME);
	bbzero(gbl.SDM_BILLNO);

	char index[2+1];
	bbzero(index);
	memset(&txnLogs, 0, sizeof(txnLogs));
	txnLogs.colsnum = 7;
	txnLogs.colsWidth[0] = 120;
	txnLogs.colsWidth[1] = 120;
	txnLogs.colsWidth[2] = 60;
	txnLogs.colsWidth[3] = 60;
	txnLogs.colsWidth[4]=60;
	txnLogs.colsWidth[5] = 0;
	txnLogs.colsWidth[6] = 0;
	txnLogs.colsNameLen = 43;
	//获取账户姓名+缴费单号 
	strcpy(gbl.sdm_CUSTOMERNAME,gbl.sdmBills.BillDetails[0].CUSTOMERNAME);
	strcpy(gbl.SDM_BILLNO,gbl.sdmBills.BillDetails[0].BILLNO);
	sprintf(txnLogs.top, "用户名:%s 用户号:%s",gbl.sdm_CUSTOMERNAME,gbl.SDM_BILLNO);
	memcpy(txnLogs.colsName, "用户号\x00账期\x00收费单位\x00缴费项目\x00金额(元)\x00菜单ID\x00菜单内容", txnLogs.colsNameLen);
	for (int i=0;i<gbl.sdmBills.nCnt;i++)
	{
	
		if( txnLogs.itemsLen+strlen(gbl.sdmBills.BillDetails[i].BILLNO) < MAX_INTERM_BUF ) //缴费单号
		{
			strcpy(txnLogs.items+txnLogs.itemsLen, gbl.sdmBills.BillDetails[i].BILLNO);
			txnLogs.itemsLen = txnLogs.itemsLen + strlen(txnLogs.items+txnLogs.itemsLen) + 1;
		}
		else
		{
			break;
		}
		
		char temp[20];
		char month[20];
		bbzero(month);
		bbzero(temp);
		memcpy(temp, gbl.sdmBills.BillDetails[i].BILLMONTH, 4);
		strcpy(month, temp);
		strcat(month, "年");
		bbzero(temp);
		memcpy(temp, gbl.sdmBills.BillDetails[i].BILLMONTH + 4, 2);
		strcat(month, temp);
		strcat(month, "月");
		
		if( txnLogs.itemsLen+strlen(month) < MAX_INTERM_BUF )
		{
			strcpy(txnLogs.items+txnLogs.itemsLen, month);
			txnLogs.itemsLen = txnLogs.itemsLen + strlen(txnLogs.items+txnLogs.itemsLen) + 1;
		}
		else
		{
			break;
		}
		//收费单位
		if( txnLogs.itemsLen+strlen(gbl.sdm_PAYMENTNAME) < MAX_INTERM_BUF )
		{
			strcpy(txnLogs.items+txnLogs.itemsLen, gbl.sdm_PAYMENTNAME);
			txnLogs.itemsLen = txnLogs.itemsLen + strlen(txnLogs.items+txnLogs.itemsLen) + 1;
		}
		else
		{
			break;
		}

		txnLogs.itemsLen++;
		txnLogs.itemsLen++;
		if( txnLogs.itemsLen+strlen("684") < MAX_INTERM_BUF )
		{
			strcpy(txnLogs.items+txnLogs.itemsLen, "684");
			txnLogs.itemsLen = txnLogs.itemsLen + strlen("684") + 1;
		}
		else
		{
			break;
		}

		sprintf(index, "%d", i);
		if( txnLogs.itemsLen+strlen(index) < MAX_INTERM_BUF )
		{
			strcpy(txnLogs.items+txnLogs.itemsLen, index);
			txnLogs.itemsLen = txnLogs.itemsLen + strlen(txnLogs.items+txnLogs.itemsLen) + 1;
		}
		else
		{
			break;
		}

		//缴费项目
		
		if( txnLogs.itemsLen+strlen(gbl.sdm_PAYMENTNAME) < MAX_INTERM_BUF )
		{
			strcpy(txnLogs.items+txnLogs.itemsLen, gbl.sdm_PAYMENTNAME);
			txnLogs.itemsLen = txnLogs.itemsLen + strlen(txnLogs.items+txnLogs.itemsLen) + 1;
		}
		else
		{
			break;
		}

		//显示费用项目

		bill_totalfee=0;
		char bill_amount_tmp[12+1];
		bbzero(bill_amount_tmp);
		bill_amount=atol(gbl.sdmBills.BillDetails[i].BILLAMOUNT);
		bill_totalfee+=bill_amount;
	
		CTools::longToMny(atol(gbl.sdmBills.BillDetails[i].BILLAMOUNT), bill_amount_tmp);
		if( txnLogs.itemsLen+strlen(bill_amount_tmp) < MAX_INTERM_BUF )
		{
		
			strcpy(txnLogs.items+txnLogs.itemsLen, bill_amount_tmp); //缴费金额 精确到分

			txnLogs.itemsLen = txnLogs.itemsLen + strlen(txnLogs.items+txnLogs.itemsLen) + 1;
		}

		else
		{
			break;
		}
		
		//判断是否有滞纳金
		if (atol(gbl.sdmBills.BillDetails[i].BILLDELAY)>0)
		{
			char bill_delay[12+1];
			bbzero(bill_delay);
			CTools::longToMny(atol(gbl.sdmBills.BillDetails[i].BILLDELAY),bill_delay);
			if( txnLogs.itemsLen+strlen(bill_delay) < MAX_INTERM_BUF )
			{
				
				strcpy(txnLogs.items+txnLogs.itemsLen,bill_delay); //滞纳金
				txnLogs.itemsLen = txnLogs.itemsLen + strlen(txnLogs.items+txnLogs.itemsLen) + 1;
			}
			else
			{
				break;
			}

		}
	}

	//合计总缴费金额
	CTools::longToMny(bill_totalfee,gbl.sdm_totalFee);
	sprintf(txnLogs.hint, "缴费总额:%s 请确认进行缴费 ",gbl.sdm_totalFee);
	strcpy(txnLogs.bottom, "【<-】【->】翻页 【确认】下一步");
	iRet = TS_ShowTxnLogs(gbl.dPosInfo, &txnLogs);

	return iRet;
}

int CTrade::pep_distribute()
{
	//	wrLog("新线程运行");
	//	int iSelect;
	//	TSTradeInfoSend tradeInfoSend;
	// 	TSTradeInfoRecv tradeInfoRecv;
	// 	
	// 	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	// 	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	// 	
	// 	strcpy(tradeInfoSend.acMainTitle, "账单选项");
	// 	tradeInfoSend.uHasTradeID = 1;
	// 	tradeInfoSend.uTotalContents = 1;
	// 	
	// 	strcpy(tradeInfoSend.Contents[0].acTitle, "请选择账单项");	
	// 	tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//全字符
	// 	tradeInfoSend.Contents[0].uCount = 0;		//输入1次
	// 	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
	// 	tradeInfoSend.Contents[0].uMinLen = 1;	
	// 	tradeInfoSend.Contents[0].uMaxLen = 2;
	// 	
	// 	TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	// TS_OutPutMsg(gbl.dPosInfo, "aaa", 0, iSelect);
	//	strcpy(gbl.phone_no, bill_list[0].mainphone);
	//	DZDBAirPay("电信直充", pep_type, 1);
	return 0;
}

int CTrade::sell_txtgame_card(const char* type)
{
	int  iRet=0, flag = 0;
	int  iSelect;
	int  b48_len;
	char response_code[3];
	
	char len_tmp[2+1];
	char amoMny[15], msg[200];
	
	TSMENULIST menuList;
	
	wrLog("天下通游戏卡售卡业务");
    memset(&menuList,0,sizeof(menuList));
	bbzero(gbl.amount);
	bbzero(gbl.card_amount);
	bbzero(gbl.xmcard_type);
	bbzero(gbl.xmcard_name);
	
	menuList.iTotalNum =7;
	strcpy(menuList.acTitle, "请选择游戏卡类型");
	strcpy(menuList.menuItem[0], "战网魔兽世界30元");
	strcpy(menuList.menuItem[1], "完美世界一卡通10元");
	strcpy(menuList.menuItem[2], "光宇一卡通30元");
	strcpy(menuList.menuItem[3], "米米卡摩尔庄园30元");
	strcpy(menuList.menuItem[4], "梦幻龙族15元");
	strcpy(menuList.menuItem[5], "征途巨人一卡通10元");
	strcpy(menuList.menuItem[6], "久游一卡通15元");
	
	iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
	if(iRet)
		return -1;
	switch(iSelect)
	{
	case 1:
		strcpy(gbl.amount,"000000003000");
		strcpy(gbl.card_amount,"000000003000");
		strcpy(gbl.sell_card_type,"0812");
		strcpy(gbl.xmcard_name,"战网魔兽世界");
		break;
	case 2:
		strcpy(gbl.amount,"000000001000");
		strcpy(gbl.card_amount,"000000001000");
		strcpy(gbl.sell_card_type,"0810");
		strcpy(gbl.xmcard_name,"完美世界一卡通");
		break;
	case 3:
		strcpy(gbl.amount,"000000003000");
		strcpy(gbl.card_amount,"000000003000");
		strcpy(gbl.sell_card_type,"0812");
		strcpy(gbl.xmcard_name,"光宇一卡通");
		break;
	case 4:
		strcpy(gbl.amount,"000000003000");
		strcpy(gbl.card_amount,"000000003000");
		strcpy(gbl.sell_card_type,"0812");
		strcpy(gbl.xmcard_name,"米米卡摩尔庄园");
		break;
	case 5:
		strcpy(gbl.amount,"000000001500");
		strcpy(gbl.card_amount,"000000001500");
		strcpy(gbl.sell_card_type,"0811");
		strcpy(gbl.xmcard_name,"梦幻龙族");
		break;
	case 6:
		strcpy(gbl.amount,"000000001000");
		strcpy(gbl.card_amount,"000000001000");
		strcpy(gbl.sell_card_type,"0810");
		strcpy(gbl.xmcard_name,"征途巨人一卡通");
		break;
	case 7:
		strcpy(gbl.amount,"000000001500");
		strcpy(gbl.card_amount,"000000001500");
		strcpy(gbl.sell_card_type,"0811");
		strcpy(gbl.xmcard_name,"久游一卡通");
		break;
	default: 
		return CANCLE_KEY;
	}
	
	if(atoi(gbl.dPosInfo.prmVer)>=9000)
	{
		bbzero(amoMny);
		CTools::chgToMny(gbl.amount,amoMny);
		bbzero(msg);
		sprintf(msg, "%s\n\n%s\n\n【是 Enter】  【否 Esc】", gbl.xmcard_name, amoMny);
		iRet = TS_OutPutMsg(gbl.dPosInfo, msg, 0, iSelect);
		if(iSelect)
		{
			return -1;
		}
	}
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{	
		if(!flag)
		{
			iRet = mngCard_Hdl(type);
			if(iRet == CANCLE_KEY)
				return CANCLE_KEY;
			else if(iRet != 0)
				return -1;
		}
        
		pack.wrField(2, gbl);	//写交费域
		/*************48bit****************/
		b48_len = 0;
		bbzero(pack.FIELD48);
		memcpy(pack.FIELD48, gbl.fee_type, 4);
		b48_len += 4;
		bbzero(len_tmp);
		memcpy(len_tmp, "04", 2);
		memcpy(pack.FIELD48 + b48_len, len_tmp, 2);
		b48_len += 2;
		memcpy(pack.FIELD48+b48_len, gbl.sell_card_type, 4);
		b48_len += 4;
		pack.Packet_Table[48].Real_Length=b48_len;
		/*************end 48bit****************/
		
		iRet = packHdl(2);
		if(iRet < 0)
			return -1;
		
		memset(response_code,0,sizeof(response_code));
		memcpy(response_code,pack.FIELD39,2);
		if (!memcmp(response_code,"00",2)) 
		{   
			if(atoi(gbl.fee_type)==153){
				TS_OutPutMsg(gbl.dPosInfo," \n     交易成功！\n   请连接好打印机\n   按【确认】打印",0,iSelect);
			}
			else
				TS_OutPutMsg(gbl.dPosInfo,"     售卡成功！\n按【确认】打印卡数据\n如无法正常获得卡数据，请立即致电400-80-11888（最好于3小时以内），我们将为您优先处理",0,iSelect);
			wrLog("售卡成功，准备打印!");
			CPrint prt;
			prt.set_in_par(gbl);
			//prt.print_detail(3, gbl.xmcard_name);	 //打印售卡明细
			prt.print_card_detail(pack,gbl.xmcard_name);
			return 0;
		}
		else if(!memcmp(response_code,"55",2))
		{
			flag = 1;
			if(reGetPwd( type) == 0) //密码错误，重新输入密码, 2006-10-25，lihk
				continue;
			else
				return CANCLE_KEY;
		}
		else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
			if (iSelect!=0)
			{
				return -1;
			}else
				continue;
		}
		else
		{					
			returnFail(response_code);
		}
		return 1;
	}
	return -1;
}

CTrade::game_recharge_showGames(const char* title, int type)
{
	int iSelect, iRet; 
	char sql[1024], temp[20];
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	TSTxnLogs txnLogs;
	
	
	bbzero(sql);
	switch(type)
	{
	case 0:
		//strcpy(sql, "select * from xkl_game");
		if(gbl.tgroup == 5)
		{
			strcpy(sql, "select distinct game_name, server_flag, memo, reward, listorder from xkl_game where pay_flag='S0A' or pay_flag='S0N' order by listorder");
		}
		else
		{
			strcpy(sql, "select distinct game_name, server_flag, memo, reward, listorder from xkl_game where pay_flag='S0A' order by listorder");
		}
		break;
	case 1:
		//TS_CONTROL获取字符
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
		
		strcpy(tradeInfoSend.acMainTitle, title);
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents = 1;		
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入关键字：");	
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//全字符
		tradeInfoSend.Contents[0].uCount = 0;		//输入1次		
		tradeInfoSend.Contents[0].uTimeOut = 60;	//超时40秒
		tradeInfoSend.Contents[0].uMinLen = 0;		
		tradeInfoSend.Contents[0].uMaxLen = 18;
		
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		
		if(iRet != 0)
		{
			wrLog("TS_TradeControl返回错误[%d]", iRet);
			wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
			return iRet;
		}
		
		bbzero(temp);
		memcpy(temp, (char *)tradeInfoRecv.Contents[0].uMsg, tradeInfoRecv.Contents[0].uMsgLen);
		
		//将小写字母转换为大写
		CTools::lowerToUpper(temp);
		
		//sprintf(sql, "select * from xkl_game where GAME_NAME like '%%%s%%'", temp);
		if(gbl.tgroup == 5)
		{
			sprintf(sql, "select distinct game_name, server_flag, memo, reward, listorder from xkl_game where game_name like '%%%s%%' and (pay_flag='S0A' or pay_flag='S0N') order by listorder", temp);
		}
		else
		{
			sprintf(sql, "select distinct game_name, server_flag, memo, reward, listorder from xkl_game where game_name like '%%%s%%' and pay_flag='S0A' order by listorder", temp);
		}
		
		
		break;
	default:
		return -1;
	}
	
	memset(&txnLogs, 0, sizeof(txnLogs));
	
	iRet = CDB::getGameList(&txnLogs, sql);
	
	if (iRet != 0)
	{
		TS_OutPutMsg(gbl.dPosInfo,"暂无符合条件的游戏，请更换条件后再试",0,iSelect);
		return -1;
	}
	
	iRet = TS_ShowTxnLogs(gbl.dPosInfo, &txnLogs);
	return iRet;
}

CTrade::game_recharge_showAmount(const char* title)
{
	int iSelect, iRet, iLen; 
	char content[30], len[3], server_flag[2],  game_name[30], sql[1024];
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	TSTxnLogs txnLogs;
	
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, "游戏查询信息");
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	strcpy(tradeInfoSend.Contents[0].acTitle, "游戏查询信息");
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;
	tradeInfoSend.Contents[0].uCount = 0;
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME + 30;
	tradeInfoSend.Contents[0].uMinLen = 4;
	tradeInfoSend.Contents[0].uMaxLen = 40;
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	
	bbzero(content);
	memcpy(content, (char *)tradeInfoRecv.Contents[0].uMsg, tradeInfoRecv.Contents[0].uMsgLen);
	
	//分割出game_name, server_flag;
	bbzero(game_name);

	bbzero(server_flag);
	memcpy(len, content, 2);
	iLen = atoi(len);
	memcpy(game_name, content + 2, iLen);
	memcpy(server_flag, content + 2 + iLen, 1);
	
	memset(&txnLogs, 0, sizeof(txnLogs));
	
	bbzero(sql);
	if(gbl.tgroup == 5)
	{
		sprintf(sql, "select * from xkl_game where game_name = '%s' and (pay_flag='S0A' or pay_flag = 'S0N' )order by length(amount), amount", game_name);
	}
	else
	{
		sprintf(sql, "select * from xkl_game where game_name = '%s' and pay_flag='S0A' order by length(amount), amount", game_name);
	}
	

	iRet = CDB::getMoneyList(&txnLogs, sql);
	
	if (iRet != 0)
	{
		TS_OutPutMsg(gbl.dPosInfo,"暂无可选择的充值金额，请稍后再试",0,iSelect);
		return -1;
	}
	
	iRet = TS_ShowTxnLogs(gbl.dPosInfo, &txnLogs);
	return iRet;
}

CTrade::game_recharge_do1(const char* title)
{
	int iSelect, iRet, iLen, recharge_flag; 
	char content[60], len[3], server_flag[2],  game_name[30], game_id[11], autogame_id[11], game_value[11], amount[13];
	char game_account[40], warcraft_account[40], message[100], temp[20];
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	TSTxnLogs txnLogs;
	TSMENULIST menuList;
	
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, "游戏查询信息");
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	strcpy(tradeInfoSend.Contents[0].acTitle, "游戏查询信息");
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;
	tradeInfoSend.Contents[0].uCount = 0;
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME + 30;
	tradeInfoSend.Contents[0].uMinLen = 4;
	tradeInfoSend.Contents[0].uMaxLen = 60;
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	
	bbzero(content);
	memcpy(content, (char *)tradeInfoRecv.Contents[0].uMsg, tradeInfoRecv.Contents[0].uMsgLen);
	strcpy(gbl.pos_serial, (char *)tradeInfoRecv.uTradeID);	
	wrLog("content:%s",content);
	
	bbzero(game_name);
	bbzero(game_id);
	bbzero(autogame_id);
	bbzero(game_value);
	bbzero(amount);
	bbzero(server_flag);
	//分割出数据
	//游戏名称
	bbzero(len);
	memcpy(len, content, 2);
	iLen = 2;
	memcpy(game_name, content+iLen, atoi(len));
	wrLog("game_name:%s",game_name);//game_name
	iLen += atoi(len);
	//游戏ID
	bbzero(len);
	memcpy(len, content+iLen, 2);
	iLen += 2;
	memcpy(game_id, content+iLen, atoi(len));
	//修改新宽联游戏直充 原光宇一卡通(希望/问道) autogameid由：10011001，改为：10011002 
	if(strcmp(game_name, "希望/问道") == 0)
	{
		memcpy(game_id,"10011002",8);
	}

	wrLog("game_id:%s",game_id);//game_id
	iLen += atoi(len);
	//91卡ID
	bbzero(len);
	memcpy(len, content+iLen, 2);
	iLen += 2;
	memcpy(autogame_id, content+iLen, atoi(len));
	wrLog("autogame_id:%s",autogame_id);//autogame_id 
	iLen += atoi(len);
	//游戏值
	bbzero(len);
	memcpy(len, content+iLen, 2);
	iLen += 2;
	memcpy(game_value, content+iLen, atoi(len));
	wrLog("game_value:%s",game_value);//game_value
	iLen += atoi(len);
	//金额
	bbzero(len);
	memcpy(len, content+iLen, 2);
	iLen += 2;
	memcpy(amount, content+iLen, atoi(len));
	wrLog("amount:%s",amount);//amount
	iLen += atoi(len);
	//服务器值
	memcpy(server_flag, content+iLen, 1);
	wrLog("server_flag:%s",server_flag);
	sprintf(gbl.amount, "%012d", atoi(amount));
	
	//写查询域
	pack.wrField(1, gbl);	
	//修改自定义的域
	//------------------------------
	bbzero(pack.FIELD3);
	CTools::hex_to_byte((BYTE *)"310000", pack.FIELD3, 6);
	bbzero(pack.FIELD48);
	memcpy(pack.FIELD48, gbl.fee_type, 4);
	pack.Packet_Table[48].Real_Length = 4;
	
	bbzero(pack.FIELD63);
	iLen = 0;
	bbzero(len);
	sprintf(len, "%02d", strlen(game_id));//直储ID长度2位
	memcpy(pack.FIELD63, len, 2);
	iLen = 2;
	memcpy(pack.FIELD63 + iLen, game_id, strlen(game_id));//直储ID
	iLen += strlen(game_id);
	bbzero(len);
	sprintf(len, "%02d", strlen(autogame_id));//91卡ID长度2位
	memcpy(pack.FIELD63 + iLen, len, 2);
	iLen += 2;
	memcpy(pack.FIELD63 + iLen, autogame_id, strlen(autogame_id));//91卡ID
	iLen += strlen(autogame_id);
	memcpy(pack.FIELD63 + iLen, gbl.amount, 12);//金额(12位)
	iLen += 12;
	pack.Packet_Table[63].Real_Length = iLen;
	//------------------------------
	
	iRet = packHdl(1);
	if(iRet < 0)
		return -1;
	
	if (memcmp(pack.FIELD39,"00",2)) 
	{
		returnFail((char *)pack.FIELD39);
		return -1;
	}
	
	//判断是否有区服
	if(strcmp(server_flag, "Y") == 0)
	{
		memset(&txnLogs, 0, sizeof(txnLogs));
		
		iRet = CDB::getServerList(&txnLogs, game_name, game_id, autogame_id, game_value, amount);
		
		if (iRet != 0)
		{
			TS_OutPutMsg(gbl.dPosInfo,"没有符合条件的服务器",0,iSelect);
			return -1;
		}
		
		iRet = TS_ShowTxnLogs(gbl.dPosInfo, &txnLogs);
		return iRet;
	}
	
	
	bbzero(game_account);
	bbzero(warcraft_account);
	
	//判断是否战网一卡通
	if(strcmp(game_name, "魔兽世界（战网一卡通）") == 0)
	{

		recharge_flag = 1;
		//输入战网通行证（两次）
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
		
		strcpy(tradeInfoSend.acMainTitle, "请输入战网通行证");
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents = 1;
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入战网通行证(电子邮箱地址)");
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;
		tradeInfoSend.Contents[0].uCount = 0;
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME + 10;
		tradeInfoSend.Contents[0].uMinLen = 4;
		tradeInfoSend.Contents[0].uMaxLen = 40;
		
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		
		if(iRet != 0)
		{
			wrLog("TS_TradeControl返回错误[%d]", iRet);
			wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
			return iRet;
		}
		
		bbzero(game_account);
		memcpy(game_account, (char *)tradeInfoRecv.Contents[0].uMsg, tradeInfoRecv.Contents[0].uMsgLen);
		
		//战网下绑定的魔兽帐号
		memset(&menuList,0,sizeof(menuList));
		menuList.iTotalNum = 2;
		strcpy(menuList.acTitle, "魔兽帐号(非游戏人物角色名)：");
		strcpy(menuList.menuItem[0], "仅有一个魔兽帐号");
		strcpy(menuList.menuItem[1], "两个或以上魔兽帐号");
		
		iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
		if(iRet)
			return -1;
		
		if(iSelect == 2)
		{
			
			//输入魔兽帐号（两次）
			memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
			memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
			
			strcpy(tradeInfoSend.acMainTitle, "请输入魔兽世界帐号");
			tradeInfoSend.uHasTradeID = 1;
			tradeInfoSend.uTotalContents = 1;
			strcpy(tradeInfoSend.Contents[0].acTitle, "请输入需要充值的魔兽世界帐号(数字或字母)");
			tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;
			tradeInfoSend.Contents[0].uCount = 0;
			tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME + 10;
			tradeInfoSend.Contents[0].uMinLen = 4;
			tradeInfoSend.Contents[0].uMaxLen = 40;
			
			iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
			
			if(iRet != 0)
			{
				wrLog("TS_TradeControl返回错误[%d]", iRet);
				wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
				return iRet;
			}
			memcpy(warcraft_account, (char *)tradeInfoRecv.Contents[0].uMsg, tradeInfoRecv.Contents[0].uMsgLen);
		}
		
	}
	else
	{
		recharge_flag = 0;
		//输入游戏帐号（两次）
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
		
		strcpy(tradeInfoSend.acMainTitle, "请输入充值帐号");
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents = 1;
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入充值帐号(数字或字母)");
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;
		tradeInfoSend.Contents[0].uCount = 0;
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME + 10;
		tradeInfoSend.Contents[0].uMinLen = 4;
		tradeInfoSend.Contents[0].uMaxLen = 40;
		
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		
		if(iRet != 0)
		{
			wrLog("TS_TradeControl返回错误[%d]", iRet);
			wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
			return iRet;
		}
		memcpy(game_account, (char *)tradeInfoRecv.Contents[0].uMsg, tradeInfoRecv.Contents[0].uMsgLen);
	}
	
	bbzero(gbl.phone_no);
	strcpy(gbl.phone_no, game_account);
	
	bbzero(message);
	strcat(message, "0076','0077','0078','0087','0088','0167','0168','0273','0274','0275','0277','0278','0293','0294','0322','0341");
	
	if(CDB::chKChinaUnicom(message, gbl.phone_no, atoi(gbl.amount))==0)
	{
		NULL;
	}
	else
	{
		bbzero(message);
		sprintf(message, "业务运营商规定：\n同一号码%s\n同一金额%d元\n%d分钟内不能连续充值\n请稍后再试", gbl.phone_no, atoi(gbl.amount)/100,FORBID_TIME);
		TS_OutPutMsg(gbl.dPosInfo, message, 1, iSelect);
		return -1;
	}
	
	bbzero(message);
	bbzero(temp);
	CTools::chgToMny(gbl.amount, temp);
	if(recharge_flag == 1)
	{
		sprintf(message, "游戏名称：%s\n\n战网通行证：%s\n魔兽世界帐号：%s\n充值金额：%s\n\n【确认】继续  【返回】取消", game_name, game_account, warcraft_account, temp);
	}
	else
	{
		sprintf(message, "游戏名称：%s\n\n充值帐号：%s\n充值金额：%s\n\n【确认】继续  【返回】取消", game_name, game_account, temp);
	}
	
	TS_OutPutMsg(gbl.dPosInfo, message, 0, iSelect);
	if(iSelect)
	{
		return -1;
	}
	
	//发送交易包
	
	bbzero(message);
	bbzero(len);
	iLen = 0;
	sprintf(len, "%02d", strlen(game_id));
	memcpy(message + iLen, len, 2);
	iLen += 2;
	memcpy(message + iLen, game_id, atoi(len));
	iLen += atoi(len);
	// 	bbzero(len);
	// 	sprintf(len, "%02d", strlen(autogame_id));
	// 	memcpy(message + iLen, len, 2);
	// 	iLen += 2;
	// 	memcpy(message + iLen, autogame_id, atoi(len));
	// 	iLen += atoi(len);
	bbzero(len);
	sprintf(len, "%02d", strlen(game_value));
	memcpy(message + iLen, len, 2);
	iLen += 2;
	memcpy(message + iLen, game_value, atoi(len));
	iLen += atoi(len);
	memcpy(message + iLen, "0", 1);
	iLen += 1;
	bbzero(len);
	sprintf(len, "%02d", strlen(warcraft_account));
	memcpy(message + iLen, len, 2);
	iLen += 2;
	if(atoi(len) > 0)
	{
		memcpy(message + iLen, warcraft_account, atoi(len));
		iLen += atoi(len);
	}
	
	
	//--------------------------------------------------------------------------------------------------------------------------
	/************刷卡****************/
	int flag = 0;
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{
		if(!flag)
		{
			iRet = mngCard_Hdl(title);
			if(iRet == CANCLE_KEY)
				return CANCLE_KEY;
			else if(iRet != 0)
				return -1;
		}
		pack.wrField(2, gbl);	//写交费域
		bbzero(pack.FIELD48);
		int pack48_len=0;
		memcpy(pack.FIELD48+pack48_len,gbl.fee_type,4); //业务代码4位
		pack48_len+=4;
		bbzero(len);
		sprintf(len, "%02d", strlen(autogame_id)); //91卡ID长度（2位）
		memcpy(pack.FIELD48 + pack48_len, len, 2);
		pack48_len+=2;
		memcpy(pack.FIELD48 +pack48_len, autogame_id, strlen(autogame_id)); // //91卡ID
		pack48_len+=strlen(autogame_id);
		bbzero(len);
		sprintf(len,"%02d",strlen(game_account)); //游戏账号长度为2位
		memcpy(pack.FIELD48 + pack48_len, len, 2);
		pack48_len+=2;
		memcpy(pack.FIELD48 + pack48_len, game_account, strlen(game_account));
		pack48_len+=strlen(game_account);
		pack.Packet_Table[48].Real_Length = pack48_len;
		bbzero(pack.FIELD63);
		wrLog(message);
		memcpy(pack.FIELD63, "00000000", 8);
		memcpy(pack.FIELD63 + 8, message, strlen(message));
		pack.Packet_Table[63].Real_Length = strlen(message) + 8;
		wrLog((char*)pack.FIELD63);
		//交费包
		iRet = packHdl(2);
		if(iRet < 0)
			return -1;
		
		bbzero(gbl.stan_no);
		memcpy(gbl.stan_no,(char *)pack.FIELD37,12);
		
		if (!memcmp(pack.FIELD39,"00",2)) 
		{
			iRet = TS_OutPutMsg(gbl.dPosInfo, "充值成功，按【确认】打印凭条", 0, iSelect);
			if(!iRet && !iSelect)
			{
				CPrint prt;
				prt.set_in_par(gbl);
				bbzero(message);
				if(recharge_flag == 1)
				{
					sprintf(message, "战网通行证：%s\n魔兽世界帐号：%s\n充值金额：%s", game_account, warcraft_account, temp);
				}
				else
				{
					sprintf(message, "充值帐号：%s\n充值金额：%s", game_account, temp);
				}
				prt.print_game_recharge(game_name, message);	//打印明细
			}
		}
		else if(!memcmp(pack.FIELD39,"55",2))
		{
			
			flag = 1;
			if(reGetPwd(title) == 0) //密码错误，重新输入密码, 2006-10-25
				continue;
			else
				return CANCLE_KEY;
		}
		else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
			if (iSelect!=0)
			{
				return -1;
			}else
				continue;
		}
		else
			returnFail((char*)pack.FIELD39);
		return 1;	
	}
	
	return iRet;
}

CTrade::qqGame_recharge_do(const char* title) //腾讯QQ充值，可充全国
{
	int iSelect, iRet, iLen; 
	char  len[3], server_flag[2],  game_name[30], game_id[11], autogame_id[11], game_value[11], amount[13];
	char game_account[40], warcraft_account[40], message[100], temp[20];
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	
	iRet = selectAmount();	
	if(iRet == CANCLE_KEY)
		return CANCLE_KEY;
	else if(iRet < 0)
		return -1;
	bbzero(game_name);
	bbzero(game_id);
	bbzero(autogame_id);
	bbzero(game_value);
	bbzero(amount);
	bbzero(server_flag);
	//游戏名称
	strcpy(game_name,"腾讯QQ币");
	//游戏ID
	strcpy(game_id,"10002001");
	//91卡ID
	strcpy(autogame_id,"5178");
	//游戏值
	strcpy(game_value, "987654");
	//服务器值
	strcpy(server_flag,"N");//服务器标志现在是N，没有可以的服务器。如果有服务器的时候，需要添加修改
	
	bbzero(game_account);
	bbzero(warcraft_account);
	//输入游戏帐号（两次）
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, "请输入充值QQ帐号");
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入充值QQ帐号");
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;//数字
	tradeInfoSend.Contents[0].uCount = 0;
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME + 10;
	tradeInfoSend.Contents[0].uMinLen = 5;
	tradeInfoSend.Contents[0].uMaxLen = 40;
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	
	bbzero(gbl.pos_serial);
	strcpy(gbl.pos_serial, (char *)tradeInfoRecv.uTradeID);//系统流水号
	memcpy(game_account, (char *)tradeInfoRecv.Contents[0].uMsg, tradeInfoRecv.Contents[0].uMsgLen);
	
	bbzero(gbl.phone_no);
	strcpy(gbl.phone_no, game_account);//gbl.phone_no 
	
	bbzero(message);
	strcat(message, "0076','0077','0078','0087','0088','0167','0168','0273','0274','0275','0277','0278','0293','0294','0322','0341");
	
	if(CDB::chKChinaUnicom(message, gbl.phone_no, atoi(gbl.amount))==0)
	{
		
		NULL;
	}
	else
	{
		bbzero(message);
		sprintf(message, "业务运营商规定：\n同一号码%s\n同一金额%d元\n%d分钟内不能连续充值\n请稍后再试", gbl.phone_no, atoi(gbl.amount)/100,FORBID_TIME);
		TS_OutPutMsg(gbl.dPosInfo, message, 1, iSelect);
		return -1;
	}
	
	bbzero(message);
	bbzero(temp);
	CTools::chgToMny(gbl.amount, temp);
	wrLog("gbl.amount:%s",gbl.amount);
	sprintf(message, "腾讯QQ充值\n充值帐号：%s\n充值金额：%s\n\n【确认】继续  【返回】取消", game_account, temp);
	
	TS_OutPutMsg(gbl.dPosInfo, message, 0, iSelect);
	if(iSelect)
	{
		return -1;
	}
	
	//发送交易包
	
	bbzero(message);
	bbzero(len);
	iLen = 0;
	sprintf(len, "%02d", strlen(game_id));
	memcpy(message + iLen, len, 2);
	iLen += 2;
	memcpy(message + iLen, game_id, atoi(len));
	iLen += atoi(len);
	
	bbzero(len);
	sprintf(len, "%02d", strlen(game_value));
	memcpy(message + iLen, len, 2);
	iLen += 2;
	memcpy(message + iLen, game_value, atoi(len));
	iLen += atoi(len);
	memcpy(message + iLen, "0", 1);
	iLen += 1;
	bbzero(len);
	sprintf(len, "%02d", strlen(warcraft_account));
	memcpy(message + iLen, len, 2);
	iLen += 2;
	if(atoi(len) > 0)
	{
		memcpy(message + iLen, warcraft_account, atoi(len));
		iLen += atoi(len);
	}
	
	
	//--------------------------------------------------------------------------------------------------------------------------
	/************刷卡****************/
	int flag = 0;
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{
		if(!flag)
		{
			iRet = mngCard_Hdl(title);
			if(iRet == CANCLE_KEY)
				return CANCLE_KEY;
			else if(iRet != 0)
				return -1;
		}
		
		pack.wrField(2, gbl);	//写交费域
		bbzero(pack.FIELD48);
		int pack48_len=0;
		memcpy(pack.FIELD48+pack48_len,gbl.fee_type,4); //业务代码
		pack48_len+=4;

		bbzero(len);
		sprintf(len, "%02d", strlen(autogame_id)); 
		memcpy(pack.FIELD48 + pack48_len, len, 2);
		pack48_len+=2;

		memcpy(pack.FIELD48 + pack48_len, autogame_id, strlen(autogame_id)); //autogame_id
		pack48_len+=strlen(autogame_id);

		bbzero(len);
		sprintf(len, "%02d", strlen(game_account));
		memcpy(pack.FIELD48 + pack48_len, len, 2);
		pack48_len+=2;

		memcpy(pack.FIELD48 + pack48_len, game_account, strlen(game_account));
		pack48_len+=strlen(game_account);

		pack.Packet_Table[48].Real_Length =pack48_len;
	
		bbzero(pack.FIELD63);
		wrLog(message);
		memcpy(pack.FIELD63, "00000000", 8);
		memcpy(pack.FIELD63 + 8, message, strlen(message));
		pack.Packet_Table[63].Real_Length = strlen(message) + 8;
		wrLog((char*)pack.FIELD63);
		//交费包
		iRet = packHdl(2);
		if(iRet < 0)
			return -1;
		
		bbzero(gbl.stan_no);
		memcpy(gbl.stan_no,(char *)pack.FIELD37,12);
		
		if (!memcmp(pack.FIELD39,"00",2)) 
		{
			iRet = TS_OutPutMsg(gbl.dPosInfo, "充值成功，按【确认】打印凭条", 0, iSelect);
			if(!iRet && !iSelect)
			{
				CPrint prt;
				prt.set_in_par(gbl);
				bbzero(message);		
				sprintf(message, "充值帐号：%s\n充值金额：%s", game_account, temp);
				
				prt.print_game_recharge(game_name, message);	//打印明细
			}
		}
		else if(!memcmp(pack.FIELD39,"55",2))
		{
			
			flag = 1;
			if(reGetPwd(title) == 0) //密码错误，重新输入密码, 2006-10-25
				continue;
			else
				return CANCLE_KEY;
		}
		else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
			if (iSelect!=0)
			{
				return -1;
			}else
				continue;
		}
		else
			returnFail((char*)pack.FIELD39);
		return 1;	
	}
	
	return iRet;
}


CTrade::game_recharge_do2(const char* title)
{
	return 0;
	
	int iSelect, iRet, iLen; 
	char content[60], message[100], temp[20], len[3];
	char game_name[40], game_id[11], autogame_id[11], server_value[11], server_name[40], game_value[11], amount[13], game_account[40];
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, "游戏查询信息");
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	strcpy(tradeInfoSend.Contents[0].acTitle, "游戏查询信息");
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;
	tradeInfoSend.Contents[0].uCount = 0;
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME + 30;
	tradeInfoSend.Contents[0].uMinLen = 6;
	tradeInfoSend.Contents[0].uMaxLen = 40;
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	
	bbzero(content);
	memcpy(content, (char *)tradeInfoRecv.Contents[0].uMsg, tradeInfoRecv.Contents[0].uMsgLen);
	strcpy(gbl.pos_serial, (char *)tradeInfoRecv.uTradeID);	
	
	bbzero(game_name);
	bbzero(game_id);
	bbzero(autogame_id);
	bbzero(game_value);
	bbzero(amount);
	bbzero(server_value);
	bbzero(server_name);
	bbzero(game_account);
	//分割出数据
	//游戏名称
	bbzero(len);
	memcpy(len, content, 2);
	iLen = 2;
	memcpy(game_name, content+iLen, atoi(len));
	iLen += atoi(len);
	//游戏ID
	bbzero(len);
	memcpy(len, content+iLen, 2);
	iLen += 2;
	memcpy(game_id, content+iLen, atoi(len));
	iLen += atoi(len);
	//91卡ID
	bbzero(len);
	memcpy(len, content+iLen, 2);
	iLen += 2;
	memcpy(autogame_id, content+iLen, atoi(len));
	iLen += atoi(len);
	//游戏值
	bbzero(len);
	memcpy(len, content+iLen, 2);
	iLen += 2;
	memcpy(game_value, content+iLen, atoi(len));
	iLen += atoi(len);
	//金额
	bbzero(len);
	memcpy(len, content+iLen, 2);
	iLen += 2;
	memcpy(amount, content+iLen, atoi(len));
	iLen += atoi(len);
	//服务器值
	bbzero(len);
	memcpy(len, content+iLen, 2);
	iLen += 2;
	memcpy(server_value, content+iLen, atoi(len));
	iLen += atoi(len);
	//服务器名称
	bbzero(len);
	memcpy(len, content+iLen, 2);
	iLen += 2;
	memcpy(server_name, content+iLen, atoi(len));
	iLen += atoi(len);
	
	sprintf(gbl.amount, "%012d", atoi(amount));
	
	
	//输入游戏帐号（两次）
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, "请输入充值帐号");
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入充值帐号(数字或字母)");
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;
	tradeInfoSend.Contents[0].uCount = 0;
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME + 10;
	tradeInfoSend.Contents[0].uMinLen = 5;
	tradeInfoSend.Contents[0].uMaxLen = 40;
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	
	bbzero(game_account);
	memcpy(game_account, (char *)tradeInfoRecv.Contents[0].uMsg, tradeInfoRecv.Contents[0].uMsgLen);
	
	bbzero(message);
	bbzero(temp);
	CTools::chgToMny(gbl.amount, temp);
	sprintf(message, "游戏名称：%s\n服务器名称：%s\n\n充值帐号：%s\n充值金额：%s\n\n【确认】继续  【返回】取消", game_name, server_value, game_account, temp);
	
	
	TS_OutPutMsg(gbl.dPosInfo, message, 0, iSelect);
	if(iSelect)
	{
		return -1;
	}
	
	//发送交易包
	bbzero(gbl.amount);
	sprintf(gbl.amount,"%012d", amount);
	
	bbzero(message);
	bbzero(len);
	iLen = 0;
	sprintf(len, "%02d", strlen(game_id));
	memcpy(message + iLen, len, 2);
	iLen += 2;
	memcpy(message + iLen, game_id, atoi(len));
	iLen += atoi(len);
	// 	bbzero(len);
	// 	sprintf(len, "%02d", strlen(autogame_id));
	// 	memcpy(message + iLen, len, 2);
	// 	iLen += 2;
	// 	memcpy(message + iLen, autogame_id, atoi(len));
	// 	iLen += atoi(len);
	bbzero(len);
	sprintf(len, "%02d", strlen(game_value));
	memcpy(message + iLen, len, 2);
	iLen += 2;
	memcpy(message + iLen, game_value, atoi(len));
	iLen += atoi(len);
	bbzero(len);
	sprintf(len, "%01d", strlen(server_value));
	memcpy(message + iLen, len, 1);
	iLen += 2;
	memcpy(message + iLen, server_value, atoi(len));
	iLen += atoi(len);
	memcpy(message + iLen, "00", 2);
	iLen += 2;
	
	
	//--------------------------------------------------
	/************刷卡****************/
	int flag = 0;
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{
		if(!flag)
		{
			iRet = mngCard_Hdl(title);
			if(iRet == CANCLE_KEY)
				return CANCLE_KEY;
			else if(iRet != 0)
				return -1;
		}
		pack.wrField(2, gbl);	//写交费域
		bbzero(pack.FIELD48);
		int pack48_len=0;
		memcpy(pack.FIELD48+pack48_len,gbl.fee_type,4); //业务类型
		pack48_len+=4;
		bbzero(len);
		sprintf(len, "%02d", strlen(autogame_id) ); //autogame_id长度
		memcpy(pack.FIELD48 + pack48_len, len, 2);
		pack48_len+=2;
		memcpy(pack.FIELD48 + pack48_len, autogame_id, strlen(autogame_id)); //autogame_id
		pack48_len+=strlen(autogame_id);
		bbzero(len);
		sprintf(len,"%02d",strlen(game_account));
		memcpy(pack.FIELD48 + pack48_len, len, 2);
		pack48_len+=2;
		memcpy(pack.FIELD48 + pack48_len, game_account, strlen(game_account)); //游戏账户
		pack48_len+=strlen(game_account);
		pack.Packet_Table[48].Real_Length = pack48_len;
		
		bbzero(pack.FIELD63);
		wrLog(message);
		memcpy(pack.FIELD63, "00000000", 8);
		memcpy(pack.FIELD63 + 8, message, strlen(message));
		pack.Packet_Table[63].Real_Length = strlen(message) + 8;
		wrLog((char*)pack.FIELD63);
		//交费包
		iRet = packHdl(2);
		if(iRet < 0)
			return -1;
		
		bbzero(gbl.stan_no);
		memcpy(gbl.stan_no,(char *)pack.FIELD37,12);
		
		if (!memcmp(pack.FIELD39,"00",2)) 
		{
			iRet = TS_OutPutMsg(gbl.dPosInfo, "充值成功，按【确认】打印凭条", 0, iSelect);
			if(!iRet && !iSelect)
			{
				CPrint prt;
				prt.set_in_par(gbl);
				bbzero(message);
				sprintf(message, "服务器：%s\n充值帐号：%s\n充值金额：%s", server_name, game_account, temp);
				
				prt.print_game_recharge(game_name, message);	//打印明细
			}
		}
		else if(!memcmp(pack.FIELD39,"55",2))
		{
			
			flag = 1;
			if(reGetPwd(title) == 0) //密码错误，重新输入密码, 2006-10-25
				continue;
			else
				return CANCLE_KEY;
		}
		else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
			if (iSelect!=0)
			{
				return -1;
			}else
				continue;
		}
		else
			returnFail((char*)pack.FIELD39);
		return 1;	
	}
	
	return iRet;
}

//判断是否是广东省手机号码。
int CTrade::is_gd_phone(char* phone)
{
	int i, index, iend;
	char ind[3];
	
	bbzero(ind);
	
	memcpy(ind, phone + 1, 2);
	index = atoi(ind);
	
	i = field_group[index];
	iend = field_group[index + 100];
	
	if(i == -1)
	{
		return -1;
	}
	
	for(;i < epos_mobile_totalNum && i < iend;i++)
	{
		if(!memcmp(phone,  gd_field[i].mobile_field, gd_field[i].field_len))
		{
			return i;
		}
	}
	
	return -1;
}



int CTrade::unicom_direct_recharge(const char* title)
{
	int iRet, iSelect;
	wrLog("【unicom_direct_recharge】");
	//char message[100], mny[20];
	//TSMENULIST menuList;
	/*
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	
	  iRet = get_area_biz(BIZ_AREA_BIZ_UNICOM_CHARGE, gbl.city_no, gbl.acc_city_no, gbl.fee_type);
	  if( iRet==0 )
	  {
	  wrLog("gbl.fee_type = [%s]", gbl.fee_type);
	  }
	  else
	  {
	  return -1;
	  }
	  
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
		
		  strcpy(tradeInfoSend.acMainTitle, "联通话费直充");
		  tradeInfoSend.uHasTradeID = 1;
		  tradeInfoSend.uTotalContents = 1;
		  
			strcpy(tradeInfoSend.Contents[0].acTitle, "请输入要充值的号码");	
			tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
			tradeInfoSend.Contents[0].uCount = 1;		//输入2次
			tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
			tradeInfoSend.Contents[0].uMinLen = 7;		
			tradeInfoSend.Contents[0].uMaxLen = 12;	
			
			  iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
			  if(iRet != 0)
			  {
			  wrLog("TS_TradeControl返回错误[%d]", iRet);
			  wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
			  return iRet;
			  }
			  
				memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
				bbzero(gbl.phone_no);
				strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);	
				strcpy(gbl.phone_no,(char *)tradeInfoRecv.Contents[0].uMsg );
				
				  CTools::trim(gbl.phone_no);
				  gbl.phone_len = strlen(gbl.phone_no);
				  
					if(gbl.phone_no[0]=='1')//如果是手机
					{
					iRet = is_gd_phone(gbl.phone_no);
					if(iRet < 0)
					{
					TS_OutPutMsg(gbl.dPosInfo,"\n\n该号码不属于广东地区\n   请更换号码再试",0,iSelect);
					return -1;
					}
					}
					
					  sprintf(gbl.amount, "%010d00", amount);
					  wrLog(gbl.amount);
	*/
	//写查询域
	pack.wrField(1, gbl);		
	//修改自定义的域
	//------------------------------
	memcpy(pack.FIELD48+pack.Packet_Table[48].Real_Length, "01", 2);
	pack.Packet_Table[48].Real_Length += 2;
	//------------------------------
	
	iRet = packHdl(1);
	if(iRet < 0)
		return -1;
	
	if (memcmp(pack.FIELD39,"00",2)) 
	{
		returnFail((char *)pack.FIELD39);
		return -1;
	}
	/*
	bbzero(message);
	bbzero(mny);
	CTools::chgToMny(gbl.amount, mny);
	sprintf(message, "手机号码：%s\n充值金额：%s\n\n 【确认】继续  【返回】取消", gbl.phone_no, mny);
	iRet = TS_OutPutMsg(gbl.dPosInfo, message, 0, iSelect);
	if( iRet==0 && iSelect==0 )
	{
	NULL;
	}
	else
	{
	return -1;
	}
	
	  if(CDB::chKChinaUnicom(gbl.fee_type, gbl.phone_no, atoi(gbl.amount))==0)
	  {
	  NULL;
	  }
	  else
	  {
	  bbzero(message);
	  sprintf(message, "业务运营商规定：\n同一号码%s\n同一金额%d元\n%d分钟内不能连续充值\n请稍后再试", gbl.phone_no, atoi(gbl.amount)/100,FORBID_TIME);
	  TS_OutPutMsg(gbl.dPosInfo, message, 1, iSelect);
	  return -1;
	  }
	*/
	int flag = 0;
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{
		if(!flag)
		{
			iRet = mngCard_Hdl(title);
			if(iRet == CANCLE_KEY)
				return CANCLE_KEY;
			else if(iRet != 0)
				return -1;
		}
		if(!memcmp(gbl.card_no,"8828",4))	//若是付费易卡
		{
			memset(gbl.xlt_type, 0, sizeof(gbl.xlt_type));
			memcpy(gbl.xlt_type, "01",2);
			iRet = xltMulCard(title, 0);
			return iRet;
		}
		
		pack.wrField(2, gbl);	//写交费域
		
		//修改自定义的域
		//------------------------------
		memcpy(pack.FIELD63+pack.Packet_Table[63].Real_Length, "01", 2);
		pack.Packet_Table[63].Real_Length += 2;
		//------------------------------
		
		iRet = packHdl(2);
		if(iRet < 0)
			return -1;
		
		if (!memcmp(pack.FIELD39,"00",2))
		{
			iRet = TS_OutPutMsg(gbl.dPosInfo,"     充值成功！\n    谢谢您的使用\n请按【确认】打印发票",0,iSelect);
			if(!iRet && !iSelect)
			{
				CPrint prt;
				prt.set_in_par(gbl);
				//prt.print_detail(2, title);	
				prt.print_pre_detail(pack,title);
			}
			return 0;
		}
		else if(!memcmp(pack.FIELD39,"55",2))
		{
			flag = 1;
			if(reGetPwd(title) == 0) //密码错误，重新输入密码, 2006-11-09 KF ADD
				continue;
			else
				return CANCLE_KEY;
		}
		else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
			if (iSelect!=0)
			{
				return -1;
			}else
				continue;
		}
		else
			returnFail((char *)pack.FIELD39);
		return -1;
	}
	return -1;
}

int CTrade::coachTicketTradeGetInfo()
{
	int iRet, iSelect, i, iLen;
	char temp[100], scont[100];
	char m_strDestination[20], m_strGetOnDate[10], m_strGetOnTime[6];
	
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	TSTxnLogs txnLogs;
	
	//读入目的地城市
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, "长途汽车票");
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "目的站场：(如珠海拱北站，只输入【拱北】或【gb】)");
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
	tradeInfoSend.Contents[0].uCount = 0;
	tradeInfoSend.Contents[0].uMinLen = 1;		
	tradeInfoSend.Contents[0].uMaxLen = 10;
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	strcpy(m_strDestination, (char *)tradeInfoRecv.Contents[0].uMsg);	
	
	//读入出发日期
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, "长途汽车票");
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入出发日期：");
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_DATE;	
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
	tradeInfoSend.Contents[0].uCount = 0;
	tradeInfoSend.Contents[0].uMinLen = 8;		
	tradeInfoSend.Contents[0].uMaxLen = 8;
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	
	strcpy(m_strGetOnDate, (char *)tradeInfoRecv.Contents[0].uMsg);//获取订票的时间
	
	//取消比对当前时间，可以购买当前日期的车票。
	
	/*
	iRet = TS_OutPutMsg(gbl.dPosInfo, "如需要输入具体出发时间，请按【确认】，如不输入具体时间，将会显示当天所有时段班次。\n\n【确认】输入具体出发时间\n【取消】跳过", 0, iSelect);
	if(iRet < 0)
	{
	TS_OutPutMsg(gbl.dPosInfo, "网络繁忙，请稍候再试", 0, iSelect);
	return -1;
	}
	
	  if(iSelect)
	  {
	  strcpy(m_strGetOnTime, "00000");
	  }
	  else
	{*/
	//读入出发时间
	/*		while(1)
	{
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	  strcpy(tradeInfoSend.acMainTitle, "长途汽车票");
	  tradeInfoSend.uHasTradeID = 1;
	  tradeInfoSend.uTotalContents = 1;
	  
		strcpy(tradeInfoSend.Contents[0].acTitle, "出发时间：(24小时制。直接回车显示所有时段班次)");
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
		tradeInfoSend.Contents[0].uMinLen = 0;
		tradeInfoSend.Contents[0].uMaxLen = 2;
		
		  iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		  if(iRet != 0)
		  {
		  wrLog("TS_TradeControl返回错误[%d]", iRet);
		  wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		  return iRet;
		  }
		  bbzero(temp);
		  strcpy(temp, (char *)tradeInfoRecv.Contents[0].uMsg);
		  if(strlen(temp) < 1)
		  {
		  strcpy(m_strGetOnTime, "     ");
		  break;
		  }
		  else if(atoi(temp) > 23 || atoi(temp) < 0)
		  {
		  TS_OutPutMsg(gbl.dPosInfo, "输入有误，请按提示范围输入\n", 0, iSelect);
		  continue;
		  }
		  else
		  {
		  sprintf(m_strGetOnTime, "%02s:00", temp);
		  break;
		  }
		  }
		  //}
	*/
	strcpy(m_strGetOnTime, "     ");
	
	bbzero(scont);
	strcpy(scont, "BK001");	//服务名
	strcat(scont, "0027");	//包长度，固定
	strcat(scont, m_strGetOnDate);	//班次日期
	strcat(scont, m_strGetOnTime);  //班次时间
	iLen = strlen(m_strDestination);
	bbzero(temp);
	strcpy(temp, m_strDestination);
	iLen = strlen(m_strDestination);
	for(i = 0; i < 10 - iLen; i++)
	{
		strcat(temp, " ");
	}
	strcat(scont, temp);
	
	//读入出发站点
	memset(&txnLogs, 0, sizeof(txnLogs));
	iRet = CDB::getBusStop(&txnLogs, "020", scont);
	if (iRet != 0)
	{
		TS_OutPutMsg(gbl.dPosInfo,"暂无可选择的出发站点，请稍后再试",0,iSelect);
		return -1;
	}
	
	iRet = TS_ShowTxnLogs(gbl.dPosInfo, &txnLogs);
	if(iRet)
	{
		TS_OutPutMsg(gbl.dPosInfo, "网络繁忙，请稍候再试", 0, iSelect);
		return -2;
	}
	
	return 0;
}

int CTrade::coachTicketTradeQuery()
{
	SOCKET sd = 0;
	CConnect con;
	int i, j, iRet, iSelect, iTotal, iRecordNum, rLen, loc;
	int disCount=0;
	int err_flag = 0;
	char scont[100], revdata[200], temp[1025], sTotal[5], sRecordNum[3];
	char name[20], start_stop[20], end_stop[20], type[20], bus_time[20], ticket_num[12], m_strGetOnDate[10];
	char * querydata;
	char currentDate[10],currentTime[20];
	
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	TSTxnLogs txnLogs;
	
	
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, "长途汽车票");
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	strcpy(tradeInfoSend.Contents[0].acTitle, "查询信息：");
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;
	tradeInfoSend.Contents[0].uCount = 0;
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;
	tradeInfoSend.Contents[0].uMinLen = 1;
	tradeInfoSend.Contents[0].uMaxLen = 40;
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		TS_OutPutMsg(gbl.dPosInfo, "网络繁忙，请稍候再试", 0, iSelect);
		return iRet;
	}
	
	bbzero(scont);
	memcpy(scont, (char *)tradeInfoRecv.Contents[0].uMsg, tradeInfoRecv.Contents[0].uMsgLen);
	bbzero(m_strGetOnDate);
	memcpy(m_strGetOnDate, scont+9, 8);
	
	if(con.conToHost(COACH_TICKET_IP, COACH_TICKET_PORT, &sd)==0)
	{
		//发送数据包
		//wrLog("发送明细请求:");
		wrLog(scont);
		iRet = con.sndMsg(sd, scont, strlen(scont));
		if( iRet!=0 )
		{
			TS_OutPutMsg(gbl.dPosInfo, "网络繁忙，请稍候再试", 0, iSelect);
			closesocket(sd);
			return -3;
		}
		//------------------------------------------
		//接收包头
		
		bbzero(temp);
		iRet = con.rcvMsg(sd, temp, &rLen, 11);
		if(rLen != 11 || iRet != 0)
		{
			TS_OutPutMsg(gbl.dPosInfo, "网络繁忙，请稍候再试", 0, iSelect);
			closesocket(sd);
			return -3;
		}
		
		bbzero(sTotal);
		memcpy(sTotal, temp+5, 4);
		iTotal = atoi(sTotal) - 2;
		bbzero(sRecordNum);
		memcpy(sRecordNum, temp+9, 2);
		iRecordNum = atoi(sRecordNum);
		
		if(iRecordNum < 1)
		{
			TS_OutPutMsg(gbl.dPosInfo, "没有搜索到您所需要的班次，请更改输入信息再试", 0, iSelect);
			return -3;
		}
		
		//分配空间
		querydata = new char[iTotal+1];
		memset(querydata, 0, iTotal + 1);
		
		wrLog("申请堆空间[%d]", iTotal+1);
		while(1)
		{
			memset(temp, 0, 1025);
			iRet = con.rcvMsg(sd, temp, &rLen, 1024);
			strcat(querydata, temp);
			wrLog("Get Data:%s", temp);//获取所有长途汽车车票信息
			
			if(iRet)
			{
				delete[] querydata;
				TS_OutPutMsg(gbl.dPosInfo, "网络繁忙，请稍候再试", 0, iSelect);
				closesocket(sd);
				return -1;
			}
			if(iTotal - rLen > 0)
			{
				iTotal = iTotal - rLen;
				continue;
			}
			break;
		}
		
		closesocket(sd);
		
		memset(&txnLogs, 0, sizeof(txnLogs));
		
		//分割显示
		txnLogs.colsnum = 9;
		txnLogs.colsWidth[0] = 30;
		txnLogs.colsWidth[1] = 50;
		txnLogs.colsWidth[2] = 100;
		txnLogs.colsWidth[3] = 100;
		txnLogs.colsWidth[4] = 100;
		txnLogs.colsWidth[5] = 100;
		txnLogs.colsWidth[6] = 100;
		txnLogs.colsWidth[7] = 0;
		txnLogs.colsWidth[8] = 0;
		
		txnLogs.colsNameLen = 66;
		memcpy(txnLogs.colsName, "编号\x00班次\x00发车站\x00到站\x00档次\x00发车时间\x00剩余车票（张）\x00菜单ID\x00菜单内容", txnLogs.colsNameLen);
		
		sprintf(txnLogs.top, "班次查询");
		strcpy(txnLogs.bottom, "【<-】【->】翻页 【Enter】下一步 【Esc】返回");
		
		wrLog("iRecordNum:%d",iRecordNum);
		
		for(i = 0; i < iRecordNum && i < 500; i++)
		{
			loc = 0;
			//获取一条班次记录
			for(j = 0; j < i; j++)
			{
				bbzero(temp);
				memcpy(temp, querydata + loc, 4);
				loc += atoi(temp) + 4;
				
				
			}
			
			
			
			bbzero(temp);
			memcpy(temp, querydata + loc, 4);
			bbzero(revdata);
			memcpy(revdata, querydata + loc + 4, atoi(temp));
			
			loc = 0;
			//分割数据并填入列表
			iRet = CTools::findChar(revdata, ',', loc);
			loc = iRet + 1;
			
			
			//获取班次编号
			bbzero(name);
			iRet = CTools::findChar(revdata, ',', loc);
			if(iRet > loc)
			{
				memcpy(name, revdata+loc, iRet - loc);
			}
			loc = iRet + 1;
			
			iRet = CTools::findChar(revdata, ',', loc);
			loc = iRet + 1;
			
			//获取发车时间
			bbzero(bus_time);
			iRet = CTools::findChar(revdata, ',', loc);
			if(iRet > loc)
			{
				memcpy(bus_time, revdata+loc, iRet - loc);
			}
			
			loc = iRet + 1;
			
			iRet = CTools::findChar(revdata, ',', loc);
			loc = iRet + 1;
			iRet = CTools::findChar(revdata, ',', loc);
			loc = iRet + 1;
			iRet = CTools::findChar(revdata, ',', loc);
			loc = iRet + 1;
			
			//获取班次档次
			bbzero(type);
			iRet = CTools::findChar(revdata, ',', loc);
			if(iRet > loc)
			{
				memcpy(type, revdata+loc, iRet - loc);
			}
			loc = iRet + 1;
			
			iRet = CTools::findChar(revdata, ',', loc);
			loc = iRet + 1;
			
			//获取到站点名称
			bbzero(end_stop);
			iRet = CTools::findChar(revdata, ',', loc);
			if(iRet > loc)
			{
				memcpy(end_stop, revdata+loc, iRet - loc);
				
			}
			loc = iRet + 1;
			
			iRet = CTools::findChar(revdata, ',', loc);
			loc = iRet + 1;
			
			//获取发车站点名称
			bbzero(start_stop);
			iRet = CTools::findChar(revdata, ',', loc);
			if(iRet > loc)
			{
				memcpy(start_stop, revdata+loc, iRet - loc);
				
			}
			loc = iRet + 1;
			
			//获取剩余票数
			bbzero(ticket_num);
			iRet = CTools::findChar(revdata, ',', loc);
			if(iRet > loc)
			{
				memcpy(ticket_num, revdata+loc, iRet - loc);
				
			}
			loc = iRet + 1;
			
			
			//如果日期是当日的时间，显示向前时间之后
			bbzero(currentDate);
			CTools::getDate(currentDate);
			bbzero(currentTime);
			CTools::getCurrentTime(currentTime);
			
			if(atoi(m_strGetOnDate)==atoi(currentDate)&&strcmp(bus_time,currentTime)<0)
			{
				disCount++;
				continue;
			}
			
			bbzero(temp);
			sprintf(temp, "%d", (i-disCount) + 1);
			if( txnLogs.itemsLen+strlen(temp) < MAX_INTERM_BUF )
			{
				strcpy(txnLogs.items+txnLogs.itemsLen, temp);
				txnLogs.itemsLen = txnLogs.itemsLen + strlen(txnLogs.items+txnLogs.itemsLen) + 1;
				
			}
			else
			{
				err_flag = 1;
				break;
			}
			
			//显示信息列表	
			
			//显示班次
			if(txnLogs.itemsLen+ strlen(name)< MAX_INTERM_BUF )
			{
				strcpy(txnLogs.items+txnLogs.itemsLen, name);
				txnLogs.itemsLen = txnLogs.itemsLen + strlen(txnLogs.items+txnLogs.itemsLen) + 1;
				
			}
			else
			{
				err_flag = 1;
				break;
			}
			
			
			
			//显示发车站
			if(txnLogs.itemsLen+ strlen(start_stop)< MAX_INTERM_BUF )
			{
				strcpy(txnLogs.items+txnLogs.itemsLen, start_stop);
				txnLogs.itemsLen = txnLogs.itemsLen + strlen(txnLogs.items+txnLogs.itemsLen) + 1;
				
			}
			else
			{
				err_flag = 1;
				break;
			}
			
			//显示到站
			if(txnLogs.itemsLen+ strlen(end_stop)< MAX_INTERM_BUF )
			{
				strcpy(txnLogs.items+txnLogs.itemsLen, end_stop);
				txnLogs.itemsLen = txnLogs.itemsLen + strlen(txnLogs.items+txnLogs.itemsLen) + 1;
			}
			else
			{
				err_flag = 1;
				break;
			}
			//显示档次
			if(txnLogs.itemsLen+ strlen(type)< MAX_INTERM_BUF )
			{
				strcpy(txnLogs.items+txnLogs.itemsLen, type);
				txnLogs.itemsLen = txnLogs.itemsLen + strlen(txnLogs.items+txnLogs.itemsLen) + 1;
			}
			else
			{
				err_flag = 1;
				break;
			}
			
			//显示发车时间
			if(txnLogs.itemsLen+ strlen(bus_time)< MAX_INTERM_BUF )
			{
				strcpy(txnLogs.items+txnLogs.itemsLen, bus_time);
				txnLogs.itemsLen = txnLogs.itemsLen + strlen(txnLogs.items+txnLogs.itemsLen) + 1;
			}
			else
			{
				err_flag = 1;
				break;
			}
			//显示剩余票数
			if(txnLogs.itemsLen+ strlen(ticket_num)< MAX_INTERM_BUF )
			{
				strcpy(txnLogs.items+txnLogs.itemsLen, ticket_num);
				txnLogs.itemsLen = txnLogs.itemsLen + strlen(txnLogs.items+txnLogs.itemsLen) + 1;
			}
			else
			{
				err_flag = 1;
				break;
			}
			
			if( txnLogs.itemsLen+strlen("714") < MAX_INTERM_BUF )
			{
				strcpy(txnLogs.items+txnLogs.itemsLen, "714");
				txnLogs.itemsLen = txnLogs.itemsLen + strlen("714") + 1;
			}
			else
			{
				err_flag = 1;
				break;
			}
			
			bbzero(temp);
			strcat(temp, m_strGetOnDate);
			strcat(temp, revdata);
			if( txnLogs.itemsLen+strlen(temp) < MAX_INTERM_BUF )
			{
				strcpy(txnLogs.items+txnLogs.itemsLen, temp);
				txnLogs.itemsLen = txnLogs.itemsLen + strlen(txnLogs.items+txnLogs.itemsLen) + 1;
			}
			else
			{
				err_flag = 1;
				break;
			}
		}
		
		delete[] querydata;
		if(err_flag == 1)
		{
			TS_OutPutMsg(gbl.dPosInfo, "您的请求返回数据过多，请提供更明确的信息，以便更准确地为您提供班次信息", 0, iSelect);
			return -4;
		}
		
		bbzero(temp);
		sprintf(temp, "共%d个可选班次 ", (i-disCount));
		strcpy(txnLogs.hint, temp);
		
		//显示列表
		iRet = TS_ShowTxnLogs(gbl.dPosInfo, &txnLogs);
		if(iRet)
		{
			TS_OutPutMsg(gbl.dPosInfo, "网络繁忙，请稍候再试", 0, iSelect);
			wrLog("TS_ShowTxnLogs返回错误[%d]", iRet);
			return -1;
		}
	}
	else
	{
		TS_OutPutMsg(gbl.dPosInfo, "网络繁忙，请稍候再试", 0, iSelect);
		return -3;
	}
	return 0;
}

int CTrade::coachTicketTradePay()
{
	SOCKET sd = 0;
	CConnect con;
	int i, iLen, iRet, rLen, loc, iSelect, flag;
	long m_lngTicketNumber, m_lngTicketPrice, m_lngBuyNumber;
	int b48_len = 0, b63_len = 0;
	char len_buff[10];
	char scont[512], revdata[200], temp[1025], date[11], response_code[2+1];
	char m_strTradeInfo1[200], m_strTradeInfo2[200];
	char m_strTicketBusStopID[5], m_strBusClassID[9], m_strBusClassName[20], m_strTicketType[20];
	char m_strDestinationID[20], m_strDestinationBusStop[20], m_strBusStop[30], m_strBusClassBusStopID[5];
	char m_strBusLocation[30], m_strCheckPort[30], m_strGetOnDate[10], m_strGetOnTime[6], m_strFuelTax[13], m_strPassword[20];
	char m_strTicketSerials[10][25];
	//订票人信息
	char m_strClientName[20], m_strClientID[20], m_strClientPhone[20], m_strClientID_print[20];
	
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, "长途汽车票");
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	strcpy(tradeInfoSend.Contents[0].acTitle, "查询信息：");
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;
	tradeInfoSend.Contents[0].uCount = 0;
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;
	tradeInfoSend.Contents[0].uMinLen = 1;
	tradeInfoSend.Contents[0].uMaxLen = 100;
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		TS_OutPutMsg(gbl.dPosInfo, "网络繁忙，请稍候再试", 0, iSelect);
		return iRet;
	}
	
	bbzero(temp);
	memcpy(temp, (char *)tradeInfoRecv.Contents[0].uMsg, tradeInfoRecv.Contents[0].uMsgLen);
	
	bbzero(m_strGetOnDate);
	bbzero(revdata);
	memcpy(m_strGetOnDate, temp, 8);
	memcpy(revdata, temp + 8, strlen(temp) - 8);
	
	bbzero(m_strTradeInfo1);
	strcpy(m_strTradeInfo1, revdata);
	//分割数据
	loc = 0;
	//票源客运站编码
	bbzero(m_strTicketBusStopID);
	iRet = CTools::findChar(revdata, ',', loc);
	if(iRet > loc)
	{
		memcpy(m_strTicketBusStopID, revdata+loc, iRet - loc);
	}
	loc = iRet + 1;
	
	//班次编号
	bbzero(m_strBusClassID);
	iRet = CTools::findChar(revdata, ',', loc);
	if(iRet > loc)
	{
		memcpy(m_strBusClassID, revdata+loc, iRet - loc);
	}
	loc = iRet + 1;
	
	//班次名称
	bbzero(m_strBusClassName);
	iRet = CTools::findChar(revdata, ',', loc);
	if(iRet > loc)
	{
		memcpy(m_strBusClassName, revdata+loc, iRet - loc);
	}
	loc = iRet + 1;
	
	//发车时间
	bbzero(m_strGetOnTime);
	iRet = CTools::findChar(revdata, ',', loc);
	if(iRet > loc)
	{
		memcpy(m_strGetOnTime, revdata+loc, iRet - loc);
	}
	loc = iRet + 1;
	
	iRet = CTools::findChar(revdata, ',', loc);
	loc = iRet + 1;
	iRet = CTools::findChar(revdata, ',', loc);
	loc = iRet + 1;
	iRet = CTools::findChar(revdata, ',', loc);
	loc = iRet + 1;
	
	//档次
	bbzero(m_strTicketType);
	iRet = CTools::findChar(revdata, ',', loc);
	if(iRet > loc)
	{
		memcpy(m_strTicketType, revdata+loc, iRet - loc);
	}
	loc = iRet + 1;
	
	//到站站点编码
	bbzero(m_strDestinationID);
	iRet = CTools::findChar(revdata, ',', loc);
	if(iRet > loc)
	{
		memcpy(m_strDestinationID, revdata+loc, iRet - loc);
	}
	loc = iRet + 1;
	
	//到站站点名称
	bbzero(m_strDestinationBusStop);
	iRet = CTools::findChar(revdata, ',', loc);
	if(iRet > loc)
	{
		memcpy(m_strDestinationBusStop, revdata+loc, iRet - loc);
	}
	loc = iRet + 1;
	
	iRet = CTools::findChar(revdata, ',', loc);
	loc = iRet + 1;
	
	//发车区域名称
	bbzero(m_strBusStop);
	iRet = CTools::findChar(revdata, ',', loc);
	if(iRet > loc)
	{
		memcpy(m_strBusStop, revdata+loc, iRet - loc);
	}
	loc = iRet + 1;
	
	//剩余票数
	bbzero(temp);
	iRet = CTools::findChar(revdata, ',', loc);
	if(iRet > loc)
	{
		memcpy(temp, revdata+loc, iRet - loc);
		m_lngTicketNumber = atol(temp);
	}
	loc = iRet + 1;
	
	iRet = CTools::findChar(revdata, ',', loc);
	loc = iRet + 1;
	
	//班次所属客运站编码
	bbzero(m_strBusClassBusStopID);
	iRet = CTools::findChar(revdata, ',', loc);
	if(iRet > loc)
	{
		memcpy(m_strBusClassBusStopID, revdata+loc, iRet - loc);
	}
	
	//查询价格包
	if(con.conToHost(COACH_TICKET_IP, COACH_TICKET_PORT, &sd)==0)
	{
		bbzero(scont);
		strcpy(scont, "BK002");	//服务名
		strcat(scont, "0050");	//包长度，固定
		
		strcat(scont, m_strGetOnDate);	//班次日期
		
		bbzero(temp);					//班次编号
		strcpy(temp, m_strBusClassID);	
		iLen = strlen(m_strBusClassID);
		for(i = 0; i < 8 - iLen; i++)
		{
			strcat(temp, " ");
		}
		strcat(scont, temp);
		
		bbzero(temp);					//到站站点编码
		strcpy(temp, m_strDestinationID);
		iLen= strlen(m_strDestinationID);
		for(i = 0; i < 6 - iLen; i++)
		{
			strcat(temp, " ");
		}
		strcat(scont, temp);
		
		strcat(scont, m_strTicketBusStopID);//票源客运站编码
		strcat(scont, m_strBusClassBusStopID);//班次所属站编码
		
		bbzero(temp);					//发车区域名称
		strcpy(temp, m_strBusStop);	
		iLen = strlen(m_strBusStop);
		for(i = 0; i < 20 - iLen; i++)
		{
			strcat(temp, " ");
		}
		strcat(scont, temp);
		
		//发送数据包
		wrLog("发送明细请求:");
		wrLog(scont);
		
		iRet = con.sndMsg(sd, scont, strlen(scont));
		if( iRet!=0 )
		{
			TS_OutPutMsg(gbl.dPosInfo, "\n网络繁忙，请稍候再试\n 按【确认】返回", 0, iSelect);
			closesocket(sd);
			return -1;
		}
		//------------------------------------------
		//接收包
		bbzero(revdata);
		iRet = con.rcvMsg(sd, revdata, &rLen, 200);
		if(iRet != 0)
		{
			TS_OutPutMsg(gbl.dPosInfo, "\n网络繁忙，请稍候再试\n 按【确认】返回", 0, iSelect);
			closesocket(sd);
			return -1;
		}
		
		strcat(revdata, ",");
		bbzero(temp);
		memcpy(temp, revdata+9, 2);
		if(atoi(temp) != 0)
		{
			bbzero(temp);
			memcpy(temp, revdata+7, 2);
			iLen = atoi(temp) - 2;
			
			bbzero(temp);
			if(iLen <= 0)
			{
				strcpy(temp, "网络繁忙，请稍候再试");
			}
			else
			{
				memcpy(temp, revdata+11, iLen);
			}
			
			
			TS_OutPutMsg(gbl.dPosInfo, temp, 0, iSelect);
			closesocket(sd);
			return -1;
		}
		loc = 11;
		//票价
		bbzero(temp);
		iRet = CTools::findChar(revdata, ',', loc);
		if(iRet > loc)
		{
			memcpy(temp, revdata+loc, iRet - loc);
			m_lngTicketPrice = atol(temp)*100;
		}
		loc = iRet + 1;
		//停车卡位
		bbzero(m_strBusLocation);
		iRet = CTools::findChar(revdata, ',', loc);
		wrLog("%d,%d,%s",iRet, loc, revdata);
		if(iRet > loc)
		{
			memcpy(m_strBusLocation, revdata+loc, iRet - loc);
		}
		loc = iRet + 1;
		//检票口
		bbzero(m_strCheckPort);
		iRet = CTools::findChar(revdata, ',', loc);
		if(iRet > loc)
		{
			memcpy(m_strCheckPort, revdata+loc, iRet - loc);
		}
		loc = iRet + 1;
		//燃油附加税
		bbzero(m_strFuelTax);
		iRet = CTools::findChar(revdata, ',', loc);
		if(iRet > loc)
		{
			memcpy(m_strFuelTax, revdata+loc, iRet - loc);
		}
		loc = iRet + 1;
		//目的站名称
		// 		bbzero(m_strDestinationBusStop);
		// 		iRet = CTools::findChar(revdata, ',', loc);
		// 		if(iRet > loc)
		// 		{
		// 			memcpy(m_strDestinationBusStop, revdata+loc, iRet - loc);
		// 		}
		
		closesocket(sd);
	}
	else
	{
		TS_OutPutMsg(gbl.dPosInfo, "\n网络繁忙，请稍候再试\n 按【确认】返回", 0, iSelect);
		return -1;
	}
	
	bbzero(date);
	CTools::formatDate(m_strGetOnDate, date);
	
	wrLog("燃油附加费%s", m_strFuelTax);
	
	bbzero(temp);
	sprintf(temp, "【班次信息】\n班次：%s\n线路名称：%s\n发车站：%s  到站：%s\n发车日期：%s\n发车时间：%s\n档次：%s\n车票单价：%ld元\n剩余车票：%ld张\n\n【确认】继续 【取消】退出",
		m_strBusClassID, m_strBusClassName, m_strBusStop, m_strDestinationBusStop, date, m_strGetOnTime, m_strTicketType, m_lngTicketPrice/100, m_lngTicketNumber);
	
	
	if(atoi(m_strFuelTax) > 0)
	{
		strcat(temp, "\n\n\n\n\n【温馨提示】车票价格已包含燃油附加税");
		strcat(temp, m_strFuelTax);
		strcat(temp, "元");
	}
	
	iRet = TS_OutPutMsg(gbl.dPosInfo, temp, 0, iSelect);
	if(iRet)
	{
		TS_OutPutMsg(gbl.dPosInfo, "交互出错，请稍候再试", 0, iSelect);
		return iRet;
	}
	if(iSelect != 0)
	{
		return -1;
	}
	
	//订票数量
	while(1)
	{
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
		
		strcpy(tradeInfoSend.acMainTitle, "长途汽车票");
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents = 1;
		
		sprintf(tradeInfoSend.Contents[0].acTitle, "请输入订票数量：(1-5)");
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
		tradeInfoSend.Contents[0].uCount = 0;
		tradeInfoSend.Contents[0].uMinLen = 1;		
		tradeInfoSend.Contents[0].uMaxLen = 1;
		
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		if(iRet != 0)
		{
			return -1;
		}
		bbzero(temp);
		strcpy(temp, (char *)tradeInfoRecv.Contents[0].uMsg);
		m_lngBuyNumber = atol(temp);
		
		if(m_lngBuyNumber > 5 || m_lngBuyNumber < 1)
		{
			TS_OutPutMsg(gbl.dPosInfo, "输入的订票数量有误，请重新输入", 0, iSelect);
			continue;
		}
		else if(m_lngBuyNumber > m_lngTicketNumber)
		{
			iRet = TS_OutPutMsg(gbl.dPosInfo, "您输入的订票数量大于当前剩余数量，有可能预订失败。\n【确认】继续\n【取消】重新输入", 0, iSelect);
			if(iRet)
			{
				TS_OutPutMsg(gbl.dPosInfo, "交互出错，请稍候再试", 0, iSelect);
				return -1;
			}
			
			if(!iSelect)
			{
				break;
			}
			else
			{
				continue;
			}
		}
		else
		{
			break;
		}
	}
	/*
	//取票人姓名
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	  strcpy(tradeInfoSend.acMainTitle, "长途汽车票");
	  tradeInfoSend.uHasTradeID = 1;
	  tradeInfoSend.uTotalContents = 1;
	  
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入取票人姓名：");
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
		tradeInfoSend.Contents[0].uCount = 0;
		tradeInfoSend.Contents[0].uMinLen = 2;		
		tradeInfoSend.Contents[0].uMaxLen = 20;
		
		  iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		  if(iRet != 0)
		  {
		  wrLog("TS_TradeControl返回错误[%d]", iRet);
		  wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		  return iRet;
		  }
		  bbzero(m_strClientName);
		  strcpy(m_strClientName, (char *)tradeInfoRecv.Contents[0].uMsg);
	*/
	bbzero(m_strClientName);
	strcpy(m_strClientName, "交费易");
	
	//	while(1)
	//	{
	//取票人身份证号码
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, "长途汽车票");
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入【取票人】身份证号码：");
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
	tradeInfoSend.Contents[0].uCount = 0;
	tradeInfoSend.Contents[0].uMinLen = 15;		
	tradeInfoSend.Contents[0].uMaxLen = 18;
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	bbzero(m_strClientID);
	strcpy(m_strClientID, (char *)tradeInfoRecv.Contents[0].uMsg);
	
	//取票人电话号码
	while(1)
	{
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
		
		strcpy(tradeInfoSend.acMainTitle, "长途汽车票");
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents = 1;
		
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入【取票人】联系手机号码：");
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;	//超时30秒
		tradeInfoSend.Contents[0].uCount = 0;
		tradeInfoSend.Contents[0].uMinLen = 11;		
		tradeInfoSend.Contents[0].uMaxLen = 11;
		
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		if(iRet != 0)
		{
			wrLog("TS_TradeControl返回错误[%d]", iRet);
			wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
			return iRet;
		}
		bbzero(m_strClientPhone);
		strcpy(m_strClientPhone, (char *)tradeInfoRecv.Contents[0].uMsg);
		
		if(m_strClientPhone[0] == '1')
		{
			break;
		}
	}
	
	bbzero(m_strTradeInfo2);
	sprintf(m_strTradeInfo2, "%s,%s,%ld,%s,", m_strClientName, m_strClientID, m_lngBuyNumber, m_strGetOnDate);
	
	bbzero(temp);
	sprintf(temp, "【班次信息】\n目的地：%s \n出发站点：%s  班次：%s\n发车日期：%s  发车时间：%s\n档次：%s\n票面单价：%ld元  票数：%ld\n合计：%ld元\n\n【取票人信息】\n身份证号码：%s\n联系电话号码：%s\n\n【确认】交费 【取消】退出", 
		m_strDestinationBusStop, m_strBusStop, m_strBusClassID, date, 
		m_strGetOnTime, m_strTicketType, m_lngTicketPrice/100, m_lngBuyNumber, m_lngBuyNumber*m_lngTicketPrice/100, 
		m_strClientID, m_strClientPhone);
	
	iRet = TS_OutPutMsg(gbl.dPosInfo, temp, 0, iSelect);
	if(iRet)
	{
		TS_OutPutMsg(gbl.dPosInfo, "交互出错，请稍候再试", 0, iSelect);
		return -1;
	}
	if(iSelect == 0)
	{
		NULL;
	}
	else
	{
		return -1;
	}
	//	}
	
	sprintf(gbl.amount, "%012d", m_lngTicketPrice * m_lngBuyNumber);
	
	flag = 0;
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{
		if(!flag)
		{
			iRet = mngCard_Hdl("长途汽车票");
			if(iRet == CANCLE_KEY)
				return CANCLE_KEY;
			else if(iRet != 0)
				return -1;
		}
		pack.wrField(2, gbl);	//写交费域
		
		/***********修改一些域信息*********/
		bbzero(pack.FIELD48);
		memcpy(pack.FIELD48, gbl.fee_type,4);	//4位信息码
		b48_len = 4;
		bbzero(len_buff);
		sprintf(len_buff,"%02d", strlen(m_strClientPhone));	
		memcpy(pack.FIELD48+b48_len,len_buff,2);	
		b48_len +=2;
		memcpy(pack.FIELD48+b48_len, m_strClientPhone, strlen(m_strClientPhone));
		b48_len += strlen(m_strClientPhone);
		pack.Packet_Table[48].Real_Length=b48_len;
		
		bbzero(temp);
		strcpy(temp, m_strTradeInfo1);
		strcat(temp, ",|");
		memcpy(pack.FIELD63+8, temp, strlen(temp));
		b63_len = 8+strlen(temp);
		bbzero(temp);
		strcpy(temp, m_strTradeInfo2);
		strcat(temp, m_strFuelTax);
		strcat(temp, "00");
		strcat(temp, ",");
		memcpy(pack.FIELD63+b63_len, temp, strlen(temp));
		b63_len += strlen(temp);
		pack.Packet_Table[63].Real_Length=b63_len;
		
		/**********************************/
		
		//交费包
		iRet = packHdl(2);
		if(iRet < 0)
			return -1;
		
		memset(response_code,0,sizeof(response_code));
		memcpy(response_code,pack.FIELD39,2);
		
		if (!memcmp(response_code,"00",2)) 
		{
			bbzero(gbl.stan_no);
			memcpy(gbl.stan_no, (char *)pack.FIELD37, 12);
			bbzero(temp);
			memcpy(temp, pack.FIELD63, pack.Packet_Table[63].Real_Length);
			memset(m_strTicketSerials, 0 , sizeof(m_strTicketSerials));
			loc = 0;
			iRet = CTools::findChar(temp, '|', loc);
			loc = iRet + 1;		
			iRet = CTools::findChar(temp, '|', loc);
			bbzero(m_strPassword);
			memcpy(m_strPassword, temp+loc, iRet - loc);
			loc = iRet + 1;
			wrLog("pass: %s", m_strPassword);
			for(i = 0; i < m_lngBuyNumber; i++)
			{
				iRet = CTools::findChar(temp, ',', loc);
				if(iRet > loc)
				{
					memcpy(m_strTicketSerials[i], temp+loc, 10);
				}
				loc = iRet + 1;
			}
			
			bbzero(m_strClientID_print);
			strcpy(m_strClientID_print, m_strClientID);
			memcpy(m_strClientID_print+5, "*********", 9);
			
			bbzero(temp);
			sprintf(temp, "取票人身份证：%s\n目的地：%s  出发站点：%s\n发车时间：%s %s\n车票单价：%d",
				m_strClientID_print, m_strDestinationBusStop, m_strBusStop, date, m_strGetOnTime, m_lngTicketPrice/100);
			
			if(atoi(m_strFuelTax) != 0)
			{
				strcat(temp, "(含燃油附加费");
				strcat(temp, m_strFuelTax);
				strcat(temp, "元)\n");
			}
			else
			{
				strcat(temp, "\n");
			}
			
			strcat(temp, "票号：");
			if(m_lngBuyNumber == 1)
			{
				strcat(temp, m_strTicketSerials[0]);
			}
			else
			{
				strcat(temp, m_strTicketSerials[0]);
				strcat(temp, " - ");
				strcat(temp, m_strTicketSerials[m_lngBuyNumber - 1]);
			}
			
			bbzero(len_buff);
			sprintf(len_buff, "  %d张\n", m_lngBuyNumber);
			strcat(temp, len_buff);
			
			strcat(temp, "取票密码：");
			strcat(temp, m_strPassword);
			
			strcat(temp, "\n1.发车前60分钟必须到发车站服务窗口取票\n2.换票时须提供取票人身份证原件和票号\n3.退票须到相应发车站窗口并按相关规定处理\n");
			
			
			bbzero(revdata);
			strcpy(revdata, "\n订票成功！\n按【确认】打印\n\n\n票号：\n");
			for(i = 0; i < m_lngBuyNumber; i++)
			{
				strcat(revdata, m_strTicketSerials[i]);
				if((i+1)%3 != 0 && (i+1) != m_lngBuyNumber)
					strcat(revdata, "/");
				else
					strcat(revdata, "\n");
			}
			strcat(revdata, "\n\n重要说明：\n1.发车前60分钟必须到发车站服务窗口取票\n2.换票时须提供取票人身份证原件和票号\n3.退票须到相应发车站窗口并按相关规定处理\n\n【温馨提示】尊敬的客户，已发订购信息到您的手机，敬请关注。");
			
			iRet = TS_OutPutMsg(gbl.dPosInfo, revdata, 0, iSelect);
			
			if(!iRet && !iSelect)
			{
				CPrint print;
				print.set_in_par(gbl);
				print.print_coach_ticket_detail("广州长途汽车换票凭证", temp);
			}
			
			return 0;
		}
		else if(!memcmp(response_code,"55",2))
		{
			
			flag = 1;
			if(reGetPwd("长途汽车票") == 0) //密码错误，重新输入密码, 2006-10-25
				continue;
			else
				return CANCLE_KEY;
		}
		else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
			if (iSelect!=0)
			{
				return -1;
			}else
				continue;
		}
		else
		{
			returnFail(response_code);
			return -1;
		}
		
		return 0;
	}
	
	
	return 0;
}

int CTrade::Unicom_Sell_Phoneno(const char* title)
{
	int iRet,iSelect,type_flag=0;
	
	TSTxnLogs txnLogs;
	memset(&txnLogs, 0, sizeof(txnLogs));
	
	
	
	iRet = CDB::getTEL_STOCKS(7,&txnLogs,gbl.city_no);
	
	if (iRet != 0)
	{
		TS_OutPutMsg(gbl.dPosInfo,"没有符合查询内容的手机号码，请重新输入条件",0,iSelect);
		return -1;
	}
	iRet = TS_ShowTxnLogs(gbl.dPosInfo, &txnLogs);
	return 0;
}

int CTrade::Unicom_Sell_Phoneno_Hdl1(const char* title)
{
	int iRet,iSelect;
	
	TSTxnLogs txnLogs;
	memset(&txnLogs, 0, sizeof(txnLogs));
	
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, title);
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入手机号码：");	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//全字符
	tradeInfoSend.Contents[0].uCount = 0;		//输入1次
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
	tradeInfoSend.Contents[0].uMinLen = 11;	
	tradeInfoSend.Contents[0].uMaxLen = 11;
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	
	bbzero(gbl.phone_no);
	strcpy(gbl.phone_no,(char *)tradeInfoRecv.Contents[0].uMsg );
	gbl.phone_len = tradeInfoRecv.Contents[0].uMsgLen;
	
	iRet = CDB::getTermUim(&txnLogs, gbl.phone_no, gbl.pos_no, 2);
	
	if (iRet != 0)
	{
		TS_OutPutMsg(gbl.dPosInfo,"没有符合查询内容的白卡，请重新输入条件",0,iSelect);
		return -1;
	}
	iRet = TS_ShowTxnLogs(gbl.dPosInfo, &txnLogs);
	return 0;
}



/////////////////////////////////////////////////////////////////

int CTrade::Unicom_Sell_Phoneno_Hdl2(const char* title)
{
	int iRet,iSelect,b48_len,b63_len;
	char buff[512], user_name[20], user_sex[2], user_id[20], prestored_mny[11], product_id[10], stan_tmp[13];
	char iccid_buff[30+1],mny[15+1],fee[12+1],type[2+1],len_buff[2+1];
	
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, title);
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入白卡ICCID号：");	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	
	tradeInfoSend.Contents[0].uCount = 0;		//输入1次
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
	tradeInfoSend.Contents[0].uMinLen = 29;	
	tradeInfoSend.Contents[0].uMaxLen = 31;
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	
	bbzero(buff);
	strcpy(buff, (char *)tradeInfoRecv.Contents[0].uMsg );
	
	bbzero(gbl.phone_no);
	memcpy(gbl.phone_no, buff, 11);
	gbl.phone_len = 11;
	
	bbzero(gbl.ICCID_no);
	memcpy(gbl.ICCID_no, buff+11, tradeInfoRecv.Contents[0].uMsgLen - 11);
	
	bbzero(gbl.pos_serial);
	strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
	
	bbzero(buff);
	bbzero(iccid_buff);
	
	for (int i=0;i<strlen(gbl.ICCID_no);i+=4)
	{
		strncat(iccid_buff,gbl.ICCID_no+i,4);
		strcat(iccid_buff," ");
	}
	bbzero(fee);
	bbzero(type);
	iRet = CDB::getTEL_STOCKS_detail(gbl.phone_no,fee,type);
	if (iRet<0)
	{
		TS_OutPutMsg(gbl.dPosInfo,"您查找的手机号码不存在!请重新选择号码",0,iSelect);
		return -1;
	}
	bbzero(user_name);
	bbzero(user_sex);
	bbzero(user_id);
	///////////////////////////////////////////////////////////////////
	while(1)//获取身份证ID
	{
		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
		
		strcpy(tradeInfoSend.acMainTitle, title);
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents = 1;
		
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入用户身份证号：");	
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//全字符
		tradeInfoSend.Contents[0].uCount = 0;		//输入1次
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
		tradeInfoSend.Contents[0].uMinLen = 0;	
		tradeInfoSend.Contents[0].uMaxLen = 18;
		
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		if(iRet != 0)
		{
			wrLog("TS_TradeControl返回错误[%d]", iRet);
			wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
			return iRet;
		}
		
		bbzero(user_id);
		strcpy(user_id, (char *)tradeInfoRecv.Contents[0].uMsg );
		
		if(strlen(user_id) != 0 && strlen(user_id) != 15 && strlen(user_id) != 18)
		{
			iRet = TS_OutPutMsg(gbl.dPosInfo, "输入长度有误，按【确认】重新输入", 0, iSelect);
			if(iRet)
			{
				return -1;
			}
			else if(iSelect)
			{
				return 0;
			}
			else
			{
				continue;
			}
		}
		break;
	}
	
	
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, title);
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入用户名：");	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//全字符
	tradeInfoSend.Contents[0].uCount = 0;		//输入1次
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
	tradeInfoSend.Contents[0].uMinLen = 0;	
	tradeInfoSend.Contents[0].uMaxLen = 50;
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	
	bbzero(user_name);
	strcpy(user_name, (char *)tradeInfoRecv.Contents[0].uMsg );
	
	
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, title);
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入用户性别：(0女1男)");	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;
	tradeInfoSend.Contents[0].uCount = 0;		//输入1次
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
	tradeInfoSend.Contents[0].uMinLen = 0;	
	tradeInfoSend.Contents[0].uMaxLen = 1;
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	
	bbzero(user_sex);
	strcpy(user_sex, (char *)tradeInfoRecv.Contents[0].uMsg );
	
	///////////////////////////////////////////////////////////////////////////////////////////
	
	if(strlen(user_name) <= 0)
	{
		strcpy(user_name, "unknow_user");
	}
	if(strlen(user_id) <= 0)
	{
		strcpy(user_id, "111111111111111");
	}
	if(strlen(user_sex) <= 0 || memcmp(user_sex, "0", 1))
	{
		strcpy(user_sex, "1");
	}
	
	CTools::chgToMny(fee, mny);
	sprintf(buff,"选定号码：%s\n价格：%s\n白卡卡号：%s\n\n 【确认】继续 【返回】取消 \n",gbl.phone_no,mny,iccid_buff);
	iRet = TS_OutPutMsg(gbl.dPosInfo, buff, 0, iSelect);
	if(iRet != 0)
	{
		TS_OutPutMsg(gbl.dPosInfo, "网络繁忙，请稍候再试", 0, iSelect);
		return -1;
	}
	else if (iSelect != 0)
	{
		return -1;
	}
	bbzero(gbl.fee_type);
	strcpy(gbl.fee_type,"0352");
	bbzero(gbl.amount);
	strcpy(gbl.amount, fee);
	
	pack.wrField(1, gbl);	//写交费域
	/***************修改一些域****************/
	bbzero(pack.FIELD48);
	memcpy(pack.FIELD48,gbl.fee_type,4);
	b48_len = 4;
	bbzero(len_buff);
	sprintf(len_buff,"%02d",gbl.phone_len);
	memcpy(pack.FIELD48+b48_len,len_buff,2);
	b48_len += 2;
	memcpy(pack.FIELD48+b48_len,gbl.phone_no,gbl.phone_len);
	b48_len += gbl.phone_len;
	// 	memcpy(pack.FIELD48+b48_len,"01",2);
	// 	b48_len += 2;
	pack.Packet_Table[48].Real_Length = b48_len;
	/*****************************************/
	
	iRet = packHdl(1);
	if(iRet < 0)
		return -1;
	
	if (!memcmp(pack.FIELD39,"00",2)) 
	{
		NULL;
	}else{
		returnFail((char*)pack.FIELD39);
		return -1;
	}
	
	//获取预存金额
	bbzero(prestored_mny);
	memcpy(prestored_mny, pack.FIELD63, 10);
	
	//产品资源ID
	bbzero(product_id);
	memcpy(product_id, pack.FIELD63+12, 8);
	
	//获取系统参考号
	bbzero(stan_tmp);
	memcpy(stan_tmp, (char *)pack.FIELD37, 12);
	
	int flag = 0;
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{
		if(!flag)
		{
			iRet = mngCard_Hdl(title);
			if(iRet == CANCLE_KEY)
				return CANCLE_KEY;
			else if(iRet != 0)
				return -1;
		}
		pack.wrField(2, gbl);	//写交费域
		/***************修改一些域****************/
		bbzero(buff);
		memcpy(buff, "                    ", 20);
		memcpy(buff, gbl.ICCID_no, strlen(gbl.ICCID_no));
		b63_len = 8;
		memcpy(pack.FIELD63+b63_len, buff, 20);       //ICCID
		b63_len += 20;
		memcpy(pack.FIELD63+b63_len, product_id, 8);
		b63_len += 8;
		memcpy(pack.FIELD63+b63_len, prestored_mny, 10);
		b63_len += 10;
		bbzero(buff);
		memcpy(buff, "                  ", 18);
		memcpy(buff, user_id, strlen(user_id));
		memcpy(pack.FIELD63+b63_len, buff, 18);
		b63_len += 18;
		bbzero(buff);
		memcpy(buff, "                         ", 25);
		memcpy(buff+25, "                         ", 25);
		memcpy(buff, user_name, strlen(user_name));
		memcpy(pack.FIELD63+b63_len, buff, 50);
		b63_len += 50;
		memcpy(pack.FIELD63+b63_len, user_sex, 1);
		b63_len += 1;
		memcpy(pack.FIELD63+b63_len, stan_tmp, 12);
		b63_len += 12;
		
		pack.Packet_Table[63].Real_Length = b63_len;
		/*****************************************/
		
		iRet = packHdl(2);
		if(iRet < 0)
			return -1;
		
		if (!memcmp(pack.FIELD39,"00",2)) 
		{
			iRet = TS_OutPutMsg(gbl.dPosInfo,"     号码购买成功！\n请按【确认】打印凭证",0,iSelect);
			if(iRet != 0)
			{
				TS_OutPutMsg(gbl.dPosInfo, "网络繁忙，请稍候再试", 0, iSelect);
				return -1;
			}
			else if (iSelect != 0)
			{
				return -1;
			}
			
			bbzero(gbl.stan_no);
			memcpy(gbl.stan_no,(char *)pack.FIELD37,12);
			
			CPrint prt;
			prt.set_in_par(gbl);
			prt.print_sell_phone("联通空中放号");
			return 0;
		}
		else if(!memcmp(pack.FIELD39,"55",2))
		{
			flag = 1;
			if(reGetPwd(title) == 0) //密码错误，重新输入密码, 2006-10-25
				continue;
			else
				return CANCLE_KEY;
		}
		else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
			if (iSelect!=0)
			{
				return -1;
			}else
				continue;
		}
		else
			returnFail((char*)pack.FIELD39);
		return -1;
	}
	return 0;
}


int CTrade::setPrintPaper()
{
	int iRet, iSelect;
	char temp[100];
	
	TSMENULIST menuList;
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	
	strcpy(tradeInfoSend.acMainTitle, "设置发票类型");
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入设置密码：");	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_PWD;	//全字符
	tradeInfoSend.Contents[0].uCount = 0;		//输入1次
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
	tradeInfoSend.Contents[0].uMinLen = 0;	
	tradeInfoSend.Contents[0].uMaxLen = 8;
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	
	bbzero(temp);
	strcpy(temp, (char *)tradeInfoRecv.Contents[0].uMsg);
	if(strcmp(temp, "345678"))
	{
		TS_OutPutMsg(gbl.dPosInfo, "密码错误!", 0, iSelect);
		return -1;
	}
	
	memset(&menuList, 0, sizeof(menuList));
	
	
	strcpy(menuList.acTitle, "请选择发票纸类型:");
	menuList.iTotalNum = 2;
	
	strcpy(menuList.menuItem[0], "新发票打印纸(较长)");
	strcpy(menuList.menuItem[1], "旧发票打印纸(较短)");
	
	iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect);
	
	if(iRet)
	{
		return -1;
	}
	
	switch(iSelect)
	{
	case 1:
		iRet = CDB::update_print_paper(gbl.pos_no, 1);
		break;
	case 2:
		iRet = CDB::update_print_paper(gbl.pos_no, 0);
		break;
	}
	
	if(!iRet)
	{
		TS_OutPutMsg(gbl.dPosInfo, "设置成功,请重启", 0, iSelect);
	}
	else
	{
		TS_OutPutMsg(gbl.dPosInfo, "设置失败,请稍候再试", 0, iSelect);
	}
	
	return 0;
}


int CTrade::ecard_query(const char* type)
{
	CConnect con;
	SOCKET sd = 0;
	char scont[1024], rcont[10240], temp[1025], _date[9], _time[7], totallen[10];
	int sLen, rLen, itotal, iRet;
    char bytetmp[32] = {0};

    //if(con.conToHost("132.97.117.186", atoi(ecard_ser_port), &sd) == 0)
    if(con.conToHost(ecard_ip, atoi(ecard_ser_port), &sd) == 0)   //生产
	{
		bbzero(scont);
		//包头
		strcpy(scont, "FFFF");
		bbzero(_date);
		CTools::getDate(_date);
		bbzero(_time);
		CTools::getTime(_time);
		bbzero(temp);
		sprintf(temp, "%s%s", _date, _time);
		strcat(scont, temp);//日期时间14
		strcat(scont, "88300003");//固定终端号8
		strcat(scont, "00000000"); //包总长度8
		strcat(scont, type); //包类型8
		strcat(scont, "0");
		//包体
		strcat(scont, "0083");//业务代码4 0083 
		strcat(scont, gbl.dPosInfo.pos_no); //终端号8
		bbzero(temp);
		memset(temp, ' ', 30);
		//memcpy(temp, "                              ", 30);
		memcpy(temp, gbl.card_no, strlen(gbl.card_no));
		strcat(scont, temp);	//e卡帐号30
        strcat(scont, "0001");//密码类型=>支付密码
        //工号,定长16位
        bbzero(temp);
        strcat(temp, gbl.dPosInfo.pos_no);
        strcat(temp, "_01");
        sprintf(bytetmp, "%-16.16s", temp);
        strcat(scont, bytetmp);

        bbzero(temp);
    	CTools::byte_to_hex((BYTE*)gbl.password, (BYTE*)bytetmp, 8);
        sprintf(temp, "%02d%s", strlen(bytetmp), bytetmp );
		strcat(scont, temp);	//密码长度2两位+密码体
		
		bbzero(temp);
		bbzero(bytetmp);
		CTools::byte_to_hex((BYTE*)gbl.posInfo.psamNum, (BYTE*)temp, 8);
		memset(bytetmp,' ', 20);
		//当ipos登录时，统一使用“2000000000000001”
		//memcpy(bytetmp, temp, 16);
		if(atoi(gbl.dPosInfo.prmVer)>=9000)
			memcpy(bytetmp, "2000000000000001", 16);
		else
			memcpy(bytetmp, temp, 16);
		strcat(scont, bytetmp);	//psam卡号16
		wrLog("PSAM卡号:{%s}", bytetmp);
		bbzero(temp);
		sLen = strlen(scont);
		sprintf(temp, "%08d", sLen);	
		memcpy(scont+26, temp, 8);
		
		wrLog("发送ENQ0001请求包到FAS_ACC[%d]:[%s]", sLen, scont);		
		iRet = con.sndMsg(sd, scont, sLen);
		if( iRet!=0) {
			closesocket(sd);
			return -4;
		}

		bbzero(temp);
		//收报头
		iRet = con.rcvMsg(sd, temp, &rLen, 42, 90);
		if(rLen != 42 || iRet != 0)	{
			closesocket(sd);
			return -1;
		}
		bbzero(totallen);
		memcpy(totallen, temp+26, 8);		
		itotal = atoi(totallen);
		if(itotal >= 10240)
		{
			wrLog("超过包内容最大长度[%d]", itotal);
			closesocket(sd);
			return -1;
		}
		//要接收的包体长度
		itotal -= 42;
		bbzero(rcont);
		//收包体
		while(1)
		{
			bbzero(temp);
			iRet = con.rcvMsg(sd, temp, &rLen, 1024);
			strcat(rcont, temp);		
			if(iRet)
			{
				closesocket(sd);
				return -1;
			}
			if(itotal - rLen > 0)
			{
				itotal = itotal - rLen;
				continue;
			}
			break;
		}
		
		wrLog("接收查询内容长度[%d]：", strlen(rcont));
		if (strlen(rcont) < 8192)
		{
			wrLog("接收查询内容:[%s]", rcont);
		}
		else
		{
			wrLog("【明细过长，无法写LOG】");
		}
		
		closesocket(sd);
		
		//数据声明
		char rspcode[5], party_code[8], temp[100];
		rLen = 0;
		//成功获取数据rcont
		bbzero(rspcode);
		memcpy(rspcode, rcont, 4);
		rLen += 4;
		memcpy(pack.FIELD39, rspcode, 2);
		pack.Packet_Table[39].Real_Length = 2;
	    memcpy(pack.FIELD37, rcont+54, 12);
		pack.Packet_Table[37].Real_Length = 12;
		//FFFF201211200223098830000300000067ENQ00011000619网络繁忙,请稍后再试
		if(atoi(rspcode) != 0)
		{
			//返回失败
			bbzero(party_code);
			strcpy(party_code, "P200024");
			memcmp(party_code+1, rcont+66, 6);
			memcpy(pack.FIELD62, party_code, 7);
			memcpy(pack.FIELD62+7, rspcode+2, 2);
			pack.Packet_Table[62].Real_Length = 9;
            if (strcmp(rspcode, "5500") == 0) {
                return -2;//密码错
            } else if (strcmp(rspcode, "7500") == 0) {
				//密码错误过多，锁定
				return -3;
			}
            //错误码处理
            return -1;
		}
		else
		{
			//返回成功
			bbzero(temp);
			memcpy(temp, rcont+110, 36);
			memcpy(pack.FIELD63, temp, 36);
			pack.Packet_Table[63].Real_Length = 36;
			wrLog("FIELD63:%s", temp);
		}
		return 0;
	}
	else
	{
		return -1;
	}
	return 0;
}

int CTrade::getRecommandMenu(int type)
{
	switch(type)
	{
	case 597:
	case 598:
		getYCTRecommandMenu();
		break;
	default:
		break;
	}
	
	return 0;
}

int CTrade::getYCTRecommandMenu()
{
	int iRet, iSelect;
	
	TSMENULIST menuList;
	memset(&menuList, 0, sizeof(menuList));
	
	menuList.iTotalNum = 3;
	strcpy(menuList.acTitle, "您还可以向商户推荐以下服务：");
	strcpy(menuList.menuItem[0], "公交卡消费(即将推出)");
	strcpy(menuList.menuItem[1], "中国电信直充");
	strcpy(menuList.menuItem[2], "中国联通直充");
	
	iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
	
	if(iRet==HOTKEY)
	{
		return CANCLE_KEY;
	}
	else if(iRet!=0)
	{
		return iRet;
	}
	else
	{
		NULL;
	}
	
	switch(iSelect)
	{
	case 1:
		TS_OutPutMsg(gbl.dPosInfo, "\n即将推出，敬请关注！\n", 0, iSelect);
		return 0;
	case 2:
		DZDBAirPay("电信直充", 3, 0);
		return 0;
	case 3:
		mblAirPay("联通话费直充", 3);
		return 0;
	default: 
		return CANCLE_KEY;
	}
	
	return 0;
}

int CTrade::YctSuccTxnEnq(const char *title)
{
	int iRet=0, count=0, status=0, iSelect=0, itemNum=0;
	char date[16+1];
	TSTxnLogs txnLogs;
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, title);
	tradeInfoSend.uHasTradeID = 1;
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入日期");
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_DATE;	
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;//超时30秒
	tradeInfoSend.Contents[0].uMinLen = 8;	
	tradeInfoSend.Contents[0].uMaxLen = 8;
	tradeInfoSend.uTotalContents = 1;
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	
	bbzero(date);
	memcpy(date, (char *)tradeInfoRecv.Contents[0].uMsg, 8);
	
	memset(&txnLogs, 0, sizeof(txnLogs));
	
	iRet = CDB::getYctTxn(gbl.pos_no, date, &txnLogs);
	
	if(iRet == -4)
	{
		TS_OutPutMsg(gbl.dPosInfo, "没有相关交易记录!", 0, iSelect);
		return iRet;
	}
	else if(iRet!=0)
	{
		
		TS_OutPutMsg(gbl.dPosInfo, "网络繁忙，查找出错!\n\n请稍后再查!", 0, iSelect);
		return iRet;
	}
	
	iRet = TS_ShowTxnLogs(gbl.dPosInfo, &txnLogs);
	if(iRet != 0)
	{
		wrLog("TS_ShowTxnLogs返回错误[%d]", iRet);
		return iRet;
	}
	
	return 0;
}

int CTrade::printYctBill(const char *title)
{
	int iRet=0, count=0, status=0, iSelect=0, itemNum=0;
	char date[16+1], normal_amount[12+1], plus_amount[12+1];
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	
	
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	strcpy(tradeInfoSend.acMainTitle, title);
	tradeInfoSend.uHasTradeID = 1;
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入原交易日期");
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_DATE;	
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;//超时30秒
	tradeInfoSend.Contents[0].uMinLen = 8;
	tradeInfoSend.Contents[0].uMaxLen = 8;
	tradeInfoSend.uTotalContents = 1;
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}	
	
	bbzero(date);
	memcpy(date, (char *)tradeInfoRecv.Contents[0].uMsg, 8);
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入原交易金额：");	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_MONEY;	//全字符
	tradeInfoSend.Contents[0].uCount = 0;		//输入1次
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
	tradeInfoSend.Contents[0].uMinLen = 1;	
	tradeInfoSend.Contents[0].uMaxLen = 12;	
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	bbzero(normal_amount);
	strcpy(normal_amount,(char *)tradeInfoRecv.Contents[0].uMsg );
	
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入多收交易金额：");
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_MONEY;	//全字符
	tradeInfoSend.Contents[0].uCount = 0;		//输入1次
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
	tradeInfoSend.Contents[0].uMinLen = 0;
	tradeInfoSend.Contents[0].uMaxLen = 12;
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	bbzero(plus_amount);
	strcpy(plus_amount,(char *)tradeInfoRecv.Contents[0].uMsg );
	
	iRet = CDB::setYctBill(date, normal_amount, plus_amount);
	if(iRet!=0)
	{
		
		TS_OutPutMsg(gbl.dPosInfo, "处理送款单出错!", 0, iSelect);
		return iRet;
	}
	
	CPrint prt;
	prt.set_in_par(gbl);
	prt.printYctBill(date, normal_amount, plus_amount);	 //打印明细
	if(iRet != 0)
	{
		wrLog("TS_ShowTxnLogs返回错误[%d]", iRet);
		return iRet;
	}
	
	return 0;
}


CTrade::bestPay_rechargeHdl(const char *title,int select) //翼支付账户充值

{
	int iSelect, iRet=0;
	int flag,b48_len,b63_len;
	char msg[200],response_code[3],tmp[20],amoMny[12+1];
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	char amountFlag[1+1];//余额标志位
	
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入需充值的翼支付账户:");
	tradeInfoSend.Contents[0].uCommand =TS_INPUT_MATH;
	tradeInfoSend.Contents[0].uCount = 1; //输入2次翼支付
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME + 30;
	tradeInfoSend.Contents[0].uMinLen = 11; //翼支付账户长度11
	tradeInfoSend.Contents[0].uMaxLen = 11;
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	
	bbzero(gbl.pos_serial);
	strcpy(gbl.pos_serial, (char *)tradeInfoRecv.uTradeID);//系统流水号
	bbzero(gbl.bestpayAccount);//翼支付充值账户
	strcpy(gbl.bestpayAccount,(char *) tradeInfoRecv.Contents[0].uMsg);
	gbl.bestpayAccount_len=tradeInfoRecv.Contents[0].uMsgLen; //翼支付账户长度
	
	iRet = selectAmount(0,select);	
	if(iRet == CANCLE_KEY)
		return CANCLE_KEY;
	else if(iRet < 0)
		return -1;
	
	wrLog("gbl.amount:%s",gbl.amount); //交易金额
	wrLog("gbl.bestpayAccount:%s",gbl.bestpayAccount); //翼支付账户
	CTools::trim(gbl.bestpayAccount); //去除空格
	
	flag=0;
	/***************刷卡*************************/
	
	for(int curTry=0; curTry<MAXTRY; curTry++) 
	{
		if(!flag)
		{
			iRet = mngCard_Hdl(title);//
			if(iRet == CANCLE_KEY)
				return CANCLE_KEY;
			else if(iRet != 0)
				return -1;
		}
		
		if(atoi(gbl.dPosInfo.prmVer)>=9000)
		{
			bbzero(amoMny);
			CTools::chgToMny(gbl.amount,amoMny);
			bbzero(msg);
			sprintf(msg, "充值的翼支付账户：%s\n充值金额：%s\n\n【是 Enter】  【否 Esc】", gbl.bestpayAccount, amoMny);
			iRet = TS_OutPutMsg(gbl.dPosInfo, msg, 0, iSelect);
			if(iSelect)
			{
				return -1;
			}
		}
		
		pack.wrField(2, gbl);	//写交费域
		/***************修改一些域****************/
		
		bbzero(pack.FIELD48);
		memcpy(pack.FIELD48,gbl.fee_type,4);//收费种类(4)
		b48_len = 4;
		
		bbzero(tmp);
		sprintf(tmp,"%02d",strlen(gbl.bestpayAccount));
		memcpy(pack.FIELD48+b48_len,tmp,2); //翼支付号码长度11
		b48_len+=2;
		memcpy(pack.FIELD48 + b48_len, gbl.bestpayAccount, strlen(gbl.bestpayAccount));	//翼支付账户(长度是11位)
		
		b48_len +=strlen(gbl.bestpayAccount);
		pack.Packet_Table[48].Real_Length=b48_len;
		/*****************************************/
		
		iRet = packHdl(2);

		if(iRet < 0)

		{
			wrLog("解包失败[%d]",iRet);
	
			return -1;
		}
		
		memset(response_code,0,sizeof(response_code));
		memcpy(response_code,pack.FIELD39,2);
		wrLog("response_code:%s",response_code);
		
		if (!memcmp(response_code,"00",2)) //如果交易成功
		{
			
			//获取解包的数据  
			
			b63_len=0;	
			memset(tmp,0,sizeof(tmp));
			memcpy(tmp,pack.FIELD63,12);
			memset(gbl.amount,0,sizeof(gbl.amount));//获取充值余额
			CTools::chgToMny(tmp,gbl.amount);
			wrLog("返回数据包充值金额gbl.amount:%s",gbl.amount);//输出充值金额
			b63_len+=12;
			bbzero(amountFlag);//余额标志位
			bbzero(tmp);
			memcpy(tmp,pack.FIELD63+b63_len,1);
			b63_len++;	

			memset(tmp,0,sizeof(tmp));
			memcpy(tmp,pack.FIELD63+b63_len,12);//获取用户余额
			memset(gbl.bestpayTotalMny,0,sizeof(gbl.bestpayTotalMny));
			CTools::chgToMny(tmp,gbl.bestpayTotalMny);
			if(!memcmp(amountFlag,"d",1))
			{
				bbzero(tmp);
				sprintf(tmp,"-%s",gbl.bestpayTotalMny);//如果余额为负数
				bbzero(gbl.bestpayTotalMny);
				memcpy(gbl.bestpayTotalMny,tmp,13);
				wrLog("gbl.bestpayTotalMny:%s",gbl.bestpayTotalMny);
			}
			
			wrLog("返回数据包gbl.bestpayAcount:%s",gbl.bestpayTotalMny);//输出翼支付账户余额
			b63_len+=13;
			
			bbzero(msg);
			sprintf(msg, "翼支付账户充值成功！\n\n充值账户：%s\n充值金额：%s\n账户余额：%s\n\n谢谢您的使用,是否打印发票\n 【是 Enter】  【否 Esc】",gbl.bestpayAccount,gbl.amount,gbl.bestpayTotalMny);
			iRet = TS_OutPutMsg(gbl.dPosInfo,msg,0,iSelect);
			
			if(iRet!=0 || iSelect==0)
				
			{
				CPrint prt;
				prt.set_in_par(gbl);
			//	prt.print_detail(18, "翼支付充值");	//打印欠费明细 (去掉“发票”两字)
				prt.print_bestpay_detail(pack,"翼支付充值");
			}
			
			return 0;
		}
		
		else if(!memcmp(pack.FIELD39,"55",2))
		{
			flag = 1;
			if(reGetPwd(title) == 0) //密码错误，重新输入密码, 2006-10-25
				continue;
			else
				
				return CANCLE_KEY;
		}
		else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
			if (iSelect!=0)
			{
				return -1;
			}else
				continue;
		}
		
		else
			
			returnFail(response_code);
		
		return 1;
	}
	
	return -1;
}

//薪加薪审核权限设置
int CTrade::xjx_checkauthorcfg_hdl(const char *title)
{
	int iRet,iSelect;
	char input_pwd[6+1];
	char db_pwd[6+1];
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	TSMENULIST menuList;
	
	bbzero(input_pwd);
	bbzero(db_pwd);
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	//管理员密码输入
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入管理员密码：");	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_PWD;//明文密码
	tradeInfoSend.Contents[0].uDesMode = TS_NO_ENC;//不加密
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;//超时30秒
	tradeInfoSend.Contents[0].uMinLen = 6;
	tradeInfoSend.Contents[0].uMaxLen = 6;
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	
	strcpy(input_pwd, (char *)tradeInfoRecv.Contents[0].uMsg);//输入的管理员密码
	
	iRet = CDB::xjx_get_password(0,gbl.dPosInfo.pos_no,db_pwd);
	if(iRet == -4)
	{
		TS_OutPutMsg(gbl.dPosInfo, "查询失败!", 0, iSelect);
		return iRet;
	}
	else if(iRet!=0)
	{
		
		TS_OutPutMsg(gbl.dPosInfo, "网络繁忙，查询出错!\n\n", 0, iSelect);
		return iRet;
	}
	
	if (strncmp(input_pwd,db_pwd,6) != 0)
	{
		TS_OutPutMsg(gbl.dPosInfo, "密码错误，请重新输入!\n\n", 0, iSelect);
		xjx_checkauthorcfg_hdl("薪加薪理财二级审核设置");
	}
	
	memset(&menuList,0,sizeof(menuList));
	menuList.iTotalNum = 2;
	strcpy(menuList.acTitle, "资金划拨设置->审核权限设置");
	strcpy(menuList.menuItem[0], "二级审核");
	strcpy(menuList.menuItem[1], "三级审核");
	
	iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
	if(iRet)
		return -1;

	if (iSelect == 1)
	{
		wrLog("薪加薪理财二级审核设置");
		strcpy(gbl.fee_type,"0368");
		set_in_par(gbl);
		xjx_LLcheckcfg_hdl("薪加薪理财二级审核设置");//薪加薪理财二级审核设置
	}
	else if (iSelect == 2)
	{
		wrLog("薪加薪理财三级审核设置");
		strcpy(gbl.fee_type,"0368");
		set_in_par(gbl);
		xjx_LLLcheckcfg_hdl("薪加薪理财三级审核设置");//薪加薪理财三级审核设置
	}

	return 0;
}

//薪加薪二级审核设置
int CTrade::xjx_LLcheckcfg_hdl(const char *title)
{
	int iRet,iSelect;
	TSMENULIST menuList;

	memset(&menuList,0,sizeof(menuList));
	menuList.iTotalNum = 2;
	strcpy(menuList.acTitle, "审核权限设置->二级审核");
	strcpy(menuList.menuItem[0], "审核金额设置");
	strcpy(menuList.menuItem[1], "操作员权限设置");
	
	iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
	if(iRet)
		return -1;

    if (iSelect == 1)
    { 
       wrLog("二级审核金额设置");
       xjx_setcheckamount_hdl(2, "二级审核金额设置");
       return 0;
    }
	else if (iSelect == 2)
	{
	   wrLog("操作员权限设置");
       memset(&menuList,0,sizeof(menuList));
	   menuList.iTotalNum = 2;
	   strcpy(menuList.acTitle, "二级审核->操作员权限设置");
	   strcpy(menuList.menuItem[0], "录入员");
	   strcpy(menuList.menuItem[1], "审核员");
	   
	   iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
	   if(iRet)
		   return -1;

	   xjx_setstaff_hdl(iSelect,2);
	}

    return 0;
}

//薪加薪三级审核设置
int CTrade::xjx_LLLcheckcfg_hdl(const char *title)
{
	int iRet,iSelect;
	TSMENULIST menuList;
	
	memset(&menuList,0,sizeof(menuList));
	menuList.iTotalNum = 2;
	strcpy(menuList.acTitle, "审核权限设置->三级审核");
	strcpy(menuList.menuItem[0], "审核金额设置");
	strcpy(menuList.menuItem[1], "操作员权限设置");
	
	iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
	if(iRet)
		return -1;
	
    if (iSelect == 1)
    { 
		wrLog("三级审核金额设置");
		xjx_setcheckamount_hdl(3, "三级审核金额设置");
		return 0;
    }
	else if (iSelect == 2)
	{
		wrLog("操作员权限设置");
		memset(&menuList,0,sizeof(menuList));
		menuList.iTotalNum = 3;
		strcpy(menuList.acTitle, "三级审核->操作员权限设置");
		strcpy(menuList.menuItem[0], "录入员");
		strcpy(menuList.menuItem[1], "一级审核员");
		strcpy(menuList.menuItem[2], "二级审核员");
		
		iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
		if(iRet)
			return -1;
		
		xjx_setstaff_hdl(iSelect,3);
	}

    return 0;
}

//设置审核金额	
int CTrade::xjx_setcheckamount_hdl(int ilevel, const char *title)
{
	int iSelect,iRet=0;
	char amount[12+1];
	char org_amount[12+1];
	char show_info[256];
	char cdate[20+1];
    TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;

	bbzero(show_info);
	if (ilevel == 2)
	{
		strcpy(show_info,"【设置说明】请输入二级审核适用的最大划拨金额，单位为元。超过二级审核的最大金额的资金划拨必须三级审核。\n\n");
	}
	else if (ilevel == 3)
	{
		strcpy(show_info,"【设置说明】请输入三级审核适用的最大划拨金额，单位为元。超过三级审核的最大金额的资金划拨将被拒绝交易。\n\n");
	}
    
	strcat(show_info,"\n\n\n\n【Enter】确认\t【Esc】返回\n");
    TS_OutPutMsg(gbl.dPosInfo, show_info, 0, iSelect);
    if (iSelect != 0)
        return -1;

	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));

	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	//划扣金额输入
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入审核金额：");	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_MONEY;	//全字符
	tradeInfoSend.Contents[0].uCount = 0;		//输入1次
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
	tradeInfoSend.Contents[0].uMinLen = 1;	
	tradeInfoSend.Contents[0].uMaxLen = 12;	

	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}

	bbzero(amount);
	bbzero(org_amount);
	strncpy(org_amount,(char *)tradeInfoRecv.Contents[0].uMsg,12);
	CTools::chgToMny(org_amount,amount,0);

	bbzero(cdate);
	SYSTEMTIME   systime;   
	::GetLocalTime(&systime);
	sprintf(cdate, "%04d年%d月%d日",systime.wYear, systime.wMonth, systime.wDay);

	bbzero(show_info);
	if (ilevel == 2)
	{
     	sprintf(show_info,"设置日期：%s\n二级审核最大金额为：%s元\n\n\n\n【Enter】确认\t【Esc】返回\n",cdate,amount);
	}
	else if (ilevel == 3)
	{
		sprintf(show_info,"设置日期：%s\n三级审核最大金额为：%s元\n\n\n\n【Enter】确认\t【Esc】返回\n",cdate,amount);
	}

	TS_OutPutMsg(gbl.dPosInfo, show_info, 0, iSelect);
    if (iSelect != 0)
        return -1;

	iRet = CDB::xjx_set_checkamount(ilevel,org_amount);
	if(iRet == -4)
	{
		TS_OutPutMsg(gbl.dPosInfo, "更新审核金额失败!", 0, iSelect);
		return iRet;
	}
	else if(iRet!=0)
	{
		
		TS_OutPutMsg(gbl.dPosInfo, "网络繁忙，更新出错!\n\n", 0, iSelect);
		return iRet;
	}
   
	TS_OutPutMsg(gbl.dPosInfo, "更新审核金额成功!\n按【Enter】或【Esc】返回", 0, iSelect);
	return 0;
}

//设置员工(包括录入员，审核员，二级审核员)
//iSelect - 所选菜单号
//ilevel  - 审核等级
int CTrade::xjx_setstaff_hdl(int iSelect,int ilevel)
{
	int iRet,menu_select;
	char tmp[512];
	char log_msg[64];
	char output_msg[512];
	char title[512];
	char cdate[20+1];
	char userid[6+1];
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;

	menu_select = iSelect;
	bbzero(log_msg);
	bbzero(output_msg);
	bbzero(title);
	switch(menu_select)
	{
	case 1:
		strcpy(log_msg,"设置录入员");
		strcpy(output_msg,"【设置说明】请输入录入员工号（工号为6位数字）。");
		if (ilevel == 2)
		{
			strcpy(title,"您的位置：二级审核->操作员权限设置->录入员");
		}
		else if (ilevel ==3)
		{
			strcpy(title,"您的位置：三级级审核->操作员权限设置->录入员");
		}
		break;
	case 2:
		if (ilevel == 2)
		{
		   strcpy(log_msg,"设置审核员");
		   strcpy(output_msg,"【设置说明】请输入审核员工号（工号为6位数字），审核员不能与录入员为同一人。");
		   strcpy(title,"您的位置：二级审核->操作员权限设置->审核员");
		}
		else if (ilevel ==3)
		{
		   strcpy(log_msg,"设置一级审核员");
		   strcpy(output_msg,"【设置说明】请输入一级审核员工号（工号为6位数字），一级审核员不能与录入员，二级审核员为同一人。");
		   strcpy(title,"您的位置：三级审核->操作员权限设置->一级审核员");			
		}
		break;
	case 3:
		strcpy(log_msg,"设置二级审核员");
		strcpy(output_msg,"【设置说明】请输入二级审核员工号（工号为6位数字），二级审核员不能与录入员，一级审核员为同一人。");
		strcpy(title,"您的位置：三级审核->操作员权限设置->二级审核员");	
		break;
	default:
		break;
	}

    wrLog(log_msg);
    strcat(output_msg,"\n\n\n\n\n【Enter】进入设置\t【Esc】返回\n");
    TS_OutPutMsg(gbl.dPosInfo, output_msg, 0, iSelect);
	if (iSelect != 0)
		return -1;

	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));

	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	//员工编号输入
	strcpy(tradeInfoSend.Contents[0].acTitle,title);	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
	tradeInfoSend.Contents[0].uCount = 0;		//输入1次
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
	tradeInfoSend.Contents[0].uMinLen = 6;	
	tradeInfoSend.Contents[0].uMaxLen = 6;	

	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}

	bbzero(userid);
	strncpy(userid,(char *)tradeInfoRecv.Contents[0].uMsg,6);

	bbzero(cdate);
	SYSTEMTIME   systime;   
	::GetLocalTime(&systime);
	sprintf(cdate, "%04d年%d月%d日",systime.wYear, systime.wMonth, systime.wDay);

	strcpy(output_msg,title);

	bbzero(tmp);
	sprintf(tmp,"\n设置日期：%s\n%s为：%s",cdate,title+36,userid);
	strcat(output_msg,tmp);
    strcat(output_msg,"\n\n\n\n【Enter】确认\t【Esc】返回");

	TS_OutPutMsg(gbl.dPosInfo, output_msg, 0, iSelect);
	if (iSelect != 0)
		return -1;

	//更新user表
    iRet = CDB::xjx_update_staff(menu_select,userid);
	if(iRet == -4)
	{
		TS_OutPutMsg(gbl.dPosInfo, "更新员工设置失败!", 0, iSelect);
		return iRet;
	}
	else if(iRet!=0)
	{
		TS_OutPutMsg(gbl.dPosInfo, "网络繁忙，更新出错!\n\n", 0, iSelect);
		return iRet;
	}
	
	TS_OutPutMsg(gbl.dPosInfo, "更新员工设置成功!\n按【Enter】或【Esc】返回", 0, iSelect);

	return 0;
}


//设置划拨账号
//flag: 0 - 设置划出账号；1 - 设置汇入账号 
int CTrade::xjx_accountcfg_hdl(int flag,const char *title)
{
	int iRet,iSelect;
	char input_title[512],out_msg[512];
	char account[30], account_name[20], account_bank[30];
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;

	bbzero(input_title);
	switch(flag)
	{
	case 0:
		strcpy(input_title,"请输入资金划出账号:");
		break;
	case 1:
		strcpy(input_title,"请输入资金汇入账号:");
		break;
	default:
		break;
	}

	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));

	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	//账号输入
	strcpy(tradeInfoSend.Contents[0].acTitle,input_title);	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
	tradeInfoSend.Contents[0].uCount = 0;		//输入1次
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
	tradeInfoSend.Contents[0].uMinLen = 1;	
	tradeInfoSend.Contents[0].uMaxLen = 30;	

	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	
	bbzero(account);
	strncpy(account,(char *)tradeInfoRecv.Contents[0].uMsg,tradeInfoRecv.Contents[0].uMsgLen);

	iRet = CDB::xjx_check_account(account,account_name,account_bank);
    if(iRet < 0)
	{
		TS_OutPutMsg(gbl.dPosInfo, "网络繁忙，查询出错!\n\n", 0, iSelect);
		return iRet;
	}
	else if(iRet == 2)//账号未录入数据库，输入账号详细信息录入数据库
	{
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents = 2;
		//账户名输入
		strcpy(tradeInfoSend.Contents[0].acTitle,"请输入账户名：");	
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//全字符
		tradeInfoSend.Contents[0].uCount = 0;		//输入1次
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
		tradeInfoSend.Contents[0].uMinLen = 1;	
	    tradeInfoSend.Contents[0].uMaxLen = 20;	

		//开户行输入
		strcpy(tradeInfoSend.Contents[1].acTitle,"请输入开户行：");	
		tradeInfoSend.Contents[1].uCommand = TS_INPUT_ALL_CHAR;	//全字符
		tradeInfoSend.Contents[1].uCount = 0;		//输入1次
		tradeInfoSend.Contents[1].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
		tradeInfoSend.Contents[1].uMinLen = 1;	
	    tradeInfoSend.Contents[1].uMaxLen = 30;	

		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		if(iRet != 0)
		{
			wrLog("TS_TradeControl返回错误[%d]", iRet);
			wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
			return iRet;
		}

		bbzero(account_name);
		bbzero(account_bank);
		strncpy(account_name,(char *)tradeInfoRecv.Contents[0].uMsg,tradeInfoRecv.Contents[0].uMsgLen);
		strncpy(account_bank,(char *)tradeInfoRecv.Contents[1].uMsg,tradeInfoRecv.Contents[1].uMsgLen);

		iRet = CDB::xjx_add_account(account,account_name,account_bank);
		if(iRet < 0)
		{
			TS_OutPutMsg(gbl.dPosInfo, "网络繁忙，插入出错!\n\n", 0, iSelect);
			return iRet;
		}
	}

	bbzero(out_msg);
	sprintf(out_msg,"账号：%s\n账户名：%s\n开户行：%s\n\n\n\n\n【Enter】确认\t【Esc】返回\n",account,account_name,account_bank);
	iRet = TS_OutPutMsg(gbl.dPosInfo,out_msg, 0, iSelect);
    if (iSelect != 0)
    {
		return -1;
    }

	iRet = CDB::xjx_set_account(flag,account);
	if(iRet < 0)
	{
		TS_OutPutMsg(gbl.dPosInfo, "网络繁忙，更新出错!\n\n", 0, iSelect);
		return iRet;
	}

	bbzero(out_msg);
	sprintf(out_msg,"划拨账号设置成功！\n按【Enter】或【Esc】返回");
	iRet = TS_OutPutMsg(gbl.dPosInfo,out_msg, 0, iSelect);

    return 0;
}


//审核设置查询
//iType: 0 - 二级审核查询；1 - 三级审核查询；
int CTrade::xjx_checkconfig_InqHdl(int iType,char *title)
{
	int iRet,iSelect;
	char checker_id[6+1];
	char tmp_amo[12+1];
	char check_amount[12+1];
	char term_id[8+1];
    char out_msg[256];
	
	iRet = CDB::xjx_get_checkconfig(iType,checker_id,tmp_amo,term_id);
	if(iRet < 0)
	{
		TS_OutPutMsg(gbl.dPosInfo, "网络繁忙，查询出错!\n\n", 0, iSelect);
		return iRet;
	}

	bbzero(check_amount);
	CTools::chgToMny(tmp_amo,check_amount,1);

	bbzero(out_msg);
	switch(iType)
	{
	case 0:
		sprintf(out_msg,"审核员工号：%s\n二级审核金额上限：%s\n终端号：%s\n\n\n\n按【Enter】或【Esc】返回\n",checker_id,check_amount,term_id);
		break;
	case 1:
		sprintf(out_msg,"二级审核员工号：%s\n三级审核金额上限：%s\n终端号：%s\n\n\n\n按【Enter】或【Esc】返回\n",checker_id,check_amount,term_id);
		break;
	default:
		break;
	}

	TS_OutPutMsg(gbl.dPosInfo,out_msg, 0, iSelect);
    
	return 0;
}

//划拨账号设置查询
//iType: 0 - 划出账号查询；1 - 汇入账号查询；
int CTrade::xjx_accountconfig_InqHdl(int iType,char *title)
{
	int iRet,iSelect;
    char account[30+1];
	char account_name[20+1];
	char account_bank[50+1];
    char out_msg[256];
	
	iRet = CDB::xjx_get_accountconfig(iType, account, account_name, account_bank);
	if(iRet < 0)
	{
		TS_OutPutMsg(gbl.dPosInfo, "网络繁忙，查询出错!\n\n", 0, iSelect);
		return iRet;
	}

	bbzero(out_msg);
	switch(iType)
	{
	case 0:
		sprintf(out_msg,"划出账号：%s\n账户名：%s\n开户行：%s\n\n\n\n按【Enter】或【Esc】返回\n",account,account_name,account_bank);
		break;
	case 1:
		sprintf(out_msg,"汇入账号：%s\n账户名：%s\n开户行：%s\n\n\n\n按【Enter】或【Esc】返回\n",account,account_name,account_bank);
		break;
	default:
		break;
	}
	
	TS_OutPutMsg(gbl.dPosInfo,out_msg, 0, iSelect);

	return 0;
}


//薪加薪资金划拨录入
int CTrade::xjx_funds_transferhdl(const char *title)
{
	int iSelect,iRet=0;
	char tmp[512],tmpMny[12],tDate[20];
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	char out_bank[50+1];//划出账号开户行
	char in_bank[50+1];//汇入账号开户行
	
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 2;
	//划扣金额输入
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入划扣金额：");	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_MONEY;	//全字符
	tradeInfoSend.Contents[0].uCount = 0;		//输入1次
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
	tradeInfoSend.Contents[0].uMinLen = 1;	
	tradeInfoSend.Contents[0].uMaxLen = 12;	
	
	//摘要输入
	strcpy(tradeInfoSend.Contents[1].acTitle, "摘要：");	
	tradeInfoSend.Contents[1].uCommand = TS_INPUT_ALL_CHAR;	
	tradeInfoSend.Contents[1].uCount = 0;		//输入1次
	tradeInfoSend.Contents[1].uTimeOut = EPOS_OVER_TIME+10;	//超时40秒
	tradeInfoSend.Contents[1].uMinLen = 0;	
	tradeInfoSend.Contents[1].uMaxLen = 50;	
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
    
	bbzero(gbl.pos_serial);
	strcpy(gbl.pos_serial, (char *)tradeInfoRecv.uTradeID);//流水号

	bbzero(gbl.out_account);  //转出账号
	bbzero(gbl.payer_info);   //付款方信息
	iRet = CDB::xjx_get_accountconfig(0, gbl.out_account, gbl.payer_info, out_bank);
	if(iRet < 0)
	{
		TS_OutPutMsg(gbl.dPosInfo, "网络繁忙，查询出错!\n\n", 0, iSelect);
		return iRet;
	}

	bbzero(gbl.in_account);   //转入账号
	bbzero(gbl.payee_info);   //收款方信息
	iRet = CDB::xjx_get_accountconfig(1, gbl.in_account, gbl.payee_info, in_bank);
	if(iRet < 0)
	{
		TS_OutPutMsg(gbl.dPosInfo, "网络繁忙，查询出错!\n\n", 0, iSelect);
		return iRet;
	}

	bbzero(gbl.bank);
	strcpy(gbl.bank,"687810");
	//bbzero(gbl.card_no);
	//strcpy(gbl.card_no,"5201521211666000");
    //strcpy(gbl.out_account,gbl.card_no);

	//strcpy(gbl.in_account,gbl.card_no);
	//strcpy(gbl.in_account,"1088103004028024");


	

	//strcpy(gbl.payee_info," ");
    
//	bbzero(gbl.xjx_phone_no);   //电话号码
	//strcpy(gbl.xjx_phone_no," ");
	
	bbzero(gbl.amount);
	memset(tmpMny,0,sizeof(tmpMny));
	CTools::chgToMny((char *)tradeInfoRecv.Contents[0].uMsg,tmpMny);
	strcpy(gbl.amount,(char *)tradeInfoRecv.Contents[0].uMsg);
	
	bbzero(gbl.abstract);     //摘要
	strcpy(gbl.abstract,(char *)tradeInfoRecv.Contents[1].uMsg);
	
	wrLog("gbl.amount: %s",gbl.amount);
	wrLog("划扣金额：%s",tmpMny); //划扣金额
	
	wrLog("gbl.abstract: %s",gbl.abstract);//摘要
	
	bbzero(tDate);
    bbzero(tmp);
	//获取系统日期
	SYSTEMTIME   systime;   
	::GetLocalTime(&systime);
	sprintf(tDate, "%04d-%02d-%d",systime.wYear, systime.wMonth, systime.wDay);
	
	sprintf(tmp, "\n\n交易日期：%s\n\n划扣金额：%s\n\n摘    要：%s\n\n付款方信息：%s\n\n收款方信息：%s\n\n\n\n【Enter】确认        【Esc】返回",tDate,tmpMny,gbl.abstract,gbl.payer_info,gbl.payee_info);
    iRet = TS_OutPutMsg(gbl.dPosInfo,tmp, 0, iSelect);
	
	if(iRet!=0 || iSelect==0) 
	{
		iRet = CDB::setXjxTxn(gbl);
		if(iRet == -4)
		{
			TS_OutPutMsg(gbl.dPosInfo, "插入交易记录失败!", 0, iSelect);
			return iRet;
		}
		else if(iRet!=0)
		{
			
			TS_OutPutMsg(gbl.dPosInfo, "网络繁忙，插入出错!\n\n!", 0, iSelect);
			return iRet;
		}

        bbzero(tmp);
		sprintf(tmp, "录入成功。\n\n流水号：%s\n\n录入日期：%s\n\n划扣金额：%s\n\n摘    要：%s\n\n付款方信息：%s\n\n收款方信息：%s\n\n\n\n【Enter】确认        【Esc】返回",gbl.pos_serial,tDate,tmpMny,gbl.abstract,gbl.payer_info,gbl.payee_info);
		iRet = TS_OutPutMsg(gbl.dPosInfo,tmp, 0, iSelect);

	}
 
    return -1;
}


//交易查询
int CTrade::xjx_txn_InqHdl(int flag,const char *title)
{
    int iSelect,iRet=0;
	char fromDate[20],toDate[20];
	TSTxnLogs txnLogs;
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	char selItemCont[30+1];
	char out_msg[1024];
	
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 2;
	//划扣金额输入
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入起止日期");	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_DATE;	//日期
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;//超时30秒
	
	strcpy(tradeInfoSend.Contents[1].acTitle, "至");
	tradeInfoSend.Contents[1].uCommand = TS_INPUT_DATE;	//日期
	tradeInfoSend.Contents[1].uTimeOut = EPOS_OVER_TIME;//超时30秒
	
    iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	
	bbzero(fromDate);
	memcpy(fromDate, (char *)tradeInfoRecv.Contents[0].uMsg, 10);
	strcat(fromDate,"000000");

	bbzero(toDate);
	memcpy(toDate, (char *)tradeInfoRecv.Contents[1].uMsg, 10);
	strcat(toDate,"235959");
	
	memset(&txnLogs, 0, sizeof(txnLogs));
	
	iRet =  CDB::getXjxTxn(flag,fromDate,toDate,&txnLogs);
	if(iRet == -4)
	{
		TS_OutPutMsg(gbl.dPosInfo, "没有相关交易记录!", 0, iSelect);
		return iRet;
	}
	else if(iRet!=0)
	{
		
		TS_OutPutMsg(gbl.dPosInfo, "网络繁忙，查找出错!\n\n请稍后再查!", 0, iSelect);
		return iRet;
	}
	
	while (1)
	{
		iRet = TS_ShowTxnLogs(gbl.dPosInfo, &txnLogs);
		if(iRet != 0)
		{
			wrLog("TS_ShowTxnLogs返回错误[%d]", iRet);
			return iRet;
		}

        //加密改造时屏蔽 // 2012-09-06
/*
		bbzero(selItemCont);
	//	iRet = TS_GetSelItemCont(gbl.dPosInfo,selItemCont,0);
		if(iRet < 0)
		{
			wrLog("TS_GetSelItemCont返回错误[%d]", iRet);
			return iRet;
		}
*/
		//0x02
        if (selItemCont == NULL)
		{
			continue;
        }

		bbzero(gbl.xjx_seq);
		strncpy(gbl.xjx_seq,selItemCont,10);
		iRet =  CDB::xjx_gettxnfromSeq(&gbl);
		if(iRet == -4)
		{
			TS_OutPutMsg(gbl.dPosInfo, "没有相关交易记录!", 0, iSelect);
			return iRet;
		}
		else if(iRet!=0)
		{
			
			TS_OutPutMsg(gbl.dPosInfo, "网络繁忙，查找出错!\n\n请稍后再查!", 0, iSelect);
			return iRet;
		}

		char tmp_amo[12+1];
		bbzero(tmp_amo);
		CTools::chgToMny(gbl.amount,tmp_amo,1);
 		bbzero(out_msg);
		if (strcmp(gbl.status_info,"交易失败") != 0)
		{
			sprintf(out_msg,"序号：%s\n流水号：%s\n交易状态：%s\n到账日期/时间：%s\n划扣金额：%s\n摘要：%s\n付款方信息：%s\n收款方信息：%s\n",\
				selItemCont,gbl.xjx_stan,gbl.status_info,gbl.txn_datetime,tmp_amo,gbl.abstract,gbl.payer_info,gbl.payee_info);
		}
		sprintf(out_msg,"序号：%s\n流水号：%s\n交易状态：%s\n失败原因：%s\n到账日期/时间：%s\n划扣金额：%s\n摘要：%s\n付款方信息：%s\n收款方信息：%s\n",\
			selItemCont,gbl.xjx_stan,gbl.status_info,gbl.xjx_rspcode,gbl.txn_datetime,tmp_amo,gbl.abstract,gbl.payer_info,gbl.payee_info);
       
		strcat(out_msg,"【Enter】返回列表\t\t【Esc】返回主菜单");
		iRet = TS_OutPutMsg(gbl.dPosInfo, out_msg, 0, iSelect);
		if (iSelect != 0)
		{
            break;
		}
	}

	return 0;
}


//修改密码
//iuserType: 0 - 管理员；1 - 录入员；2 - 审核员；3 - 二级审核员
int CTrade::xjx_updatepwd_Hdl(int iuserType,char *title)
{
	int iSelect,iRet;
	char db_pwd[6+1];
	char org_pwd[6+1];
	char new_pwd[6+1];
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
    char input_title[30];

	bbzero(input_title);
	switch(iuserType)
	{
	case 0:
		strcpy(input_title,"请输入管理员密码：");
		break;
	case 1:
		strcpy(input_title,"请输入录入密码：");
		break;
	case 2:
		strcpy(input_title,"请输入审核密码：");
		break;
	case 3:
		strcpy(input_title,"请输入二级审核密码：");
		break;
	default:
		strcpy(input_title,"请输入密码：");
		break;
	}

	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));

	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	//原密码输入
	strcpy(tradeInfoSend.Contents[0].acTitle, input_title);	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_PWD;//明文密码
	tradeInfoSend.Contents[0].uDesMode = TS_NO_ENC;//不加密
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;//超时30秒
	tradeInfoSend.Contents[0].uMinLen = 6;
	tradeInfoSend.Contents[0].uMaxLen = 6;

	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	
	bbzero(org_pwd);
	memcpy(org_pwd, (char *)tradeInfoRecv.Contents[0].uMsg, 6);

	//校验旧密码
	iRet = CDB::xjx_get_password(iuserType,gbl.dPosInfo.pos_no,db_pwd);
	if(iRet == -4)
	{
		TS_OutPutMsg(gbl.dPosInfo, "查询失败!", 0, iSelect);
		return iRet;
	}
	else if(iRet!=0)
	{
		
		TS_OutPutMsg(gbl.dPosInfo, "网络繁忙，查询出错!\n\n", 0, iSelect);
		return iRet;
	}
	
	if (strncmp(org_pwd,db_pwd,6) != 0)
	{
		TS_OutPutMsg(gbl.dPosInfo, "密码错误，请重新输入!\n\n", 0, iSelect);
		xjx_updatepwd_Hdl(iuserType,"薪加薪资金划拨密码修改");
	}

	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));

	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	//新密码输入
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入新密码：");	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_PWD;//明文密码
	tradeInfoSend.Contents[0].uDesMode = TS_NO_ENC;//不加密
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;//超时30秒
	tradeInfoSend.Contents[0].uCount = 1;//输入两次
	tradeInfoSend.Contents[0].uMinLen = 6;
	tradeInfoSend.Contents[0].uMaxLen = 6;

	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}

	bbzero(new_pwd);
	memcpy(new_pwd, (char *)tradeInfoRecv.Contents[0].uMsg, 6);

	iRet = CDB::xjx_upd_password(iuserType,new_pwd);
	if(iRet == -4)
	{
		TS_OutPutMsg(gbl.dPosInfo, "更新失败!", 0, iSelect);
		return iRet;
	}
	else if(iRet!=0)
	{
		
		TS_OutPutMsg(gbl.dPosInfo, "网络繁忙，查询出错!\n\n", 0, iSelect);
		return iRet;
	}

    TS_OutPutMsg(gbl.dPosInfo, "修改密码成功!\n\n\n\n按【Enter】或【Esc】返回\n", 0, iSelect);
	return 0;
}

//审核薪加薪资金划拨
int CTrade::xjx_txn_checkHdl(const char *title)
{   
    int iSelect,iRet=0;
	int b48_len;
	char msg[200],response_code[3],tmp[1024];
    char audit_pwd[6+1];
	char db_pwd[6+1];
	char selItemCont[30+1];
	char out_msg[1024];
	char not_passreason[50+1];//不通过理由
	char status[2+1];//交易状态
	char checker_id[6+1];
	char LLcheck_amo[12+1];
	char term_id[8+1];
	char xjx_seq[10+1];
    int b2_len;

	 char ID_Type[3];//证件类型
     char ID_NUM[20];//证件号码
	 char account_name[20];//银行帐号户名
	 char acc_area[10];//帐号归属地
	 char party_code[7];//银行帐号所属银行代码
	 char bank_info[50];//开户行信息
	 char credit_flag[2];//信用卡标识
	 char tel_num[20];//联系号码
	 char address[50];//联系地址
	 char credit_validate[10];//信用卡有效期
	 char credit_verificode[20];//信用卡验证码
	 char tempstr[256];

	TSTxnLogs txnLogs;
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	//密码输入
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入审核密码");	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_PWD;//明文密码
	tradeInfoSend.Contents[0].uDesMode = TS_NO_ENC;//不加密
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;//超时30秒
	tradeInfoSend.Contents[0].uMinLen = 6;
	tradeInfoSend.Contents[0].uMaxLen = 6;

	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}

	bbzero(audit_pwd);
	memcpy(audit_pwd, (char *)tradeInfoRecv.Contents[0].uMsg, 6);
	
	//校验审核密码
	iRet = CDB::xjx_get_password(2,gbl.dPosInfo.pos_no,db_pwd);
	if(iRet == -4)
	{
		TS_OutPutMsg(gbl.dPosInfo, "查询失败!", 0, iSelect);
		return iRet;
	}
	else if(iRet!=0)
	{
		
		TS_OutPutMsg(gbl.dPosInfo, "网络繁忙，查询出错!\n\n", 0, iSelect);
		return iRet;
	}
	
	if (strncmp(audit_pwd,db_pwd,6) != 0)
	{
		TS_OutPutMsg(gbl.dPosInfo, "密码错误，请重新输入!\n\n", 0, iSelect);
		xjx_txn_checkHdl("薪加薪资金划拨审核");
	}

    char level[2+1];

	iRet = CDB::xjx_get_CheckLevel(gbl.dPosInfo.pos_no,level);
	if(iRet == -4)
	{
		TS_OutPutMsg(gbl.dPosInfo, "查询失败!", 0, iSelect);
		return iRet;
	}
	else if(iRet!=0)
	{
		
		TS_OutPutMsg(gbl.dPosInfo, "网络繁忙，查询出错!\n\n", 0, iSelect);
		return iRet;
	}

	/************************************************************************/

	while (1)
	{
		memset(&txnLogs, 0, sizeof(txnLogs));
		
		iRet =  CDB::xjx_get_UncheckTxnLogs(atoi(level),&txnLogs);
		if(iRet == -4)
		{
			TS_OutPutMsg(gbl.dPosInfo, "没有相关交易记录!", 0, iSelect);
			return iRet;
		}
		else if(iRet!=0)
		{
			TS_OutPutMsg(gbl.dPosInfo, "网络繁忙，查找出错!\n\n请稍后再查!", 0, iSelect);
			return iRet;
		}

		iRet = TS_ShowTxnLogs(gbl.dPosInfo, &txnLogs);
		if(iRet != 0)
		{
			wrLog("TS_ShowTxnLogs返回错误[%d]", iRet);
			return iRet;
		}

		//加密改造时屏蔽 // 2012-09-06
/*
		bbzero(selItemCont);
//		iRet = TS_GetSelItemCont(gbl.dPosInfo,selItemCont,0);
		if(iRet < 0)
		{
			wrLog("TS_GetSelItemCont返回错误[%d]", iRet);
			return iRet;
		}
*/
        
        if (strcmp(selItemCont,"\x02") == 0)
		{
			break;
        }
		
		bbzero(gbl.xjx_seq);
		strncpy(gbl.xjx_seq,selItemCont,10);
		iRet =  CDB::xjx_gettxnfromSeq(&gbl);
		if(iRet == -4)
		{
			TS_OutPutMsg(gbl.dPosInfo, "没有相关交易记录!", 0, iSelect);
			return iRet;
		}
		else if(iRet!=0)
		{
			TS_OutPutMsg(gbl.dPosInfo, "网络繁忙，查找出错!\n\n请稍后再查!", 0, iSelect);
			return iRet;
		}
		
		char tmp_amo[12+1];
		bbzero(tmp_amo);
		CTools::chgToMny(gbl.amount,tmp_amo,1);

		bbzero(out_msg);
		sprintf(out_msg,"序号：%s\n流水号：%s\n划扣金额：%s\n录入日期：%s\n摘要：%s\n付款方信息：%s\n收款方信息：%s\n",\
			gbl.xjx_seq,gbl.xjx_stan,tmp_amo,gbl.txn_datetime,gbl.abstract,gbl.payer_info,gbl.payee_info);

		strcat(out_msg,"【业务说明】请仔细核对资金划拨信息。\n【Y】通过     【N】不通过     【Esc】返回");

		iRet = TS_OutPutMsg(gbl.dPosInfo, out_msg, 0, iSelect);
		if (iSelect == 3)
		{
            //更新状态并写不通过理由
			memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
			memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
			
			tradeInfoSend.uHasTradeID = 1;
			tradeInfoSend.uTotalContents = 1;
			//不通过理由输入
			strcpy(tradeInfoSend.Contents[0].acTitle, "请输入不通过理由");	
			tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;//全字符
			tradeInfoSend.Contents[0].uDesMode = TS_NO_ENC;//不加密
			tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME+10;//超时40秒
			tradeInfoSend.Contents[0].uMinLen = 0;
			tradeInfoSend.Contents[0].uMaxLen = 50;
			
			iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
			if(iRet != 0)
			{
				wrLog("TS_TradeControl返回错误[%d]", iRet);
				wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
				return iRet;
			}

			bbzero(not_passreason);
			strcpy(not_passreason, (char *)tradeInfoRecv.Contents[0].uMsg);

			bbzero(status);
			if (atoi(level) == 2)
			{
                strcpy(status,"4");
			}
			if (atoi(level) == 3)
			{
				strcpy(status,"6");
			}

			iRet = CDB::xjx_update_checkstatus(gbl.xjx_seq,level,status,gbl.dPosInfo.pos_no,not_passreason);
			if(iRet == -4)
			{
				TS_OutPutMsg(gbl.dPosInfo, "更新审核状态失败!", 0, iSelect);
				return iRet;
			}
			else if(iRet!=0)
			{

				TS_OutPutMsg(gbl.dPosInfo, "网络繁忙，更新审核状态出错!\n\n", 0, iSelect);
				return iRet;
			}		
			
			bbzero(msg);
			sprintf(msg, "审核不通过。\n不通过理由：%s\n序号：%s\n流水号：%s\n划扣金额：%s\n交易日期：%s\n摘    要：%s\n付款方信息：%s\n收款方信息：%s\n【Enter】继续审核 \t按【Esc】返回",\
				not_passreason,gbl.xjx_seq,gbl.xjx_stan,tmp_amo,gbl.txn_datetime,gbl.abstract,gbl.payer_info,gbl.payee_info);
			
			iRet = TS_OutPutMsg(gbl.dPosInfo, msg, 0, iSelect);
			if(iSelect)
			{
				break;
			}
			continue;
		}
		else if (iSelect == 1)
		{
			continue;
		}

		iRet = CDB::xjx_get_checkconfig(2,checker_id,LLcheck_amo,term_id);
		if(iRet < 0)
		{
			TS_OutPutMsg(gbl.dPosInfo, "网络繁忙，查询出错!\n\n", 0, iSelect);
			return iRet;
		}

		if (atoi(level) == 2 && atoi(gbl.amount) > atoi(LLcheck_amo))//大于二级审核金额上限
		{
			strcpy(status,"3");
			iRet = CDB::xjx_update_checkstatus(gbl.xjx_seq,level,status,gbl.dPosInfo.pos_no,not_passreason);
			if(iRet == -4)
			{
				TS_OutPutMsg(gbl.dPosInfo, "更新审核状态失败!", 0, iSelect);
				return iRet;
			}
			else if(iRet!=0)
			{
				
				TS_OutPutMsg(gbl.dPosInfo, "网络繁忙，查询出错!\n\n", 0, iSelect);
				return iRet;
			}
			
			bbzero(msg);
			sprintf(msg, "二级审核通过。\n序号：%s\n流水号：%s\n划扣金额：%s\n交易日期：%s\n摘    要：%s\n付款方信息：%s\n收款方信息：%s\n【Enter】继续审核 \t按【Esc】返回",\
				gbl.xjx_seq,gbl.xjx_stan,tmp_amo,gbl.txn_datetime,gbl.abstract,gbl.payer_info,gbl.payee_info);
			
			iRet = TS_OutPutMsg(gbl.dPosInfo, msg, 0, iSelect);
			if(iSelect)
			{
				break;
			}
			continue;
		}

		/*******************************发起交易*********************************/
		    bbzero(gbl.card_no);		
	        strcpy(gbl.card_no,"5201521211666000");
		
	        TS_SetCardNum(&gbl.dPosInfo, "5201521211666000", (int)gbl.posInfo.inType);

			 
            /***************修改2域********************/
            bbzero(pack.FIELD2);
			bbzero(tmp);
			/*
			sprintf(tmp,"%02d",strlen(gbl.out_account));
			memcpy(pack.FIELD2,tmp,2); //转入账号长度
			b2_len = 2;*/

			memcpy(pack.FIELD2,gbl.out_account,strlen(gbl.out_account)); //转入账号
			b2_len = strlen(gbl.out_account);
			
			pack.Packet_Table[2].Real_Length=b2_len;
			/******************************************/


            pack.wrField(2, gbl);	//写交费域


			/***************修改46域******************/
			bbzero(pack.FIELD46);
			memcpy(pack.FIELD46,"2",1);
			pack.Packet_Table[46].Real_Length=1;
			/*****************************************/

			/***************修改48域****************/
			bbzero(pack.FIELD48);
			memcpy(pack.FIELD48,gbl.fee_type,4);//收费种类(4)
			b48_len = 4;
			
			bbzero(tmp);
			sprintf(tmp,"%02d",strlen(selItemCont));
			memcpy(pack.FIELD48+b48_len,tmp,2); //发起方流水号长度
			b48_len+=2;
			
			memcpy(pack.FIELD48 + b48_len, selItemCont, strlen(selItemCont));	//发起方流水号
			b48_len +=strlen(selItemCont);
			
			pack.Packet_Table[48].Real_Length=b48_len;
			/*****************************************/

			/***************修改63域****************/
			bbzero(pack.FIELD63);
			bbzero(tmp);
            //sprintf(tmp,"%s",gbl.abstract);

			//test 20120206
			bbzero(ID_Type);
			bbzero(ID_NUM);
			bbzero(account_name);
            bbzero(acc_area);
			bbzero(party_code);
            bbzero(bank_info);
			bbzero(credit_flag);
			bbzero(tel_num);
			bbzero(address);
			bbzero(credit_validate);
			bbzero(credit_verificode);
			
            strcpy(ID_Type,"00");
			strcpy(ID_NUM,"0123456789");
			strcpy(account_name,"test");
			strcpy(acc_area,"Guangzhou");
			strcpy(party_code,"68");
            strcpy(bank_info,"广东发展银行");
            strcpy(credit_flag,"0");
            strcpy(tel_num,"0123456789");
			strcpy(address,"广州");
            strcpy(credit_validate,"20120206");
			strcpy(credit_verificode,"ABCDEFGH");

			bbzero(tempstr);
			sprintf(tempstr,"%02d%s",strlen(gbl.out_account),gbl.out_account);
			strncat(tmp,tempstr,strlen(tempstr));

			bbzero(tempstr);
			sprintf(tempstr,"%02d%s",strlen(gbl.in_account),gbl.in_account);
			strncat(tmp,tempstr,strlen(tempstr));

			bbzero(tempstr);
			sprintf(tempstr,"%02d%s",strlen(account_name),account_name);
			strncat(tmp,tempstr,strlen(tempstr));

			bbzero(tempstr);
			sprintf(tempstr,"%02d%s",strlen("68"),"68");
			strncat(tmp,tempstr,strlen(tempstr));

			bbzero(tempstr);
			sprintf(tempstr,"%02d%s",strlen("0"),"0");
			strncat(tmp,tempstr,strlen(tempstr));

			bbzero(tempstr);
			sprintf(tempstr,"%02d%s",strlen(gbl.abstract),gbl.abstract);
			strncat(tmp,tempstr,strlen(tempstr));
            //end test

			memcpy(pack.FIELD63,tmp,strlen(tmp)); //63域		
			pack.Packet_Table[63].Real_Length=strlen(tmp);
			/*****************************************/
			
			//打包，发包，收包
			iRet = packHdl(2);

			bbzero(gbl.xjx_stan);
			memcpy(gbl.xjx_stan,(char *)pack.FIELD37,12);

			memset(response_code,0,sizeof(response_code));
			memcpy(response_code,pack.FIELD39,2);
			wrLog("response_code:%s",response_code);

// 			if(iRet != 0xfffffff)
// 			{
// 				//更新交易记录状态
// 				iRet = CDB::updateXjxTxnStatus(1,xjx_seq);
// 				if(iRet)
// 				{
// 					TS_OutPutMsg(gbl.dPosInfo, "更新状态出错\n请稍候再试!", 0, iSelect);
// 					return -1;
// 				}
// 				
// 				iRet = CDB::xjx_update_checkstatus(xjx_seq,level,"1",gbl.dPosInfo.pos_no,not_passreason);
// 				if(iRet == -4)
// 				{
// 					TS_OutPutMsg(gbl.dPosInfo, "更新失败!", 0, iSelect);
// 					return iRet;
// 				}
// 				else if(iRet!=0)
// 				{
// 					
// 					TS_OutPutMsg(gbl.dPosInfo, "网络繁忙，查询出错!\n\n", 0, iSelect);
// 					return iRet;
// 				}
// 
// 				//更新系统参考号，响应码
// 				if(CDB::updXjxStanRspcode(xjx_seq,response_code,gbl.xjx_stan))
// 				{
// 					TS_OutPutMsg(gbl.dPosInfo, "更新系统参考号和响应码出错\n请稍候再试!", 0, iSelect);
// 					return -1;
// 				}
// 				return -1;
// 			}

			//更新系统参考号，响应码
			if(CDB::updXjxStanRspcode(gbl.xjx_seq,response_code,gbl.xjx_stan))
			{
				TS_OutPutMsg(gbl.dPosInfo, "更新系统参考号和响应码出错\n请稍候再试!", 0, iSelect);
				return -1;
			}

			if (!memcmp(response_code,"00",2)) //如果交易成功	
			{
				//更新交易记录状态
				iRet = CDB::updateXjxTxnStatus(0,gbl.xjx_seq);
				if(iRet)
				{
					TS_OutPutMsg(gbl.dPosInfo, "更新状态出错\n请稍候再试!", 0, iSelect);
					return -1;
				}
				else
				{
					iRet = CDB::xjx_update_checkstatus(xjx_seq,level,"0",gbl.dPosInfo.pos_no,not_passreason);
					if(iRet == -4)
					{
						TS_OutPutMsg(gbl.dPosInfo, "更新失败!", 0, iSelect);
						return iRet;
					}
					else if(iRet!=0)
					{	
						TS_OutPutMsg(gbl.dPosInfo, "网络繁忙，查询出错!\n\n", 0, iSelect);
						return iRet;
					}

					bbzero(msg);
					sprintf(msg, "审核通过，交易成功。\n序号：%s\n流水号：%s\n划扣金额：%s\n交易日期：%s\n摘    要：%s\n付款方信息：%s\n收款方信息：%s\n【Enter】继续审核 \t按【Esc】返回",\
						gbl.xjx_seq,gbl.xjx_stan,tmp_amo,gbl.txn_datetime,gbl.abstract,gbl.payer_info,gbl.payee_info);
					
					iRet = TS_OutPutMsg(gbl.dPosInfo, msg, 0, iSelect);
					if(iSelect)
					{
						break;
					}
// 				   bbzero(msg);
// 				   bbzero(amount);
// 				   CTools::chgToMny(gbl.amount,amount,1);
// 				   sprintf(msg, "薪加薪划账交易成功！\n\n银行监管账户：%s\n划账金额：%s\n账户余额：%s\n\n谢谢您的使用,是否打印发票\n 【是 Enter】  【否 Esc】",gbl.card_no,amount," ");
// 				   iRet = TS_OutPutMsg(gbl.dPosInfo, msg, 0, iSelect);
// 				   if(iRet!=0 || iSelect==0)
// 				   {
// 					CPrint prt;
// 					prt.set_in_par(gbl, pack);
// 					prt.print_detail(19, "薪加薪资金划拨发票");	//打印明细
// 				   }
				}
			}
			else	
			{
				//更新交易记录状态
				iRet = CDB::updateXjxTxnStatus(1,gbl.xjx_seq);
				if(iRet)
				{
					TS_OutPutMsg(gbl.dPosInfo, "更新状态出错\n请稍候再试!", 0, iSelect);
					return -1;
				}

				iRet = CDB::xjx_update_checkstatus(gbl.xjx_seq,level,"1",gbl.dPosInfo.pos_no,not_passreason);
				if(iRet == -4)
				{
					TS_OutPutMsg(gbl.dPosInfo, "更新失败!", 0, iSelect);
					return iRet;
				}
				else if(iRet!=0)
				{	
					TS_OutPutMsg(gbl.dPosInfo, "网络繁忙，查询出错!\n\n", 0, iSelect);
					return iRet;
				}

				returnFail(response_code);
				bbzero(msg);
				sprintf(msg, "审核通过，交易失败。\n序号：%s\n流水号：%s\n划扣金额：%s\n交易日期：%s\n摘    要：%s\n付款方信息：%s\n收款方信息：%s\n【Enter】继续审核 \t按【Esc】返回",\
					gbl.xjx_seq,gbl.xjx_stan,tmp_amo,gbl.txn_datetime,gbl.abstract,gbl.payer_info,gbl.payee_info);
						
				iRet = TS_OutPutMsg(gbl.dPosInfo, msg, 0, iSelect);
				if(iSelect)
				{
					break;
				}
			}
	}

	return 0;
}

int CTrade::xjx_pymreceived_InqHdl(const char *title)
{
    int iSelect = 0;
	int iRet=0;
	char msg[200],amoMny[12+1];
	char fromDate[20],toDate[20];
	TSTxnLogs txnLogs;

	memset(&txnLogs,0, sizeof(txnLogs));
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 2;
	//划扣金额输入
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入起止日期");	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_DATE;	//日期
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;//超时30秒
	
	strcpy(tradeInfoSend.Contents[1].acTitle, "至");
	tradeInfoSend.Contents[1].uCommand = TS_INPUT_DATE;	//日期
	tradeInfoSend.Contents[1].uTimeOut = EPOS_OVER_TIME;//超时30秒
	
    iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	
	bbzero(fromDate);
	strcpy(fromDate, (char *)tradeInfoRecv.Contents[0].uMsg);
	
	bbzero(toDate);
	strcpy(toDate, (char *)tradeInfoRecv.Contents[1].uMsg);
	
	memset(&txnLogs, 0, sizeof(txnLogs));
	
	iRet =  CDB::getXjxTxn(1,fromDate,toDate,&txnLogs);
	if(iRet == -4)
	{
		TS_OutPutMsg(gbl.dPosInfo, "没有相关交易记录!", 0, iSelect);
		return iRet;
	}
	else if(iRet!=0)
	{
		TS_OutPutMsg(gbl.dPosInfo, "网络繁忙，查找出错!\n\n请稍后再查!", 0, iSelect);
		return iRet;
	}
	
	iRet = TS_ShowTxnLogs(gbl.dPosInfo, &txnLogs);
	if(iRet != 0)
	{
		wrLog("TS_ShowTxnLogs返回错误[%d]", iRet);
		return iRet;
	}
	
	//显示详情
	if (iSelect == 0)
	{
       	//再次确认
		bbzero(msg);
		sprintf(msg, "流水号：%s     到账日期/时间：%s\n划扣金额：%s\n摘    要：%s\n收款方信息：%s\n\n【Esc】返回", gbl.bestpayAccount, amoMny);
		
		iRet = TS_OutPutMsg(gbl.dPosInfo, msg, 0, iSelect);
		if(iSelect)
		{
			return -1;
		}
	}
	return 0;
}


//获取交易状态说明
//输入参数：char *status - 交易状态
//输出参数：char *status_info - 交易状态说明
int CTrade::xjx_get_statusinfo(char *status,char *status_info)
{
    bbzero(status_info);
	switch(atoi(status))
	{
		case 0:
			strcpy(status_info, "交易成功");
			break;
		case 1:
			strcpy(status_info, "交易失败");
			break;
		case 2:
			strcpy(status_info, "未审核");
			break;
		case 3:
			strcpy(status_info, "已通过二级审核");
			break;
		case 4:
			strcpy(status_info, "二级审核不通过");
			break;
		case 5:
			strcpy(status_info, "已通过三级审核");
			break;
		case 6:
			strcpy(status_info, "三级审核不通过");
			break;
		case 7:
			strcpy(status_info, "交易拒绝（交易金额超过三级审核金额）");
			break;
		default:
			break;
	}

	return 0;
}


//羊城通白卡/套餐购买业务
int CTrade::Yct_WCardPack_purchaseHdl(const char *title)
{
	int iRet, iSelect, count=0;
	TSMENULIST menuList;

	memset(&menuList,0,sizeof(menuList));
	menuList.iTotalNum=2;
	strcpy(menuList.acTitle, "羊城通白卡/套餐购买：");
	strcpy(menuList.menuItem[0], "羊城通白卡采购");
	strcpy(menuList.menuItem[1], "羊城通读卡器");

	count = 0;
	while(strcmp(menuList.menuItem[count++], ""))
		menuList.iTotalNum++;
	iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
	if(iRet)
		return -1;
	if(iSelect < 0 && iSelect > menuList.iTotalNum)
		return CANCLE_KEY;

	switch(iSelect)
	{
	case 1:
		Yct_Whitecard_purchaseHdl("羊城通白卡采购业务");
		break;
	case 2:
		Yct_Package_purchaseHdl("羊城通套餐采购业务");
		break;
	default: 
		TS_OutPutMsg(gbl.dPosInfo, "选择有误\n\n请按回车后重新操作", 0, iSelect);
		return -1;
	}

	return 0;
}


//羊城通白卡采购业务
int CTrade::Yct_Whitecard_purchaseHdl(const char *title)
{
	int iRet,iSelect;
	int  iPurchase_num = 0;	
	int  iPay_sum = 0;
	int  b48_len = 0;
	int  b63_len = 0;
	char msg[1024];
	char contact_name[30+1];
    char contact_num[11+1];
	char distribute_adr[100+1];
	char payamo_sum[12+1];
	char temp_amo[12+1];
	char purchase_num[4+1];
	char product_no[10+1];
	char tmp[1024];
	char random_num[8+1];
	char respond_code[4+1];
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;


	bbzero(msg);
	strcpy(msg, "【业务说明】采购羊城通（岭南通），须填写相关采购数量和配送信息，配送途径为快递，快递费用由商户承担，10张起包邮。");
	iRet = TS_OutPutMsg(gbl.dPosInfo, msg, 0, iSelect);
	if(iSelect)
	{
		return -1;
	}

	bbzero(msg);
	strcpy(msg, "提示：羊城通白卡单价25元/张（运费8元，10张以上包邮）");
	iRet = TS_OutPutMsg(gbl.dPosInfo, msg, 0, iSelect);
	if(iSelect)
	{
		return -1;
	}

	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	//采购数量输入
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入采购数量（张）：");	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;//超时30秒
	tradeInfoSend.Contents[0].uMinLen = 1;

    iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}

	strcpy(purchase_num,(char *)tradeInfoRecv.Contents[0].uMsg);
	iPurchase_num = atoi(purchase_num);
	if (iPurchase_num < 10)
	{
		bbzero(msg);
		strcpy(msg, "【温馨提示】采购数量不足10张，需额外支付8元快递费用。");
		iRet = TS_OutPutMsg(gbl.dPosInfo, msg, 0, iSelect);
		if(iSelect)
		{
			return -1;
		}
	}

	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 3;
	//联系人姓名输入
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入联系人姓名：");	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//全字符
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;//超时30秒
	tradeInfoSend.Contents[0].uMinLen = 4;
	tradeInfoSend.Contents[0].uMaxLen = 30;

	//联系电话输入
	strcpy(tradeInfoSend.Contents[1].acTitle, "请输入联系电话：");	
	tradeInfoSend.Contents[1].uCommand = TS_INPUT_MATH;	//数字
	tradeInfoSend.Contents[1].uTimeOut = EPOS_OVER_TIME;//超时30秒
	tradeInfoSend.Contents[1].uCount = 1;//两次输入
	tradeInfoSend.Contents[1].uMinLen = 10;
	tradeInfoSend.Contents[1].uMaxLen = 30;

	//配送地址输入
	strcpy(tradeInfoSend.Contents[2].acTitle, "请输入配送地址：");	
	tradeInfoSend.Contents[2].uCommand = TS_INPUT_ALL_CHAR;	//全字符
	tradeInfoSend.Contents[2].uTimeOut = EPOS_OVER_TIME + 40;//超时70秒
	tradeInfoSend.Contents[2].uMinLen = 1;
	tradeInfoSend.Contents[2].uMaxLen = 128;

    iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}

	bbzero(contact_name);
	strcpy(contact_name,(char *)tradeInfoRecv.Contents[0].uMsg);
	
	bbzero(contact_num);
	strcpy(contact_num,(char *)tradeInfoRecv.Contents[1].uMsg);

    bbzero(distribute_adr);
	strcpy(distribute_adr,(char *)tradeInfoRecv.Contents[2].uMsg);


	/****************************发起查询交易获取产品单价****************************/
	
//     pack.wrField(1, gbl);	//写查询域
// 
// 	/***************修改48域****************/
// 	bbzero(pack.FIELD48);
// 	memcpy(pack.FIELD48,gbl.fee_type,4);//收费种类(4)
// 	b48_len = 4;
// 	
// 	bbzero(tmp);
// 	bbzero(product_no);
// 	strcpy(product_no,"SB00000005");
// 	sprintf(tmp,"%02d",strlen(product_no));
// 	memcpy(pack.FIELD48+b48_len,tmp,2); //产品编号长度
// 	b48_len+=2;
// 	
// 	memcpy(pack.FIELD48 + b48_len,product_no, strlen(product_no));	//产品编号
// 	b48_len +=strlen(product_no);
// 	
// 	pack.Packet_Table[48].Real_Length=b48_len;
// 	/*****************************************/
// 
// 	/***************修改35域****************/
// 	bbzero(pack.FIELD35);
// 	memcpy(pack.FIELD35,"0",1);
// 	pack.Packet_Table[35].Real_Length=1;
// 	/*****************************************/
// 
// 	/***************修改46域****************/
// 	bbzero(pack.FIELD46);
// 	memcpy(pack.FIELD46,"0",1);
// 	pack.Packet_Table[46].Real_Length=1;
// 	/*****************************************/
// 
// 	/***************修改63域****************/
// 	bbzero(pack.FIELD63);
// 	memcpy(pack.FIELD63,"0",1);
// 	pack.Packet_Table[63].Real_Length=1;
// 	/*****************************************/
// 
// 	//打包，发包，收包
// 	iRet = packHdl(1);
// 	
//     bbzero(respond_code);
// 	memcpy(respond_code,pack.FIELD39,4);
// 	wrLog("respond_code: %s",respond_code);
// 
//     if (strcmp(respond_code,"00") == 0)
//     {
// 
//     }

	//付款总额计算方法：
	//购买张数大于等于10张，付款总额=单价x数量
	//购买张数小于10张，付款总额=单价x数量+8元
	iPay_sum = iPurchase_num * (YCT_CARD_UNITPRICE);//单位元
	if (iPurchase_num < 10)
	{
		iPay_sum += YCT_CARDDELIVERY_COSTS;
	}
	
	bbzero(temp_amo);
	bbzero(payamo_sum);
	CTools::longToMny(iPay_sum * 100,temp_amo);
	CTools::chg12asc(temp_amo,payamo_sum);

	//显示确认信息
	bbzero(msg);
	sprintf(msg, "订单信息:羊城通卡单价：%d元/张；\n\t下单数量：%d张\n\t付款总额：%d元\n配送信息:终端号：%s\n\t联系人：%s\n\t联系电话：%s\n\t配送地址：%s\n",YCT_CARD_UNITPRICE,iPurchase_num,iPay_sum,	gbl.posInfo.posNum,contact_name,contact_num,distribute_adr);
	strcat(msg,"\n\n【Enter】确认\t【Esc】返回\n【温馨提示】请确认以上信息，由于以上信息不正确或不完整导致的一切损失由商户承担。");
	iRet = TS_OutPutMsg(gbl.dPosInfo, msg, 0, iSelect);
	if(iSelect)
	{
		return -1;
	}

    //从E卡中扣除相应的采购金额
	/****************************发起交易****************************/

	bbzero(gbl.amount);
	memcpy(gbl.amount,payamo_sum,12);//应付金额

    pack.wrField(2, gbl);	//写交费域

	/***************修改48域****************/
	bbzero(pack.FIELD48);
	memcpy(pack.FIELD48,gbl.fee_type,4);//收费种类(4)
	b48_len = 4;
	
	bbzero(tmp);
	bbzero(product_no);
	strcpy(product_no,"YT00000001");
	sprintf(tmp,"%02d",strlen(product_no));
	memcpy(pack.FIELD48+b48_len,tmp,2); //产品编号长度
	b48_len+=2;
	
	memcpy(pack.FIELD48 + b48_len,product_no, strlen(product_no));	//产品编号
	b48_len +=strlen(product_no);
	
	pack.Packet_Table[48].Real_Length=b48_len;
	/*****************************************/

	/***************修改63域****************/
	bbzero(pack.FIELD63);
    bbzero(random_num);
	CTools::generate_random_num(random_num,8);//产生八位随机数
	memcpy(pack.FIELD63,random_num,strlen(random_num));//八位随机数
	b63_len = strlen(random_num);
	
	bbzero(tmp);
	sprintf(tmp,"%04d",iPurchase_num);
	memcpy(pack.FIELD63 + b63_len,tmp,strlen(tmp)); //采购数量
	b63_len+=strlen(tmp);
	
	bbzero(tmp);
	sprintf(tmp,"%02d%s",strlen(contact_num),contact_num);
	memcpy(pack.FIELD63 + b63_len,tmp, strlen(tmp));	//用户联系电话
	b63_len +=strlen(tmp);

	bbzero(tmp);
	sprintf(tmp,"%02d%s",strlen(distribute_adr),distribute_adr);
	memcpy(pack.FIELD63 + b63_len,tmp, strlen(tmp));	//配送地址
	b63_len +=strlen(tmp);	
	
	pack.Packet_Table[63].Real_Length=b63_len;
	/*****************************************/

				//打包，发包，收包
	iRet = packHdl(2);
	
    bbzero(respond_code);
	memcpy(respond_code,pack.FIELD39,4);
	wrLog("respond_code: %s",respond_code);

	

	return 0;
}


//羊城通套餐采购业务
int CTrade::Yct_Package_purchaseHdl(const char *title)
{	
	INT iRet = 0,iSelect = 0;
	int  iPurchase_num = 0;	
	int  iPay_sum = 0;
	char msg[1024];
	char purchase_num[4+1];
	char contact_name[30+1];
    char contact_num[11+1];
	char distribute_adr[100+1];
	int  b48_len = 0;
	int  b63_len = 0;
	char payamo_sum[12+1];
	char temp_amo[12+1];
	char product_no[10+1];
	char tmp[1024];
	char random_num[8+1];
	char respond_code[4+1];
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;


	bbzero(msg);
	strcpy(msg, "【业务说明】采购羊城通套餐，套餐包含一台羊城通读卡器和30张羊城通白卡，扣费成功后我司将在X工作日内上门安装。");
	iRet = TS_OutPutMsg(gbl.dPosInfo, msg, 0, iSelect);
	if(iSelect)
	{
		return -1;
	}

	bbzero(msg);
	strcpy(msg, "提示：羊城通加盟套餐1388元/套（包含一台羊城通读卡器和30张羊城通白卡）");
	iRet = TS_OutPutMsg(gbl.dPosInfo, msg, 0, iSelect);
	if(iSelect)
	{
		return -1;
	}

	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 4;
	//采购数量输入
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入采购数量（套）：");	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;//超时30秒
	tradeInfoSend.Contents[0].uMinLen = 1;

	//联系人姓名输入
	strcpy(tradeInfoSend.Contents[1].acTitle, "请输入联系人姓名：");	
	tradeInfoSend.Contents[1].uCommand = TS_INPUT_ALL_CHAR;	//全字符
	tradeInfoSend.Contents[1].uTimeOut = EPOS_OVER_TIME;//超时30秒
	tradeInfoSend.Contents[1].uMinLen = 4;
	tradeInfoSend.Contents[1].uMaxLen = 30;
	
	//联系电话输入
	strcpy(tradeInfoSend.Contents[2].acTitle, "请输入联系电话：");	
	tradeInfoSend.Contents[2].uCommand = TS_INPUT_MATH;	//数字
	tradeInfoSend.Contents[2].uTimeOut = EPOS_OVER_TIME;//超时30秒
	tradeInfoSend.Contents[2].uCount = 1;//两次输入
	tradeInfoSend.Contents[2].uMinLen = 10;
	tradeInfoSend.Contents[2].uMaxLen = 30;
	
	//配送地址输入
	strcpy(tradeInfoSend.Contents[3].acTitle, "请输入配送地址：");	
	tradeInfoSend.Contents[3].uCommand = TS_INPUT_ALL_CHAR;	//全字符
	tradeInfoSend.Contents[3].uTimeOut = EPOS_OVER_TIME + 40;//超时70秒
	tradeInfoSend.Contents[3].uMinLen = 1;
	tradeInfoSend.Contents[3].uMaxLen = 128;
	
    iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}

	bbzero(purchase_num);
	strcpy(purchase_num,(char *)tradeInfoRecv.Contents[0].uMsg);

	bbzero(contact_name);
	strcpy(contact_name,(char *)tradeInfoRecv.Contents[1].uMsg);
	
	bbzero(contact_num);
	strcpy(contact_num,(char *)tradeInfoRecv.Contents[2].uMsg);
	
    bbzero(distribute_adr);
	strcpy(distribute_adr,(char *)tradeInfoRecv.Contents[3].uMsg);


	//付款总额计算方法：
	//付款总额=单价x数量
	iPurchase_num = atoi(purchase_num);	
	iPay_sum = iPurchase_num * (YCT_PACKAGE_UNITPRICE);//单位元
	bbzero(temp_amo);
	bbzero(payamo_sum);
	CTools::longToMny(iPay_sum * 100,temp_amo);
	CTools::chg12asc(temp_amo,payamo_sum);

	//显示确认信息
	bbzero(msg);
	sprintf(msg, "订单信息:羊城通套餐单价：%d元/套；\n\t下单数量：%d套\n\t付款总额：%d元\n配送信息:终端号：%s\n\t联系人：%s\n\t联系电话：%s\n\t配送地址：%s\n",YCT_PACKAGE_UNITPRICE,iPurchase_num,iPay_sum,	gbl.posInfo.posNum,contact_name,contact_num,distribute_adr);
	strcat(msg,"\n\n【Enter】确认\t【Esc】返回\n【温馨提示】请确认以上信息，由于以上信息不正确或不完整导致的一切损失由商户承担。");
	iRet = TS_OutPutMsg(gbl.dPosInfo, msg, 0, iSelect);
	if(iSelect)
	{
		return -1;
	}

	//从E卡中扣除相应的采购金额
	/****************************发起交易****************************/
	
    pack.wrField(2, gbl);	//写交费域
    
	/***************修改48域****************/
	bbzero(pack.FIELD48);
	memcpy(pack.FIELD48,gbl.fee_type,4);//收费种类(4)
	b48_len = 4;
	
	bbzero(tmp);
	bbzero(product_no);
	strcpy(product_no,"YT00000002");
	sprintf(tmp,"%02d",strlen(product_no));
	memcpy(pack.FIELD48+b48_len,tmp,2); //产品编号长度
	b48_len+=2;
	
	memcpy(pack.FIELD48 + b48_len,product_no, strlen(product_no));	//产品编号
	b48_len +=strlen(product_no);
	
	pack.Packet_Table[48].Real_Length=b48_len;
	/*****************************************/
	
	/***************修改63域****************/
	bbzero(pack.FIELD63);
    bbzero(random_num);
	CTools::generate_random_num(random_num,8);//产生八位随机数
	memcpy(pack.FIELD63,random_num,strlen(random_num));//八位随机数
	b63_len = strlen(random_num);
	
	bbzero(tmp);
	sprintf(tmp,"%04d",iPurchase_num);
	memcpy(pack.FIELD63+b63_len,tmp,strlen(tmp)); //采购数量
	b63_len+=strlen(tmp);
	
	bbzero(tmp);
	sprintf(tmp,"%02d%s%s",strlen(contact_num)+strlen(distribute_adr),contact_num,distribute_adr);
	memcpy(pack.FIELD63 + b63_len,tmp, strlen(tmp));	//用户联系电话+配送地址
	b63_len +=strlen(tmp);
	
	pack.Packet_Table[63].Real_Length=b63_len;
	/*****************************************/
	
	//打包，发包，收包
	iRet = packHdl(2);
	
    bbzero(respond_code);
	memcpy(respond_code,pack.FIELD39,4);
	wrLog("respond_code: %s",respond_code);

	return 0;
}


//羊城通读卡器采购采购业务 
int CTrade::Yct_ICReader_purchaseHdl(const char *title)
{	
	INT iRet = 0,iSelect = 0;
	int  iPurchase_num = 0;	
	int  iPay_sum = 0;
	int  b48_len = 0;
	int  b63_len = 0;
	char product_no[10+1];
	char tmp[1024];
	char random_num[8+1];
	char response_code[2+1];
	char showMsg[500];

	//付款总额计算方法：
	//付款总额=单价x数量
	iPurchase_num = 1;
	iPay_sum=1100; //价格变更为1100
	bbzero(gbl.amount);
	sprintf(gbl.amount,"%012ld",iPay_sum*iPurchase_num*100);

	bbzero(showMsg);
	sprintf(showMsg,"\n羊城通读卡器一套1100元（含PKI密钥卡及PSAM卡各一张）\n\n %d元\n\n【是 Enter】　【否 Esc】\n【请确认您已申请购买并收到交费易的通知：申请已通过】 ",atoi(gbl.amount)/100);
	iRet=TS_OutPutMsg(gbl.dPosInfo,showMsg,0,iSelect);
	if (iRet!=0 || iSelect!=0)
	{
		return -1;
	}
	//从E卡中扣除相应的采购金额
	/****************************发起交易****************************/
	int flag = 0;
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{
		if(!flag)
		{
			iRet = mngCard_Hdl(title);
			if(iRet == CANCLE_KEY)
				return CANCLE_KEY;
			else if(iRet != 0)
				return -1;
		}

	pack.wrField(2, gbl);	//写交费域
    
	/***************修改48域****************/
	bbzero(pack.FIELD48);
	memcpy(pack.FIELD48,gbl.fee_type,4);//收费种类(4)
	b48_len = 4;
	
	bbzero(tmp);
	bbzero(product_no);
	strcpy(product_no,"YT00000001");
	sprintf(tmp,"%02d",strlen(product_no));
	memcpy(pack.FIELD48+b48_len,tmp,2); //产品编号长度
	b48_len+=2;
	
	memcpy(pack.FIELD48 + b48_len,product_no, strlen(product_no));	//产品编号
	b48_len +=strlen(product_no);
	
	pack.Packet_Table[48].Real_Length=b48_len;
	/*****************************************/
	
	/***************修改63域****************/
	bbzero(pack.FIELD63);
    bbzero(random_num);
	CTools::generate_random_num(random_num,8);//产生八位随机数
	memcpy(pack.FIELD63,random_num,strlen(random_num));//八位随机数
	b63_len = strlen(random_num);
	
	bbzero(tmp);
	sprintf(tmp,"%04d",iPurchase_num);
	memcpy(pack.FIELD63+b63_len,tmp,strlen(tmp)); //采购数量
	b63_len+=strlen(tmp);
	
	pack.Packet_Table[63].Real_Length=b63_len;
	/*****************************************/
	
	//打包，发包，收包
	iRet = packHdl(2);
	if(iRet < 0)
		return -1;
	
	memset(response_code,0,sizeof(response_code));
	memcpy(response_code,pack.FIELD39,2);
	if (!memcmp(response_code,"00",2)) 
	{
		bbzero(showMsg);
		bbzero(gbl.stan_no);
		memcpy(gbl.stan_no,(char *)pack.FIELD37,12);
		sprintf(showMsg," 交费成功!\n系统参考号:%s\n羊城通读卡器:%.2f元\n\n请按【Enter】打印凭证，按【Esc】取消",gbl.stan_no,atof(gbl.amount)/100);
		iRet = TS_OutPutMsg(gbl.dPosInfo,showMsg,0,iSelect);
		if(iRet!=0 || iSelect==0 )
		{
			CPrint prt;
			prt.set_in_par(gbl);
			prt.print_yct_sellDetail(title);
		}
		return 0;
	}
	else if(!memcmp(response_code,"55",2))
	{
		flag = 1;
		if(reGetPwd( title) == 0) //密码错误，重新输入密码, 2006-10-25
			continue;
		else
			return CANCLE_KEY;
	}
	else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
	{
		TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡",1,iSelect);
		if (iSelect!=0)
		{
			return -1;
		}else
			continue;
	}
	else
		returnFail(response_code);
		return 1;
	
	}

	return 0;
}

/*羊城通充值撤销*/
int CTrade::Yct_charge_cancel(const char *title)
{
	int iRet = 0 , iSelect = 0;
	char byteTmp[64] = { 0 };
    char charge_pz[8+1] = {0}; //充值凭证
	char stan[16+1] = {0};
	char charge_amo[8+1] = {0}; //交易金额
	YCT_DATA yct_data;
	CYCTYPTrade::init_yct_data(&yct_data);

	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;

	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 3;

	//充值凭证号输入
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入充值凭证号：");	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//全字符
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME;//超时30秒
	tradeInfoSend.Contents[0].uMinLen = 1;
	tradeInfoSend.Contents[0].uMaxLen = 8;
	
	//系统参考输入
	strcpy(tradeInfoSend.Contents[1].acTitle, "请输入羊城通充值流水号：");	
	tradeInfoSend.Contents[1].uCommand = TS_INPUT_ALL_CHAR;	//全字符
	tradeInfoSend.Contents[1].uTimeOut = EPOS_OVER_TIME;//超时30秒
	tradeInfoSend.Contents[1].uMinLen = 3;
	tradeInfoSend.Contents[1].uMaxLen = 16;
	
	//金额
	strcpy(tradeInfoSend.Contents[2].acTitle, "请输入原交易金额：");	
	tradeInfoSend.Contents[2].uCommand = TS_INPUT_MONEY;	//金额
	tradeInfoSend.Contents[2].uTimeOut = EPOS_OVER_TIME;//超时30秒

	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}

	bbzero(byteTmp);
	strcpy(byteTmp,(char *)tradeInfoRecv.Contents[0].uMsg); //充值凭证号
	strupr(byteTmp);
	CTools::trim(byteTmp);
	//转为十六进制
	CTools::DecToHex(byteTmp, charge_pz,8);
	//sprintf(charge_pz , "%08s" , byteTmp);

	bbzero(byteTmp);
	strcpy(byteTmp,(char *)tradeInfoRecv.Contents[1].uMsg); //羊城通流水号
	strupr(byteTmp);
	CTools::trim(byteTmp);
	//转为十六进制
	bbzero(yct_data.yct_serial);
	for(int i = 0;i<16-strlen(byteTmp);i++)		//前补0，凑足16位
		yct_data.yct_serial[i] = '0';
	memcpy(yct_data.yct_serial+(16-strlen(byteTmp)),byteTmp,strlen(byteTmp));
	wrLog("转换后的羊城通流水号：%s",yct_data.yct_serial);

	CTools::DecToHex(byteTmp, stan,16);
	//sprintf(stan , "%016s" , byteTmp);
	
	strcpy(charge_amo,(char *)tradeInfoRecv.Contents[2].uMsg);	//充值金额
	CTools::trim(charge_amo);
	//数据库中通过羊城通交易流水号查找该笔交易，如果这个终端24小时之内是否存在这笔交易，如果存在则可以进行撤销，如果不存在，不能进行撤销。

	iRet=CDB::get_yctptxn(gbl,&yct_data,charge_amo);

	if (iRet!=0)
	{
		if (iRet==-1)
		{
			TS_OutPutMsg(gbl.dPosInfo,"原充值金额与输入金额不符",0,iSelect);
		}
		else
		{
			TS_OutPutMsg(gbl.dPosInfo,"查无此交易记录",0,iSelect);
		}

		return CANCLE_KEY;
	}

	iRet =  CYCTYPTrade::Charge_Cancle(&gbl , stan , charge_pz , charge_amo, yct_data); //羊城通充值流水号

	if(iRet == 0)
	{
		//打印撤销单据
	}
    
	return iRet;
	//////////////////////////////////////////////////////////////////////////
}

int CTrade::Yct_Card_Extend(const char *title)
{
	int iRet = -1;
	int iSelect = 0;

	iRet = CYCTYPTrade::ExtendApp(&gbl , 0 );
	if (iRet == 0)
	{
		TS_OutPutMsg(gbl.dPosInfo , "卡扩展激活成功，按【Enter】返回。" , 0 , iSelect);
	}
	else
	{
		TS_OutPutMsg(gbl.dPosInfo , "卡扩展激活失败，按【Enter】返回并重试。" , 0 , iSelect);
	}

	return 0;
}

//获取卡余额信息

int CTrade::read_IcCardInfo(const char  *type, char * term_serial,int deviceType, char *cardMny) 
{
	
	char bus_amo_tmp[8+1];
	char rcvData[1024];
	bbzero(rcvData);
	int rcvLen=0;
	bbzero(bus_amo_tmp);
	
	if (deviceType==1) // 如果读卡器是清华同方读卡器
	{
		
		if( busSndRcvHID_IcData(type, (const BYTE *)"\xC2\x81",2, (BYTE *)rcvData, rcvLen, term_serial) ) //充值验卡是读卡器之间的。
		{
			return -1;
		}
		if ((unsigned char)(rcvData[0]) == 0x81) //如果第一个状态吗发挥0x81，那么执行指令不成功。
			
		{
			returnHIDBusFail(rcvData[1]); 
			return -3;
			
		}
		//余额为：
		CTools::byte_to_hex((const BYTE *)rcvData+10, (BYTE *)bus_amo_tmp, 4); //票卡金额
		CTools::sixten_toten(bus_amo_tmp,cardMny);	
		wrLog("卡余额为:%.2f",atof(cardMny)/100);
		
	}
	else //如果是串口读卡器
	{
		
		if( CTrade::busSndRcvIcData(type, (const BYTE *)"\x0C\x01\x00\x02\x81\x00\x8E", 7, (BYTE *)rcvData, rcvLen, term_serial) ) //充值验卡是读卡器之间的。
		{
			return -1;
		}
		if ((unsigned char)(rcvData[4]) == 0xA1)
		{
			CTrade::returnBusFail(rcvData[5]);
			return -3;
		}	
		
		CTools::byte_to_hex((const BYTE *)rcvData+14, (BYTE *)bus_amo_tmp, 4);
		CTools::sixten_toten(bus_amo_tmp,cardMny);
		wrLog("卡余额为:%.2f",atof(cardMny)/100);
		
	}
	
	
	return 0;
	
}


//全国水电煤业务
int CTrade::sdm_service(const char *title)
{

	int iRet;
	iRet=sdm_district_service(title); //水电煤地区查询 

	if (iRet!=0)
	{

		return CANCLE_KEY;
	}

	return 0;

}


int CTrade::sdm_district_service(const char *title) //水电煤地区查询
{
	
	TSMENULIST menuList;
	int iSelect;
	int iRet=0;
	
	memset(&menuList,0,sizeof(menuList));
	strcpy(menuList.acTitle, "请查询开通地区");
	menuList.iTotalNum = 2;
	strcpy(menuList.menuItem[0], "显示所有地区");
	strcpy(menuList.menuItem[1], "请选择地区搜索");
	
	iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
	if(iRet)
		return -1;
	
	switch(iSelect)
	{
		
	case 1:
		
		iRet=sdm_showAreas(title,0,gbl); 
		break;
	case 2:
		iRet=sdm_showAreas(title,1,gbl); //显示地市查询列表
		break;
		
	}
	
	return iRet;
}

/*
type:0为按照列表查询交费地区
type:1 直接输入地区查询交费地区 如果输入的地区为省，需要继续查询后续的交费城市
*/
CTrade::sdm_showAreas(const char* title, int type,CGlobal gbl)
{
	int iSelect, iRet; 
	char sql[1024], temp[20];
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	TSTxnLogs txnLogs;
	memset(&txnLogs,0, sizeof(txnLogs));

	switch(type)
	{
	case 0: // 

		{
			bbzero(sql); //1,是省，3是直辖市
			strcpy(sql, "select * from sdm_area t where t.area_flag in ('1','3') and t.status='1' order by t.areacode"); //
		}

		break;

	case 1:

		memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
		memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
		
		strcpy(tradeInfoSend.acMainTitle, title);
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents = 1;		
		strcpy(tradeInfoSend.Contents[0].acTitle, "请输入城市，如北京");	
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;	//全字符
		tradeInfoSend.Contents[0].uCount = 0;		//输入1次		
		tradeInfoSend.Contents[0].uTimeOut = 60;	//超时40秒
		tradeInfoSend.Contents[0].uMinLen = 1;		
		tradeInfoSend.Contents[0].uMaxLen = 60;
		
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		
		if(iRet != 0)
		{
			wrLog("TS_TradeControl返回错误[%d]", iRet);
			wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
			return iRet;
		}
		
		bbzero(temp);
		memcpy(temp, (char *)tradeInfoRecv.Contents[0].uMsg, tradeInfoRecv.Contents[0].uMsgLen);
		//将小写字母转换为大写
		CTools::lowerToUpper(temp);
		bbzero(sql);
		//sprintf(sql, "select AREACODE, DX_CODE, AREA_NAME,PARENT_CODE,AREA_FLAG,SHORTNAME from sdm_area t  where t.area_name like '%%%s%%' ", temp); //for test
		sprintf(sql, "select AREACODE, DX_CODE, AREA_NAME,PARENT_CODE,AREA_FLAG,SHORTNAME from sdm_area t  where t.area_name like '%%%s%%'  and t.status='1'  ", temp); //for test
		break;
	default:
		return -1;
	}
	
	memset(&txnLogs, 0, sizeof(txnLogs));
	if (type==0) //直接列出全部列表
	{

		iRet = CDB::getSDMList(&txnLogs, sql,0,gbl); 

	}
	else //直接输入缴费地区
	{
	
		iRet = CDB::getSDMList(&txnLogs, sql,1,gbl); 
	}

	
	if (iRet != 0)
	{
		TS_OutPutMsg(gbl.dPosInfo,"该地区水电煤业务尚未开通",0,iSelect);
		return -1;
	}
	
	iRet = TS_ShowTxnLogs(gbl.dPosInfo, &txnLogs);
	return iRet;
}


//根据所在的省份来查询交费地区
int CTrade::showSMD_cityList(char *title)
{

	TSTxnLogs txnLogs;
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	int iRet,iSelect;
	char sql[1024];
	char content[66+1];
	bbzero(content);
	bbzero(sql);
	memset(&txnLogs,0, sizeof(txnLogs));
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	strcpy(tradeInfoSend.acMainTitle, "请选择交费城市");
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	strcpy(tradeInfoSend.Contents[0].acTitle, "水电煤交费城市查询");
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;
	tradeInfoSend.Contents[0].uCount = 0;
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME + 30;
	tradeInfoSend.Contents[0].uMinLen = 4;
	tradeInfoSend.Contents[0].uMaxLen = 60;
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}
	
	bbzero(content);
	memcpy(content, (char *)tradeInfoRecv.Contents[0].uMsg, tradeInfoRecv.Contents[0].uMsgLen);
	strcpy(gbl.pos_serial, (char *)tradeInfoRecv.uTradeID);	
	wrLog("content:%s",content);
	bbzero(gbl.PARENT_CODE);
	bbzero(gbl.PARENT_NAME);
	memcpy(gbl.PARENT_CODE,content,6);
	strcpy(gbl.PARENT_NAME,content+6);
	wrLog("gbl.PARENT_CODE:%s",gbl.PARENT_CODE);
	wrLog("gbl.PARENT_NAME:%s",gbl.PARENT_NAME);
	memset(&txnLogs, 0, sizeof(txnLogs));
	
	sprintf(sql, "select  AREACODE,DX_CODE,AREA_NAME,PARENT_CODE, SHORTNAME,AREA_FLAG from sdm_area t where t.parent_code='%s' and t.status='1' order by AREACODE  ", gbl.PARENT_CODE); //查找对应的市
	iRet = CDB::getSDMList(&txnLogs, sql,0,gbl);
	
	if (iRet != 0)
	{
		TS_OutPutMsg(gbl.dPosInfo,"该地区水电煤业务尚未开通",0,iSelect);
		return -1;
	}
	
	iRet = TS_ShowTxnLogs(gbl.dPosInfo, &txnLogs);
	return iRet;

}

//水电煤交易 地区查询
CTrade::sdm_trade(char *title)
{
	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	char content[200+1];
	int content_len=0;
	char len_tmp[2+1];
	int len=0;
	int iRet;
	string dataStr;
	string errString; //错误码
	string RSP_String; //返回码
	int iSelect;
	char BILLMONTH[6+1]; //账期
	int delayFlag=0; //滞纳金标志
	char sdm_txnAmount[12+1];
	char billDetails[200];

	bbzero(len_tmp);
	bbzero(sdm_txnAmount);
	bbzero(billDetails);
	bbzero(gbl.SDM_BILLMONTH); //账期
	bbzero(BILLMONTH);
	bbzero(content);
	bbzero(len_tmp);

	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	strcpy(tradeInfoSend.acMainTitle, "请选择充值地区");
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	strcpy(tradeInfoSend.Contents[0].acTitle, "水电煤交费城市查询");
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;
	tradeInfoSend.Contents[0].uCount = 0;
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME + 30;
	tradeInfoSend.Contents[0].uMinLen = 4;
	tradeInfoSend.Contents[0].uMaxLen = 60;
	
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		return iRet;
	}
	
	bbzero(content);
	memcpy(content, (char *)tradeInfoRecv.Contents[0].uMsg, tradeInfoRecv.Contents[0].uMsgLen); //查询内容
	//解析参数 1101001011000006

	bbzero(gbl.AREA_NAME);
	bbzero(gbl.AREACODE);
	bbzero(gbl.PARENT_NAME);
	bbzero(gbl.PARENT_CODE);

	memcpy(gbl.AREACODE,content,6);
	content_len+=6;
	memcpy(len_tmp,content+content_len,2);
	len=atoi(len_tmp);
	memcpy(gbl.PARENT_CODE,content+content_len,6);
	content_len+=6;
	wrLog("content:%s",content);
	wrLog("gbl.AREACODE:%s",gbl.AREACODE);
	wrLog("gbl.PARENT_CODE:%s",gbl.PARENT_CODE);

	iRet=area_query_service(gbl,dataStr,"地市查询接口","INF06002",RSP_String,errString);
	//显示该地区的费用情况 以菜单的形式返回
	if (iRet!=0)
	{
		char errMsg[100];
		bbzero(errMsg);
		strcpy(errMsg,errString.c_str());
		TS_OutPutMsg(gbl.dPosInfo,errMsg,0,iSelect);//显示错误信息
		return CANCLE_KEY;
	}

	iRet=CxmlParser::getAreaDatas(dataStr,gbl);
	if (iRet!=0)
	{

		return -1;
	}

		return 0;

}

//txn_money：缴费的金额 格式单位是分


int CTrade::sdm_pay(char *title,char *sdm_txnAmount,char *BILLMONTH,int BILLSTAT,string &errString)
{
	int iRet;
	int flag;
	string errcode="";
	char operUser[20];
	bbzero(operUser);
	int iSelect;
	sprintf(operUser,"%s_01",gbl.pos_no); //操作员
	bbzero(gbl.stan_no);
	memcpy(gbl.stan_no,gbl.sdm_SYSTEMNO+(strlen(gbl.sdm_SYSTEMNO)-12),12);
	int nowAmo;
	if(CDB::getDayAmo(gbl.dPosInfo.pos_no, &nowAmo)==0)
		//20120105修改-yyx
		//if (CDB::pep_getDayAmo(pgbl->pos_no, &nowAmo) == 0)
	{
		if( gbl.dayAmo!=0 && nowAmo+atoi(gbl.amount)>gbl.dayAmo )
		{
			TS_OutPutMsg(gbl.dPosInfo, "已超出当天的最大消费金额，交易取消", 1, iSelect);
			return -1;
		}
	}
	else
	{
		TS_OutPutMsg(gbl.dPosInfo, "数据库操作出错，交易取消\n请稍候再试!\n 如果交易结果不明确请做 最后一笔交易查询", 1, iSelect);
		return -1;
	}

	//进行缴费，刷卡
	flag = 0;
	for(int curTry=0; curTry<MAXTRY; curTry++)
	{	
		if(!flag)
		{
			iRet = mngCard_Hdl(title);
			if(iRet == CANCLE_KEY)
				return CANCLE_KEY;
			else if(iRet != 0)
				return -1;
		}

		char password[16+1];
		bbzero(password);
		wrLog("gbl.sdm_SYSTEMNO:%s",gbl.sdm_SYSTEMNO);
		CTools::byte_to_hex((BYTE *)gbl.password,(BYTE *)password,8);

		if (BILLSTAT==1)
		{

			iRet=sdm_pay_service("账单缴费接口","INF06102",gbl.sdm_SYSTEMNO,gbl.amount,1,"",0,operUser,password,errString,errcode);

		}
		else
		{
			iRet=sdm_pay_service("账单缴费接口","INF06102",gbl.sdm_SYSTEMNO,gbl.amount,1, BILLMONTH,0,operUser,password,errString,errcode);

		}

		if (iRet==0)
		{

			char showMsg[500];
			bbzero(showMsg);
			CDB::setSumDayAmo(atoi(gbl.amount),gbl.pos_no);
			iRet=CDB::insertEposTxn(gbl,"00");
			if (iRet!=0)
			{
				wrLog("插入数据库记录失败");
			}

			gbl.billNum--;

			break; 
			 
		}
		else
		{
			if(strcmp(errcode.c_str(),"002135")==0) //如果是密码错误，提示用户输入密码
			{
				
				flag = 1;
				if(reGetPwd(title) == 0) //密码错误，重新输入密码, 2006-10-25
					continue;
				else
				return CANCLE_KEY;

			}

			else //其他错误
			{

				iRet=CDB::insertEposTxn(gbl,"01"); //交易失败
				if (iRet!=0)
				{
					wrLog("插入数据库记录失败");
				}
				return -1;

			}
		
		}

				
	}

	return 0;

}

int CTrade::area_query_service(CGlobal gbl,string &datas,char *WEBSVRNAME,char *WEBSVRCODE,string &strRsp,string &errStr)
{
	//受理时间:
	char server_time[14+1];
	string strReq0,strReq1;
	int iRet;
	string SIGN;
	string showMsg="";
	string rsp_str="";

	char datas_tmp[100];
	bbzero(datas_tmp);

	map<string, string>::iterator iter;
	map<string, string> _mapData;

	bbzero(server_time);
	CTools::get_termTime(server_time);
	CxmlParser::packAreaQryxml(gbl,gbl.pos_no,gbl.AREACODE,server_time,strReq0,strReq1,WEBSVRNAME,WEBSVRCODE); //for test
	
	iRet=ks_soap::get_response(TRADE_FLAG,strReq0,strReq1,strRsp,errStr);

	if (iRet!=0)
	{
	//	TS_OutPutMsg(gbl.dPosInfo,"连接服务器错误，请稍后再试!",0,iSelect);
	//	return CANCLE_KEY;
		errStr="";
		errStr = "网络繁忙，请稍后再试";
		return -4;
	}

	iRet=CxmlParser::unpack(strRsp,WEBSVRCODE,_mapData,errStr);
	if (iRet!=0)
	{
		errStr="";
		errStr = "报文解析错误,请稍后再试";
		return -1;
	}

	if ( (iter=_mapData.find("RSPCODE")) == _mapData.end() ) //清结算终端
	{
		errStr="";
		errStr = "查询失败,请稍后再试";
        return -1;
    }
	
	rsp_str=iter->second;
	if (strcmp(rsp_str.c_str(),"000000")!=0)
	{
		errStr="";
		errStr = "查询失败，请稍后再试";
		return -1;
	}

	if ( (iter=_mapData.find("DATAS")) == _mapData.end() )
    {
        errStr = "该地区暂未开通水电煤业务";
        return -1;
    }

    datas = iter->second;  
	wrLog("datas:%s",datas.c_str());
	
	return 0;
	
}


/************************************************************************/
//请输入用户手册
//SELECTTYPE:001
                                                                 
/************************************************************************/
int CTrade::sdm_query_service(char *WEBSVRNAME,char *WEBSVRCODE,char *SELECTTYPE,char *sdm_SYSTEMNO,int *billNum,int *BILLSTAT,string &strerr)
{
	//受理时间:
	char server_time[14+1];
	string strReq0,strReq1;
	int iRet;
	string BILLNUM;
	string BILLSTATStr="";
	strerr="";
	string strRsp="";
	string SYSTEMNO="";
	string datas="";
	string rsp_str="";

	bbzero(server_time);
	map<string, string>::iterator iter;
	map<string, string> _mapData;

	CTools::get_termTime(server_time);
	iRet=CxmlParser::packSDMQryxml(gbl,WEBSVRNAME,WEBSVRCODE,gbl.pos_no,SELECTTYPE,gbl.sdm_SELECTVALUE,server_time,gbl.AREACODE,gbl.sdm_PAYMENTCODE,gbl.query_amy,strReq0,strReq1);
	iRet=ks_soap::get_response(TRADE_FLAG,strReq0,strReq1,strRsp,strerr);

	if (iRet!=0)
	{

		//TS_OutPutMsg(gbl.dPosInfo,"连接服务器错误，请稍后再试!",0,iSelect);
		//return CANCLE_KEY;
		strerr="";
		strerr = "网络繁忙，请稍后再试";
		return -4;
	}

	iRet=CxmlParser::unpack(strRsp,WEBSVRCODE,_mapData,strerr);
	if (iRet!=0)
	{
		strerr="";
		strerr = "报文解析失败,请稍后再试";
		return -1;
	}

	if ( (iter=_mapData.find("RSPCODE")) == _mapData.end() ) //清结算终端
	{
		strerr="";
		strerr = "查询失败,请稍后再试";
        return -1;
    }
	
	rsp_str=iter->second;
	if (strcmp(rsp_str.c_str(),"000000")!=0)
	{
		strerr="";
		strerr = "查询失败，请稍后再试";
		return -1;
	}


	if ( (iter=_mapData.find("SYSTEMNO")) == _mapData.end() ) //系统参考号
    {
        strerr = "无SYSTEMNO信息";
        return -1;
    }

	 SYSTEMNO = iter->second; 
	 strcpy(sdm_SYSTEMNO,SYSTEMNO.c_str());
	 wrLog("sdm_SYSTEMNO:%s",sdm_SYSTEMNO);

	if ( (iter=_mapData.find("DATAS")) == _mapData.end() )
    {
        strerr = "无订单详情";
        return -1;
    }

    datas = iter->second;  
	wrLog("账单查询datas:%s",datas.c_str());

	if ( (iter=_mapData.find("BILLNUM")) == _mapData.end() )
    {
        strerr = "无账单数";
        return -1;
    }

    BILLNUM = iter->second;  
	*billNum=atoi(BILLNUM.c_str());

	if ( (iter=_mapData.find("BILLSTAT")) == _mapData.end() )
    {
        strerr = "无销账方式";
        return -1;
    }
	
    BILLSTATStr = iter->second;  
	*BILLSTAT=atoi(BILLSTATStr.c_str());

	wrLog("账单查询账单数:%d",*billNum);
	wrLog("datas:%s",datas.c_str());

	if (datas.size()>0)

	{	
		iRet=CxmlParser::getBillDatas(&gbl,datas);

		//输出测试；
		wrLog("账单数TEST:%d",gbl.sdmBills.nCnt);
		for(int j =0;j<*billNum;j++)
			
		{
			
			wrLog("客户姓名test:%s\n",gbl.sdmBills.BillDetails[j].CUSTOMERNAME);
			wrLog("BALANCEtest:%s\n",gbl.sdmBills.BillDetails[j].BILLMONTH);
			wrLog("BILLNOtest:%s",gbl.sdmBills.BillDetails[j].BILLNO);
			
		}

	}

	else
	{
		strerr = "无账单详情";
        return -1;
	}

	return 0;

}

/************************************************************************/
/*SYSTEMNO：订单号
CASHTYPE:销账单号类型
CASHORDER:销账单号 //销账单号复用账期
OPERUSER：操作员
OPERPASSWORD：交易密码
                                                                  
/************************************************************************/

int CTrade::sdm_pay_service(char *WEBSVRNAME,char *WEBSVRCODE,char *sdm_SYSTEMNO,char *sdm_txnamount,int CASHTYPE,char *feeCircle,int PAYTYPE,char *OPERUSER,char *OPERPASSWORD,string &errString,string &errcode)
{
	//受理时间:
	char server_time[14+1];
	string strReq0,strReq1;
	string strRsp,strerr;
	string TRANSSEQ_STR; //交易流水号
	string ORDERSEQ_STR; //订单号
	string TXNAMOUNT_STR; //交易金额
	char PAYTYPE_STR[1+1];
	int iRet;
	map<string, string>::iterator iter;
	map<string, string> _mapData;
	map<string,string> _pack_mapData;
	char keep[32+1];
	char orderNo[32+1];
	char psam_temp[16+1];
	bbzero(PAYTYPE_STR);
	bbzero(orderNo);
	sprintf(PAYTYPE_STR,"%d",PAYTYPE);
	bbzero(psam_temp);
	CTools::byte_to_hex((BYTE*)gbl.posInfo.psamNum, (BYTE*)psam_temp, 8);
	bbzero(server_time);
	bbzero(keep);
	CTools::get_termTime(server_time);
	CTools::get_orderNo(orderNo);
	char strReqTmp[100];
	bbzero(strReqTmp);
	char APPFROMTmp[50];
	bbzero(APPFROMTmp);
	sprintf(strReqTmp,"%s|440100-APP001-001-%s|APP001|%s|",WEBSVRCODE,gbl.server_ip,gbl.server_ip);
	sprintf(APPFROMTmp,"440100-APP001-001-%s",gbl.server_ip);
	strReq0.assign(strReqTmp,strlen(strReqTmp));
	//CTools::get_keep(keep);
	bbzero(keep);
	CTools::get_keep(gbl.pos_no,keep);
	_pack_mapData.insert(pair<string,string> ("MERID",MERID));
	_pack_mapData.insert(pair<string,string>("CHANNELCODE",CHANNELCODE));
	_pack_mapData.insert(pair<string,string>("TMNNUM",TMNNUM));
	_pack_mapData.insert(pair<string,string>("SIGN","SIGN"));
	_pack_mapData.insert(pair<string,string>("CER","CER"));
	_pack_mapData.insert(pair<string,string>("WEBSVRNAME",WEBSVRNAME));
	_pack_mapData.insert(pair<string,string>("WEBSVRCODE",WEBSVRCODE));
	_pack_mapData.insert(pair<string,string>("APPFROM",APPFROMTmp));
	_pack_mapData.insert(pair<string,string>("KEEP",keep));
	_pack_mapData.insert(pair<string,string>("REQUESTTIME",server_time));
	_pack_mapData.insert(pair<string, string>("ORDERSEQ",orderNo)); //平台数据  订单号
	_pack_mapData.insert(pair<string,string> ("TMNNUMNO",gbl.pos_no)); //终端号
	_pack_mapData.insert(pair<string,string> ("ACCEPTDATE",server_time)); //受理时间
	_pack_mapData.insert(pair<string,string> ("SYSTEMNO",gbl.sdm_SYSTEMNO)); //系统参考号
	_pack_mapData.insert(pair<string,string> ("TXNAMOUNT",gbl.amount)); //订单金额
	_pack_mapData.insert(pair<string,string> ("CASHORDER",feeCircle)); //账期
	_pack_mapData.insert(pair<string,string> ("CASHNUMBER",gbl.SDM_BILLNO)); //销账单号
	_pack_mapData.insert(pair<string,string> ("PAYTYPE",PAYTYPE_STR)); //支付方式
	_pack_mapData.insert(pair<string,string> ("ECARDNO",gbl.card_no)); //E卡信息
	_pack_mapData.insert(pair<string,string> ("PASSFLAG","2")); //密码类型
	_pack_mapData.insert(pair<string,string> ("PSAMCARDNO",psam_temp)); //PSAM卡号
	_pack_mapData.insert(pair<string,string> ("OPERUSER",OPERUSER)); //企业账户操作员
	_pack_mapData.insert(pair<string,string> ("OPERPASSWORD",OPERPASSWORD)); //企业账户操作员密码
	wrLog("strReq0:%s",strReq0.c_str());
	CxmlParser::pack(WEBSVRCODE,strReq1,_pack_mapData,strerr);

	iRet=ks_soap::get_response(TRADE_FLAG,strReq0,strReq1,strRsp,strerr);

	if (iRet!=0)
	{
		errString=strerr;
		return -1;
	}
	
	iRet=CxmlParser::unpack(strRsp,WEBSVRCODE,_mapData,strerr);
	if (iRet!=0)
	{
		errString=strerr;
        return -1;
	}

	if ( (iter=_mapData.find("RSPCODE")) == _mapData.end() ) //返回码
    {
        errString = "无返回码";
        return -1;
    }

	errcode = iter->second; 
	if ("000000" !=errcode) //响应码
	{
		//错误码011007进行处理
		errString="";
		/*

		if ("011007" == errcode)
		{

			errString="交易处理中,请进入商户自服务系统查询交易情况!\n如有疑问，请咨询在线客服或致电客服400-80-11888";
			return -1;

		}
		*/
	//	else
	//	{
			if ( (iter=_mapData.find("RSPMSG")) == _mapData.end() ) 
			{
				errString = "交易失败,请进入商户自服务系统查询交易结果!\n如有疑问，请咨询在线客服或致电客服400-80-11888";
				return -3;
			}
			
			errString="交易失败 ";
			errString +=iter->second; //明确失败
			return -3;

	//	}
	
	}

	if ( (iter=_mapData.find("TRANSSEQ")) == _mapData.end() ) //系统参考号
    {
        errString = "无交易流水号信息";
        return -1;
    }

	TRANSSEQ_STR = iter->second; 

	if ( (iter=_mapData.find("ORDERSEQ")) == _mapData.end() ) //订单号
    {
        errString = "无订单号信息";
        return -1;
    }

	ORDERSEQ_STR = iter->second;  
	if ( (iter=_mapData.find("TXNAMOUNT")) == _mapData.end() ) //交易金额
    {
        errString = "无交易金额信息";
        return -1;
    }
	
	TXNAMOUNT_STR= iter->second;   
	return 0;
}

/* cut 
int CTrade::show_areaDatas(vector<BUSDATAS> &datasVector,CGlobal gbl)
{
	TSMENULIST menuList;
	int iRet,iSelect;
	char menu_Name[100];
	int totalNum=0;


	bbzero(menu_Name);
	memset(&menuList,0,sizeof(menuList));
	sprintf(menuList.acTitle,"请选择水电煤交费类型");

	for(int i=0; i<datasVector.size();i++)
	{
		//获取menu_list
		sprintf(menu_Name,"%s (%s)",datasVector[i].BUSNAME,datasVector[i].PAYMENTNAME);
		totalNum++;
		strcpy(menuList.menuItem[i],menu_Name);
		
	}
	
	menuList.iTotalNum=totalNum;
	iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
	if (iRet ||iSelect==CANCLE_KEY)
	{

		return CANCLE_KEY;
	}

	if (iSelect) //按照选择给全局变量赋值
	{
		bbzero(gbl.sdm_BUSCODE);
		bbzero(gbl.sdm_BUSNAME);
		bbzero(gbl.sdm_PAYMENTCODE);
		bbzero(gbl.sdm_PAYMENTNAME);
		strcpy(gbl.sdm_BUSCODE,datasVector[iSelect].BUSCODE);
		strcpy(gbl.sdm_BUSNAME,datasVector[iSelect].BUSNAME);
		strcpy(gbl.sdm_PAYMENTCODE,datasVector[iSelect].PAYMENTCODE);
		strcpy(gbl.sdm_PAYMENTNAME,datasVector[iSelect].PAYMENTNAME);
		
	}

	return 0;

}
*/
//水电煤账单信息显示
int CTrade::showSDM_Bills(const char *type,int BILLSTAT)
{
	char temp_buff[512];
	TSTxnLogs txnLogs;
	long total_fee=0;
	int iRet;
	int index=0;
	char  delayFlag[1+1];
	char content[500];
	int content_len=0;
	char len_buffer[2+1];
	char total_fee_tmp[12+1];
	char feeCircle_tmp[8+1];
	bbzero(feeCircle_tmp);
	bbzero(total_fee_tmp);
	bbzero(content);
	bbzero(len_buffer);
	bbzero(delayFlag);
	
	memset(&txnLogs,0, sizeof(txnLogs));
	
	txnLogs.colsnum = 8;
	txnLogs.colsWidth[0] = 60;
	txnLogs.colsWidth[1] = 60;
	txnLogs.colsWidth[2] = 60;
	txnLogs.colsWidth[3] = 60;
	txnLogs.colsWidth[4] = 60;
	txnLogs.colsWidth[5] = 150;
	txnLogs.colsWidth[6] = 0;
	txnLogs.colsWidth[7] = 0;
	txnLogs.colsNameLen = 60;
	memcpy(txnLogs.colsName, "序号\x00缴费单号\x00计费周期\x00缴费金额(元)\x00滞纳金额(元)\x00收费单位\x00菜单ID\x00菜单内容", txnLogs.colsNameLen);

	bbzero(temp_buff);
	bbzero(gbl.sdm_CUSTOMERNAME);
	strcpy(gbl.sdm_CUSTOMERNAME,gbl.sdmBills.BillDetails[0].CUSTOMERNAME);
	bbzero(gbl.SDM_BILLNO);
	strcpy(gbl.SDM_BILLNO,gbl.sdmBills.BillDetails[0].BILLNO);
	sprintf(temp_buff,"用户姓名:%s 用户号码:%s",gbl.sdm_CUSTOMERNAME,gbl.sdm_SELECTVALUE);
	strcpy(txnLogs.top,temp_buff);
	bbzero(gbl.SDM_BILLMONTH);

	//显示列表信息

	for(int i =0;i <gbl.sdmBills.nCnt;i++)
	{
		char feeTmp[12+1];
		char feeCircle[20];
		long billAmount=0;
		long delayAmount=0;
		long bill_totalFee=0;
		char circle_tmp[10];
		char feeCircle_tmp[8+1];
		bbzero(feeCircle_tmp);
		bbzero(circle_tmp);
		bbzero(feeTmp);
		bbzero(feeCircle);
		char delay[12+1];
		bbzero(delay);
		billAmount=atol(gbl.sdmBills.BillDetails[i].BILLAMOUNT); //账单信息
		delayAmount=atol(gbl.sdmBills.BillDetails[i].BILLDELAY); //账单滞纳金金额
		bill_totalFee=billAmount+delayAmount; //账单总额

		if (gbl.BILLSTAT==1) //如果是多账期合并消单
		{
			total_fee+=bill_totalFee; //计算总共的金额

		}

		if (strcmp(gbl.sdmBills.BillDetails[i].BILLMONTH,"")!=0)
		{
			bbzero(feeCircle);
			strcpy(feeCircle,gbl.sdmBills.BillDetails[i].BILLMONTH);
			sprintf(feeCircle_tmp,"%s ",gbl.sdmBills.BillDetails[i].BILLMONTH);
			if (gbl.BILLSTAT==1)
			{

				strcat(gbl.SDM_BILLMONTH,feeCircle_tmp);
			}

		}

		bbzero(delay);
		long delay_amount=0;
		delay_amount=atol(gbl.sdmBills.BillDetails[i].BILLDELAY);
		CTools::longToMny(delay_amount,delay);			

		//缴费金额 
		bbzero(feeTmp);
		CTools::longToMny(billAmount,feeTmp);

		char index_tmp[2+1];
		bbzero(index_tmp);
		sprintf(index_tmp,"%02d",(index+1));
		if( txnLogs.itemsLen+strlen(index_tmp) < MAX_INTERM_BUF ) //序号
		{
			strcpy(txnLogs.items+txnLogs.itemsLen,index_tmp); 
			txnLogs.itemsLen = txnLogs.itemsLen + strlen(txnLogs.items+txnLogs.itemsLen) + 1;
			
		}
		
		else
		{
			break;
		}

		if( txnLogs.itemsLen+strlen(gbl.SDM_BILLNO) < MAX_INTERM_BUF ) //缴费单号
		{
			strcpy(txnLogs.items+txnLogs.itemsLen,gbl.SDM_BILLNO); 
			txnLogs.itemsLen = txnLogs.itemsLen + strlen(txnLogs.items+txnLogs.itemsLen) + 1;
			
		}
		
		else
		{
			break;
		}

		
		if( txnLogs.itemsLen+strlen(feeCircle) < MAX_INTERM_BUF ) //计费周期
		{
			strcpy(txnLogs.items+txnLogs.itemsLen,feeCircle); 
			txnLogs.itemsLen = txnLogs.itemsLen + strlen(txnLogs.items+txnLogs.itemsLen) + 1;
			
		}
		
		else
		{
			break;
		}
		
		if( txnLogs.itemsLen+strlen(feeTmp) < MAX_INTERM_BUF ) //缴费金额
		{
			strcpy(txnLogs.items+txnLogs.itemsLen, feeTmp); 
			txnLogs.itemsLen = txnLogs.itemsLen + strlen(txnLogs.items+txnLogs.itemsLen) + 1;
			
		}
		
		else
		{
			break;
		}
		
		if( txnLogs.itemsLen+strlen(delay) < MAX_INTERM_BUF ) //滞纳金额
		{
			strcpy(txnLogs.items+txnLogs.itemsLen, delay); 
			txnLogs.itemsLen = txnLogs.itemsLen + strlen(txnLogs.items+txnLogs.itemsLen) + 1;
			
		}
		
		else
		{
			break;
		}
		
		if( txnLogs.itemsLen+strlen(gbl.sdm_PAYMENTNAME) < MAX_INTERM_BUF ) //收费单位
		{
			strcpy(txnLogs.items+txnLogs.itemsLen, gbl.sdm_PAYMENTNAME); 
			txnLogs.itemsLen = txnLogs.itemsLen + strlen(txnLogs.items+txnLogs.itemsLen) + 1;
			
		}
		
		else
		{
			break;
		}

	
		if( txnLogs.itemsLen+strlen("684") < MAX_INTERM_BUF ) //缴费菜单 change from 684 to 788
		
			{

				strcpy(txnLogs.items+txnLogs.itemsLen, "684"); 
				txnLogs.itemsLen = txnLogs.itemsLen + strlen("684") + 1;
			
			}
		
			else
			{

				break;
			}


			if( txnLogs.itemsLen+strlen(index_tmp) < MAX_INTERM_BUF ) //缴费菜单 change from 684 to 788
				
			{
				
				strcpy(txnLogs.items+txnLogs.itemsLen, index_tmp); 
				txnLogs.itemsLen = txnLogs.itemsLen + strlen(index_tmp) + 1;
				
			}
			
			else
			{
				
				break;
			}

		index ++;
	}

	if (gbl.BILLSTAT==1)
	{

	 char mny_temp[12+1];
	 bbzero(mny_temp);
	 bbzero(gbl.amount);
	 CTools::longToMny(total_fee,mny_temp);
	 CTools::chg12asc(mny_temp,gbl.amount);

	}
	else
	{
	
		int  currentAmount=atoi(gbl.sdmBills.BillDetails[0].BILLAMOUNT);
		int  currrentDelay=atoi(gbl.sdmBills.BillDetails[0].BILLDELAY);
		int current_total=currentAmount+currrentDelay;
		sprintf(gbl.amount,"%0.12d",current_total);
		bbzero(gbl.SDM_BILLMONTH);
		strcpy(gbl.SDM_BILLMONTH,gbl.sdmBills.BillDetails[0].BILLMONTH);
		
	}

	if (BILLSTAT==1) //如果是合并账单
	{

		sprintf(txnLogs.hint," 当前缴费账期:%s 当前应付金额:%.2f元",gbl.SDM_BILLMONTH,atof(gbl.amount)/100) ;
		sprintf(txnLogs.bottom," 本次缴费为多账期合并缴费  【是 Enter】 【否 Esc】") ;

	}
	else //如果是顺序销账
	{
	
		sprintf(txnLogs.hint," 当前缴费账期:%s   当前应付金额:%.2f元",gbl.SDM_BILLMONTH,atof(gbl.amount)/100);
		sprintf(txnLogs.bottom," 本次缴费为单个账期并非合并缴费  【是 Enter】 【否 Esc】") ;
	}

	iRet=TS_ShowTxnLogs(gbl.dPosInfo,&txnLogs);
	if (iRet!=0)
	{
		wrLog("TS_ShowTxnLogs返回错误[%d]", iRet); 
		return -1;
	}

	return iRet;
	
}


//查询银行信息
int CTrade::getBankInfoService(char * WEBSVRNAME,char *WEBSVRCODE,char *staff_code,char *CUSTCODE)
{
	//受理时间:
	char server_time[14+1];
	string strReq0,strReq1;
	int iRet;
	string strerr="";
	string rsp_code="";
	char keep[32+1];
	char orderNo[32+1];

	char strReqTmp[100];
	char APPFROMTmp[50];

	bbzero(APPFROMTmp);
	bbzero(strReqTmp);
	bbzero(orderNo);
	bbzero(strReqTmp);
	bbzero(strReqTmp);
	bbzero(keep);
	string strRsp="";
	bbzero(server_time);
	map<string, string>::iterator iter;
	map<string, string> _mapData;
	map<string, string> _pack_mapData;

	sprintf(strReqTmp,"%s|440100--001-%s|APP001|%s|",WEBSVRCODE,gbl.server_ip,gbl.server_ip);
	sprintf(APPFROMTmp,"440100-APP001-APP001001-%s",gbl.server_ip);
	strReq0.assign(strReqTmp,strlen(strReqTmp));
	strReq0.assign(strReqTmp,strlen(strReqTmp));


	bbzero(keep);
	//CTools::get_keep(keep);
	CTools::get_keep(gbl.pos_no,keep);
	CTools::get_termTime(server_time);
	CTools::get_orderNo(orderNo);
	_pack_mapData.insert(pair<string,string> ("MERID",MERID));
	_pack_mapData.insert(pair<string,string>("CHANNELCODE",CHANNELCODE));
	_pack_mapData.insert(pair<string,string>("TMNNUM",TMNNUM));
	_pack_mapData.insert(pair<string,string>("SIGN","SIGN"));
	_pack_mapData.insert(pair<string,string>("CER","CER"));
	_pack_mapData.insert(pair<string,string>("WEBSVRNAME",WEBSVRNAME));
	_pack_mapData.insert(pair<string,string>("WEBSVRCODE",WEBSVRCODE));
	_pack_mapData.insert(pair<string,string>("APPFROM",APPFROMTmp));
	_pack_mapData.insert(pair<string,string>("KEEP",keep));
	_pack_mapData.insert(pair<string,string>("REQUESTTIME",server_time));
	_pack_mapData.insert(pair<string, string>("STAFFCODE",staff_code)); //平台数据
	
	wrLog("strReq0:%s",strReq0.c_str());
	CxmlParser::pack(WEBSVRCODE,strReq1,_pack_mapData,strerr);

	iRet=ks_soap::get_response(TRADE_FLAG,strReq0,strReq1,strRsp,strerr);

	if (iRet!=0)
	{
			strerr="";
			strerr = "网络繁忙，请稍后再试";
			return -4;
	}
	
	iRet=CxmlParser::unpack(strRsp,WEBSVRCODE,_mapData,strerr);
	if (iRet!=0)
	{
		strerr="";
		strerr = "报文解析失败,请稍后再试";
		return -1;
	}

	if ( (iter=_mapData.find("RSPCODE")) == _mapData.end() )
	{
		strerr="";
		strerr = "查询失败,请稍后再试";
        return -1;
    }
	

	return 0;
	
}

//车船税查询
int CTrade::carTax_query_service(CGlobal gbl,char *WEBSVRNAME,char *WEBSVRCODE,int *billNum,char *sdm_SYSTEMNO,string &strerr)
{
	//受理时间:
	char server_time[14+1];
	string strReq0,strReq1;
	int iRet;
	string BILLNUM;
	strerr="";
	string rsp_code="";
	char keep[32+1];
	char orderNo[32+1];
	bbzero(orderNo);
	char strReqTmp[100];
	bbzero(strReqTmp);
	bbzero(strReqTmp);
	char APPFROMTmp[50];
	bbzero(APPFROMTmp);
	bbzero(strReqTmp);
	sprintf(strReqTmp,"%s|440100--001-%s|APP001|%s|",WEBSVRCODE,gbl.server_ip,gbl.server_ip);
	sprintf(APPFROMTmp,"440100-APP001-APP001001-%s",gbl.server_ip);
	strReq0.assign(strReqTmp,strlen(strReqTmp));
	strReq0.assign(strReqTmp,strlen(strReqTmp));
	bbzero(keep);
	string strRsp="";
	string SYSTEMNO="";
	string datas;
	bbzero(server_time);
	map<string, string>::iterator iter;
	map<string, string> _mapData;
	map<string, string> _pack_mapData;
	bbzero(keep);
	//CTools::get_keep(keep);
	CTools::get_keep(gbl.pos_no,keep);
	CTools::get_termTime(server_time);
	CTools::get_orderNo(orderNo);
	_pack_mapData.insert(pair<string,string> ("MERID",MERID));
	_pack_mapData.insert(pair<string,string>("CHANNELCODE",CHANNELCODE));
	_pack_mapData.insert(pair<string,string>("TMNNUM",TMNNUM));
	_pack_mapData.insert(pair<string,string>("SIGN","SIGN"));
	_pack_mapData.insert(pair<string,string>("CER","CER"));
	_pack_mapData.insert(pair<string,string>("WEBSVRNAME",WEBSVRNAME));
	_pack_mapData.insert(pair<string,string>("WEBSVRCODE",WEBSVRCODE));
	_pack_mapData.insert(pair<string,string>("APPFROM",APPFROMTmp));
	_pack_mapData.insert(pair<string,string>("KEEP",keep));
	_pack_mapData.insert(pair<string,string>("REQUESTTIME",server_time));

	_pack_mapData.insert(pair<string, string>("ORDERSEQ",orderNo)); //平台数据
	_pack_mapData.insert(pair<string,string> ("TMNNUMNO",gbl.pos_no));
	_pack_mapData.insert(pair<string,string> ("PLATENO",gbl.car_no)); //车牌号
	_pack_mapData.insert(pair <string,string>("ENGINENO",gbl.engine_no));
	_pack_mapData.insert(pair<string,string> ("ACCEPTDATE",server_time));//受理时间
	
	wrLog("strReq0:%s",strReq0.c_str());
	CxmlParser::pack(WEBSVRCODE,strReq1,_pack_mapData,strerr);

	iRet=ks_soap::get_response(TRADE_FLAG,strReq0,strReq1,strRsp,strerr);

	if (iRet!=0)
	{
			strerr="";
			strerr = "网络繁忙，请稍后再试";
			return -4;
	}
	
	iRet=CxmlParser::unpack(strRsp,WEBSVRCODE,_mapData,strerr);
	if (iRet!=0)
	{
		strerr="";
		strerr = "报文解析失败,请稍后再试";
		return -1;
	}

	if ( (iter=_mapData.find("RSPCODE")) == _mapData.end() ) //清结算终端
	{
		strerr="";
		strerr = "查询失败,请稍后再试";
        return -1;
    }
	
	rsp_code=iter->second;
	if (strcmp(rsp_code.c_str(),"000000")!=0)
	{
		strerr="";
		strerr = "查询失败，请稍后再试";
		return -1;
	}
	
	if ( (iter=_mapData.find("SYSTEMNO")) == _mapData.end() ) //系统参考号
    {
        strerr = "无SYSTEMNO信息";
        return -1;
    }
	SYSTEMNO = iter->second; 
	strcpy(sdm_SYSTEMNO,SYSTEMNO.c_str());
	wrLog("sdm_SYSTEMNO:%s",sdm_SYSTEMNO);
	
	if ( (iter=_mapData.find("DATAS")) == _mapData.end() )
    {
        strerr = "无订单详情";
        return -1;
    }
	
    datas = iter->second;  
	wrLog("账单查询datas:%s",datas.c_str());
	
	if ( (iter=_mapData.find("BILLNUM")) == _mapData.end() )
    {
        strerr = "无账单数";
        return -1;
    }
	
    BILLNUM = iter->second;  
	*billNum=atoi(BILLNUM.c_str());
	wrLog("datas:%s",datas.c_str());
	iRet=CxmlParser::getCardTaxBills(datas,gbl);
	if (iRet!=0)
	{
		strerr="解析记录错误";
		return -1;
	}

	return 0;
	
}


//支付方式为3，授权银行卡扣
int CTrade::carTax_pay_service(char *WEBSVRNAME,char *WEBSVRCODE,char *PAYTYPE,char *operUser,char *password,char *SYSTEMNO,string &strerr)
{
	//受理时间:
	char server_time[14+1];
	string strReq0,strReq1;
	int iRet;
	string BILLNUM;
	string SYSTEMNO_STR="";
	strerr="";
	string strRsp="";
	string datas;
	string rsp_code="";
	bbzero(server_time);
	char keep[32+1];
	char orderNo[32+1];
	char psam_temp[16+1];

	bbzero(keep);
	bbzero(orderNo);
	bbzero(psam_temp);
	CTools::byte_to_hex((BYTE*)gbl.posInfo.psamNum, (BYTE*)psam_temp, 8);

	map<string, string>::iterator iter;
	map<string, string> _mapData;
	map<string, string> _pack_mapData;
	
	char strReqTmp[100];
	bbzero(strReqTmp);
	char APPFROMTmp[50];
	bbzero(APPFROMTmp);
	sprintf(strReqTmp,"%s|440100-APP001-001-%s|APP001|%s|",WEBSVRCODE,gbl.server_ip,gbl.server_ip);
	sprintf(APPFROMTmp,"440100-APP001-001-%s",gbl.server_ip);
	strReq0.assign(strReqTmp,strlen(strReqTmp));

	CTools::get_termTime(server_time);
	bbzero(keep);
	CTools::get_keep(gbl.pos_no,keep);
	CTools::get_orderNo(orderNo);

	_pack_mapData.insert(pair<string,string> ("MERID",MERID));
	_pack_mapData.insert(pair<string,string>("CHANNELCODE",CHANNELCODE));
	_pack_mapData.insert(pair<string,string>("TMNNUM",TMNNUM));
	_pack_mapData.insert(pair<string,string>("SIGN","SIGN"));
	_pack_mapData.insert(pair<string,string>("CER","CER"));
	_pack_mapData.insert(pair<string,string>("WEBSVRNAME",WEBSVRNAME));
	_pack_mapData.insert(pair<string,string>("WEBSVRCODE",WEBSVRCODE));
	_pack_mapData.insert(pair<string,string>("APPFROM",APPFROMTmp));
	_pack_mapData.insert(pair<string,string>("KEEP",keep));
	_pack_mapData.insert(pair<string,string>("REQUESTTIME",server_time));
	
	_pack_mapData.insert(pair<string, string>("ORDERSEQ",orderNo)); //平台数据
	_pack_mapData.insert(pair<string,string> ("TMNNUMNO",gbl.pos_no));//终端号
	_pack_mapData.insert(pair<string,string> ("ECARDNO",gbl.card_no));//E卡
	_pack_mapData.insert(pair<string,string> ("PASSFLAG","2"));//密码类型
	_pack_mapData.insert(pair<string,string> ("PSAMCARDNO",psam_temp));//psam卡号

	_pack_mapData.insert(pair<string,string> ("ACCEPTDATE",server_time));//受理时间
	_pack_mapData.insert(pair<string,string> ("SYSTEMNO",SYSTEMNO));//系统参考号
	_pack_mapData.insert(pair<string,string> ("TXNAMOUNT",gbl.amount));//缴费金额
	_pack_mapData.insert(pair<string,string> ("SYSTEMNO",gbl.amount));//缴费金额
	_pack_mapData.insert(pair<string,string> ("PLATENO",gbl.car_no)); //车牌号
	_pack_mapData.insert(pair<string,string> ("PAYTYPE",PAYTYPE)); //车牌号
	_pack_mapData.insert(pair<string,string> ("OPERUSER",operUser)); //操作员
	_pack_mapData.insert(pair<string,string> ("OPERPASSWORD",password)); //密码
	_pack_mapData.insert(pair<string,string> ("PAYTYPE",PAYTYPE)); //支付方式 
	
	CxmlParser::pack(WEBSVRCODE,strReq1,_pack_mapData,strerr);

	iRet=ks_soap::get_response(TRADE_FLAG,strReq0,strReq1,strRsp,strerr);

	if (iRet!=0)
	{
		
		
		//TS_OutPutMsg(gbl.dPosInfo,"连接服务器错误，请稍后再试!",0,iSelect);
		strerr="";
		strerr = "网络繁忙，请稍后再试";
		return -4;

	}
	
	iRet=CxmlParser::unpack(strRsp,WEBSVRCODE,_mapData,strerr);
	if (iRet!=0)
	{
		strerr="";
		strerr = "报文解析失败,请稍后再试";
		return -1;
	}
	if ( (iter=_mapData.find("RSPCODE")) == _mapData.end() ) //清结算终端
	{
		strerr="";
		strerr = "查询失败,请稍后再试";
        return -1;
    }
	
	rsp_code=iter->second;
	if (strcmp(rsp_code.c_str(),"000000")!=0)
	{
		strerr="";
		strerr = "查询失败，请稍后再试";
		return -1;
	}
	
	if ( (iter=_mapData.find("SYSTEMNO")) == _mapData.end() ) //系统参考号
    {
        strerr = "无SYSTEMNO信息";
        return -1;
    }

	SYSTEMNO_STR = iter->second; 
	strcpy(SYSTEMNO,SYSTEMNO_STR.c_str());
	wrLog("SYSTEMNO:%s",SYSTEMNO);
	
	return 0;
	
}


int CTrade::sdm_handle(char * title)
{

	int iRet;
	int iSelect;
	char showMsg[500];
	bbzero(showMsg);
	iRet=sdm_qury_input(title);
	if (iRet!=0)
	{
		return CANCLE_KEY;
	}
	queryNext:
	iRet=sdm_query_handle(title);

	if (iRet!=0)
	{
		return -1;
	}

	iRet=sdm_pay_handle(title);

	if (iRet!=0)
	{
		return -1;

	}
	else
	{
		
			if ( (gbl.BILLSTAT==2 || gbl.BILLSTAT==3) && gbl.billNum >0)
			{
				sprintf(showMsg,"业务已受理!\n系统参考号:%s\n收费单位:%s\n账  期:%s\n客户姓名:%s\n缴费金额:%.2f元\n 本次缴费为单个账期，如需缴纳下个账期，请选择继续 \n【Esc】 继续  【Enter】打印凭条  ",gbl.stan_no,gbl.sdm_PAYMENTNAME,gbl.SDM_BILLMONTH,gbl.sdm_CUSTOMERNAME,atof(gbl.amount)/100);
				iRet=TS_OutPutMsg(gbl.dPosInfo,showMsg,0,iSelect);
				
				if (iSelect==CANCLE_KEY)
				{
				
					goto queryNext;

				}
				else if (iSelect==0)
				{
					CPrint print;
					print.set_in_par(gbl);
					print.print_sdm_detail(title);

					bbzero(showMsg);
					sprintf(showMsg,"本次缴费为单个账期，如需缴纳下个账期，请选择继续 \n【是 Enter】 【否 Esc】");
					TS_OutPutMsg(gbl.dPosInfo,showMsg,0,iSelect);
					if (iSelect==0)
					{
						goto queryNext;
					}
					else
					{
					
						return 0;
					}
					
				}
				else
				{
					
					return -1;
				}
				
			}
			else
			{
				sprintf(showMsg,"业务已受理!\n系统参考号:%s\n收费单位:%s\n账  期:%s\n客户姓名:%s\n缴费金额:%.2f元\n \n【Esc】 返回  【Enter】打印凭条 ",gbl.stan_no,gbl.sdm_PAYMENTNAME,gbl.SDM_BILLMONTH,gbl.sdm_CUSTOMERNAME,atof(gbl.amount)/100);
				iRet=TS_OutPutMsg(gbl.dPosInfo,showMsg,0,iSelect);
				wrLog("iSelect:%d",iSelect);
				if (iRet!=0)
				{
					return -1;
				}
				else
				{
					CPrint print;
					print.set_in_par(gbl);
					print.print_sdm_detail(title);
				}

			}

	}
	
	return 0;

}


int CTrade::sdm_qury_input(char * title)
{

	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	int iRet;
	char content[200+1];
	int content_len=0;
	char len_tmp[2+1];
	bbzero(len_tmp);
	bbzero(gbl.amount); //实际交易金额
	bbzero(gbl.SDM_BILLMONTH);// 水电煤缴费金额
	bbzero(gbl.sdm_CUSTOMERNAME); //水电煤客户姓名


	//输入用户号码 。上海水和煤要求输入查询金额 进行账单查询
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	strcpy(tradeInfoSend.acMainTitle, "水电煤交费项目查询");
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents =1 ;
	strcpy(tradeInfoSend.Contents[0].acTitle,"请输入查询内容");
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;
	tradeInfoSend.Contents[0].uCount = 0;
	tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME + 30;
	tradeInfoSend.Contents[0].uMinLen = 4;
	tradeInfoSend.Contents[0].uMaxLen = 100;
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		return iRet;
	}

	bbzero(gbl.pos_serial);
	strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
	bbzero(content);
	content_len=0;
	memcpy(content, (char *)tradeInfoRecv.Contents[0].uMsg, tradeInfoRecv.Contents[0].uMsgLen);
	//解析content 
	bbzero(gbl.sdm_BUSNAME);
	bbzero(gbl.sdm_PAYMENTNAME);
	bbzero(gbl.sdm_PAYMENTCODE);
	bbzero(gbl.AREACODE);
	bbzero(gbl.PARENT_CODE);
	bbzero(gbl.sdm_BUSCODE);
	
	bbzero(len_tmp);
	memcpy(len_tmp,content+content_len,2);
	content_len+=2;
	memcpy(gbl.sdm_PAYMENTCODE,content+content_len,atoi(len_tmp));
	content_len+=atoi(len_tmp);

	memcpy(gbl.sdm_BUSCODE,content+content_len,3);
	content_len+=3;
	bbzero(len_tmp);
	memcpy(len_tmp,content+content_len,2);
	content_len+=2;
	memcpy(gbl.sdm_PAYMENTNAME,content+content_len,atoi(len_tmp));
	content_len+=atoi(len_tmp);
	bbzero(len_tmp);
	memcpy(len_tmp,content+content_len,2);
	content_len+=2;
	memcpy(gbl.sdm_BUSNAME,content+content_len,atoi(len_tmp));

	memcpy(gbl.AREACODE,gbl.sdm_PAYMENTCODE+6,6);
	memcpy(gbl.PARENT_CODE,gbl.PARENT_CODE,6);
	wrLog("水电煤账单查询");
	wrLog("gbl.sdm_PAYMENTCODE:%s",gbl.sdm_PAYMENTCODE);
	wrLog("gbl.sdm_PAYMENTNAME:%s",gbl.sdm_PAYMENTNAME);
	wrLog("gbl.AREACODE:%s",gbl.AREACODE);
	wrLog("gbl.sdm_BUSCODE:%s",gbl.sdm_BUSCODE);
	wrLog("gbl.sdm_BUSNAME:%s",gbl.sdm_BUSNAME);

	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	strcpy(tradeInfoSend.acMainTitle, "水电煤账单查询");

	if (memcmp(gbl.sdm_PAYMENTCODE,"3100003101001",13)==0 && memcmp(gbl.sdm_PAYMENTCODE,"3100003101003",13)==0 ) //如果是上海水和煤气
		
	{
		
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents =2 ; //菜单项为2

		strcpy(tradeInfoSend.Contents[0].acTitle,"请输入用户号");
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;
		tradeInfoSend.Contents[0].uCount = 0;
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME + 30;
		tradeInfoSend.Contents[0].uMinLen = 4;
		tradeInfoSend.Contents[0].uMaxLen = 64;
		
		strcpy(tradeInfoSend.Contents[1].acTitle,"请输入缴费金额");
		tradeInfoSend.Contents[1].uCommand = TS_INPUT_MONEY;
		tradeInfoSend.Contents[1].uCount = 0;
		tradeInfoSend.Contents[1].uTimeOut = EPOS_OVER_TIME + 30;
		tradeInfoSend.Contents[1].uMinLen = 1;
		tradeInfoSend.Contents[1].uMaxLen = 8;

		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		if(iRet != 0)
		{
			wrLog("TS_TradeControl返回错误[%d]", iRet);
			return iRet;
		}
		
		bbzero(gbl.pos_serial);
		strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
		
		bbzero(gbl.sdm_SELECTVALUE);
		strcpy(gbl.sdm_SELECTVALUE,(char *)tradeInfoRecv.Contents[1].uMsg) ;
		bbzero(gbl.query_amy);
		strcpy(gbl.query_amy,(char *)tradeInfoRecv.Contents[2].uMsg );//注意金额格式
	}
	
	else
	{
		tradeInfoSend.uHasTradeID = 1;
		tradeInfoSend.uTotalContents =1 ;
		
		strcpy(tradeInfoSend.Contents[0].acTitle,"请输入用户号");
		tradeInfoSend.Contents[0].uCommand = TS_INPUT_ALL_CHAR;
		tradeInfoSend.Contents[0].uCount = 0; 
		tradeInfoSend.Contents[0].uTimeOut = EPOS_OVER_TIME + 30;
		tradeInfoSend.Contents[0].uMinLen = 4;
		tradeInfoSend.Contents[0].uMaxLen = 64;
		
		iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
		if(iRet != 0)
		{
			wrLog("TS_TradeControl返回错误[%d]", iRet);
			return iRet;
		}
		
		bbzero(gbl.pos_serial);
		strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
		//解析content 内容需要账单查询的值 PAYMENTCODE(16)+BUSCODE(3)+strlen(PAYMENTNAME)+PAYMENTNAME(128)+strlen(BUSNAME)+BUSNAME(64+1)
		
		bbzero(gbl.sdm_SELECTVALUE);
		CTools::trim(gbl.sdm_SELECTVALUE);
		strcpy(gbl.sdm_SELECTVALUE,(char *)tradeInfoRecv.Contents[0].uMsg );
		bbzero(gbl.query_amy);
		strcpy(gbl.query_amy,"000000000000"); 
		
	}

	return 0;

}


int CTrade::sdm_query_handle(char *title)
{
	
	char billDetails[500];
	bbzero(gbl.sdm_SYSTEMNO);
	char content_temp[100];
	char bottom[100];
	string errString="";
	int iSelect,iRet ;

	char billMonth_temp[10+1];
	long  billAmount=0,delayAmount=0,totalAmount=0;
	bbzero(bottom);
	bbzero(billMonth_temp);
	iRet=sdm_query_service("账单查询接口","INF06003","001",gbl.sdm_SYSTEMNO,&gbl.billNum,&gbl.BILLSTAT,errString); //用户手册号码,账单详情
	wrLog("账单缴费类型:%d",gbl.BILLSTAT);
	
	if (iRet!=0)
	{
		TS_OutPutMsg(gbl.dPosInfo,(char *)errString.c_str(),0,iSelect); //显示错误信息
		return CANCLE_KEY;
	}
	

	if (gbl.billNum>3) // 如果水电煤账单期数大约3，则用列表显示。 for test ..>2显示
	{
		iRet=showSDM_Bills(title,gbl.BILLSTAT);
		//再发一次确认信息 用户缴费确认信息
		if (iRet!=0)
		{
			TS_OutPutMsg(gbl.dPosInfo,"无账期信息",0,iSelect);
			return CANCLE_KEY;
		}

		bbzero(billDetails);
		if (gbl.BILLSTAT==2 || gbl.BILLSTAT==3)
		{
			sprintf(billDetails,"本次缴费为单个账期并非合并缴费\n当前缴费账期:%s\n当前应付金额:%.2f元\n\n请确认缴费信息 【是Enter】【否Esc】",gbl.SDM_BILLMONTH,atof(gbl.amount)/100);
		}
		else
		{

			sprintf(billDetails,"\n本次缴费为多账期合并缴费\n当前缴费账期:%s\n当前应付金额:%.2f元\n\n请确认缴费信息 【是Enter】【否Esc】",gbl.SDM_BILLMONTH,atof(gbl.amount)/100);
	
		}
	
		TS_OutPutMsg(gbl.dPosInfo,billDetails,0,iSelect);
		if (iSelect!=0)
		{

			return CANCLE_KEY;
		}
	}
	else //在界面上面显示缴费信息

	{
		bbzero(gbl.sdm_CUSTOMERNAME);
		strcpy(gbl.sdm_CUSTOMERNAME,gbl.sdmBills.BillDetails[0].CUSTOMERNAME);
		bbzero(billDetails);
		sprintf(billDetails,"收费单位:%s\n客户姓名:%s\n\n",gbl.sdm_PAYMENTNAME,gbl.sdm_CUSTOMERNAME);
		bbzero(gbl.SDM_BILLNO);
		strcpy(gbl.SDM_BILLNO,gbl.sdmBills.BillDetails[0].BILLNO);

		for (int i=0;i<gbl.sdmBills.nCnt;i++) //显示并统计账期和实付余额
		{
			bbzero(content_temp);
			sprintf(content_temp,"账  期:%s  当前欠费:%.2f元\n滞纳金:%.2f元\n\n",gbl.sdmBills.BillDetails[i].BILLMONTH,atof(gbl.sdmBills.BillDetails[i].BILLAMOUNT)/100,atof(gbl.sdmBills.BillDetails[i].BILLDELAY)/100);
			strcat(billDetails,content_temp);
			
			//统计账期，并显示界面信息。
	
			 if (gbl.BILLSTAT==1 || gbl.BILLSTAT==0) //多账期一笔消 计算总的交易
			{
				bbzero(billMonth_temp);
				sprintf(billMonth_temp,"%s ",gbl.sdmBills.BillDetails[i].BILLMONTH); //显示账单信息
				strcat(gbl.SDM_BILLMONTH,billMonth_temp);
				billAmount=atof(gbl.sdmBills.BillDetails[i].BILLAMOUNT);
				delayAmount=atof(gbl.sdmBills.BillDetails[i].BILLDELAY);
				totalAmount+=billAmount+delayAmount;

			}


		}

		if (gbl.BILLSTAT==2 || gbl.BILLSTAT==3) //多账单 ,默认按照月份顺序销账
		{

			bbzero(gbl.SDM_BILLMONTH);
			strcpy(gbl.SDM_BILLMONTH,gbl.sdmBills.BillDetails[0].BILLMONTH);
			billAmount=atof(gbl.sdmBills.BillDetails[0].BILLAMOUNT);
			delayAmount=atof(gbl.sdmBills.BillDetails[0].BILLDELAY);
			totalAmount+=billAmount+delayAmount;
			sprintf(gbl.amount,"%0.12d",totalAmount);
			bbzero(bottom);
			sprintf(bottom,"本次缴费为单个账期并非合并缴费\n当前缴费账期:%s\n当前应付金额:%.2f元\n【是 Enter】  【否 Esc】",gbl.SDM_BILLMONTH,atof(gbl.amount)/100);
			
		}
		else if (gbl.BILLSTAT==1) //多笔账单 ，一次销账。
		{
			bbzero(gbl.amount);
			sprintf(gbl.amount,"%0.12d",totalAmount);
			bbzero(bottom);
			sprintf(bottom,"本次缴费为多账期合并缴费\n当前缴费账期:%s\n当前应付金额:%.2f元\n【是 Enter】  【否 Esc】",gbl.SDM_BILLMONTH,atof(gbl.amount)/100);
			
		}
		else //单账期
		{
			
			bbzero(bottom);
			bbzero(gbl.amount);
			sprintf(gbl.amount,"%0.12d",totalAmount);
			wrLog("gbl.amount:%s",gbl.amount);
			sprintf(bottom,"本次缴费为单个账期缴费\n当前缴费账期:%s\n当前应付金额:%.2f元\n【是 Enter】  【否 Esc】",gbl.SDM_BILLMONTH,atof(gbl.amount)/100);
			
		}

		strcat(billDetails,bottom);
		TS_OutPutMsg(gbl.dPosInfo,billDetails,0,iSelect);

		if (iSelect!=0)
		{
			return CANCLE_KEY;

		}

	}

	return 0;

}

//缴费查询
int CTrade::sdm_pay_handle(char *title)
{

	char content[500+1];
	int content_len=0;
	char len_tmp[2+1];
	int len=0;
	int iRet;
	string dataStr;
	string errString; //错误码
	string RSP_String; //返回码
	int iSelect;
	bbzero(content);
	bbzero(len_tmp);

	wrLog("姓名:%s",gbl.sdm_CUSTOMERNAME);
	wrLog("用户号:%s",gbl.sdm_SELECTVALUE);
	wrLog("缴费单位:%s",gbl.sdm_PAYMENTNAME);
	wrLog("系统参考号:%s",gbl.sdm_SYSTEMNO);
	wrLog("销账单号:%s",gbl.SDM_BILLNO);
	wrLog("缴费金额:%s",gbl.amount);
	wrLog("账期:%s",gbl.SDM_BILLMONTH);
	wrLog("销账类型:%d",gbl.BILLSTAT);

	//进行缴费
	iRet=sdm_pay(title,gbl.amount,gbl.SDM_BILLMONTH,gbl.BILLSTAT,errString);

	if (iRet!=0)
	{
		if (iRet==CANCLE_KEY)
		{
			return CANCLE_KEY;
		}
		else
		{
		
			char errMsg[500+1];
			bbzero(errMsg);
			memcpy(errMsg,errString.c_str(),500);
			TS_OutPutMsg(gbl.dPosInfo,errMsg,0,iSelect); //显示错误信息

			return -1;

		}
	


	}

	ecardInqHdl();
	return 0;
}

//3G流量卡扣费
int CTrade::g3DisChargeCard_pay_service(CGlobal gbl,char *WEBSVRNAME,char *WEBSVRCODE,char *RECHARGETYPE,char *isVerify,char *operUser,char *password,char *SYSTEMNO,string &rspcode,string &strerr)
{
	//受理时间:
	char server_time[14+1];
	string strReq0,strReq1;
	int iRet;
	string BILLNUM;
	string SYSTEMNO_STR="";
	strerr="";
	string strRsp="";
	string rsp_code="";
	string datas;
	bbzero(server_time);
	char keep[32+1];
	bbzero(keep);
	char psam_temp[16+1];
	char orderNo[32+1];

	bbzero(orderNo);
	bbzero(psam_temp);
	CTools::byte_to_hex((BYTE*)gbl.posInfo.psamNum, (BYTE*)psam_temp, 8);
	
	map<string, string>::iterator iter;
	map<string, string> _mapData; //返回的数据
	map<string, string> _pack_mapData; //发送的数据
	
	char strReqTmp[100];
	bbzero(strReqTmp);
	char APPFROMTmp[50];
	bbzero(APPFROMTmp);
	sprintf(strReqTmp,"%s|440100-APP001-001-%s|APP001|%s|",WEBSVRCODE,gbl.server_ip,gbl.server_ip);
	sprintf(APPFROMTmp,"440100-APP001-001-%s",gbl.server_ip);
	strReq0.assign(strReqTmp,strlen(strReqTmp));
	CTools::get_termTime(server_time);
	bbzero(keep);
	//CTools::get_keep(keep);
	CTools::get_keep(gbl.pos_no,keep);
	CTools::get_orderNo(orderNo);
	_pack_mapData.insert(pair<string,string> ("MERID",MERID));
	_pack_mapData.insert(pair<string,string>("CHANNELCODE",CHANNELCODE));
	_pack_mapData.insert(pair<string,string>("TMNNUM",TMNNUM));
	_pack_mapData.insert(pair<string,string>("SIGN","SIGN"));
	_pack_mapData.insert(pair<string,string>("CER","CER"));
	_pack_mapData.insert(pair<string,string>("WEBSVRNAME",WEBSVRNAME));
	_pack_mapData.insert(pair<string,string>("WEBSVRCODE",WEBSVRCODE));
	_pack_mapData.insert(pair<string,string>("APPFROM",APPFROMTmp));
	_pack_mapData.insert(pair<string,string>("KEEP",keep));
	_pack_mapData.insert(pair<string,string>("REQUESTTIME",server_time));
	
	_pack_mapData.insert(pair<string, string>("ORDERNO",orderNo)); //平台数据  订单号
	_pack_mapData.insert(pair<string,string> ("TMNNUMNO",gbl.pos_no)); //客户终端号
	_pack_mapData.insert(pair<string,string> ("ECARDNO",gbl.card_no)); //E卡号
	_pack_mapData.insert(pair<string,string> ("PASSFLAG","2")); //密码类型
	_pack_mapData.insert(pair<string,string> ("PSAMCARDNO",psam_temp)); //PSAM卡号
	_pack_mapData.insert(pair<string,string> ("STAFFCODE",operUser)); //用户名
	_pack_mapData.insert(pair<string,string> ("PAYPASSWORD",password)); //交易密码
	_pack_mapData.insert(pair<string,string> ("RECHARGETYPE",RECHARGETYPE)); //充值类型 001：直充  (目前只支持直充)002：常规卡003：促销卡
	_pack_mapData.insert(pair<string,string> ("VERIFY",isVerify)); //是否验证手机
	_pack_mapData.insert(pair<string,string> ("PHONE",gbl.phone_no)); //充入手机号
	_pack_mapData.insert(pair<string,string> ("RECHARGEFLOW",gbl.RECHARGEFLOW)); //充入流量
	_pack_mapData.insert(pair<string,string> ("TXNAMOUNT",gbl.amount)); //订单金额
	//_pack_mapData.insert(pair<string,string> ("ACCEPTAREACODE","440100") ); //受理地区编码，默认为企业账户地区编码
	_pack_mapData.insert(pair<string,string> ("TRADETIME",server_time));//受理时间
	_pack_mapData.insert(pair<string,string> ("SYSTEMNO",gbl.SYSTEMNO));//系统参考号

	wrLog("strReq0:%s",strReq0.c_str());
	CxmlParser::pack(WEBSVRCODE,strReq1,_pack_mapData,strerr);

	iRet=ks_soap::get_response(TRADE_FLAG,strReq0,strReq1,strRsp,strerr);
	
	if (iRet!=0)
	{
		
		//TS_OutPutMsg(gbl.dPosInfo,"连接服务器错误，请稍后再试!",0,iSelect);
			strerr="";
			strerr = "交易超时，请进入商户自服务门户查询交易结果!";
			return -4;
	//	return CANCLE_KEY;
	}
	
	iRet=CxmlParser::unpack(strRsp,WEBSVRCODE,_mapData,strerr);
	if (iRet!=0)
	{
		strerr="";
		strerr = "报文解析失败，请稍后再试";
        return -4;

	} 

	if ( (iter=_mapData.find("RSPCODE")) == _mapData.end() ) //清结算终端
	{
		strerr="";
		strerr = "查询失败,请稍后再试";
        return -4;
    }
	
	rsp_code=iter->second;
	if ("000000" != rsp_code)
	{
		strerr="";
		//对响应码011007进行处理
		/*
		if ("011007" == rsp_code)
		{
			strerr = "处理中,请进入商户自服务门户查询交易结果!\n如有疑问，请咨询在线客服或致电客服400-80-11888";
			return -1;

		}
		else
		*/
		//{
		
			if ( (iter=_mapData.find("RSPMSG")) == _mapData.end() ) //错误信息
			{
				strerr = "交易失败,请进入商户自服务门户查询交易结果!\n如有疑问，请咨询在线客服或致电客服400-80-11888";
				return -3;
			}
			
			strerr="交易失败 ";
			strerr  += iter->second; 
			return -3;
	//	}
	}

	
	if ( (iter=_mapData.find("TRANSSEQ")) == _mapData.end() ) //系统参考号
	 {
        strerr = "无ORDERSEQ信息";
        return -1;
    }

	SYSTEMNO_STR = iter->second; 
	strcpy(SYSTEMNO,SYSTEMNO_STR.c_str());
	wrLog("SYSTEMNO:%s",SYSTEMNO);

	return 0;
	
}

//广禄qq充值

int CTrade::qq_guanglu_pay_service(char *WEBSVRNAME,char *WEBSVRCODE,char *operUser,char *password,char *SYSTEMNO,string &rspcode,string &strerr)
{
	//受理时间:
	char server_time[14+1];
	string strReq0,strReq1;
	int iRet;
	string BILLNUM;
	string SYSTEMNO_STR="";
	strerr="";
	string strRsp="";
	string rsp_code="";
	string PAYAMOUNT="";
	string datas;
	bbzero(server_time);
	char keep[32+1];
	char orderNo[32+1];
	bbzero(keep);
	bbzero(orderNo);
	char psam_temp[16+1];

	bbzero(psam_temp);
	CTools::byte_to_hex((BYTE*)gbl.posInfo.psamNum, (BYTE*)psam_temp, 8);
	
	map<string, string>::iterator iter;
	map<string, string> _mapData; //返回的数据
	map<string, string> _pack_mapData; //发送的数据
	
	char strReqTmp[100];
	bbzero(strReqTmp);
	char APPFROMTmp[50];
	bbzero(APPFROMTmp);
	sprintf(strReqTmp,"%s|440100-APP001-001-%s|APP001|%s|",WEBSVRCODE,gbl.server_ip,gbl.server_ip);
	sprintf(APPFROMTmp,"440100-APP001-001-%s",gbl.server_ip);
	strReq0.assign(strReqTmp,strlen(strReqTmp));
	CTools::get_termTime(server_time);
	bbzero(keep);
	//CTools::get_keep(keep);
	CTools::get_keep(gbl.pos_no,keep);
	CTools::get_orderNo(orderNo);

	_pack_mapData.insert(pair<string,string> ("MERID",MERID));
	_pack_mapData.insert(pair<string,string>("CHANNELCODE",CHANNELCODE));
	_pack_mapData.insert(pair<string,string>("TMNNUM",TMNNUM));
	_pack_mapData.insert(pair<string,string>("SIGN","SIGN"));
	_pack_mapData.insert(pair<string,string>("CER","CER"));
	_pack_mapData.insert(pair<string,string>("WEBSVRNAME",WEBSVRNAME));
	_pack_mapData.insert(pair<string,string>("WEBSVRCODE",WEBSVRCODE));
	_pack_mapData.insert(pair<string,string>("APPFROM",APPFROMTmp));
	_pack_mapData.insert(pair<string,string>("KEEP",keep));
	_pack_mapData.insert(pair<string,string>("REQUESTTIME",server_time));
	
	_pack_mapData.insert(pair<string, string>("ORDERSEQ",orderNo)); //平台数据  订单号
	_pack_mapData.insert(pair<string,string> ("TMNNUMNO",gbl.pos_no)); //客户终端号
	_pack_mapData.insert(pair<string,string> ("ECARDNO",gbl.card_no)); //E卡号
	_pack_mapData.insert(pair<string,string> ("PASSFLAG","2")); //密码类型
	_pack_mapData.insert(pair<string,string> ("PSAMCARDNO",psam_temp)); //PSAM卡号
	_pack_mapData.insert(pair<string,string> ("STAFFCODE",operUser)); //用户名
	_pack_mapData.insert(pair<string,string> ("PAYPASSWORD",password)); //交易密码
	_pack_mapData.insert(pair<string,string> ("PRODUCTCODE",gbl.glQQPayInfo.PRODUCTCODE)); //产品编码
	_pack_mapData.insert(pair<string,string> ("REQIP",gbl.server_ip)); //REQIP
	_pack_mapData.insert(pair<string,string> ("ACCTCODE",gbl.glQQPayInfo.ACCTCODE)); //ACCTCODE
	_pack_mapData.insert(pair<string,string> ("RECHNUM",gbl.glQQPayInfo.RECHNUM)); //RECHNUM
	_pack_mapData.insert(pair<string,string> ("RECHAMOUNT",gbl.glQQPayInfo.RECHAMOUNT)); //RECHNUM
	_pack_mapData.insert(pair<string,string> ("TRADETIME",server_time));//受理时间

	wrLog("strReq0:%s",strReq0.c_str());
	CxmlParser::pack(WEBSVRCODE,strReq1,_pack_mapData,strerr);


	iRet=ks_soap::get_response(TRADE_FLAG,strReq0,strReq1,strRsp,strerr);
	
	if (iRet!=0)
	{
		strerr="";
		strerr = "交易超时，请登陆自服务门户，查询交易结果!";
		return -4;
	}
	
	iRet=CxmlParser::unpack(strRsp,WEBSVRCODE,_mapData,strerr);
	if (iRet!=0)
	{
		strerr="";
		strerr = "交易超时，请登陆自服务门户，查询交易结果!";
		return -1;

	} 

	if ( (iter=_mapData.find("RSPCODE")) == _mapData.end() ) //清结算终端
	{
		strerr="";
		strerr = "交易未知，请登陆自服务门户，查询交易结果";
        return -1;
    }
	
	rsp_code=iter->second;
	if ("000000" != rsp_code) //明确失败的时候返回错误信息
	{

		/*
		//对错误吗011007进行处理
		if ("011007" == rsp_code)
		{
			strerr="";
			strerr = "处理中,请进入商户自服务门户查询交易结果!\n如有疑问，请咨询在线客服或者致电客服400-80-11888";
			return -1;
		}
		*/
		if ( (iter=_mapData.find("RSPMSG")) == _mapData.end() ) //清结算终端

		{
			strerr="";
			strerr = "交易失败,请进入商户自服务门户查询交易结果!\n如有疑问，请咨询在线客服或者致电客服400-80-11888";
			return -3;
		}
		
		strerr="交易失败 " ;
		strerr += iter->second;
		if(strerr.length()>100)
		{
		
			strerr="";
			strerr = "交易失败,请稍后再试";
		}

		return -3;
	}
	
	if ( (iter=_mapData.find("TRANSSEQ")) == _mapData.end() ) //系统参考号
	 {
        strerr = "无ORDERSEQ信息";
        return -1;
    }

	SYSTEMNO_STR = iter->second; 
	strcpy(SYSTEMNO,SYSTEMNO_STR.c_str());
	wrLog("SYSTEMNO:%s",SYSTEMNO);
	
	if ( (iter=_mapData.find("PAYAMOUNT")) == _mapData.end() ) 
	{
        strerr = "无支付金额信息";
        return -1;
    }
	
	PAYAMOUNT = iter->second; 
	bbzero(gbl.amount);
	sprintf(gbl.amount,"%012s",PAYAMOUNT.c_str());
	
	return 0;
	
}

//全国话费充值

int CTrade::phone_pay_service(char *WEBSVRNAME,char *WEBSVRCODE,char *RECHARGETYPE,char *operUser,char *password,char *SYSTEMNO,string &rspcode,string &strerr)
{
	//受理时间:
	char server_time[14+1];
	string strReq0,strReq1;
	int iRet;
	string BILLNUM;
	string SYSTEMNO_STR="";
	strerr="";
	string strRsp="";
	string rsp_code="";
	string datas;
	bbzero(server_time);
	char keep[32+1];
	char orderNo[32+1];
	bbzero(keep);
	bbzero(orderNo);
	char psam_temp[16+1];

	bbzero(psam_temp);
	CTools::byte_to_hex((BYTE*)gbl.posInfo.psamNum, (BYTE*)psam_temp, 8);
	
	map<string, string>::iterator iter;
	map<string, string> _mapData; //返回的数据
	map<string, string> _pack_mapData; //发送的数据
	
	char strReqTmp[100];
	bbzero(strReqTmp);
	char APPFROMTmp[50];
	bbzero(APPFROMTmp);
	sprintf(strReqTmp,"%s|440100-APP001-001-%s|APP001|%s|",WEBSVRCODE,gbl.server_ip,gbl.server_ip);
	sprintf(APPFROMTmp,"440100-APP001-001-%s",gbl.server_ip);
	strReq0.assign(strReqTmp,strlen(strReqTmp));
	CTools::get_termTime(server_time);
	bbzero(keep);
	//CTools::get_keep(keep);
	CTools::get_keep(gbl.pos_no,keep);
	CTools::get_orderNo(orderNo);
	_pack_mapData.insert(pair<string,string> ("MERID",MERID));
	_pack_mapData.insert(pair<string,string>("CHANNELCODE",CHANNELCODE));
	_pack_mapData.insert(pair<string,string>("TMNNUM",TMNNUM));
	_pack_mapData.insert(pair<string,string>("SIGN","SIGN"));
	_pack_mapData.insert(pair<string,string>("CER","CER"));
	_pack_mapData.insert(pair<string,string>("WEBSVRNAME",WEBSVRNAME));
	_pack_mapData.insert(pair<string,string>("WEBSVRCODE",WEBSVRCODE));
	_pack_mapData.insert(pair<string,string>("APPFROM",APPFROMTmp));
	_pack_mapData.insert(pair<string,string>("KEEP",keep));
	_pack_mapData.insert(pair<string,string>("REQUESTTIME",server_time));
	
	_pack_mapData.insert(pair<string, string>("ORDERNO",orderNo)); //平台数据  订单号
	_pack_mapData.insert(pair<string,string> ("TMNNUMNO",gbl.pos_no)); //客户终端号
	_pack_mapData.insert(pair<string,string> ("ECARDNO",gbl.card_no)); //E卡号
	_pack_mapData.insert(pair<string,string> ("PASSFLAG","2")); //密码类型
	_pack_mapData.insert(pair<string,string> ("PSAMCARDNO",psam_temp)); //PSAM卡号
	_pack_mapData.insert(pair<string,string> ("STAFFCODE",operUser)); //用户名
	_pack_mapData.insert(pair<string,string> ("PAYPASSWORD",password)); //交易密码
	_pack_mapData.insert(pair<string,string> ("RECHARGETYPE",RECHARGETYPE)); //充值类型 充值业务类型03010008：全国电信直充05010005 全国移动直充 16010002 全国联通直充
	_pack_mapData.insert(pair<string,string> ("PHONE",gbl.phone_no)); //充入手机号
	_pack_mapData.insert(pair<string,string> ("RECHARGEAMOUNT",gbl.origAmount)); //充入金额
	_pack_mapData.insert(pair<string,string> ("TXNAMOUNT",gbl.origAmount)); //订单金额
	_pack_mapData.insert(pair<string,string> ("TRADETIME",server_time));//受理时间

	wrLog("strReq0:%s",strReq0.c_str());
	CxmlParser::pack(WEBSVRCODE,strReq1,_pack_mapData,strerr);


	iRet=ks_soap::get_response(TRADE_FLAG,strReq0,strReq1,strRsp,strerr);
	
	if (iRet!=0)
	{
		strerr="";
		strerr = "网络繁忙，请稍后再试";
		return -4;
	}
	
	iRet=CxmlParser::unpack(strRsp,WEBSVRCODE,_mapData,strerr);
	if (iRet!=0)
	{
		strerr="";
		strerr = "报文解析失败,请稍后再试";
		return -4;

	} 

	if ( (iter=_mapData.find("RSPCODE")) == _mapData.end() ) //清结算终端
	{
		strerr="";
		strerr = "交易超时，请进入商户自服务门户查询交易结果!";
        return -4;
    }
	
	rsp_code=iter->second;
	if ("000000" !=rsp_code) //对于失败的，需要获取失败信息
	{
		strerr="";
		//对于错误码011007 进行处理
		/*
		if ("011007" == rsp_code)
		{
			strerr = "处理中!请进入商户自服务门户查询交易结果\n如有疑问，请咨询在线客服或致电400-80-11888";
			return -1;
		}
		*/
	//	else
	//	{

			if ( (iter=_mapData.find("RSPMSG")) == _mapData.end() ) //清结算终端
			{
				strerr = "交易失败，请进入商户子服务门户查询交易结果!\n如有疑问，请咨询在线客服或致电400-80-11888";
				return -3;
			}
			
			strerr = "交易失败 " ;

			strerr += iter->second;
			
			return -3; //明确失败
	//	}

	}
	
	if ( (iter=_mapData.find("TRANSSEQ")) == _mapData.end() ) //系统参考号
	 {
        strerr = "无ORDERSEQ信息";
        return -1;
    }

	SYSTEMNO_STR = iter->second; 
	strcpy(SYSTEMNO,SYSTEMNO_STR.c_str());
	wrLog("SYSTEMNO:%s",SYSTEMNO);

	return 0;
	
}

int CTrade::phone_pay_serviceGDYD(char *WEBSVRNAME,char *WEBSVRCODE,char *RECHARGETYPE,char *operUser,char *password,char *SYSTEMNO,CGlobal& gbl,string &rspcode,string &strerr)
{
	//受理时间:
	char server_time[14+1];
	string strReq0,strReq1;
	int iRet;
	string BILLNUM;
	string SYSTEMNO_STR="";
	strerr="";
	string strRsp="";
	string rsp_code="";
	string datas;
	bbzero(server_time);
	char keep[32+1];
	char orderNo[32+1];
	bbzero(keep);
	bbzero(orderNo);
	char psam_temp[16+1];

	bbzero(psam_temp);
	CTools::byte_to_hex((BYTE*)gbl.posInfo.psamNum, (BYTE*)psam_temp, 8);
	
	map<string, string>::iterator iter;
	map<string, string> _mapData; //返回的数据
	map<string, string> _pack_mapData; //发送的数据
	
	char strReqTmp[100];
	bbzero(strReqTmp);
	char APPFROMTmp[50];
	bbzero(APPFROMTmp);
	sprintf(strReqTmp,"%s|440100-APP001-001-%s|APP001|%s|",WEBSVRCODE,gbl.server_ip,gbl.server_ip);
	sprintf(APPFROMTmp,"440100-APP001-001-%s",gbl.server_ip);
	strReq0.assign(strReqTmp,strlen(strReqTmp));
	CTools::get_termTime(server_time);
	bbzero(keep);
	//CTools::get_keep(keep);
	CTools::get_keep(gbl.pos_no,keep);
	CTools::get_orderNo(orderNo);
	_pack_mapData.insert(pair<string,string> ("MERID",MERID));
	_pack_mapData.insert(pair<string,string>("CHANNELCODE",CHANNELCODE));
	_pack_mapData.insert(pair<string,string>("TMNNUM",TMNNUM));
	_pack_mapData.insert(pair<string,string>("SIGN","SIGN"));
	_pack_mapData.insert(pair<string,string>("CER","CER"));
	_pack_mapData.insert(pair<string,string>("WEBSVRNAME",WEBSVRNAME));
	_pack_mapData.insert(pair<string,string>("WEBSVRCODE",WEBSVRCODE));
	_pack_mapData.insert(pair<string,string>("APPFROM",APPFROMTmp));
	_pack_mapData.insert(pair<string,string>("KEEP",keep));
	_pack_mapData.insert(pair<string,string>("REQUESTTIME",server_time));
	
	_pack_mapData.insert(pair<string, string>("ORDERSEQ",orderNo)); //平台数据  订单号
	_pack_mapData.insert(pair<string,string> ("TMNNUMNO",gbl.pos_no)); //客户终端号
	_pack_mapData.insert(pair<string,string> ("ECARDNO",gbl.card_no)); //E卡号
	_pack_mapData.insert(pair<string,string> ("PASSFLAG","2")); //密码类型
	_pack_mapData.insert(pair<string,string> ("PSAMCARDNO",psam_temp)); //PSAM卡号
	_pack_mapData.insert(pair<string,string> ("STAFFCODE",operUser)); //用户名
	_pack_mapData.insert(pair<string,string> ("PAYPASSWORD",password)); //交易密码
	_pack_mapData.insert(pair<string,string> ("RECHARGETYPE",RECHARGETYPE)); //充值类型 充值业务类型03010008：全国电信直充05010005 全国移动直充 16010002 全国联通直充
	_pack_mapData.insert(pair<string,string> ("PHONE",gbl.phone_no)); //充入手机号
	_pack_mapData.insert(pair<string,string> ("TXAMOUNT",gbl.amount)); //订单金额
	_pack_mapData.insert(pair<string,string> ("TRADETIME",server_time));//受理时间

	wrLog("strReq0:%s",strReq0.c_str());
	CxmlParser::pack(WEBSVRCODE,strReq1,_pack_mapData,strerr);


	iRet=ks_soap::get_response(TRADE_FLAG,strReq0,strReq1,strRsp,strerr);
	
	if (iRet!=0)
	{
		strerr="";
		strerr = "交易超时，请进入商户自服务门户查询交易结果!";
		return -4;
	}
	
	iRet=CxmlParser::unpack(strRsp,WEBSVRCODE,_mapData,strerr);
	if (iRet!=0)
	{
		strerr="";
		strerr = "报文解析失败,请稍后再试";
		return -4;

	} 

	if ( (iter=_mapData.find("RSPCODE")) == _mapData.end() ) //清结算终端
	{
		strerr="";
		strerr = "查询失败,请稍后再试";
        return -4;
    }
	
	rsp_code=iter->second;

	if (strcmp(rsp_code.c_str(),"000000")!=0) //对于失败的，需要获取失败信息
	{
		strerr="";
		/*
		//对于响应码进行处理011007
		if ("011007" == rsp_code)
		{
			strerr = "处理中,请进入商户自服务门户查询交易结果!\n如有疑问，请咨询在线客服或致电客服400-80-11888";
			return -1;
		}
		else
		*/
		//{

			if ( (iter=_mapData.find("RSPMSG")) == _mapData.end() ) //清结算终端
			{
				strerr = "交易失败,请进入商户自服务门户查询交易结果!\n如有疑问，请咨询在线客服或致电客服400-80-11888";
				return -3;
			}
			
			strerr = "\n交易失败 " ;
			strerr += iter->second;
			return -3; //明确失败
		//}

	}
	
	if ( (iter=_mapData.find("TRANSSEQ")) == _mapData.end() ) //系统参考号
	 {
        strerr = "无ORDERSEQ信息";
        return -1;
    }

	SYSTEMNO_STR = iter->second; 
	strcpy(SYSTEMNO,SYSTEMNO_STR.c_str());
	wrLog("SYSTEMNO:%s",SYSTEMNO);

	//实收金额
	if ( (iter=_mapData.find("PAYAMOUNT")) == _mapData.end() ) //实收金额
	 {
        strerr = "无实收金额";
        return -1;
    }
	
	//将面值先复制
	strcpy(gbl.origAmount,gbl.amount);

	string strPAYAMOUNT = iter->second;
	int iPAYAMOUNT = atoi(strPAYAMOUNT.c_str());
	sprintf(gbl.amount,"%012d",iPAYAMOUNT);

// 	SYSTEMNO_STR = iter->second; 
// 	strcpy(,SYSTEMNO_STR.c_str());
// 	wrLog("SYSTEMNO:%s",SYSTEMNO);

	return 0;
	
}

//东莞公交签到服务 获取签到密钥，SAM卡号，SAM卡授权信息，结算时间。批次号。中心时间。密钥等

int CTrade::dgtSignInService(char *WEBSVRNAME,char *WEBSVRCODE,PDGTSignInfo pdgtSignInfo,string &strerr)
{

	char server_time[14+1];
	string strReq0,strReq1;
	int iRet;
	string BILLNUM;
	string SYSTEMNO_STR="";
	strerr="";
	string strRsp="";
	string rsp_code="";
	string datas;
	bbzero(server_time);
	char keep[32+1];
	bbzero(keep);
	char STAFFCODE[20];
	//返回参数信息
	string  POSID=""; //清算设备编号
	string  KEYSET=""; //密钥信息
	string  SAMID=""; //SAM卡卡号
	string  SAMAUTHINFO="";//SAM卡授权信息
	string  EDAUTHINFO=""; //ED卡授权信
	string  SETTDATE=""; //结算时间
	string BATCHNO=""; //批次
	string  SYSDATETIME=""; //中心时间 用于矫正时间
	string  AUTHCODE=""; //授权认证吗M1
	string  PARAMBIT=""; //参数更新标志位

	
	map<string, string>::iterator iter;
	map<string, string> _mapData; //返回的数据
	map<string, string> _pack_mapData; //发送的数据
	char ORDERSEQ[32+1];
	
	char strReqTmp[100];
	bbzero(strReqTmp);
	char APPFROMTmp[50];
	bbzero(APPFROMTmp);

	sprintf(strReqTmp,"%s|440100-APP001-001-%s|APP001|%s|",WEBSVRCODE,gbl.server_ip,gbl.server_ip);
	sprintf(APPFROMTmp,"440100-APP001-001-%s",gbl.server_ip);
	strReq0.assign(strReqTmp,strlen(strReqTmp));
	bbzero(server_time);
	CTools::get_termTime(server_time);
	bbzero(ORDERSEQ);
	CTools::get_dgtOrderNo(ORDERSEQ);

	bbzero(keep);
	//CTools::get_keep(keep);
	CTools::get_keep(gbl.pos_no,&gbl.random_value,keep);

	bbzero(STAFFCODE);
	sprintf(STAFFCODE,"%s_01",gbl.pos_no);

	_pack_mapData.insert(pair<string,string> ("MERID",MERID));
	_pack_mapData.insert(pair<string,string>("CHANNELCODE",CHANNELCODE));
	_pack_mapData.insert(pair<string,string>("TMNNUM",TMNNUM));
	_pack_mapData.insert(pair<string,string>("SIGN","SIGN"));
	_pack_mapData.insert(pair<string,string>("CER","CER"));
	_pack_mapData.insert(pair<string,string>("WEBSVRNAME",WEBSVRNAME));
	_pack_mapData.insert(pair<string,string>("WEBSVRCODE",WEBSVRCODE));
	_pack_mapData.insert(pair<string,string>("APPFROM",APPFROMTmp));
	_pack_mapData.insert(pair<string,string>("KEEP",keep));
	_pack_mapData.insert(pair<string,string>("REQUESTTIME",server_time));
	
	_pack_mapData.insert(pair<string,string> ("ORDERSEQ",ORDERSEQ)); //终端流水号
	_pack_mapData.insert(pair<string,string> ("TMNNUMNO",gbl.pos_no)); //客户终端号
	_pack_mapData.insert(pair<string,string> ("STAFFCODE",STAFFCODE)); //操作员
	_pack_mapData.insert(pair<string,string> ("TRADETIME",server_time)); //受理时间

	wrLog("strReq0:%s",strReq0.c_str());
	CxmlParser::pack(WEBSVRCODE,strReq1,_pack_mapData,strerr);
	
	strerr="";

	iRet=ks_soap::get_response(TRADE_FLAG,strReq0,strReq1,strRsp,strerr);

	if (iRet!=0)
	{
		
		strerr="";
		strerr = "网络繁忙，请稍后再试";
		return -4;
	}
	
	strerr="";
	iRet=CxmlParser::unpack(strRsp,WEBSVRCODE,_mapData,strerr);
	if (iRet!=0)
	{
		strerr="";
		strerr = "报文解析失败,请稍后再试";
		return -1;
	} 

	
	if ( (iter=_mapData.find("RSPCODE")) == _mapData.end() ) //清结算终端
	{
		strerr="";
		strerr = "查询失败,请稍后再试";
        return -1;
    }
	
	//修改bug，对于签到过程中出现没有签退的情况，错误吗25005进行处理
	rsp_code=iter->second;

	if (strcmp(rsp_code.c_str(),"000000")!=0)
	{

			
		if ( (iter=_mapData.find("RSPMSG")) == _mapData.end() ) 
		{
			strerr = "签到未知信息";
			return -1;
		}

		strerr=iter->second;

		return -1;
	}

	//获取签到信息
	if ( (iter=_mapData.find("POSID")) == _mapData.end() ) //清结算终端
	{
        strerr = "无POSID信息信息";
        return -1;
    }
	
	POSID = iter->second; 
	strcpy(pdgtSignInfo->POSID,POSID.c_str());


	if ( (iter=_mapData.find("KEYSET")) == _mapData.end() ) 
	{
        strerr = "签到获取密钥信息失败";
        return -1;
    }

	KEYSET= iter->second;
	strcpy(pdgtSignInfo->KEYSET,KEYSET.c_str());

	if ( (iter=_mapData.find("SAMID")) == _mapData.end() ) 
	{
        strerr = "无SAMID信息";
        return -1;
    }
	


	SAMID=iter->second;
	strcpy(pdgtSignInfo->SAMID,SAMID.c_str());

	if ( (iter=_mapData.find("SAMAUTHINFO")) == _mapData.end() ) 
	{
        strerr = "无SAMAUTHINFO信息";
        return -1;
    }
	
	SAMAUTHINFO=iter->second;
	strcpy(gbl.dgtSignInfo.SAMAUTHINFO,SAMAUTHINFO.c_str());

	if ( (iter=_mapData.find("EDAUTHINFO")) == _mapData.end() ) 
	{
        strerr = "无EDAUTHINFO信息";
        return -1;
    }
	
	EDAUTHINFO=iter->second;
	strcpy(pdgtSignInfo->EDAUTHINFO,EDAUTHINFO.c_str());

	if ( (iter=_mapData.find("SETTDATE")) == _mapData.end() ) 
	{
        strerr = "无SETTDATE信息";
        return -1;
    }
	
	SETTDATE=iter->second;
	strcpy(pdgtSignInfo->SETTDATE,SETTDATE.c_str());

	if ( (iter=_mapData.find("BATCHNO")) == _mapData.end() ) 
	{
        strerr = "无BATCHNO信息";
        return -1;
    }
	
	BATCHNO=iter->second;
	strcpy(pdgtSignInfo->BATCHNO,BATCHNO.c_str());

	if ( (iter=_mapData.find("SYSDATETIME")) == _mapData.end() ) 
	{
        strerr = "无SYSDATETIME信息";
        return -1;
    }
	
	SYSDATETIME=iter->second;
	strcpy(pdgtSignInfo->SYSDATETIME,SYSDATETIME.c_str());
	
	if (TRADE_FLAG==0)
	{
		wrLog("签到信息");
		wrLog("POSID:%s",POSID.c_str());
		wrLog("KEYSET:%s",KEYSET.c_str());
		wrLog("SAMID:%s",SAMID.c_str());
		wrLog("SAMAUTHINFO:%s",SAMAUTHINFO.c_str());
		wrLog("EDAUTHINFO:%s",EDAUTHINFO.c_str());
		wrLog("SETTDATE:%s",SETTDATE.c_str());
		wrLog("BATCHNO:%s",BATCHNO.c_str());
		wrLog("SYSDATETIME:%s",SYSDATETIME.c_str());
		wrLog("授权认证码AUTHCODE:%s",AUTHCODE.c_str());
		wrLog("参数更新标志位PARAMBIT:%s",PARAMBIT.c_str());

	}

	return 0;

}


//东莞公交签退服务。签退之前需要进行合计交易总额.相同时间和批次内的交易总额
 int CTrade::dgtSignOutService(char *WEBSVRNAME,char *WEBSVRCODE,string &strerr)
{

	char server_time[14+1];
	char ACCEPTTIME[6+1];
	char acceptDate[8+1];
	string strReq0,strReq1;
	int iRet;
	string BILLNUM;
	string SYSTEMNO_STR="";
	strerr="";
	string strRsp="";
	string datas;
	bbzero(server_time);
	char keep[32+1];
	bbzero(keep);
	char STAFFCODE[20];
	char TRADETIME[14+1];//受理时间
	char SETTDATE[8+1]; //结算日期
	char BATCHNO[6+1]; //批次号
	char TOTALSVNUM[10+1]; //本批次累计售卡充值交易总笔数
	char TOTALSVAMT[10+1]; //本次累计充值交易总金额
	char TOTALSALEDEP[10+1]; //本次累计售卡交易押金总金额

	bbzero(TRADETIME);
	bbzero(SETTDATE);
	bbzero(BATCHNO);
	bbzero(TOTALSALEDEP);
	bbzero(TOTALSVAMT);
	bbzero(TOTALSVNUM);

	//返回参数信息
	string  RSPCODE="";

	map<string, string>::iterator iter;
	map<string, string> _mapData; //返回的数据
	map<string, string> _pack_mapData; //发送的数据
	
	char strReqTmp[100];
	bbzero(strReqTmp);
	char APPFROMTmp[50];
	bbzero(APPFROMTmp);
	sprintf(strReqTmp,"%s|440100-APP001-001-%s|APP001|%s|",WEBSVRCODE,gbl.server_ip,gbl.server_ip);
	sprintf(APPFROMTmp,"440100-APP001-001-%s",gbl.server_ip);
	strReq0.assign(strReqTmp,strlen(strReqTmp));
	bbzero(server_time);
	bbzero(ACCEPTTIME);
	CTools::get_termTime(server_time);
	CTools::getDate(acceptDate);
	CTools::getTime(ACCEPTTIME);
	
	bbzero(keep);
	//CTools::get_keep(keep);
	CTools::get_keep(gbl.pos_no,&gbl.random_value,keep);

	bbzero(STAFFCODE);
	sprintf(STAFFCODE,"%s_01",gbl.pos_no);

	//参数赋值
	strcpy(SETTDATE,gbl.dgtSignInfo.SETTDATE);
	strcpy(BATCHNO,gbl.dgtSignInfo.BATCHNO);
	strcpy(TOTALSALEDEP,gbl.dgtSignInfo.TOTALSALEDEP);
	strcpy(TOTALSVAMT,gbl.dgtSignInfo.TOTALSVAMT);
	strcpy(TOTALSVNUM,gbl.dgtSignInfo.TOTALSVNUM);

	_pack_mapData.insert(pair<string,string> ("MERID",MERID));
	_pack_mapData.insert(pair<string,string>("CHANNELCODE",CHANNELCODE));
	_pack_mapData.insert(pair<string,string>("TMNNUM",TMNNUM));
	_pack_mapData.insert(pair<string,string>("SIGN","SIGN"));
	_pack_mapData.insert(pair<string,string>("CER","CER"));
	_pack_mapData.insert(pair<string,string>("WEBSVRNAME",WEBSVRNAME));
	_pack_mapData.insert(pair<string,string>("WEBSVRCODE",WEBSVRCODE));
	_pack_mapData.insert(pair<string,string>("APPFROM",APPFROMTmp));
	_pack_mapData.insert(pair<string,string>("KEEP",keep));
	_pack_mapData.insert(pair<string,string>("REQUESTTIME",server_time));
		
	_pack_mapData.insert(pair<string,string> ("TMNNUMNO",gbl.pos_no)); //客户终端号
	_pack_mapData.insert(pair<string,string> ("STAFFCODE",STAFFCODE)); //操作员

	_pack_mapData.insert(pair<string,string> ("TRADETIME",server_time)); //受理时间
	_pack_mapData.insert(pair<string,string> ("SETTDATE",SETTDATE)); //结算日期
	_pack_mapData.insert(pair<string,string> ("BATCHNO",BATCHNO)); //批次号
	_pack_mapData.insert(pair<string,string> ("TOTALSVNUM",TOTALSVNUM)); //本批次累计售卡充值交易总笔数
	_pack_mapData.insert(pair<string,string> ("TOTALSVAMT",TOTALSVAMT)); //本次累计充值交易总金额
	_pack_mapData.insert(pair<string,string> ("TOTALSALEDEP",TOTALSALEDEP)); //本次累计售卡交易押金总金额
	
	wrLog("strReq0:%s",strReq0.c_str());
	CxmlParser::pack(WEBSVRCODE,strReq1,_pack_mapData,strerr);

	iRet=ks_soap::get_response(TRADE_FLAG,strReq0,strReq1,strRsp,strerr);

	if (iRet!=0)
	{
		
		strerr="";
		strerr = "网络繁忙，请稍后再试";
		return -4;
	}
	
	iRet=CxmlParser::unpack(strRsp,WEBSVRCODE,_mapData,strerr);
	if (iRet!=0)
	{
		strerr = "报文解析错误,请稍后再试";
		return -1;
	} 
	//签退响应报文0000为成功。
	if ( (iter=_mapData.find("RSPCODE")) == _mapData.end() ) //清结算终端
	{
        strerr = "无响应信息";
        return -1;
    }

	RSPCODE=iter->second;
	if (strcmp(RSPCODE.c_str(),"000000")!=0)
	{
		strerr="签退失败"; //签退失败需要重新签退
		return -2;
	}

	return 0;

}


//东莞公交通过keep进行查询信息
int CTrade::getGgtResultByKeep(char *WEBSVRNAME,char *WEBSVRCODE,char *KEEPCODE,string& strPaystat,string &strerr)
{

	char server_time[14+1];
	char ACCEPTTIME[6+1];
	char acceptDate[8+1];
	string strReq0,strReq1;
	int iRet;
	string BILLNUM;
	string SYSTEMNO_STR="";

	string strRsp="";
	string datas;
	bbzero(server_time);
	char keep[32+1];

	bbzero(keep);
	strerr="";
	strPaystat="";

	//返回参数信息
	string  RSPCODE="";
	string  SYSTEMNO="";
	string  AUTHSEQ="";
	string TRANSSEQ="";
	string LIMITEAUTHSEQL="";
	string BATCHNO="";
	string SETTDATE="";

	map<string, string>::iterator iter;
	map<string, string> _mapData; //返回的数据
	map<string, string> _pack_mapData; //发送的数据
	
	char strReqTmp[100];
	bbzero(strReqTmp);
	char APPFROMTmp[50];
	bbzero(APPFROMTmp);
	sprintf(strReqTmp,"%s|440100-APP001-001-%s|APP001|%s|",WEBSVRCODE,gbl.server_ip,gbl.server_ip);
	sprintf(APPFROMTmp,"440100-APP001-001-%s",gbl.server_ip);
	strReq0.assign(strReqTmp,strlen(strReqTmp));
	bbzero(server_time);
	bbzero(ACCEPTTIME);
	CTools::get_termTime(server_time);
	CTools::getDate(acceptDate);
	CTools::getTime(ACCEPTTIME);
	
	bbzero(keep);
	//CTools::get_keep(keep);
	CTools::get_keep(gbl.pos_no,&gbl.random_value,keep);

	//参数赋值

	_pack_mapData.insert(pair<string,string> ("MERID",MERID));
	_pack_mapData.insert(pair<string,string>("CHANNELCODE",CHANNELCODE));
	_pack_mapData.insert(pair<string,string>("TMNNUM",TMNNUM));
	_pack_mapData.insert(pair<string,string>("SIGN","SIGN"));
	_pack_mapData.insert(pair<string,string>("CER","CER"));
	_pack_mapData.insert(pair<string,string>("WEBSVRNAME",WEBSVRNAME));
	_pack_mapData.insert(pair<string,string>("WEBSVRCODE",WEBSVRCODE));
	_pack_mapData.insert(pair<string,string>("APPFROM",APPFROMTmp));
	_pack_mapData.insert(pair<string,string>("KEEP",keep));
	_pack_mapData.insert(pair<string,string>("REQUESTTIME",server_time));
		
	_pack_mapData.insert(pair<string,string> ("TMNNUMNO",gbl.pos_no)); //客户终端号
	_pack_mapData.insert(pair<string,string> ("KEEPCODE",KEEPCODE)); //上次操作的keep

	
	wrLog("strReq0:%s",strReq0.c_str());
	CxmlParser::pack(WEBSVRCODE,strReq1,_pack_mapData,strerr);

	iRet=ks_soap::get_response(TRADE_FLAG,strReq0,strReq1,strRsp,strerr);

	if (iRet!=0) //查询超时
	{
		
		strerr="";
		strerr = "网络繁忙，请稍后再试";
		return -4;
	}
	
	iRet=CxmlParser::unpack(strRsp,WEBSVRCODE,_mapData,strerr);
	if (iRet!=0)
	{
		strerr = "报文解析错误,请稍后再试";
		return -1;
	} 

	//签退响应报文0000为成功。
	if ( (iter=_mapData.find("RSPCODE")) == _mapData.end() ) //清结算终端
	{
        strerr = "无响应信息";
        return -1;
    }

	RSPCODE=iter->second;
	if (strcmp(RSPCODE.c_str(),"000000")!=0) 
	{
		strerr="查询失败"; 
		return -2;
	}

	//获取上笔交易的流水号

	if ( (iter=_mapData.find("SYSTEMNO")) == _mapData.end() ) //清结算终端
	{
        strerr = "查询失败";
        return -2;
    }

	SYSTEMNO=iter->second;
	bbzero(gbl.SYSTEMNO);
	strcpy(gbl.SYSTEMNO,SYSTEMNO.c_str());

	if ( (iter=_mapData.find("AUTHSEQ")) == _mapData.end() ) //清结算终端
	{
        strerr = "查询失败";
        return -2;
    }

	AUTHSEQ=iter->second;
	bbzero(gbl.dgtCard.AUTHSEQ);
	strcpy(gbl.dgtCard.AUTHSEQ,AUTHSEQ.c_str());


	if ( (iter=_mapData.find("TRANSSEQ")) == _mapData.end() ) //如果订单后不存在
	{
			strerr = "订单号不存在";
			bbzero(gbl.TRANSSEQ);
	}
	else
	{
			
			TRANSSEQ=iter->second;
			bbzero(gbl.TRANSSEQ);
			strcpy(gbl.TRANSSEQ,TRANSSEQ.c_str());
			
	}

	if (strlen(gbl.dgtCard.LIMITEAUTHSEQL)==0)
	{

		if ( (iter=_mapData.find("LIMITEAUTHSEQL")) == _mapData.end() ) //清结算终端
		{
			strerr = "查询失败";
			return -2;
		}
		
		LIMITEAUTHSEQL=iter->second;
		bbzero(gbl.dgtCard.LIMITEAUTHSEQL);
		strcpy(gbl.dgtCard.LIMITEAUTHSEQL,LIMITEAUTHSEQL.c_str());
	}


	if (strlen(gbl.dgtCard.BATCHNO) ==0)
	{

		if ( (iter=_mapData.find("BATCHNO")) == _mapData.end() ) //清结算终端
		{
			strerr = "查询失败";
			return -2;
		}
		
		BATCHNO=iter->second; //批次号
		bbzero(gbl.dgtCard.BATCHNO);
		strcpy(gbl.dgtCard.BATCHNO,BATCHNO.c_str());
	}

	if ( (iter=_mapData.find("SETTDATE")) == _mapData.end() ) //清结算终端
	{
        strerr = "查询失败";
        return -2;
    }

	SETTDATE=iter->second;//结算时间
	bbzero(gbl.dgtCard.SETDATE);
	strcpy(gbl.dgtCard.SETDATE,SETTDATE.c_str());

	
	//add by linwenxu 20141125 for id2910 begin
	if( (iter=_mapData.find("PAYSTAT")) != _mapData.end())
	{

		strPaystat = iter->second;
	}
	
	//add by linwenxu 20141125 for id2910 end

	return 0;

}
//东莞公交卡操作服务
/************************************************************************/
/*                                                                      */
//CARDOPRTYPE :操作类型
//TRANSTYPE: 业务类型 
//payAmount:表示充值金额。
//默认仅支持cpu卡充值
//PASSFLAG 表示1 转账或者老板密码 2交易密码
//修改内容，卡操作请求在只要是发了失败了，发冲正。
//修改内容，卡操作请求没有没有返回发冲正包的有效信息是，要发查询包去查询这笔，然后闭环发冲正

/************************************************************************/

int CTrade::cardOperate_service(char *WEBSVRNAME,char *WEBSVRCODE,char  *PASSFLAG,char *CARDOPRTYPE,char *TRANSTYPE,char *APDU,char *TRANSSEQ,string &rsp_code,string &strerr)
{

	char server_time[14+1];
	char ACCEPTTIME[6+1];
	char acceptDate[8+1];
	string strReq0="";
	string strReq1="";
	int iRet;
	string BILLNUM;
	string SYSTEMNO_STR="";
	strerr="";
	string strRsp="";
	string DICMAC="";
	string MAC2="";

	char keep[32+1];
	char STAFFCODE[20];
	char COMMANDLEN[3+1]; //APDU长度
	char TRADETIME[14+1];//受理时间
	char SETTDATE[8+1]; //结算日期
	char BATCHNO[6+1]; //批次号
	char CITYCODE[4+1]; //城市编码
	char CARDMKND[2+1]; //主卡类型
	char CARDSKND[2+1]; //	子卡类型
	char DEPOSIT[4+1]; //押金
	char CARDVALDATE[8+1]; //卡片有效期
	char SRCBAL[8+1]; //卡片原额
	char CARDSEQ[6+1]; //卡片交易流水号
	char KEYVER[2+1]; //卡片密钥版本
	char ALGIND[2+1]; //ALGIND
	char CARDRAND[8+1]; //随机数
	char MAC1[8+1]; //充资返回信息MAC1
	char DIVDATA[18+1]; //分散因子
	char KEYSET[32+1]; //密钥
	char DEPOSITMNY[8+1]; //押金
	char ORIGAMT[8+1];
	char ORDERSEQ[10];
	char password[128];
	char psam_temp[16+1];
	string TRANSSEQ_str="";
	string setDate_Str="";
	string BATCHNO_str="";
	char CARD_trade_seq[4+1];
	char DGTRSP_CODE[5+1];

	bbzero(COMMANDLEN);
	bbzero(CITYCODE);
	bbzero(CARDMKND);
	bbzero(CARDSKND);
	bbzero(DEPOSIT);
	bbzero(SRCBAL);
	bbzero(CARDSEQ);
	bbzero(KEYVER);
	bbzero(ALGIND);
	bbzero(CARDRAND);
	bbzero(MAC1);
	bbzero(DIVDATA);
	bbzero(KEYSET);
	bbzero(TRADETIME);
	bbzero(SETTDATE);
	bbzero(BATCHNO);
	bbzero(DEPOSITMNY);
	bbzero(ORIGAMT);
	bbzero(ORDERSEQ);
	bbzero(psam_temp);
	bbzero(CARD_trade_seq);
	bbzero(keep);
	bbzero(server_time);
	bbzero(DGTRSP_CODE);

	//返回参数信息
	string RSPCODE="";
	string  AUTHSEQ="";
	string LIMITEAUTHSEQL=""; //额度授权流水号
	string SYSDATETIME=""; //中心时间
	string SYSTEMNO=""; //系统参考号
	string MESSAGEDATETIME=""; //报文发送时间
	
	map<string, string>::iterator iter;
	map<string, string> _mapData; //返回的数据
	map<string, string> _pack_mapData; //发送的数据
	
	char strReqTmp[100];
	bbzero(strReqTmp);
	char APPFROMTmp[50];
	bbzero(APPFROMTmp);
	sprintf(strReqTmp,"%s|440100-APP001-001-%s|APP001|%s|",WEBSVRCODE,gbl.server_ip,gbl.server_ip);
	sprintf(APPFROMTmp,"440100-APP001-001-%s",gbl.server_ip);
	strReq0.assign(strReqTmp,strlen(strReqTmp));
	bbzero(server_time);
	bbzero(ACCEPTTIME);

	CTools::get_termTime(server_time);
	CTools::getDate(acceptDate);
	CTools::getTime(ACCEPTTIME);

	bbzero(ORDERSEQ);
	CTools::get_dgtOrderNo(ORDERSEQ);

	bbzero(gbl.dgtCard.posSeq);
	strcpy(gbl.dgtCard.posSeq,ORDERSEQ);
	wrLog("终端流水号:%s",gbl.dgtCard.posSeq);

	bbzero(keep);
	//CTools::get_keep(keep);
	CTools::get_keep(gbl.dPosInfo.pos_no,&gbl.random_value,keep);
	bbzero(gbl.dgtCard.KEEP);
	strcpy(gbl.dgtCard.KEEP,keep);

	bbzero(STAFFCODE);
	sprintf(STAFFCODE,"%s_01",gbl.dPosInfo.pos_no);
	bbzero(password);
	CTools::byte_to_hex((BYTE *)gbl.password,(BYTE *)password,8);
	CTools::byte_to_hex((BYTE*)gbl.posInfo.psamNum, (BYTE*)psam_temp, 8);
	//参数赋值
	CTools::byte_to_hex((BYTE *)gbl.dgtCard.deposit,(BYTE *)DEPOSIT,2); //押金 格式转换
	
	wrLog("DEPOSIT:%s",DEPOSIT);
	
	if (strcmp(DEPOSIT,"FFFF")==0) //无押金
	{
		//表示无押金
		strcpy(gbl.DEPOSIT,"00000000");
		
	}
	else
	{
		
		char DEPOSIT_temp[2+1];
		bbzero(DEPOSIT_temp);
		memcpy(DEPOSIT_temp,DEPOSIT+2,2); //获取后两位
		bbzero(gbl.DEPOSIT);
		sprintf(gbl.DEPOSIT,"%08d",(atoi(DEPOSIT_temp)*100)) ; //转换成分
		
	}

	strcpy(SETTDATE,"00000000"); //卡操作请求的时候，结算时间可选
	strcpy(BATCHNO,gbl.dgtSignInfo.BATCHNO);
	CTools::byte_to_hex((BYTE *)gbl.dgtCard.CItyCode,(BYTE *)CITYCODE,2);
	CTools::byte_to_hex((BYTE *)gbl.dgtCard.cardParent_type,(BYTE *)CARDMKND,1);
	CTools::byte_to_hex((BYTE *)gbl.dgtCard.cardChild_type,(BYTE *)CARDSKND,1);
	CTools::byte_to_hex((BYTE *)gbl.dgtCard.effectiveDate,(BYTE *)CARDVALDATE,4);
	strcpy(KEYSET,gbl.dgtCard.KEYSET); 

	bbzero(password);
	CTools::byte_to_hex((BYTE *)gbl.password,(BYTE *)password,8);

	bbzero(SRCBAL);//卡片原有金额
	strcpy(SRCBAL,gbl.dgtCard.tradeBeForeMny);
	memcpy(ORIGAMT,gbl.amount+4,8);

	switch (atoi(CARDOPRTYPE))

	{
		case 2063: //联机售卡
			strcpy(CARDRAND,gbl.dgtCard.CARDRAND); //随机数在售卡的时候需要
			strcpy(DIVDATA,gbl.dgtCard.CARDSALE_DIVDATA);//分散因子 售卡是ATS后8字节，充值是卡号
			strcpy(CARDSEQ,"000000"); //在售卡的过程中不会产生卡片交易流水
			strcpy(MAC1,"00000000");
			bbzero(gbl.dgtCard.CARDCNT);
			strcpy(gbl.dgtCard.CARDCNT,"000000"); ////在售卡的过程中不会产生卡片交易流水

			strcpy(KEYVER,"00"); //密钥版本 交易的时候获取的 无法获取
			strcpy(ALGIND,"00"); //算法标志交易的时候获取的 无法获取
			sprintf(COMMANDLEN,"%03d",strlen(APDU));
			break;
		case 2062: //进行充值
			bbzero(gbl.dgtCard.CHARGE_DIVDATA);
			CTools::byte_to_hex((BYTE *) gbl.dgtCard.appSerial,(BYTE *)gbl.dgtCard.CHARGE_DIVDATA,8);
			strcpy(DIVDATA,gbl.dgtCard.CHARGE_DIVDATA);
			bbzero(CARDSEQ);
			strcpy(CARDSEQ,gbl.dgtCard.CARDCNT);

			strcpy(CARDRAND,gbl.dgtCard.CARDRAND);
			wrLog("cardRAND:%s",gbl.dgtCard.CARDRAND);
			strcpy(MAC1,gbl.dgtCard.MAC1);
			strcpy(KEYVER,gbl.dgtCard.KEYVER);
			strcpy(ALGIND,gbl.dgtCard.ALGIND);
			//apdu无值
			bbzero(APDU);
			strcpy(APDU,"12323");//随便写
			bbzero(COMMANDLEN);
			strcpy(COMMANDLEN,"0");
			break;
		default:
			strerr="卡操作操作请求失败";
			return CANCLE_KEY;
				
	}

	_pack_mapData.insert(pair<string,string> ("MERID",MERID));
	_pack_mapData.insert(pair<string,string>("CHANNELCODE",CHANNELCODE));
	_pack_mapData.insert(pair<string,string>("TMNNUM",TMNNUM));
	_pack_mapData.insert(pair<string,string>("SIGN","SIGN"));
	_pack_mapData.insert(pair<string,string>("CER","CER"));
	_pack_mapData.insert(pair<string,string>("WEBSVRNAME",WEBSVRNAME));
	_pack_mapData.insert(pair<string,string>("WEBSVRCODE",WEBSVRCODE));
	_pack_mapData.insert(pair<string,string>("APPFROM",APPFROMTmp));
	_pack_mapData.insert(pair<string,string>("KEEP",keep));
	_pack_mapData.insert(pair<string,string>("REQUESTTIME",server_time));
	
	_pack_mapData.insert(pair<string,string> ("ORDERSEQ",ORDERSEQ)); //客户终端号
	_pack_mapData.insert(pair<string,string> ("TMNNUMNO",gbl.dPosInfo.pos_no)); //客户终端号
	_pack_mapData.insert(pair<string,string> ("STAFFCODE",STAFFCODE)); //操作员
	_pack_mapData.insert(pair<string,string> ("ECARDNO",gbl.card_no)); //e卡
	_pack_mapData.insert(pair<string,string> ("PSAMCARDNO",psam_temp)); //e卡 psam号
	_pack_mapData.insert(pair<string,string> ("PASSFLAG",PASSFLAG)); //扣费类型
	_pack_mapData.insert(pair<string,string> ("PAYPASSWORD",password)); //交易密码
	_pack_mapData.insert(pair<string,string> ("TRADETIME",server_time)); //发起方的受理时间
	_pack_mapData.insert(pair<string,string> ("CARDOPRTYPE",CARDOPRTYPE)); //卡操作类型
	_pack_mapData.insert(pair<string,string> ("CITYCODE",CITYCODE)); //卡操作类型
	_pack_mapData.insert(pair<string,string> ("CARDID",gbl.dgtCard.cardShowId)); //卡内号 
	_pack_mapData.insert(pair<string,string> ("CARDMKND",CARDMKND)); //卡主类型
	_pack_mapData.insert(pair<string,string> ("CARDSKND",CARDSKND)); //卡子类型
	_pack_mapData.insert(pair<string,string> ("CARDMODEL","1")); //卡型 默认是cpu卡
	_pack_mapData.insert(pair<string,string> ("TRANSTYPE",TRANSTYPE)); //业务类型
	_pack_mapData.insert(pair<string,string> ("DEPOSIT",gbl.DEPOSIT)); //押金  N8
	_pack_mapData.insert(pair<string,string> ("ORIGAMT",ORIGAMT)); //应收金额
	_pack_mapData.insert(pair<string,string> ("CARDVALDATE",CARDVALDATE)); //卡片有效期
	_pack_mapData.insert(pair<string,string> ("SRCBAL",SRCBAL)); //卡片原额 N8
	_pack_mapData.insert(pair<string,string> ("CARDSEQ",CARDSEQ)); //卡片交易流水
	_pack_mapData.insert(pair<string,string> ("KEYVER",KEYVER)); //卡片密钥版本
	_pack_mapData.insert(pair<string,string> ("ALGIND",ALGIND)); //卡片算法标志
	_pack_mapData.insert(pair<string,string> ("CARDRAND",CARDRAND)); //卡片随机数
	_pack_mapData.insert(pair<string,string> ("MAC1",MAC1)); //充资返回信息MAC1
	_pack_mapData.insert(pair<string,string> ("DIVDATA",DIVDATA)); //分散因子
	_pack_mapData.insert(pair<string,string> ("BATCHNO",BATCHNO)); //批次号
	_pack_mapData.insert(pair<string,string> ("KEYSET",KEYSET)); //密钥
	_pack_mapData.insert(pair<string,string> ("COMMANDLEN",COMMANDLEN)); //APDU指令长度
	_pack_mapData.insert(pair<string,string> ("COMMAND",APDU)); //APDU指令
	_pack_mapData.insert(pair<string,string> ("POSID",gbl.dgtSignInfo.POSID)); //posid
	wrLog("strReq0:%s",strReq0.c_str());
	CxmlParser::pack(WEBSVRCODE,strReq1,_pack_mapData,strerr);

	iRet=ks_soap::get_response(TRADE_FLAG,strReq0,strReq1,strRsp,strerr);
	if (iRet!=0) 
	{
		
		strerr="";
		strerr = "网络繁忙，请稍后再试";
		//对于超时的情况插入数据库中，等候处理
		return -4;
	}
	

	iRet=CxmlParser::unpack(strRsp,WEBSVRCODE,_mapData,strerr);

	if (iRet!=0)
	{
		strerr = "报文解析错误，请稍后再试";
		return -4;
	} 

	if ( (iter=_mapData.find("RSPCODE")) == _mapData.end() ) //清结算终端
	{
        strerr = "无响应信息";
        return -4;
    }

	RSPCODE=iter->second;

	if (strcmp(RSPCODE.c_str(),"000000")==0 )//
	{

		if ( (iter=_mapData.find("TRANSSEQ")) == _mapData.end() ) //订单号是必须的
		
		{
			 strerr = "无订单号返回";
			 return -1;
		}
		else
		{
			bbzero(TRANSSEQ);
			TRANSSEQ_str=iter->second; //订单号
			strcpy(TRANSSEQ,TRANSSEQ_str.c_str());

		}
	

		if ( (iter=_mapData.find("SYSTEMNO")) == _mapData.end() ) //系统参考号
		{
			strerr = "无系统参考号";
			return -1;
		 }
		else
		{

			SYSTEMNO=iter->second; //系统参考号
			strcpy(gbl.SYSTEMNO,SYSTEMNO.c_str()); 

		}
	
	
		if ( (iter=_mapData.find("AUTHSEQ")) == _mapData.end() ) //授权认证
		{
			strerr = "无法获取授权流水号";
			 return -1;

		 }
		else
		{
		
			AUTHSEQ=iter->second;
		}
	
		//获取结算时间
		if ( (iter=_mapData.find("SETTDATE")) == _mapData.end() ) //结算时间
		{
			strerr = "无结算时间";
			return -1;
		 }
		else
		{
		
			bbzero(gbl.dgtCard.SETDATE);
			setDate_Str=iter->second; //结算时间
			strcpy(gbl.dgtCard.SETDATE,setDate_Str.c_str());
		}
	

		//获取批次号
		if ( (iter=_mapData.find("BATCHNO")) == _mapData.end() ) //批次号
		{
			strerr = "无批次号";
			return -1;
		}
		else
		{
			bbzero(gbl.dgtCard.BATCHNO);
			BATCHNO_str=iter->second; //结算时间
			strcpy(gbl.dgtCard.BATCHNO,BATCHNO_str.c_str());

		}
	

		if ( (iter=_mapData.find("LIMITEAUTHSEQL")) == _mapData.end() ) 
		{
       
			strerr = "无法获取额度授权流水号";
			 return -1;
		}
		else
		{
			LIMITEAUTHSEQL=iter->second;

		}
	

		if ( (iter=_mapData.find("SYSDATETIME")) == _mapData.end() )  
		{

		  strerr = "无法获取中心时间";
			return -1;
		}
		else
		{
			SYSDATETIME=iter->second;
		}
	
		if ( (iter=_mapData.find("MESSAGEDATETIME")) == _mapData.end() )  
		{
        
			strerr = "无法获取报文发送时间";
			 return -1;
		}
		else
		{
			
			MESSAGEDATETIME=iter->second;
			bbzero(gbl.dgtCard.MESSAGEDATETIME);
			strcpy(gbl.dgtCard.MESSAGEDATETIME,MESSAGEDATETIME.c_str());
			//获取交易时间
			bbzero(gbl.dgtCard.tradeDate);
			bbzero(gbl.dgtCard.tradeTime);
			memcpy(gbl.dgtCard.tradeDate,gbl.dgtCard.MESSAGEDATETIME,8);
			memcpy(gbl.dgtCard.tradeTime,gbl.dgtCard.MESSAGEDATETIME+8,6);

		}
	

		if (strcmp(TRANSTYPE,"80")==0)
		{

			if ( (iter=_mapData.find("DICMAC")) == _mapData.end() ) //清结算终端
			{
				strerr = "无法获取DICMAC";
				return -1;
			}
			else
			{
				DICMAC=iter->second;
				bbzero(gbl.dgtCard.DICMAC);
				strcpy(gbl.dgtCard.DICMAC,DICMAC.c_str());
	

			}
		
		
		}
	
		if (strcmp(TRANSTYPE,"02")==0) //如果是充值

		{
			if ( (iter=_mapData.find("MAC2")) == _mapData.end() ) //清结算终端

			{
				strerr = "无法获取MAC2";
				return -1;
			}
			else
			{
			
				MAC2=iter->second;
				bbzero(gbl.dgtCard.MAC2);
				strcpy(gbl.dgtCard.MAC2,MAC2.c_str());
			}
		

		}

		bbzero(gbl.dgtCard.AUTHSEQ);
		strcpy(gbl.dgtCard.AUTHSEQ,AUTHSEQ.c_str());
		bbzero(gbl.dgtCard.LIMITEAUTHSEQL);
		strcpy(gbl.dgtCard.LIMITEAUTHSEQL,LIMITEAUTHSEQL.c_str());
		bbzero(gbl.dgtCard.sysTime);
		strcpy(gbl.dgtCard.sysTime,SYSDATETIME.c_str());
	
		wrLog("卡片操作返回信息");
		wrLog("密钥授权流水号:%s",AUTHSEQ.c_str());
		wrLog("额度授权流水号:%s",LIMITEAUTHSEQL.c_str());
		wrLog("指令MAC信息:%s",DICMAC.c_str());
		wrLog("中心时间是:%s",gbl.dgtCard.sysTime);
		wrLog("MAC2:%s",MAC2.c_str());
		wrLog("gbl.TRANSSEQ :%s",TRANSSEQ);

	}
	else //如果返回失败的情况
	{
		//如果申请失败，返回信息
		//返回错误信息

		if ( (iter=_mapData.find("RSPMSG")) == _mapData.end() ) //系统参考号
		{
		 	strerr = "未知错误";
		}
		else
		{
			
			strerr=iter->second; //系统参考号
			char dgtMSG[500];
			int err_iRet;
			bbzero(dgtMSG);
			bbzero(DGTRSP_CODE);
			memcpy(DGTRSP_CODE,strerr.c_str(),5);
			//查询错误码是否是东莞公交的。如果是东莞公交的直接退出，不需要有再发送确认信息
			err_iRet=CDB::getDGTcodeMessge(DGTRSP_CODE,dgtMSG);
			if (err_iRet==0) //如果错误码来自东莞公交，则不发送冲正信息
			{
				strerr.assign(dgtMSG,strlen(dgtMSG));
				return -6; //直接退出，不需要发冲正包了
			}

		}

		if ( (iter=_mapData.find("SYSTEMNO")) == _mapData.end() ) //系统参考号
		{
			strerr = "无系统参考号";
			return -5;
		}
		else
		{
			
			SYSTEMNO=iter->second; //系统参考号
			strcpy(gbl.SYSTEMNO,SYSTEMNO.c_str()); 
		}

		if ( (iter=_mapData.find("AUTHSEQ")) == _mapData.end() ) //授权认证
		{
			strerr = "无法获取授权流水号";
			 return -5;

		}
		else
		{
		  	AUTHSEQ=iter->second;
		}
		
		//获取结算时间
		if ( (iter=_mapData.find("SETTDATE")) == _mapData.end() ) //结算时间
		{
			strerr = "无结算时间";
			return -5;
		}
		else
		{
			bbzero(gbl.dgtCard.SETDATE);
			setDate_Str=iter->second; //结算时间
			strcpy(gbl.dgtCard.SETDATE,setDate_Str.c_str());
		}
	
		//获取批次号
		if ( (iter=_mapData.find("BATCHNO")) == _mapData.end() ) //批次号
		{
			strerr = "无批次号";
			return -5;
		}
		else
		{
		
			bbzero(gbl.dgtCard.BATCHNO);
			BATCHNO_str=iter->second; //结算时间
			strcpy(gbl.dgtCard.BATCHNO,BATCHNO_str.c_str());

		}
	
	
		if ( (iter=_mapData.find("LIMITEAUTHSEQL")) == _mapData.end() ) 
		{
       
			strerr = "无法获取额度授权流水号";
			 return -5;
		}
		else
		{
			LIMITEAUTHSEQL=iter->second;
		}
	

		if ( (iter=_mapData.find("MESSAGEDATETIME")) == _mapData.end() )  
		{
        
			strerr = "无法获取报文发送时间";
			bbzero(gbl.dgtCard.tradeDate);
			bbzero(gbl.dgtCard.tradeTime);
			CTools::getDate(gbl.dgtCard.tradeDate);
			CTools::getTime(gbl.dgtCard.tradeTime);
		}
		else
		{
		
			MESSAGEDATETIME=iter->second;
			bbzero(gbl.dgtCard.MESSAGEDATETIME);
			strcpy(gbl.dgtCard.MESSAGEDATETIME,MESSAGEDATETIME.c_str());
			//获取交易时间
			bbzero(gbl.dgtCard.tradeDate);
			bbzero(gbl.dgtCard.tradeTime);
			memcpy(gbl.dgtCard.tradeDate,gbl.dgtCard.MESSAGEDATETIME,8);
			memcpy(gbl.dgtCard.tradeTime,gbl.dgtCard.MESSAGEDATETIME+8,6);

		}

		bbzero(gbl.dgtCard.AUTHSEQ);
		strcpy(gbl.dgtCard.AUTHSEQ,AUTHSEQ.c_str());
		bbzero(gbl.dgtCard.LIMITEAUTHSEQL);
		strcpy(gbl.dgtCard.LIMITEAUTHSEQL,LIMITEAUTHSEQL.c_str());
	
		wrLog("卡片操作返回信息");
		wrLog("密钥授权流水号:%s",AUTHSEQ.c_str());
		wrLog("额度授权流水号:%s",LIMITEAUTHSEQL.c_str());
		wrLog("指令MAC信息:%s",DICMAC.c_str());
		wrLog("中心时间是:%s",gbl.dgtCard.sysTime);
		wrLog("MAC2:%s",MAC2.c_str());
		wrLog("gbl.seqhhah :%s",TRANSSEQ);

		return -2; 

	}

	return 0;

}

//卡片有效性检查
//需要检查是否是黑名单卡。
//type:1 表示充值。0 表示开卡
//errMsg:错误信息

int CTrade::dgtEffectiveCheck(int type,char * errMsg)
{
	char currentDate[8+1];
	char effectiveDate[8+1];

	bbzero(effectiveDate);
	bbzero(currentDate);
	CTools::getDate(currentDate);
	
	CTools::byte_to_hex((BYTE *)gbl.dgtCard.effectiveDate,(BYTE *)effectiveDate,4);
	
	//如果是20901231 表示长期有效 

	//充值和开卡要求卡片类型为cpu卡 并在卡片使用有效期中
	if (strcmp(gbl.dgtCard.cardType,"0A") !=0 ) 
	{
	
		bbzero(errMsg);
		strcpy(errMsg,"卡片类型错误");
		return -1; //卡片类型错误

	}

	if (type==0  && memcmp(gbl.dgtCard.appFlag,"\x01",1)==0 ) //如果是开卡
	{

		bbzero(errMsg);
		strcpy(errMsg,"卡片已经激活");
		return -3;
	}

	if (type==1) //如果是充值
	{
		if (memcmp(gbl.dgtCard.appFlag,"\x00",1)==0) //尚未激活
		{
			wrLog("卡片为开通,请先开卡");
			bbzero(errMsg);
			strcpy(errMsg,"卡片尚未激活,请先开卡");
			return -2;
		}
	
		//如果已经开卡 并且有效期不是20901231 并且已经超过有效期
	
		if (strcmp(effectiveDate,"20901231") !=0 && (atoi(currentDate)>atoi(effectiveDate)) )
		{
			bbzero(errMsg);
			strcpy(errMsg,"卡片已经失效");
			return -4;
		}
	
	}

	return 0;
}
//东莞通售卡服务
/************************************************************************/
/*                                                    
SALEMODE:销售模式 售卡方式
0  出租
1  出售
2  押金方式

0:开卡
1：开卡冲正
默认为0
OPERATIONTYPE:操作类型
*/

/************************************************************************/

int CTrade::cardSaleService(char *WEBSVRNAME,char *WEBSVRCODE,char *OPERATIONTYPE,char * TRANSTYPE,char *TRANSSEQ,char *SALEMODE,string &strerr)
{
	
	char server_time[14+1];
	char ACCEPTTIME[6+1];
	char acceptDate[8+1];
	char command_len[6+1];
	string strReq0,strReq1;
	int iRet;
	string BILLNUM;
	string SYSTEMNO_STR="";
	strerr="";
	string strRsp="";
	string datas;
	bbzero(server_time);
	char keep[32+1];
	bbzero(keep);
	char STAFFCODE[20];
	char TRADETIME[14+1];//受理时间
	char SETTDATE[8+1]; //结算日期
	char BATCHNO[6+1]; //批次号
	char CITYCODE[4+1]; //城市编码
	char CARDID[16+1]; //卡内号
	char CARDMKND[2+1]; //主卡类型
	char CARDSKND[2+1]; //	子卡类型
	char DEPOSIT[8+1]; //押金
	char CARDVALDATE[8+1]; //卡片有效期
	char SRCBAL[8+1]; //卡片原额
	char CARDSEQ[6+1]; //卡片交易流水号
	char KEYVER[2+1]; //卡片密钥版本
	char ALGIND[2+1]; //ALGIND
	char CARDRAND[8+1]; //随机数
	char MAC1[8+1]; //充资返回信息MAC1
	char DIVDATA[18+1]; //分散因子
	char KEYSET[32+1]; //密钥
	char PAYPASSWORD[128]; //交易密码
	char AUTHSEQ[18+1];
	char LIMITEAUTHSEQL[10+1]; //额度授权流水号
	char BEFBALANCE[8+1];// 交易前余额 
	char CARDCNT[6+1]; //卡内计数器
	char CARDVERNO[2+1]; //卡内版本号
	char EDCARDID[16+1]; 
	char ORDERSEQ[10];
	char TXNAMT[8+1];
	char TXNDATE[8+1];
	char TXNTIME[6+1];
	char TAC[8+1];

	bbzero(EDCARDID);
	bbzero(TAC);
	bbzero(TXNDATE);
	bbzero(TXNTIME);
	bbzero(CITYCODE);
	bbzero(CARDID);
	bbzero(CARDMKND);
	bbzero(CARDSKND);
	bbzero(DEPOSIT);
	bbzero(SRCBAL);
	bbzero(CARDSEQ);
	bbzero(KEYVER);
	bbzero(ALGIND);
	bbzero(CARDRAND);
	bbzero(MAC1);
	bbzero(DIVDATA);
	bbzero(KEYSET);
	bbzero(PAYPASSWORD);
	bbzero(CARDCNT);

	bbzero(TRADETIME);
	bbzero(SETTDATE);
	bbzero(BATCHNO);
	bbzero(LIMITEAUTHSEQL);
	bbzero(AUTHSEQ);
	bbzero(BEFBALANCE);
	bbzero(CARDVERNO);
	bbzero(command_len);
	bbzero(ORDERSEQ);
	bbzero(TXNAMT);

	//返回参数信息
	string RSPCODE ="";

	map<string, string>::iterator iter;
	map<string, string> _mapData; //返回的数据
	map<string, string> _pack_mapData; //发送的数据
	
	char strReqTmp[100];
	bbzero(strReqTmp);
	char APPFROMTmp[50];
	bbzero(APPFROMTmp);
	sprintf(strReqTmp,"%s|440100-APP001-001-%s|APP001|%s|",WEBSVRCODE,gbl.server_ip,gbl.server_ip);
	sprintf(APPFROMTmp,"440100-APP001-001-%s",gbl.server_ip);
	strReq0.assign(strReqTmp,strlen(strReqTmp));
	bbzero(server_time);
	bbzero(ACCEPTTIME);

	CTools::get_termTime(server_time);
	CTools::getDate(acceptDate);
	CTools::getTime(ACCEPTTIME);

	strcpy(ORDERSEQ,gbl.dgtCard.posSeq);
	strcpy(EDCARDID,"0000000000000000"); //卡内号
	strcpy(CARDVERNO,"00"); //卡内版本号

	bbzero(keep);
	//CTools::get_keep(keep);
	CTools::get_keep(gbl.dPosInfo.pos_no,&gbl.random_value,keep);

	bbzero(STAFFCODE);
	sprintf(STAFFCODE,"%s_01",gbl.dPosInfo.pos_no);

	if (strlen(gbl.dgtCard.tradeDate) ==0) //如果不存在
	{
		CTools::getDate(gbl.dgtCard.tradeDate);
	}

	if (strlen(gbl.dgtCard.tradeTime) ==0) //如果交易时间不存在
	{

		CTools::getTime(gbl.dgtCard.tradeTime);
	}

	strcpy(TXNDATE,gbl.dgtCard.tradeDate);
	strcpy(TXNTIME,gbl.dgtCard.tradeTime);

	strcpy(TAC,"00000000"); //无法获取TAC。
	wrLog("txndate:%s",TXNDATE);
	wrLog("txntime:%s",TXNTIME);

	CTools::byte_to_hex((BYTE *)gbl.dgtCard.deposit,(BYTE *)DEPOSIT,2); //押金 格式转换
	wrLog("DEPOSIT:%s",DEPOSIT);
	
	if (strcmp(DEPOSIT,"FFFF")==0) //无押金
	{
		//表示无押金
		strcpy(gbl.DEPOSIT,"00000000");
		
	}
	else
	{
		
		char DEPOSIT_temp[2+1];
		bbzero(DEPOSIT_temp);
		memcpy(DEPOSIT_temp,DEPOSIT+2,2); //获取后两位
		bbzero(gbl.DEPOSIT);
		sprintf(gbl.DEPOSIT,"%08d",(atoi(DEPOSIT_temp)*100)) ; //转换成分
		
	}

	CTools::byte_to_hex((BYTE *)gbl.dgtCard.cardParent_type,(BYTE *)CARDMKND,1);
	CTools::byte_to_hex((BYTE *)gbl.dgtCard.cardChild_type,(BYTE *)CARDSKND,1);
	//CTools::byte_to_hex((BYTE *)gbl.dgtCard.effectiveDate,(BYTE *)CARDVALDATE,4);
	strcpy(CARDVALDATE,"20901231");
	CTools::byte_to_hex((BYTE *)gbl.dgtCard.CItyCode,(BYTE *)CITYCODE,2);

	//参数赋值
	strcpy(SETTDATE,gbl.dgtCard.SETDATE);
	strcpy(BATCHNO,gbl.dgtCard.BATCHNO);

	strcpy(CARDSEQ,gbl.dgtCard.CARDSEQ);
	strcpy(KEYVER,gbl.dgtCard.KEYVER);
	strcpy(ALGIND,gbl.dgtCard.ALGIND);

	strcpy(CARDRAND,gbl.dgtCard.CARDRAND);
	strcpy(MAC1,gbl.dgtCard.MAC1);
	strcpy(DIVDATA,gbl.dgtCard.CARDSALE_DIVDATA);
	strcpy(KEYSET,gbl.dgtCard.KEYSET);
	strcpy(SRCBAL,gbl.dgtCard.cardMny);
	strcpy(PAYPASSWORD,gbl.password);

	bbzero(BEFBALANCE);
	strcpy(BEFBALANCE,gbl.dgtCard.tradeBeForeMny); //交易前余额

	bbzero(CARDCNT);
	strcpy(CARDCNT,gbl.dgtCard.CARDCNT); //卡内计数器

	sprintf(AUTHSEQ,"%s%s",gbl.dgtCard.SETDATE,gbl.dgtCard.AUTHSEQ);
	wrLog("授权流水号:%s",AUTHSEQ);
	wrLog("系统参考号:%s",gbl.SYSTEMNO);

	strcpy(LIMITEAUTHSEQL,gbl.dgtCard.LIMITEAUTHSEQL); //LIMITEDAUTHSEQ	额度授权流水号
	memcpy(TXNAMT,gbl.amount+4,8);

	_pack_mapData.insert(pair<string,string> ("MERID",MERID));
	_pack_mapData.insert(pair<string,string>("CHANNELCODE",CHANNELCODE));
	_pack_mapData.insert(pair<string,string>("TMNNUM",TMNNUM));
	_pack_mapData.insert(pair<string,string>("SIGN","SIGN"));
	_pack_mapData.insert(pair<string,string>("CER","CER"));
	_pack_mapData.insert(pair<string,string>("WEBSVRNAME",WEBSVRNAME));
	_pack_mapData.insert(pair<string,string>("WEBSVRCODE",WEBSVRCODE));
	_pack_mapData.insert(pair<string,string>("APPFROM",APPFROMTmp));
	_pack_mapData.insert(pair<string,string>("KEEP",keep));
	_pack_mapData.insert(pair<string,string>("REQUESTTIME",server_time));
	
	_pack_mapData.insert(pair<string,string> ("ORDERSEQ",ORDERSEQ)); //ORDERSEQ
	_pack_mapData.insert(pair<string,string> ("TMNNUMNO",gbl.dPosInfo.pos_no)); //客户终端号
	_pack_mapData.insert(pair<string,string> ("STAFFCODE",STAFFCODE)); //操作员
	_pack_mapData.insert(pair<string,string> ("SYSTEMNO",gbl.SYSTEMNO)); //系统参考号
	_pack_mapData.insert(pair<string,string> ("OPERATIONTYPE",OPERATIONTYPE)); //操作类型
	_pack_mapData.insert(pair<string,string> ("TRANSTYPE",TRANSTYPE)); //业务类型
	if (strcmp(OPERATIONTYPE,"ATR2")!=0)
	{
		_pack_mapData.insert(pair<string,string> ("APTRANSSEQ",TRANSSEQ)); //当进行ATR2的时候 不需要这个值
	}

	_pack_mapData.insert(pair<string,string> ("TRADETIME",server_time)); //发起方的受理时间
	_pack_mapData.insert(pair<string,string> ("CITYCODE",CITYCODE)); //城市编码
	_pack_mapData.insert(pair<string,string> ("EDCARDID",EDCARDID)); //操作主卡卡号
	_pack_mapData.insert(pair<string,string> ("TAC",TAC)); //tac
	_pack_mapData.insert(pair<string,string> ("TXNDATE",TXNDATE)); //txndate
	_pack_mapData.insert(pair<string,string> ("TXNTIME",TXNTIME)); //txntime
	_pack_mapData.insert(pair<string,string> ("CARDID",gbl.dgtCard.cardShowId)); //卡内号
	_pack_mapData.insert(pair<string,string> ("CARDCNT",CARDCNT)); //卡计数器
	_pack_mapData.insert(pair<string,string> ("CARDMKND",CARDMKND)); //卡主类型
	_pack_mapData.insert(pair<string,string> ("CARDSKND",CARDSKND)); //卡子类型
	_pack_mapData.insert(pair<string,string> ("CARDMODEL","1")); //卡型 默认是cpu卡
	_pack_mapData.insert(pair<string,string> ("SALEMODE",SALEMODE)); //销售方式

	_pack_mapData.insert(pair<string,string> ("DEPOSIT",gbl.DEPOSIT)); //押金 
	_pack_mapData.insert(pair<string,string> ("BEFBALANCE",BEFBALANCE)); //交易前余额
	_pack_mapData.insert(pair<string,string> ("TXNAMT",TXNAMT)); //交易金额
	_pack_mapData.insert(pair<string,string> ("CARDVALDATE",CARDVALDATE)); //卡片有效期 需要明确
	_pack_mapData.insert(pair<string,string> ("CITYCODE",CITYCODE)); //城市代码
	_pack_mapData.insert(pair<string,string> ("CARDVERNO",CARDVERNO)); //卡内版本号
	_pack_mapData.insert(pair<string,string> ("BATCHNO",BATCHNO)); //批次号
	_pack_mapData.insert(pair<string,string> ("AUTHSEQ",AUTHSEQ)); //授权流水号
	_pack_mapData.insert(pair<string,string> ("LIMITEDAUTHSEQL",LIMITEAUTHSEQL)); //额度授权流水号
	_pack_mapData.insert(pair<string,string> ("KEYSET",KEYSET)); //密钥


	wrLog("strReq0:%s",strReq0.c_str());
	CxmlParser::pack(WEBSVRCODE,strReq1,_pack_mapData,strerr);


	iRet=ks_soap::get_response(TRADE_FLAG,strReq0,strReq1,strRsp,strerr);
	if (iRet!=0)
	{
		
		strerr="";
		strerr = "网络繁忙，请稍后再试";
		return -4;
	}
	
	iRet=CxmlParser::unpack(strRsp,WEBSVRCODE,_mapData,strerr);
	if (iRet!=0)
	{
		strerr = "报文解析错误，请稍后再试";
		return -1;
	} 

	if ( (iter=_mapData.find("RSPCODE")) == _mapData.end() ) //清结算终端
	{
        strerr = "无响应信息";
        return -3;
    }

	RSPCODE=iter->second;

	if (strcmp(RSPCODE.c_str(),"000000")!=0) //如果售卡返回响应码失败。取错误信息20002 
	{

		if (strcmp(RSPCODE.c_str(),"004232")==0) //订单已经生成
		{
			return 0;
		}

		/*
		if (strcmp(RSPCODE.c_str(),"011007")==0)//订单未生成，未知错误，请联系管理员
		{
			return 0;
		}
		*/

		//对于响应码已经冲正

		if (strcmp(RSPCODE.c_str(),"26089")==0)//对于响应码，已经冲正，进行处理
		{
			return 0;
		}

		if ((iter=_mapData.find("RSPMSG"))==_mapData.end())
		{
			strerr="无错误信息";
			
			return -2;
			
		}

		strerr=iter->second;
		if (memcmp(strerr.c_str(),"20002",5)==0)
		{
			return 0;
		}

		return -2;
	}

	return 0;

}


/************************************************************************/
/* 
//东莞通充值及冲正报文
                                                                     */
/************************************************************************/

int CTrade::dgtCardChargeService(char *WEBSVRNAME,char *WEBSVRCODE, char *OPERATIONTYPE,char *TRANSTYPE,char *TRANSSEQ,string &strerr)
{

	char server_time[14+1];
	char ACCEPTTIME[6+1];
	char acceptDate[8+1];
	string strReq0,strReq1;
	int iRet;
	string BILLNUM;
	string SYSTEMNO_STR="";
	strerr="";
	string strRsp="";
	string datas;
	bbzero(server_time);
	char keep[32+1];
	bbzero(keep);
	char STAFFCODE[20];
	char TRADETIME[14+1];//受理时间
	char SETTDATE[8+1]; //结算日期
	char BATCHNO[6+1]; //批次号
	char CITYCODE[4+1]; //城市编码
	char CARDID[16+1]; //卡内号
	char CARDMKND[2+1]; //主卡类型
	char CARDSKND[2+1]; //	子卡类型
	char DEPOSIT[8+1]; //押金
	char CARDVALDATE[8+1]; //卡片有效期
	char SRCBAL[8+1]; //卡片原额
	char CARDSEQ[6+1]; //卡片交易流水号
	char KEYVER[2+1]; //卡片密钥版本
	char ALGIND[2+1]; //ALGIND
	char CARDRAND[8+1]; //随机数
	char KEYSET[32+1]; //密钥
	char PAYPASSWORD[128]; //交易密码
	char AUTHSEQ[18+1];
	char LIMITEDAUTHSEQL[18+1]; //额度授权流水号
	char BEFBALANCE[8+1];// 交易前余额 
	char CARDVERNO[2+1]; //卡内版本号
	char EDCARDID[16+1];
	char HANDINGCHARGE[8+1];
	char LASTPOSSVSEQ[9+1];
	char ORDERSEQ[10];
	char CARDCNT[8+1];
	char CARD_trade_seq[4+1];
	char ORIGAMT[8+1];
	char TXNAMT[8+1];
	char TAC[8+1];
	char TXNTIME[6+1];
	char TXNDATE[8+1];


	bbzero(TAC);
	bbzero(TXNDATE);
	bbzero(TXNTIME);
	bbzero(ORIGAMT);
	bbzero(TXNAMT);
	bbzero(CITYCODE);
	bbzero(CARDID);
	bbzero(CARDMKND);
	bbzero(CARDSKND);
	bbzero(DEPOSIT);
	bbzero(SRCBAL);
	bbzero(CARDSEQ);
	bbzero(KEYVER);
	bbzero(ALGIND);
	bbzero(CARDRAND);
	bbzero(KEYSET);
	bbzero(PAYPASSWORD);

	bbzero(TRADETIME);
	bbzero(SETTDATE);
	bbzero(BATCHNO);
	bbzero(LIMITEDAUTHSEQL);
	bbzero(AUTHSEQ);
	bbzero(BEFBALANCE);
	bbzero(CARDVERNO);
	bbzero(EDCARDID);
	bbzero(HANDINGCHARGE);
	bbzero(LASTPOSSVSEQ); //POS终端上笔充值流水号    
	bbzero(ORDERSEQ);
	bbzero(CARDCNT);
	bbzero(CARD_trade_seq);


	//返回参数信息
	string  RSPCODE="";

	map<string, string>::iterator iter;
	map<string, string> _mapData; //返回的数据
	map<string, string> _pack_mapData; //发送的数据
	
	char strReqTmp[100];
	bbzero(strReqTmp);
	char APPFROMTmp[50];
	bbzero(APPFROMTmp);
	sprintf(strReqTmp,"%s|440100-APP001-001-%s|APP001|%s|",WEBSVRCODE,gbl.server_ip,gbl.server_ip);
	sprintf(APPFROMTmp,"440100-APP001-001-%s",gbl.server_ip);
	strReq0.assign(strReqTmp,strlen(strReqTmp));
	bbzero(server_time);
	bbzero(ACCEPTTIME);
	CTools::get_termTime(server_time);
	CTools::getDate(acceptDate);
	CTools::getTime(ACCEPTTIME);
	strcpy(ORDERSEQ,gbl.dgtCard.posSeq);
	bbzero(keep);
	//CTools::get_keep(keep);
	CTools::get_keep(gbl.dPosInfo.pos_no,&gbl.random_value,keep);

	bbzero(STAFFCODE);
	sprintf(STAFFCODE,"%s_01",gbl.dPosInfo.pos_no);
	bbzero(TXNDATE);
	bbzero(TXNTIME);
	
	if (strlen(gbl.dgtCard.tradeDate)==0)
	{
		bbzero(gbl.dgtCard.tradeDate);
		CTools::getDate(gbl.dgtCard.tradeDate);
	}
	if (strlen(gbl.dgtCard.tradeTime)==0)
	{
		bbzero(gbl.dgtCard.tradeTime);
		CTools::getTime(gbl.dgtCard.tradeTime);
	}

	strcpy(TXNDATE,gbl.dgtCard.tradeDate);
	strcpy(TXNTIME,gbl.dgtCard.tradeTime);

	wrLog("交易时间:%s",TXNDATE);
	wrLog("交易日期:%s",TXNTIME);
	wrLog("系统参考号:%s",gbl.SYSTEMNO);

	//参数赋值
	CTools::byte_to_hex((BYTE *)gbl.dgtCard.deposit,(BYTE *)DEPOSIT,2); //押金 格式转换
	wrLog("DEPOSIT:%s",DEPOSIT);
	
	if (strcmp(DEPOSIT,"FFFF")==0) //无押金
	{
		//表示无押金
		strcpy(gbl.DEPOSIT,"00000000");
		
	}
	else
	{
		
		char DEPOSIT_temp[2+1];
		bbzero(DEPOSIT_temp);
		memcpy(DEPOSIT_temp,DEPOSIT+2,2); //获取后两位
		bbzero(gbl.DEPOSIT);
		sprintf(gbl.DEPOSIT,"%08d",(atoi(DEPOSIT_temp)*100)) ; //转换成分
		
	}


	CTools::byte_to_hex((BYTE *)gbl.dgtCard.cardParent_type,(BYTE *)CARDMKND,1);
	CTools::byte_to_hex((BYTE *)gbl.dgtCard.cardChild_type,(BYTE *)CARDSKND,1); //CARDSKND
	CTools::byte_to_hex((BYTE *)gbl.dgtCard.effectiveDate,(BYTE *)CARDVALDATE,4);


	strcpy(SETTDATE,gbl.dgtCard.SETDATE);
	strcpy(BATCHNO,gbl.dgtCard.BATCHNO);
	CTools::byte_to_hex((BYTE *)gbl.dgtCard.CItyCode,(BYTE *)CITYCODE,2);
	strcpy(CARDID,gbl.dgtCard.cardShowId);

	bbzero(CARDSEQ); //卡片计数器
	strcpy(CARDSEQ,gbl.dgtCard.CARDCNT);

	strcpy(CARDRAND,gbl.dgtCard.CARDRAND); 

	strcpy(KEYSET,gbl.dgtCard.KEYSET);
	strcpy(SRCBAL,gbl.dgtCard.cardMny);
	strcpy(PAYPASSWORD,gbl.password);
	strcpy(BEFBALANCE,gbl.dgtCard.tradeBeForeMny); //

	strcpy(CARDVERNO,"00");//卡内版本号 无法获取值交易前余额

	sprintf(AUTHSEQ,"%s%s",gbl.dgtCard.SETDATE,gbl.dgtCard.AUTHSEQ);
	strcpy(LIMITEDAUTHSEQL,gbl.dgtCard.LIMITEAUTHSEQL); //LIMITEDAUTHSEQ	额度授权流水号
	strcpy(EDCARDID,gbl.dgtCard.EDCARDID);

	bbzero(LASTPOSSVSEQ);
	strcpy(LASTPOSSVSEQ,gbl.dgtCard.lastPosSeq);

	memcpy(TXNAMT,gbl.amount+4,8);
	memcpy(ORIGAMT,gbl.amount+4,8);
	
	if (strcmp(OPERATIONTYPE,"RGR")==0  || strcmp(OPERATIONTYPE,"RGR2")==0 ) //如果是冲正包 
	{
		strcpy(TAC,"00000000");
		wrLog("TAC:%s",TAC);
	}
	else
	{
		bbzero(TAC);
		strcpy(TAC,gbl.dgtCard.TAC); //tac赋值
		wrLog("TAC:%s",TAC);

	}

	//该报文中如果TAC等值为空，取默认值
	if (strlen(TAC) ==0 )
	{
		strcpy(TAC,"00000000");

	}

	_pack_mapData.insert(pair<string,string> ("MERID",MERID));
	_pack_mapData.insert(pair<string,string>("CHANNELCODE",CHANNELCODE));
	_pack_mapData.insert(pair<string,string>("TMNNUM",TMNNUM));
	_pack_mapData.insert(pair<string,string>("SIGN","SIGN"));
	_pack_mapData.insert(pair<string,string>("CER","CER"));
	_pack_mapData.insert(pair<string,string>("WEBSVRNAME",WEBSVRNAME));
	_pack_mapData.insert(pair<string,string>("WEBSVRCODE",WEBSVRCODE));
	_pack_mapData.insert(pair<string,string>("APPFROM",APPFROMTmp));
	_pack_mapData.insert(pair<string,string>("KEEP",keep));
	_pack_mapData.insert(pair<string,string>("REQUESTTIME",server_time));
	
	_pack_mapData.insert(pair<string,string> ("ORDERSEQ",ORDERSEQ)); //发起方交易流水号
	_pack_mapData.insert(pair<string,string> ("TMNNUMNO",gbl.dPosInfo.pos_no)); //客户终端号
	_pack_mapData.insert(pair<string,string> ("SYSTEMNO",gbl.SYSTEMNO)); //

	_pack_mapData.insert(pair<string,string> ("TRANSTYPE",TRANSTYPE)); //
	_pack_mapData.insert(pair<string,string> ("TAC",TAC)); //
	if (strcmp(OPERATIONTYPE,"RGR2")!=0)
	{
		_pack_mapData.insert(pair<string,string> ("APTRANSSEQ",TRANSSEQ)); //
	}

	_pack_mapData.insert(pair<string,string> ("STAFFCODE",STAFFCODE)); //操作员

	_pack_mapData.insert(pair<string,string> ("OPERATIONTYPE",OPERATIONTYPE)); //操作类型
	_pack_mapData.insert(pair<string,string> ("TRADETIME",server_time)); //发起方的受理时间
	_pack_mapData.insert(pair<string,string> ("CARDID",CARDID)); //卡内号
	_pack_mapData.insert(pair<string,string> ("TXNDATE",TXNDATE)); //交易日期
	_pack_mapData.insert(pair<string,string> ("TXNTIME",TXNTIME)); //交易时间
	_pack_mapData.insert(pair<string,string> ("TAC",TAC)); //TAC
	_pack_mapData.insert(pair<string,string> ("CARDCNT",CARDSEQ)); //卡计数器

	_pack_mapData.insert(pair<string,string> ("CARDMKND",CARDMKND)); //卡主类型
	_pack_mapData.insert(pair<string,string> ("CARDSKND",CARDSKND)); //卡子类型
	_pack_mapData.insert(pair<string,string> ("CARDMODEL","1")); //卡型 默认是cpu卡
	_pack_mapData.insert(pair<string,string> ("BEFBALANCE",BEFBALANCE)); //交易前余额
	_pack_mapData.insert(pair<string,string> ("ORIGAMT",ORIGAMT)); //应收
	_pack_mapData.insert(pair<string,string> ("TXNAMT",TXNAMT)); //实收金额 
	_pack_mapData.insert(pair<string,string> ("HANDINGCHARGE","00000000")); //手续费
	_pack_mapData.insert(pair<string,string> ("DEPOSIT",gbl.DEPOSIT)); //押金
	_pack_mapData.insert(pair<string,string> ("CARDVALDATE",CARDVALDATE)); //卡片有效期
	_pack_mapData.insert(pair<string,string> ("CITYCODE",CITYCODE)); //
	_pack_mapData.insert(pair<string,string> ("CARDVERNO",CARDVERNO)); //卡内版本号
	_pack_mapData.insert(pair<string,string> ("BATCHNO",BATCHNO)); //批次号
	_pack_mapData.insert(pair<string,string> ("AUTHSEQ",AUTHSEQ)); //授权流水号
	_pack_mapData.insert(pair<string,string> ("LIMITEDAUTHSEQL",LIMITEDAUTHSEQL)); //额度授权流水号
	_pack_mapData.insert(pair<string,string> ("LASTPOSSVSEQ",LASTPOSSVSEQ)); //POS终端上笔充值流水号 
	_pack_mapData.insert(pair<string,string> ("KEYSET",KEYSET)); //密钥

	wrLog("strReq0:%s",strReq0.c_str());
	CxmlParser::pack(WEBSVRCODE,strReq1,_pack_mapData,strerr);
	
	iRet=ks_soap::get_response(TRADE_FLAG,strReq0,strReq1,strRsp,strerr);
	if (iRet!=0) //如果执行不成功，直接退出
	{
		strerr="网络连接超时";
		return -4;
	}

	iRet=CxmlParser::unpack(strRsp,WEBSVRCODE,_mapData,strerr);
	if (iRet!=0)
	{
		 strerr = "报文解析错误，请稍后再试";
		return -3;
	} 

	if ( (iter=_mapData.find("RSPCODE")) == _mapData.end() ) //清结算终端
	{
        strerr = "无响应信息";
        return -1;
    }

	RSPCODE=iter->second;
	if (strcmp(RSPCODE.c_str(),"000000")!=0)
	{
		if (strcmp(RSPCODE.c_str(),"004232")==0) //订单已经完成
		{
			return 0;

		}
		if (strcmp(RSPCODE.c_str(),"011007")==0) //订单未生成，未知错误
		{
			return -2;
		}

		if (strcmp(RSPCODE.c_str(),"26089")==0) //订单已经冲正，不需要再次发起冲正
		{
			return 0;
		}

		if ((iter=_mapData.find("RSPMSG"))==_mapData.end())
		{
			strerr="无错误信息";
			
			return -2;
			
		}
		
		strerr=iter->second;
		if (memcmp(strerr.c_str(),"20002",5)==0)
		{
			return 0;
		}
		
		return -2;
	}

	return 0;

}

//账户校验
int CTrade::accountCheck_service(char *WEBSVRNAME,char *WEBSVRCODE,char *Verify,string &strerr)
{
	//受理时间:
	char server_time[14+1];
	char ACCEPTTIME[6+1];
	char acceptDate[8+1];
	string strReq0,strReq1;
	int iRet;
	string BILLNUM;
	string SYSTEMNO_STR="";
	strerr="";
	string strRsp="";
	string datas="";
	string rsp_code="";
	string SYSTEMNO="";

	bbzero(server_time);
	char keep[32+1];
	bbzero(keep);
	

	map<string, string>::iterator iter;
	map<string, string> _mapData; //返回的数据
	map<string, string> _pack_mapData; //发送的数据
	
	char strReqTmp[100];
	bbzero(strReqTmp);
	char APPFROMTmp[50];
	bbzero(APPFROMTmp);
	sprintf(strReqTmp,"%s|440100-APP001-001-%s|APP001|%s|",WEBSVRCODE,gbl.server_ip,gbl.server_ip);
	sprintf(APPFROMTmp,"440100-APP001-001-%s",gbl.server_ip);
	strReq0.assign(strReqTmp,strlen(strReqTmp));
	bbzero(server_time);
	bbzero(ACCEPTTIME);
	CTools::get_termTime(server_time);
	CTools::getDate(acceptDate);
	CTools::getTime(ACCEPTTIME);

	bbzero(keep);
	//CTools::get_keep(keep);
	CTools::get_keep(gbl.pos_no,keep);
	switch (atoi(Verify))
	{
		case 1: //3g流量卡号码验证

			_pack_mapData.insert(pair<string,string> ("MERID",MERID));
			_pack_mapData.insert(pair<string,string>("CHANNELCODE",CHANNELCODE));
			_pack_mapData.insert(pair<string,string>("TMNNUM",TMNNUM));
			_pack_mapData.insert(pair<string,string>("SIGN","SIGN"));
			_pack_mapData.insert(pair<string,string>("CER","CER"));
			_pack_mapData.insert(pair<string,string>("WEBSVRNAME",WEBSVRNAME));
			_pack_mapData.insert(pair<string,string>("WEBSVRCODE",WEBSVRCODE));
			_pack_mapData.insert(pair<string,string>("APPFROM",APPFROMTmp));
			_pack_mapData.insert(pair<string,string>("KEEP",keep));
			_pack_mapData.insert(pair<string,string>("REQUESTTIME",server_time));
			
			_pack_mapData.insert(pair<string,string> ("TMNNUMNO",gbl.pos_no)); //客户终端号
			_pack_mapData.insert(pair<string,string> ("VERIFY",Verify)); //验证类型
			_pack_mapData.insert(pair<string,string> ("ACCTCODE",gbl.phone_no)); //账号
			_pack_mapData.insert(pair<string,string> ("ACCEPTDATE",acceptDate)); //订单金额
			_pack_mapData.insert(pair<string,string> ("ACCEPTTIME",ACCEPTTIME));//受理时间
	
			break;
		case 0: //个人账户号码验证
			break;
		default:
			break;	
	}

	wrLog("strReq0:%s",strReq0.c_str());
	CxmlParser::pack(WEBSVRCODE,strReq1,_pack_mapData,strerr);

	iRet=ks_soap::get_response(TRADE_FLAG,strReq0,strReq1,strRsp,strerr);
	if (iRet!=0)
	{
		
		strerr="";
		strerr = "网络繁忙，请稍后再试";
		return -4;
	}
	
	iRet=CxmlParser::unpack(strRsp,WEBSVRCODE,_mapData,strerr);

	if (iRet!=0) 
	{
		strerr="";
		strerr = "报文解析错误，请稍后再试";
		return -1;
	} 

	if ( (iter=_mapData.find("RSPCODE")) == _mapData.end() ) //清结算终端
	{
		strerr="";
		strerr = "查询失败,请稍后再试";
        return -1;
    }
	
	rsp_code=iter->second;
	if (strcmp(rsp_code.c_str(),"000000")!=0)
	{
		strerr="";
		strerr = "查询失败，请稍后再试";
		return -1;
	}

	//获取系统参考号
	
	if ( (iter=_mapData.find("SYSTEMNO")) == _mapData.end() ) //订单号
	{
        strerr = "查询失败,请稍后再试";
        return -1;
    }
	
	
	SYSTEMNO=iter->second;
	bbzero(gbl.SYSTEMNO);
	strcpy(gbl.SYSTEMNO,SYSTEMNO.c_str());
	
	return 0;
	
}


//东莞通异步订单生成 获取参考号等信息
int CTrade::dgtOrderProduceService(char *WEBSVRNAME,char *WEBSVRCODE,char *TRANSSEQ,string &strerr)
{
	//受理时间:
	char server_time[14+1];
	char ACCEPTTIME[6+1];
	char acceptDate[8+1];
	string strReq0,strReq1;
	int iRet;
	string BILLNUM;
	string SYSTEMNO_STR="";
	strerr="";
	string strRsp="";
	string datas;
	bbzero(server_time);
	char keep[32+1];
	char STAFFCODE[20];
	bbzero(keep);
	string RSPCODE="";
	string TRANSSEQ_str="";
	char DEPOSIT[4+1];
	char cpu_deposit[8+1];
	
	bbzero(DEPOSIT);
	bbzero(cpu_deposit);

	
	map<string, string>::iterator iter;
	map<string, string> _mapData; //返回的数据
	map<string, string> _pack_mapData; //发送的数据
	
	char strReqTmp[100];
	bbzero(strReqTmp);
	char APPFROMTmp[50];
	char openDate[8+1];
	char BALANCEBEFORE[10+1];

	bbzero(STAFFCODE);
	bbzero(APPFROMTmp);
	bbzero(openDate);
	bbzero(BALANCEBEFORE);
	bbzero(TRANSSEQ);


	sprintf(strReqTmp,"%s|440100-APP001-001-%s|APP001|%s|",WEBSVRCODE,gbl.server_ip,gbl.server_ip);
	sprintf(APPFROMTmp,"440100-APP001-001-%s",gbl.server_ip);
	strReq0.assign(strReqTmp,strlen(strReqTmp));
	bbzero(server_time);
	bbzero(ACCEPTTIME);
	CTools::get_termTime(server_time);
	CTools::getDate(acceptDate);
	CTools::getTime(ACCEPTTIME);
	
	bbzero(keep);
	//CTools::get_keep(gbl.dPosInfo.pos_no,keep);
	CTools::get_keep(gbl.dPosInfo.pos_no,&gbl.random_value,keep);

	sprintf(STAFFCODE,"%s_01",gbl.dPosInfo.pos_no);
	CTools::byte_to_hex((BYTE *) gbl.dgtCard.openDate,(BYTE *) openDate,4);
	memcpy(BALANCEBEFORE,gbl.dgtCard.cardMny+2,10);

	//参数赋值
	CTools::byte_to_hex((BYTE *)gbl.dgtCard.deposit,(BYTE *)DEPOSIT,2); //押金 格式转换
	
	wrLog("DEPOSIT:%s",DEPOSIT);
	
	if (strcmp(DEPOSIT,"FFFF")==0) //无押金
	{
		//表示无押金
		strcpy(cpu_deposit,"0");
		
	}
	else
	{
		
		char DEPOSIT_temp[2+1];
		bbzero(DEPOSIT_temp);
		memcpy(DEPOSIT_temp,DEPOSIT+2,2); //获取后两位
		bbzero(cpu_deposit);
		sprintf(cpu_deposit,"%d",(atoi(DEPOSIT_temp)*100)) ; //转换成分
		
	}

	_pack_mapData.insert(pair<string,string> ("MERID",MERID));
	_pack_mapData.insert(pair<string,string>("CHANNELCODE",CHANNELCODE));
	_pack_mapData.insert(pair<string,string>("TMNNUM",TMNNUM));
	_pack_mapData.insert(pair<string,string>("SIGN","SIGN"));
	_pack_mapData.insert(pair<string,string>("CER","CER"));
	_pack_mapData.insert(pair<string,string>("WEBSVRNAME",WEBSVRNAME));
	_pack_mapData.insert(pair<string,string>("WEBSVRCODE",WEBSVRCODE));
	_pack_mapData.insert(pair<string,string>("APPFROM",APPFROMTmp));
	_pack_mapData.insert(pair<string,string>("KEEP",keep));
	_pack_mapData.insert(pair<string,string>("REQUESTTIME",server_time));
		
	_pack_mapData.insert(pair<string,string> ("ORDERSEQ",gbl.dgt_posSerial)); 
	_pack_mapData.insert(pair<string,string> ("TMNNUMNO",gbl.dPosInfo.pos_no)); //客户终端号
	_pack_mapData.insert(pair<string,string> ("STAFFCODE",STAFFCODE)); //用户名
	_pack_mapData.insert(pair<string,string> ("TRADETIME",server_time)); //受理时间
	_pack_mapData.insert(pair<string,string> ("EDCARDID",gbl.dgtM1Card.bus_showCard));//M1卡号
	_pack_mapData.insert(pair<string,string> ("EACOUNT",gbl.dgtM1Card.bus_amt));//M1金额
	_pack_mapData.insert(pair<string,string> ("RETURNACOUNT",gbl.ReturnAmt));//M1金额
	_pack_mapData.insert(pair<string,string> ("RETURNDEPOSIT",gbl.ReturnDeposit));//退用户押金
	_pack_mapData.insert(pair<string,string> ("MONTHFEFLAG",gbl.MonthFeeFlag));//月费收取标志
	_pack_mapData.insert(pair<string,string> ("FEEACOUNTFLAG",gbl.MonthFeeFlag));//手续费收取标志
	_pack_mapData.insert(pair<string,string> ("MONTHFEEACOUNT",gbl.MonthFeeAmt));//卡成本或月费
	_pack_mapData.insert(pair<string,string> ("FEEACOUNT",gbl.FeeAmt));//手续费
	_pack_mapData.insert(pair<string,string> ("BATCHNO",gbl.dgtSignInfo.BATCHNO));//批次号  
	_pack_mapData.insert(pair<string,string> ("POSID",gbl.posId));//清算设备代码  
	_pack_mapData.insert(pair<string,string> ("CARDID",gbl.dgtCard.cardShowId));//CPU卡号  
	_pack_mapData.insert(pair<string,string> ("CARDSELLDATE",openDate));//售卡日期
	_pack_mapData.insert(pair<string,string> ("TRANSCMESSAGE","2063"));//交易类型
	_pack_mapData.insert(pair<string,string> ("BALANCEBEFORE",BALANCEBEFORE));//CPU卡余额
	_pack_mapData.insert(pair<string,string> ("TXNDATE",gbl.dgtCard.tradeDate));//交易日期
	_pack_mapData.insert(pair<string,string> ("TXNTIME",gbl.dgtCard.tradeTime));//交易时间
	_pack_mapData.insert(pair<string,string> ("DATEOFSETTLEMENT",gbl.dgtSignInfo.SETTDATE));//结算时间
	_pack_mapData.insert(pair<string,string> ("DEPOSIT",cpu_deposit));//cpu卡押金

	
	wrLog("strReq0:%s",strReq0.c_str());
	CxmlParser::pack(WEBSVRCODE,strReq1,_pack_mapData,strerr);

	iRet=ks_soap::get_response(TRADE_FLAG,strReq0,strReq1,strRsp,strerr);
	
	if (iRet!=0)
	{
		
		strerr="";
		strerr = "网络繁忙，请稍后再试";
		return -4;
	}
	
	iRet=CxmlParser::unpack(strRsp,WEBSVRCODE,_mapData,strerr);
	if (iRet!=0)
	{
	   strerr = "报文解析错误，请稍后再试";
		return -1;
	} 


	if ( (iter=_mapData.find("RSPCODE")) == _mapData.end() ) //清结算终端
	{
        strerr = "无响应信息";
        return -1;
    }
	

	RSPCODE=iter->second;
	if (strcmp(RSPCODE.c_str(),"000000")!=0)
	{
		strerr="充值失败"; 
		return -2;
	}


	if ( (iter=_mapData.find("TRANSSEQ")) == _mapData.end() ) //订单号
	{
        strerr = "无响应信息";
        return -1;
    }
	
	
	TRANSSEQ_str=iter->second;
	strcpy(TRANSSEQ,TRANSSEQ_str.c_str());

	return 0;

}


//东莞公交订单确认 type=0成功。type 1 失败
int CTrade::dgtOrderVerifyService(char *WEBSVRNAME,char *WEBSVRCODE,int type,char *BUSCODE ,CHAR *BUS_CONTERNT,string &strerr)
{
	//受理时间:
	char server_time[14+1];
	char ACCEPTTIME[6+1];
	char acceptDate[8+1];
	string strReq0,strReq1;
	int iRet;
	string BILLNUM;
	string SYSTEMNO_STR="";
	strerr="";
	string rsp_code="";
	string strRsp="";
	string datas;


	bbzero(server_time);
	char keep[32+1];
	bbzero(keep);
	
	map<string, string>::iterator iter;
	map<string, string> _mapData; //返回的数据
	map<string, string> _pack_mapData; //发送的数据
	
	char strReqTmp[100];
	bbzero(strReqTmp);
	char APPFROMTmp[50];
	bbzero(APPFROMTmp);
	sprintf(strReqTmp,"%s|440100-APP001-001-%s|APP001|%s|",WEBSVRCODE,gbl.server_ip,gbl.server_ip);
	sprintf(APPFROMTmp,"440100-APP001-001-%s",gbl.server_ip);
	strReq0.assign(strReqTmp,strlen(strReqTmp));
	bbzero(server_time);
	bbzero(ACCEPTTIME);
	CTools::get_termTime(server_time);
	CTools::getDate(acceptDate);
	CTools::getTime(ACCEPTTIME);
	
	bbzero(keep);
	//CTools::get_keep(keep);
	//CTools::get_keep(gbl.dPosInfo.pos_no,keep);
	CTools::get_keep(gbl.dPosInfo.pos_no,&gbl.random_value,keep);
	if (type==0)
	{

		bbzero(BUS_CONTERNT);
		strcpy( BUS_CONTERNT,"成功");

	}
	else //如果冲正过程中没有返回响应码
	{
	
	
		if (strlen(BUSCODE) <0 || strlen(BUS_CONTERNT) <0)
		{
			//确认失败
			bbzero(BUSCODE);
			strcpy(BUSCODE,"00001");
			bbzero(BUS_CONTERNT);
			strcpy(BUS_CONTERNT,"系统错误");
		}

	}
	
	_pack_mapData.insert(pair<string,string> ("MERID",MERID));
	_pack_mapData.insert(pair<string,string>("CHANNELCODE",CHANNELCODE));
	_pack_mapData.insert(pair<string,string>("TMNNUM",TMNNUM));
	_pack_mapData.insert(pair<string,string>("SIGN","SIGN"));
	_pack_mapData.insert(pair<string,string>("CER","CER"));
	_pack_mapData.insert(pair<string,string>("WEBSVRNAME",WEBSVRNAME));
	_pack_mapData.insert(pair<string,string>("WEBSVRCODE",WEBSVRCODE));
	_pack_mapData.insert(pair<string,string>("APPFROM",APPFROMTmp));
	_pack_mapData.insert(pair<string,string>("KEEP",keep));
	_pack_mapData.insert(pair<string,string>("REQUESTTIME",server_time));
		
	_pack_mapData.insert(pair<string,string> ("ORDERSEQ",gbl.dgt_posSerial)); //订单号
	_pack_mapData.insert(pair<string,string> ("TRANSSEQ",gbl.TRANSSEQ)); //交易流水号
	_pack_mapData.insert(pair<string,string> ("TMNNUMNO",gbl.dPosInfo.pos_no)); //客户终端号
	_pack_mapData.insert(pair<string,string> ("BUSCODE",BUSCODE)); //业务操作代码
	_pack_mapData.insert(pair<string,string> ("BUSREASON",BUS_CONTERNT));//业务操作描述
	
	wrLog("strReq0:%s",strReq0.c_str());
	CxmlParser::pack(WEBSVRCODE,strReq1,_pack_mapData,strerr);

	iRet=ks_soap::get_response(TRADE_FLAG,strReq0,strReq1,strRsp,strerr);
	if (iRet!=0)
	{
		
		strerr="";
		strerr = "网络繁忙，请稍后再试";
		return -4;
	}
	
	iRet=CxmlParser::unpack(strRsp,WEBSVRCODE,_mapData,strerr);
	if (iRet!=0)
	{
		return -1;
	} 

	if ( (iter=_mapData.find("RSPCODE")) == _mapData.end() ) //清结算终端
	{
        strerr = "无响应信息";
        return -1;
    }
	
	rsp_code=iter->second;
	if ("000000" != rsp_code)
	{
		//订单处理完成
		if ("004232" == rsp_code)
		{
			strerr="订单完成"; 
			return 0;
		}
		else
		{
			strerr="确认失败"; 
			return -2;

		}

	}
	
	return 0;

}


//签到之前必须判断用户是否已经签退。用户必须先签退后才能重新签到

int CTrade::dgtSignIn()
{

	int iRet;
	int iSelect;
	string errMsg="";
	DGTSignInfo lastDgtSignInfo;
	int sign_iRet;
	int sign_out;
	int first_sign = 0;

	memset(&lastDgtSignInfo,0,sizeof(lastDgtSignInfo));

	gbl.random_value=0;

	
	//判断最近一笔签到记录的状态，是否已经签退。如果没有签退。先进行签退。如果是第一次签到，直接进入签到
	iRet=CDB::checkSignStatus(gbl.dPosInfo.pos_no,&gbl.dgtSignInfo); 
	if (iRet==0) //已经签到
	{
		TS_OutPutMsg(gbl.dPosInfo,"您已经签到成功!",1,iSelect);
		return CANCLE_KEY;
	}

	//下面是需要签到的情况
	if(iRet==-1 || iRet==-3 ) //第一次签到
	{
		 first_sign=1;
	}

	if (iRet==-4) //自动签退没有签退的交易 系统中的状态是0
	{

		//2次签退
		for(int i=0;i<2;i++)
		{
			sign_out=dgtSignOutService("[东莞公交]签退","INF06202",errMsg);
			if (sign_out==0)
			{
				//更新签退记录 签退成功的时候更新签退信息
				CDB::update_signOutInfo(gbl.pos_no,&gbl.dgtSignInfo);
				//TS_OutPutMsg(gbl.dPosInfo,"签退成功,下次交易请重新签到!",1,iSelect);
				break;
			}
			
		}
		if (sign_out!=0) //如果两次签退均失败。则更新最后一条的签到状态为0.提示用户重新签到
		{

			TS_OutPutMsg(gbl.dPosInfo,"签到失败,请重新签到 如有需要，请联系在线客户或致电客服电话400-80-11888咨询",1,iSelect);
			return CANCLE_KEY;
		}
	
	}

	//判断用户是否已经签退 判断用户上次签到情况，如果用户上次签到和签退都完成。则需要重新签到
	//如果签到过程中出现25005:POS终端未签退 这个错误，请先执行签退。再进行签到。

	sign_iRet=dgtSignInService("[东莞公交]签到","INF06201",&gbl.dgtSignInfo,errMsg);
	if (sign_iRet!=0)
	{
		char outPutMsg[500];
		bbzero(outPutMsg);
		if (errMsg.size()>0) //如果错误信息存在需要判断错误信息
		{

			if(memcmp(errMsg.c_str(),"25005",5)==0 &&  first_sign==0)// 公交未签退 进行处理
			{

				//2次签退
				for(int i=0;i<2;i++)
				{
					sign_out=dgtSignOutService("[东莞公交]签退","INF06202",errMsg); //签退
					if (sign_out==0)
					{
						//更新签退记录 签退成功的时候更新签退信息
						CDB::update_signOutInfo(gbl.pos_no,&gbl.dgtSignInfo); // 重新签到
						break;
					}
					
				}

				if (sign_out!=0)
				{
					//将数据库里面的最后一条签到记录的状态修改为0 提示重新签到
					CDB::updateLastSigninStatus(gbl.dPosInfo.pos_no); //重新签到
					sprintf(outPutMsg,"%s\n签到失败,请重新签到 如有需要，请联系在线客户或致电客服电话400-80-11888咨询",errMsg.c_str()) ;
					TS_OutPutMsg(gbl.dPosInfo,outPutMsg,1,iSelect);
					
				}
				else
				{
				
					sign_iRet=dgtSignInService("[东莞公交]签到","INF06201",&gbl.dgtSignInfo,errMsg);
					if (sign_iRet==0)
					{
						CDB::insert_dgtSignData(gbl.dgtSignInfo,gbl.pos_no);
						TS_OutPutMsg(gbl.dPosInfo,"签到成功，请按【Del】返上一级选择业务类型",1,iSelect);
						return 0;

					}
					else
					{
						sprintf(outPutMsg,"%s\n签到失败,请重新签到 如有需要，请联系在线客户或致电客服电话400-80-11888咨询",errMsg.c_str()) ;
						TS_OutPutMsg(gbl.dPosInfo,outPutMsg,1,iSelect);
					}
				
				}

			}
			else
			{
				
				sprintf(outPutMsg,"%s\n签到失败,请联系在线客户或致电客服电话400-80-11888咨询",errMsg.c_str()) ;
				TS_OutPutMsg(gbl.dPosInfo,outPutMsg,1,iSelect);
				return -1;
			}

	
		}
		else
		{
			bbzero(outPutMsg);
			strcpy(outPutMsg,"签到失败,请联系在线客户或致电客服电话400-80-11888咨询");
			
			TS_OutPutMsg(gbl.dPosInfo,outPutMsg,1,iSelect);
			return -1;
		}

	}

	//插入数据库签到数据 
	CDB::insert_dgtSignData(gbl.dgtSignInfo,gbl.pos_no);
	TS_OutPutMsg(gbl.dPosInfo,"签到成功，请按【Enter】返上一级选择业务类型",1,iSelect);
	return 0;
}

//东莞公交签退
int CTrade::dgtSignOut()
{
	int iRet;
	string errMsg="";
	int iSelect;

	gbl.random_value=0;

	iRet=CDB::checkSignStatus(gbl.dPosInfo.pos_no,&gbl.dgtSignInfo);
	if (iRet!=0) 
	{
	
		if (iRet==-3)
		{	
			TS_OutPutMsg(gbl.dPosInfo,"您尚未签到",1,iSelect);
			return CANCLE_KEY;

		}
		else
		{
		
			TS_OutPutMsg(gbl.dPosInfo,"您已经签退 请按【Esc】返回",1,iSelect);
			return CANCLE_KEY;

		}
		
	}
	
	//2次签退
	for(int i=0;i<2;i++)
	{
		iRet=dgtSignOutService("[东莞公交]签退","INF06202",errMsg);
		if (iRet==0)
		{
			//更新签退信息
			//更新签退记录 签退成功的时候更新签退信息
			CDB::update_signOutInfo(gbl.pos_no,&gbl.dgtSignInfo);
			TS_OutPutMsg(gbl.dPosInfo,"签退成功,下次交易请重新签到!",1,iSelect);
			break;
		}

	}

	if (iRet!=0) //签退失败
	{
		TS_OutPutMsg(gbl.dPosInfo,"签退失败，请稍后重试",1,iSelect);
		return -1;

	}
 
	return 0;

}

//售卡的时候，先检查卡的合法性。检查卡片的基础信息
int CTrade::dgtCardSale(char *type)
{

	int iRet;
	char   errMsg[400];
	string errStr="";
	string errStr1="";
	string rsp_code="";
	char openDate[14+1]; //开卡日期
	char effectiveDate[14+1];//有效日期
	char stan_no[12+1];
	BYTE APDU[100];
	char DEPOSIT[4+1];
	int iSelect;
	int APDU_LEN=0;
	char APDU_COMMAND[50];
	int nowAmo;
	char term_id[8+1];
	TSMENULIST menuList;
	int TOTALSVAMT=0;
	int TOTALSVNUM=0;
	int payment=0;
	int payAmount=0;
	int query_iRet=0;
	char TRANSSEQ[16];	
	char showMsg[200];
	int verify_iRet;
	int cardStatus_iRet;
	int openCardStatus;
	int db_iRet;
	int igore_Flag=0;

	bbzero(stan_no);
	bbzero(showMsg);
	bbzero(errMsg);
	bbzero(APDU);
	bbzero(openDate);
	bbzero(effectiveDate);
	bbzero(DEPOSIT);
	bbzero(APDU_COMMAND);
	bbzero(term_id);
	strcpy(term_id,gbl.pos_no);
	memset(&menuList,0,sizeof(menuList));
	bbzero(TRANSSEQ);

	gbl.random_value=0;

	//首先获取用户是否签到。获取签到信息。如果没有签到或者已经签退，提示用户先进入签到业务进行签到
	iRet=CDB::checkSignStatus(gbl.dPosInfo.pos_no,&gbl.dgtSignInfo);
	if (iRet!=0)
	{
		TS_OutPutMsg(gbl.dPosInfo,"您尚未签到，请先签到再进行交易",1,iSelect);
		return CANCLE_KEY;
	}

	//检查上笔交易情况
	iRet=checkdgtUnsubmit(2);
	
	//初始化
	bbzero(gbl.stan_no);
	bbzero(gbl.TRANSSEQ);
	bbzero(gbl.SYSTEMNO);
	
	//设置开卡日期
	CTools::getDate(openDate);
	//设置有效日期 有效日期固定为表示普通卡
	strcpy(effectiveDate,"20901231");

	bbzero(gbl.amount); //售卡金额
	strcpy(gbl.amount,"000000002000"); //售卡固定是20元 test
	
	//读取卡片基础信息。
	memset(&gbl.dgtCard,0,sizeof(gbl.dgtCard));
	iRet=dgtCardInqHdl(&gbl.dgtCard,2); //查询卡片物理信息
	if (iRet!=0) 
	{
		wrLog("卡片查询出错"); //进行异常处理
		//TS_OutPutMsg(gbl.dPosInfo,"卡片查询出错",1,iSelect);
		return CANCLE_KEY;
	}

	//判断卡片是否需要检查卡片的激活状态。
	
	db_iRet=CDB::isCardInIgoreList(gbl.dgtCard.cardShowId);
	if (db_iRet <0) //如果不在这个忽略的列表中，则表示需要验证卡片的有效性。
	{
		iRet=dgtEffectiveCheck(0,errMsg);
		
		if (iRet!=0)
		{
			TS_OutPutMsg(gbl.dPosInfo,errMsg,1,iSelect);
			return -1; //有效性检查失败
		}

	}
	else
	{
			igore_Flag = 1;
	}


	//调用服务进行处理 之前组装APDU命令
	memcpy(APDU+APDU_LEN,"\x04\xd6\x95\x08\x18",5);
	APDU_LEN+=5;
	memcpy(APDU+APDU_LEN,"\x01",1); //开通卡片
	APDU_LEN+=1;
	memcpy(APDU+APDU_LEN,gbl.dgtCard.appVer,1);
	APDU_LEN+=1;
	memcpy(APDU+APDU_LEN,gbl.dgtCard.connectCity,2);
	APDU_LEN+=2;
	memcpy(APDU+APDU_LEN,gbl.dgtCard.appSerial,8); //卡序列号
	APDU_LEN+=8;
	CTools::hex_to_byte((BYTE *)openDate,(BYTE *)APDU+APDU_LEN,8); //开卡时间
	APDU_LEN+=4;
	CTools::hex_to_byte((BYTE *)effectiveDate, (BYTE *)APDU+APDU_LEN,8);
	APDU_LEN+=4;

	CTools::byte_to_hex((BYTE *)APDU,(BYTE *)APDU_COMMAND,APDU_LEN);

	//计算交易金额。押金 开卡收费20元。
	wrLog("APDU_COMMAND:%s",APDU_COMMAND);

	//取卡片随机数
	bbzero(gbl.dgtCard.CARDRAND);
	iRet=CDGTBusTrade::getRandom(gbl.dPosInfo,errMsg,gbl.dgtCard.CARDRAND); //取随机数
	wrLog("售卡取卡片随机数为:%s",gbl.dgtCard.CARDRAND);

	if (iRet!=0)
	{
		TS_OutPutMsg(gbl.dPosInfo,"开卡失败",1,iSelect);
		return CANCLE_KEY; //取随机数失败
	}
	
	//发交易进行充值
	if(CDB::getDayAmo(gbl.dPosInfo.pos_no, &nowAmo)==0)
		//20120105修改-yyx
		//if (CDB::pep_getDayAmo(pgbl->pos_no, &nowAmo) == 0)
	{
		if( gbl.dayAmo!=0 && nowAmo+atoi(gbl.amount)>gbl.dayAmo )
		{
			TS_OutPutMsg(gbl.dPosInfo, "已超出当天的最大消费金额，交易取消", 1, iSelect);
			return -1;
		}
	}
	else
	{
		TS_OutPutMsg(gbl.dPosInfo, "数据库操作出错，交易取消\n请稍候再试!\n 如果交易结果不明确请做 最后一笔交易查询", 1, iSelect);
		return -1;
	}

	//	//关于keyset
	bbzero(gbl.dgtCard.KEYSET);
	strcpy(gbl.dgtCard.KEYSET,gbl.dgtSignInfo.KEYSET);
	
	//进行缴费，刷卡
	int flag = 0;
	for(int curTry=0; curTry<3; curTry++) //只能刷卡三次,否则锁卡
	{
		if(!flag)
		{
			iRet = mngCard_Hdl(type);
			if(iRet == CANCLE_KEY)
				return CANCLE_KEY;
			else if(iRet != 0)
				return -1;
		}

		bbzero(gbl.TRANSSEQ);
		bbzero(gbl.dgtCard.tradeBeForeMny);
		memcpy(gbl.dgtCard.tradeBeForeMny,gbl.dgtCard.cardMny+4,8);

		//进行东莞公交卡操作请求.如果出现卡操作请求的时候出现超时，则将这笔交易记录，并进行处理。
		iRet=cardOperate_service("[东莞公交]卡操作","INF06203","2","2063","80",APDU_COMMAND,gbl.TRANSSEQ,rsp_code,errStr1); //售卡之前进行卡请求操作

		if (strlen(gbl.TRANSSEQ) >0)
		{
			bbzero(gbl.stan_no);
			memcpy(gbl.stan_no,gbl.TRANSSEQ+(strlen(gbl.TRANSSEQ)-12),12);
		}
	
		if (iRet!=0) //如果卡操作请求不成功或者超时的情况，发冲正！！！失败处理密码错误的可以继续之外，其他不能继续交易
		{
		
			//首先判断是否是公交公司反馈错误，直接退出，补发冲正。
			if (iRet==-6)
			{
				sprintf(errMsg,"开卡失败 %s",errStr1.c_str());
				TS_OutPutMsg(gbl.dPosInfo,(char *)errMsg,1,iSelect);
				return -1;
			}

			if (iRet==-2 || iRet==-1) //对于明确失败和参数不足的发送冲正！
			{
				CDB::insert_dgtTxnLog(gbl,0);
				for(int i=0;i<2;i++) 
				{

					bbzero(gbl.dgtCard.CARDCNT);
					strcpy(gbl.dgtCard.CARDCNT,"000000");
					if (strlen(gbl.TRANSSEQ)  >0 )
					{
						verify_iRet=cardSaleService("[东莞公交]开卡/冲正","INF06204","ATR","86",gbl.TRANSSEQ,"1",errStr); 
					}
					else
					{
						verify_iRet=cardSaleService("[东莞公交]开卡/冲正","INF06204","ATR2","86",gbl.TRANSSEQ,"1",errStr); 

					}
			
					if (verify_iRet==0)
					{
						break;
					}

				}

				if (verify_iRet==0) //开卡冲正发送成功。
				{
					
					CDB::update_dgtTxnLogByStan(gbl.SYSTEMNO,1);
	
				}

				if (strcmp(rsp_code.c_str(),"002135")==0) //密码错误
				{
					flag = 1;
					if(reGetPwd(type) == 0) //密码错误，重新输入密码
						continue;
					else
						return CANCLE_KEY;
					
				}
				else
				{
					
					if (strcmp(rsp_code.c_str(),"002136")==0) //密码被锁
					{
						TS_OutPutMsg(gbl.dPosInfo,"交易密码已锁，请联系在线客服或者拨打客服电话400-80-11888解锁",1,iSelect);
						
					}
					else
					{
						bbzero(errMsg);
						sprintf(errMsg,"开卡失败 %s",errStr1.c_str());
						TS_OutPutMsg(gbl.dPosInfo,(char *)errMsg,1,iSelect);
						return -1;
					}
					
				}

			}
			else if (iRet==-4 || iRet==-5) //如果是超时情况，进行处理
			{
				CDB::insert_dgtTxnLog(gbl,0);

				string strPayStat="";
				for (int i=0;i<3;i++) //三次读取卡操作结果查询
				{
					query_iRet=getGgtResultByKeep("[东莞公交]卡操作结果查询接口","INF06208",gbl.dgtCard.KEEP,strPayStat,errStr);
					if(query_iRet == 0)
					{
						break;
					}			
				}
				
				if (query_iRet==0)
				{

					CDB::update_dgtTxnLog_byKeep(gbl);
					//if (strlen(gbl.TRANSSEQ) >0) //

					bbzero(gbl.dgtCard.CARDCNT);
					strcpy(gbl.dgtCard.CARDCNT,"000000");

					if ( "S0S" == strPayStat)
					{
						iRet=cardSaleService("[东莞公交]开卡/冲正","INF06204","ATR","86",gbl.TRANSSEQ,"1",errStr); 

					}
					else
					{

						iRet=cardSaleService("[东莞公交]开卡/冲正","INF06204","ATR2","86",gbl.TRANSSEQ,"1",errStr); 
					}
					
					if (iRet==0)
					{
						//获取这笔交易的具体信息
						CDB::update_dgtTxnLogByStan(gbl.SYSTEMNO,1);
						TS_OutPutMsg(gbl.dPosInfo,"交易失败，请留意账户余额变动",1,iSelect);
					
						CDB::update_dgtTxnLogByStan(gbl.SYSTEMNO,1);
						return 0;
					}
					else
					{
						//获取这笔交易的具体信息
						TS_OutPutMsg(gbl.dPosInfo,"交易失败，请留意账户余额变动",1,iSelect);
						return -1;
					}

				}
				else 
				{
					if (iRet==-2)
					{	
					
						CDB::update_dgtTxnStatusByKeep(gbl.dgtCard.KEEP,0);
					}
					
					//获取这笔交易的具体信息
					TS_OutPutMsg(gbl.dPosInfo,"交易失败，请留意账户余额变动",1,iSelect);
					return -1;		

				}
				
			
			}

		}
		
		else //申请成功，进行充值
		{
			bbzero(TRANSSEQ);
			strcpy(TRANSSEQ,gbl.TRANSSEQ);
			break;
		}
		
	}
	
	//卡操作请求成功之后查询余额
	bbzero(gbl.pos_no);
	strcpy(gbl.pos_no,term_id);
	ecardInqHdl(); //查询账户余额
	//进行激活卡片

	iRet=CDGTBusTrade::openCard(gbl.dPosInfo,gbl.dgtCard.DICMAC,errMsg,gbl.dgtCard); 

	bbzero(gbl.dgtCard.KEYSET);
	strcpy(gbl.dgtCard.KEYSET,gbl.dgtSignInfo.KEYSET);
	
	bbzero(stan_no);
	memcpy(stan_no,TRANSSEQ+(strlen(TRANSSEQ)-12),12);
	bbzero(gbl.dgtCard.tradeBeForeMny);
	memcpy(gbl.dgtCard.tradeBeForeMny,gbl.dgtCard.cardMny+4,8);


	//如果开卡超时，需要三次读取卡片的状态信息，如果卡片的状态信息是卡状态写成功，来判断写卡是否成功
	//0128期工单，设置不管是否执行成功，都是需要读卡的

	if (iRet< 0) //如果卡片返回失败，需要再读一下卡片的信息
	{
		for (int i=0;i<3;i++)
			
		{
			//读取卡片基础信息。
			cardStatus_iRet=dgtCardInqHdl(&gbl.dgtCard,1); //查询卡片物理信息
			if (cardStatus_iRet==0)
			{
				//读取卡片信息
				
				if (memcmp(gbl.dgtCard.appFlag,"\x01",1)==0 ) //卡片激活成功
					
				{
					
					openCardStatus = 1;
				}
				else
					
				{
					
					openCardStatus = 0;
					
				}
				
				break;
			}
			
			
		}
		
		//超时情况
		
		if (cardStatus_iRet!=0) //如果三次读取卡片信息失败 不发任何确认信息
			
		{
			
			//对于该笔交易状态记做9
			bbzero(gbl.dgtCard.CARDCNT); 
			strcpy(gbl.dgtCard.CARDCNT,"000000");
			CDB::insert_dgtTxnLog(gbl,9); //写卡超时数据库中记录该信息为9 写卡超时
			TS_OutPutMsg(gbl.dPosInfo,"开卡超时，请进入菜单【卡片激活查询】查询开卡情况",1,iSelect);
			return CANCLE_KEY;
		}

	}

	
	//执行失败并且读卡的卡状态是0.未激活的状态
	if ( iRet <0 && openCardStatus==0 )   //对于明确失败，或者超时，但是最后卡状态是0，没有写卡成功的情况
	{
	
		
		//如果开卡失败。需要发冲正报文。

		wrLog("gbl.seq:%s",gbl.TRANSSEQ);
		wrLog("中心时间:%s",gbl.dgtCard.sysTime);
		bbzero(gbl.dgtCard.CARDCNT);
		strcpy(gbl.dgtCard.CARDCNT,"000000");
		CDB::insert_dgtTxnLog(gbl,3);
		iRet=cardSaleService("[东莞公交]开卡/冲正","INF06204","ATR","86",TRANSSEQ,"1",errStr); 
		ecardInqHdl(); //查询账户余额

		if (iRet==0)
		{
			CDB::update_dgtTxnLog(gbl.TRANSSEQ,1);
			TS_OutPutMsg(gbl.dPosInfo,"开卡失败",1,iSelect);
			return -1;
		}

		else
		{
			if (iRet==-4)
			{

				bbzero(errMsg);

				sprintf(errMsg,"开卡失败,退费超时,系统参考号:%s,请重新进入业务退费\n如需帮助，请联系在线客服或拨打客服电话400-80-11888",stan_no);
				wrLog("开卡过程异常：%s",errMsg);
				TS_OutPutMsg(gbl.dPosInfo,"开卡出错,请进入菜单【卡片激活查询】查询开卡情况",1,iSelect);
				//提示交易失败如何判断
				return 1;
			}
			else
			{
				bbzero(errMsg);
				sprintf(errMsg,"开卡失败,退费失败\n如需帮助,请联系在线客服或拨打客服电话400-80-11888 \n%s",errStr.c_str());
				wrLog("%s",errMsg);
				TS_OutPutMsg(gbl.dPosInfo,"开卡出错,请进入菜单【卡片激活查询】查询开卡情况",1,iSelect);

			}
		
			//提示交易失败如何判断
			return 1;

		}

	}
	else 
	//成功的确认
	{

		//发送售卡确认报文
		bbzero(gbl.pos_no);
		strcpy(gbl.pos_no,term_id);
		bbzero(gbl.TRANSSEQ);
		strcpy(gbl.TRANSSEQ,TRANSSEQ);

		TOTALSVNUM=atoi(gbl.dgtSignInfo.TOTALSVNUM);
		TOTALSVNUM++;

		bbzero(gbl.dgtSignInfo.TOTALSVNUM);// 交易笔数
		sprintf(gbl.dgtSignInfo.TOTALSVNUM,"%010d",TOTALSVNUM);


		payAmount=atoi(gbl.amount); //交易金额
		TOTALSVAMT=payAmount+atoi(gbl.dgtSignInfo.TOTALSVAMT);

		bbzero(gbl.dgtSignInfo.TOTALSVAMT);
		sprintf(gbl.dgtSignInfo.TOTALSVAMT,"%010d",TOTALSVAMT);
		
		bbzero(gbl.dgtSignInfo.TOTALSALEDEP);
		strcpy(gbl.dgtSignInfo.TOTALSALEDEP,"0000000000"); //默认为买断,不收取押金

		CDB::update_dgtSignInfo(gbl.pos_no,gbl.dgtSignInfo);
		bbzero(gbl.dgtCard.CARDCNT);
		strcpy(gbl.dgtCard.CARDCNT,"000000");
		CDB::insert_dgtTxnLog(gbl,4);

		iRet=cardSaleService("[东莞公交]开卡/冲正","INF06204","ATO","80",TRANSSEQ,"1",errStr);
	
		if (iRet==0)
		{
			CDB::update_dgtTxnLog(gbl.TRANSSEQ,2);
			if (igore_Flag==1) //如果是需要忽略的卡，再次开卡成功。需要更新数据库中的状态
			{

				CDB::update_cardIgoreStatus(gbl.dgtCard.cardShowId,"1");
			}

			TS_OutPutMsg(gbl.dPosInfo,"开卡成功!\n按【Enter】打印票据 【Esc】取消",1,iSelect);

		}
		else
		{
			if (iRet==-4)
			{

				TS_OutPutMsg(gbl.dPosInfo,"开卡出错,请进入菜单【卡片激活查询】查询开卡情况!\n",1,iSelect);
				return -1;

			}
			else
			{
					
				TS_OutPutMsg(gbl.dPosInfo,"开卡出错，请进入菜单【卡片激活查询】查询开卡情况!\n",1,iSelect);
				return -1;

			}
			
		}


		if (iSelect==0) //如果确定打印，则打印发票
		{
			//打印信息
			CPrint print;
			print.set_in_par(gbl);
			print.print_dgtBus_detail(type);
		}
		
	}

	//全部交易完成之后，提示用户是否进行充值业务
	menuList.iTotalNum = 2;
	strcpy(menuList.acTitle, "继续交易请选择其他业务");
	strcpy(menuList.menuItem[0], "东莞通充值");
	strcpy(menuList.menuItem[1], "退出");
	iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
	if(iRet)
		return -1;
			switch(iSelect)
			
			{
				case 1:
					bbzero(gbl.fee_type);
					strcpy(gbl.fee_type,"0371"); //充值
					iRet = dgtBusTrade("东莞通充值",2); //莞市通充值
					if (iRet==0)
					{
						ecardInqHdl(); //查询账户余额
					}

					break;
				default: 
					return CANCLE_KEY;
			}

	return 0;

}



//提交开卡和充值没有确认成功交易
//2是开卡和充值没有确认的成功的交易
//0是开卡，针对某张卡没有确认的交易
//如果出现开卡超时的情况。

int CTrade::checkdgtUnsubmit(int tradeFlag)
{
	int iRet;
	char showMsg[400];
	char unsubmitField[1024];
	int  tradeStatus;
	int iSelect;
	string errStr="";
	char stan_no[12+1];
	bbzero(stan_no);
	char biz_type[4+1];

	bbzero(unsubmitField);
	bbzero(biz_type);
	bbzero(showMsg);
	gbl.random_value=0;
	int openCardStatus=0;

	iRet=CDB::getdgtUnsubmit(&gbl,biz_type,tradeFlag,&tradeStatus);//获取最后一笔交易的信息
	if (iRet!=0)
	{
		return 0;

	}

	if (tradeStatus!=0) 
	{
		memcpy(stan_no,gbl.TRANSSEQ+(strlen(gbl.TRANSSEQ)-12),12);
	}

	//如果出现开卡过程中写卡失败
	if (tradeFlag==0 && tradeStatus==9) //开卡过程中写卡失败
	{
		//需要判断卡号是否已经写卡成功
		if (memcmp(gbl.dgtCard.appFlag,"\x01",1)==0 ) //如开卡成功
		{
			openCardStatus=1;
			
		}
		else
		{
			openCardStatus=0;

		}

	}

	if (tradeStatus==0) //如果订单号不存在，只是向东莞通发送冲正 交易状态是0.表示只需要向东莞通发送冲正
	{
		//如果系统
		string strPayStat;
		iRet=getGgtResultByKeep("[东莞公交]卡操作结果查询接口","INF06208",gbl.dgtCard.KEEP,strPayStat,errStr);
		if (iRet==0)
		{
			//更新参数
			
			CDB::update_dgtTxnLog_byKeep(gbl); 
			if (strcmp(biz_type,"0371")==0) //充值
			{
				//if (strlen(gbl.TRANSSEQ) >0) //如果订单号为0
				if ( "S0S" == strPayStat)
				{
					iRet=dgtCardChargeService("[东莞公交]充值冲正/冲正","INF06205","RGR","86",gbl.TRANSSEQ,errStr); 
					if (iRet==0)
					{
						//更新数据库中的交易状态
						//ecardInqHdl(); //查询账户余额
						CDB::update_dgtTxnLogByStan(gbl.SYSTEMNO,1);
						char showMsg[200];
						bbzero(showMsg);
						bbzero(stan_no);
						memcpy(stan_no,gbl.TRANSSEQ+(strlen(gbl.TRANSSEQ)-12),12);
						sprintf(showMsg,"您东莞通充值失败，退费成功。系统参考号:%s 请留意账户余额变动",stan_no);

						if (biz_type!=0) //对于开卡结果获取的时候，不需要显示在界面上面这些信息
						{	
		
							TS_OutPutMsg(gbl.dPosInfo,showMsg,1,iSelect);

						}
						else
						{
							wrLog("%s",showMsg);

						}

						return 0;
					}
					else
					{
						
						return -1;
					}
					
				}
				else
				{
					
					iRet=dgtCardChargeService("[东莞公交]充值冲正/冲正","INF06205","RGR2","86",gbl.TRANSSEQ,errStr); 
					if (iRet==0)
					{
						CDB::update_dgtTxnLogByStan(gbl.SYSTEMNO,1);
						return 0;
					}
					else
					{
						
						return -1;
					}
					
				}
				
				
			}
			else
			{
				//if (strlen(gbl.TRANSSEQ) >0)
				if ( "S0S" == strPayStat)
				{
					
					iRet=cardSaleService("[东莞公交]开卡/冲正","INF06204","ATR","86",gbl.TRANSSEQ,"1",errStr); //对于返回重复的情况设置为成功。
					if (iRet==0)
					{
						CDB::update_dgtTxnLogByStan(gbl.SYSTEMNO,1);
						char showMsg[200];
						bbzero(showMsg);
						bbzero(stan_no);
						memcpy(stan_no,gbl.TRANSSEQ+(strlen(gbl.TRANSSEQ)-12),12);
						sprintf(showMsg,"您东莞通充值失败，退费成功。系统参考号:%s 请留意账户余额变动",stan_no);
						if (tradeFlag!=0)
						{
							TS_OutPutMsg(gbl.dPosInfo,showMsg,1,iSelect);
						}
						else
						{
						
							wrLog("%s",showMsg);
						}

						return 0;
					}
					else
					{
						
						return -1;
					}
				}
				else
				{
					iRet=cardSaleService("[东莞公交]开卡/冲正","INF06204","ATR2","86",gbl.TRANSSEQ,"1",errStr); 
					if (iRet==0)
					{
						CDB::update_dgtTxnLogByStan(gbl.SYSTEMNO,1);
						return 0;
					}
					else
					{
						
						return -1;
					}
					
				}
				
				
		}
			
		}
		else
		{
		
			//如果查询不到keep返回，直接退出
			if (iRet==-2)
			{
				CDB::update_dgtTxnStatusByKeep(gbl.dgtCard.KEEP,1);
			}
			return 0;
		}
		

	}
	else if (tradeStatus ==3 || (tradeStatus==9 && openCardStatus==0)) //开卡失败，确认
	{
		bbzero(showMsg);
		sprintf(showMsg,"您上笔开卡业务交易失败，未确认，系统参考号:%s 请按【Enter】确认",stan_no);
		if (tradeFlag!=0)
		{
			TS_OutPutMsg(gbl.dPosInfo,showMsg,1,iSelect);
		}
		else
		{
		
			wrLog("%s",showMsg);
		}

		iRet=cardSaleService("[东莞公交]开卡/冲正","INF06204","ATR","86",gbl.TRANSSEQ,"1",errStr); //对于返回重复的情况设置为成功。
		if (iRet==0)
		{
			CDB::update_dgtTxnLog(gbl.TRANSSEQ,1);
			if (tradeFlag!=0)
			{
				TS_OutPutMsg(gbl.dPosInfo,"交易失败，退费成功,请留意账户余额变动\n请按【Enter】继续交易",1,iSelect);
			}
	
			return 0;
		}
		
		else
		{
			if (iRet==-4) //超时
			{
				bbzero(showMsg);
				sprintf(showMsg,"冲正超时,系统参考号为:%s 请稍后再试\n如需帮助，请联系在线客服或拨打客服电话400-80-11888",stan_no);
			
				if (tradeFlag!=0)
				{
					TS_OutPutMsg(gbl.dPosInfo,showMsg,1,iSelect);
				}
				else
				{
				
					wrLog("%s",showMsg);
				}
				return -1;
			}	
			else
			{
				bbzero(showMsg);
				sprintf(showMsg,"冲正失败 系统参考号为:%s 请按【Enter】继续交易\n如需帮助，请联系在线客服或拨打客服电话400-80-11888",stan_no);
				
				if (tradeFlag!=0)
				{
					TS_OutPutMsg(gbl.dPosInfo,showMsg,1,iSelect);
				}
				else
				{
				
					wrLog("%s",showMsg);
				}
				
				
				//提示交易失败如何判断
				return 1;

			}
			
		}
	}
	else if (tradeStatus==4 || (tradeStatus==9 && openCardStatus==1)) //开卡成功，确认
	{
		//不在提示用户，以免对用户造成困扰
		bbzero(showMsg);
		sprintf(showMsg,"您上笔东莞通开卡业务交易成功，未确认，系统参考号:%s\n请按【Enter】确认",stan_no);
		if (tradeFlag)
		{
			TS_OutPutMsg(gbl.dPosInfo,showMsg,1,iSelect);
		}
		else
		{
			wrLog("%s",showMsg);
		}
	
		iRet=cardSaleService("[东莞公交]开卡/冲正","INF06204","ATO","80",gbl.TRANSSEQ,"1",errStr);

		if (iRet==0)
		{
			CDB::update_dgtTxnLog(gbl.TRANSSEQ,2);
			if (tradeFlag)
			{
				TS_OutPutMsg(gbl.dPosInfo,"开卡成功，确认成功!",1,iSelect);
			}
			else
			{
			
				wrLog("开卡成功，确认成功");
			}

			return 0;
		}
		else
		{
			if (iRet==-4)
			{
				bbzero(showMsg);
				sprintf(showMsg,"开卡成功，确认超时!\n 系统参考号为:%s \n\n请稍后再试\n如需帮助，请联系在线客服或拨打客服电话400-80-11888",stan_no);
				if (tradeFlag)
				{
					TS_OutPutMsg(gbl.dPosInfo,showMsg,1,iSelect); //暂时直接退出
				}
				else
				{
					wrLog("%s",showMsg);
				}
			
				return -1;

			}
			else
			{
				bbzero(showMsg);
				sprintf(showMsg,"开卡成功，确认失败!\n 系统参考号为:%s \n\n请按【Enter】继续交易\n如需帮助，请联系在线客服或拨打客服电话400-80-11888",stan_no);
				
				if (tradeFlag)
				{
					TS_OutPutMsg(gbl.dPosInfo,showMsg,1,iSelect);
				}
				else
				{
					wrLog("%s",showMsg);
				}
			
				return 1;

			}
			
		}
		

	}
	else if (tradeStatus==5) //充值失败。确认
	{
		
		bbzero(showMsg);
		sprintf(showMsg,"您上笔交易失败，系统参考号:%s 请按【Enter】进行退费",stan_no);
		//TS_OutPutMsg(gbl.dPosInfo,showMsg,1,iSelect);
		
		wrLog("%s",showMsg);

		iRet=dgtCardChargeService("[东莞公交]充值冲正/冲正","INF06205","RGR","86",gbl.TRANSSEQ,errStr); 
		if (iRet==0)
		{
			CDB::update_dgtTxnLog(gbl.TRANSSEQ,1);
			//ecardInqHdl(); //查询账户余额
			bbzero(showMsg);
			sprintf(showMsg,"您上次交易失败，退费成功。系统参考号:%s 按【Enter】继续交易\n 请留意账户余额变动，如需帮助请联系在线客服或拨打客服电话400-80-11888 ",stan_no);
			TS_OutPutMsg(gbl.dPosInfo,showMsg,1,iSelect);
			return 0;
		}
		
		else
		{
			if (iRet==-4) //超时引起确认失败，直接返回
			{
				bbzero(showMsg);
				sprintf(showMsg,"交易失败,退费超时,系统参考号:%s \n\n请稍后再试，如需帮助请联系在线客服或拨打客服电话400-80-11888",stan_no);
				TS_OutPutMsg(gbl.dPosInfo,showMsg,1,iSelect);
				return -1;
			}
			else
			{

				bbzero(showMsg);
				sprintf(showMsg,"交易失败,退费失败 系统参考号:%s \n\n按【Enter】继续交易\n 请留意账户余额变动，如需帮助请联系在线客服或拨打客服电话400-80-11888",stan_no);
				TS_OutPutMsg(gbl.dPosInfo,showMsg,1,iSelect);
				return 1;
			}
			
		}
		
	}
	else if(tradeStatus==6) //充值成功，确认
	{
		bbzero(showMsg);
		sprintf(showMsg,"您上笔东莞通充值业务交易成功，未确认，系统参考号%s 请按【Enter】确认",stan_no);
	
		//TS_OutPutMsg(gbl.dPosInfo,showMsg,1,iSelect); //不再显示错误信息。
		wrLog("%s",showMsg);

		iRet=dgtCardChargeService("[东莞公交]充值/冲正","INF06205","REG","02",gbl.TRANSSEQ,errStr); 
		if (iRet==0)
		{
			
			CDB::update_dgtTxnLog(gbl.TRANSSEQ,2);
			//TS_OutPutMsg(gbl.dPosInfo,"交易成功，确认成功\n请按【Enter】继续交易",1,iSelect ); //不再显示错误信息
			return 0;
		}
		else
		{
			if (iRet==-4) //超时
			{

				bbzero(showMsg);
				sprintf(showMsg,"交易成功，确认超时，系统参考号:%s \n\n请稍后再试!\n如需帮助，请联系在线客服或拨打客服电话400-80-11888",stan_no);
				//TS_OutPutMsg(gbl.dPosInfo,showMsg,1,iSelect); //确认超时影响操作
				wrLog("%s",showMsg);
				return 1;

			}
			else
			{
				bbzero(showMsg);
				sprintf(showMsg,"交易成功，确认失败，系统参考号:%s \n\n请按【Enter】继续交易\n如需帮助，请联系在线客服或拨打客服电话400-80-11888",stan_no);
				//TS_OutPutMsg(gbl.dPosInfo,showMsg,1,iSelect); //不在显示错误信息
				wrLog("%s",showMsg);
				return 1;

			}
	
		}
		
	}


	return iRet;

}


//关于东莞通卡片激活查询
int CTrade::getCardStatusResult()
{

	int iRet;
	int iSelect;
	string errStr="";
	PDGTCard pDgtCard;
	int openCardStatus=0;
	TSMENULIST menuList;
	gbl.random_value=0;

	memset(&menuList,0,sizeof(menuList));
	memset(&pDgtCard,0,sizeof(pDgtCard));


	//首先获取这笔交易的开卡情况，如果卡片是在系统中进行的开卡，则对这笔交易进行查询，并且读取卡片的状态
   
	//首先获取用户是否签到。获取签到信息。如果没有签到或者已经签退，提示用户先进入签到业务进行签到
	iRet=CDB::checkSignStatus(gbl.dPosInfo.pos_no,&gbl.dgtSignInfo);
	if (iRet!=0)
	{
		TS_OutPutMsg(gbl.dPosInfo,"您尚未签到，请先签到再进行交易",1,iSelect);
		return CANCLE_KEY;
	}

	//读取卡片基础信息。
	TS_OutPutMsg(gbl.dPosInfo,"\n请将东莞通卡放在读卡器上 \n确认【Enter】 返回【Esc】",1,iSelect);
	if (iSelect!=0)
	{
		return CANCLE_KEY;

	}
	iRet=dgtCardInqHdl(&gbl.dgtCard,2); //查询卡片物理信息
	if (iRet!=0) 
	{
		wrLog("卡片查询出错"); //进行异常处理
		//TS_OutPutMsg(gbl.dPosInfo,"卡片查询出错",1,iSelect);
		return CANCLE_KEY;
	}

	if (memcmp(gbl.dgtCard.appFlag,"\x01",1)==0 ) //如开卡成功
	{
		openCardStatus=1; 
	}
	else
	{
		openCardStatus=0; 
	}

	//查询数据库中的换卡记录中是否存在这张卡的换卡记录。如果存在，则查询对应的交易记录情况
	iRet=checkdgtUnsubmit(0);
	if (iRet==0 ) //表示冲正或者确认已经处理成功
	{
			
			if(openCardStatus==1) 
			{
				menuList.iTotalNum = 2;
				strcpy(menuList.acTitle, "开卡成功，继续交易请选择业务");
				strcpy(menuList.menuItem[0], "东莞通充值");
				strcpy(menuList.menuItem[1], "退出");
				iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
				if(iRet)
					return -1;
				switch(iSelect)
					
				{
				case 1:
					bbzero(gbl.fee_type);
					strcpy(gbl.fee_type,"0371"); //充值
					iRet = dgtBusTrade("东莞通充值",2); //莞市通充值
					if (iRet==0)
					{
						ecardInqHdl(); //查询账户余额
					}
					
					break;
				default: 
					return CANCLE_KEY;
				}

			}
			else
			{
				menuList.iTotalNum = 2;
				strcpy(menuList.acTitle, "卡片未激活，请选择其他业务");
				strcpy(menuList.menuItem[0], "东莞通开卡");
				strcpy(menuList.menuItem[1], "退出");
				iRet = TS_Menu(gbl.dPosInfo, &menuList, iSelect, MENU_TIME_OUT);
				if(iRet)
					return -1;
				switch(iSelect)
					
				{
				case 1:
					bbzero(gbl.fee_type);
					strcpy(gbl.fee_type,"0372"); //充值
					iRet = dgtCardSale("东莞通开卡"); //莞市通充值
					if (iRet==0)
					{
						ecardInqHdl(); //查询账户余额
					}
					
					break;
				default: 
					return CANCLE_KEY;
				return -1;

				}
			}
			
	}
	else //如果是开卡失败，发送开卡失败的报文 并更新数据库中的状态
	{
		TS_OutPutMsg(gbl.dPosInfo,"卡片开卡失败,请联系在线客服或致电400-80-11888",1,iSelect);
		return CANCLE_KEY;
	}
	
	return 0;


}



//显示东莞通最近10笔交易
int CTrade::showDGTALLTrade()
{
	int iRet;
	char errMsg[200];
	char reader_rspcode[4+1];
	int iSelect ;

	bbzero(reader_rspcode);
	bbzero(errMsg);

	iRet=CDGTBusTrade::readAllTxnLogs(gbl.dPosInfo,&gbl.dgtCard,reader_rspcode,errMsg);
	if (iRet!=0)

	{
		if (iRet==-2)
		{

			wrLog("查无信息");
			TS_OutPutMsg(gbl.dPosInfo,"无交易记录",1,iSelect);
		}
		else
		{
			
			wrLog("查询失败");
			TS_OutPutMsg(gbl.dPosInfo,"查询失败",1,iSelect);
			
		}
		
		return CANCLE_KEY;
	}

	return 0;

}


//显示东莞通最近4笔交易
int CTrade::showDGTChargeTrade()
{
	int iRet;
	char errMsg[200];
	char reader_rsp[4+1];
	int iSelect;

	bbzero(errMsg);
	bbzero(reader_rsp);
	iRet=CDGTBusTrade::readChargeLogs(gbl.dPosInfo,&gbl.dgtCard,reader_rsp,errMsg);
	if (iRet!=0)
	{
		if (iRet==-2)
		{
			wrLog("查无信息");
			TS_OutPutMsg(gbl.dPosInfo,"无交易记录",1,iSelect);
		}
		else 
		{

			wrLog("查询失败");
			TS_OutPutMsg(gbl.dPosInfo,"查询失败",1,iSelect);

		}

		return CANCLE_KEY;
	}

	return 0;

}


//东莞通卡片充值

int CTrade::dgtCardCharge(char *title)
{

	int iRet;
	string errSTR="";
	string errSTR1="";
	char errMSG[200];
	string rsp_code="";
	char MAC1[8+1];
	char cardAmount[8+1]; //卡片充值前余额
	char cardCount[8+1]; //卡片计数器
	char initRandom[8+1]; //随机数
	char sysTime[14+1];
	char TAC[8+1];
	char MAC2[8+1];
	char APDU[200];
	int iSelect;
	int nowAmo;
	int iRet2;
	int write_iRet;
	char term_id[8+1];
	char APTRANSSEQ[15+1];
	int verify_iRet;

	int query_iRet=0;
	bbzero(MAC1);
	bbzero(sysTime);
	bbzero(term_id);
	bbzero(errMSG);
	bbzero(cardAmount);
	bbzero(initRandom);
	bbzero(cardCount);
	bbzero(TAC);
	bbzero(MAC2);
	bbzero(APDU);
	char showMsg[200];
	bbzero(showMsg);
	bbzero(APTRANSSEQ);


	//cpu卡初始化操作
	bbzero(gbl.dgtCard.CARDRAND);
	bbzero(gbl.dgtCard.CARDCNT);
	bbzero(gbl.dgtCard.MAC1);


	strcpy(term_id,gbl.pos_no);

	//进行扣费 卡操作请求完成之后才会扣费
	
	if(CDB::getDayAmo(gbl.dPosInfo.pos_no, &nowAmo)==0)
		//20120105修改-yyx
		//if (CDB::pep_getDayAmo(pgbl->pos_no, &nowAmo) == 0)
	{
		if( gbl.dayAmo!=0 && nowAmo+atoi(gbl.amount)>gbl.dayAmo )
		{
			TS_OutPutMsg(gbl.dPosInfo, "已超出当天的最大消费金额，交易取消", 1, iSelect);
			return -1;
		}
	}
	else
	{
		TS_OutPutMsg(gbl.dPosInfo, "数据库操作出错，交易取消\n请稍候再试!\n 如果交易结果不明确请做 最后一笔交易查询", 1, iSelect);
		return -1;
	}
	
	//显示界面确定信息
	bbzero(showMsg);
	sprintf(showMsg,"卡余额:%.2f元\n充值金额:%.2f元\n充值【Enter】 返回【Esc】",atof(gbl.dgtCard.cardMny)/100,atof(gbl.amount)/100);

	
	TS_OutPutMsg(gbl.dPosInfo,showMsg,1,iSelect);
	if (iSelect!=0)
	{
		return CANCLE_KEY;
	}

	//获取上一笔交易流水号
	bbzero(gbl.dgtCard.lastPosSeq);
	iRet=CDB::getLastPosSEQ(gbl.dPosInfo.pos_no,gbl.dgtCard.lastPosSeq);
	if (iRet!=0)
	{
		bbzero(gbl.dgtCard.lastPosSeq);
		strcpy(gbl.dgtCard.lastPosSeq,"000000000");
		
	}

	bbzero(gbl.dgtCard.tradeBeForeMny);
	memcpy(gbl.dgtCard.tradeBeForeMny,gbl.dgtCard.cardMny+4,8);
	wrLog("卡片余额:%s",gbl.dgtCard.cardMny);
	wrLog("卡片余额22:%s",gbl.dgtCard.tradeBeForeMny);

	bbzero(gbl.dgtCard.CARDCNT); //卡片计数器
	bbzero(gbl.dgtCard.CARDRAND); //卡片随机数
	char cardMNY[8+1];
	bbzero(cardMNY);
	bbzero(gbl.dgtCard.cardMny);
	bbzero(gbl.dgtCard.CARDSEQ);
	bbzero(gbl.dgtCard.KEYVER);
	bbzero(gbl.dgtCard.ALGIND);
	//校验pin2
	char appSerial[16+1];
	bbzero(appSerial);
	CTools::byte_to_hex((BYTE *) gbl.dgtCard.appSerial,(BYTE *)appSerial,8);
	iRet=CDGTBusTrade::checkPIN2(gbl.dPosInfo,appSerial,errMSG);

	if (iRet!=0)
	{
		bbzero(errMSG);
		strcpy(errMSG,"PIN2校验错误");
		wrLog("PIN2校验错误");
		TS_OutPutMsg(gbl.dPosInfo,"PIN2校验失败",1,iSelect);
		return -1;
	}
	
	iRet=CDGTBusTrade::initCPUCard(gbl.dPosInfo,gbl.dgtSignInfo.POSID,gbl.amount,gbl.dgtCard.CARDCNT,gbl.dgtCard.KEYVER,gbl.dgtCard.ALGIND,gbl.dgtCard.CARDRAND,cardMNY,gbl.dgtCard.MAC1,(char *)errMSG);
	//获取的信息赋值
	if (iRet!=0) //如果初始化失败
	{
		TS_OutPutMsg(gbl.dPosInfo,"CPU卡初始化失败",1,iSelect);

		return -1;

	}

	CTools::HexToDec(cardMNY,gbl.dgtCard.cardMny);
	bbzero(gbl.dgtCard.KEYSET);
	strcpy(gbl.dgtCard.KEYSET,gbl.dgtSignInfo.KEYSET);

	//进行缴费，刷卡
	int flag = 0;
	for(int curTry=0; curTry<3; curTry++) //只能刷卡三次,否则锁卡
	{
		if(!flag)
		{
			iRet = mngCard_Hdl(title);
			if(iRet == CANCLE_KEY)
				return CANCLE_KEY;
			else if(iRet != 0)
				return -1;
		}

		//充值之前发卡操作请求 获取MAC2
		bbzero(gbl.TRANSSEQ);
		iRet=cardOperate_service("[东莞公交]卡操作","INF06203","2","2062","02",APDU,gbl.TRANSSEQ,rsp_code,errSTR1); //充值之前进行卡操作请求

		if (strlen(gbl.TRANSSEQ) >0)
		{
			bbzero(gbl.stan_no);
			memcpy(gbl.stan_no,gbl.TRANSSEQ+(strlen(gbl.TRANSSEQ)-12),12);
		}
	
		if (iRet!=0) //卡操作请求失败的情况
		{
			//首先判断是否是公交公司反馈错误
			if (iRet==-6)
			{
				char errMsg[500];
				sprintf(errMsg,"充值失败 %s",errSTR1.c_str());
				TS_OutPutMsg(gbl.dPosInfo,(char *)errMsg,1,iSelect);
				return CANCLE_KEY;

			}

			if (iRet==-2 || iRet==-1) // //对于明确失败和参数不足的发送冲正！
			{
				CDB::insert_dgtTxnLog(gbl,0);
			
				for(int i=0;i<2;i++)
				{

					if (atoi(gbl.TRANSSEQ) >0) 
					{
						verify_iRet=dgtCardChargeService("[东莞公交]充值冲正/冲正","INF06205","RGR","86",gbl.TRANSSEQ,errSTR); 
					}
					else
					{
					
						verify_iRet=dgtCardChargeService("[东莞公交]充值冲正/冲正","INF06205","RGR2","86",gbl.TRANSSEQ,errSTR); 
					}
				
					if (verify_iRet==0)
					{
						break;
					}
				}

				if (verify_iRet==0)
				{
					CDB::update_dgtTxnLogByStan(gbl.SYSTEMNO,1);

				}

				if (strcmp(rsp_code.c_str(),"002135")==0) //密码错误
				{
					flag = 1;
					if(reGetPwd(title) == 0) //密码错误，重新输入密码
						continue;
					else
						return CANCLE_KEY;
					
				}
				else
				{
					
					if (strcmp(rsp_code.c_str(),"002136")==0) //密码被锁
					{
						TS_OutPutMsg(gbl.dPosInfo,"交易密码已锁，请联系在线客服或者拨打客服电话400-80-11888解锁",1,iSelect);
						return CANCLE_KEY;
						
					}
					else
					{
						char errMsg[500];
						bbzero(errMsg);
						sprintf(errMsg,"交易失败 %s",errSTR1.c_str());
						TS_OutPutMsg(gbl.dPosInfo,(char *)errMsg,1,iSelect);
						return CANCLE_KEY;
					}
					
				}
			}
			else if (iRet==-4 || iRet==-5) //如果是超时情况，进行处理
			{

				CDB::insert_dgtTxnLog(gbl,0);
				//获取信息，发送失败报文，并更新交易状态

				string strPayStat = "";
				for(int i=0;i<3;i++)
				{
				
					query_iRet=getGgtResultByKeep("[东莞公交]卡操作结果查询接口","INF06208",gbl.dgtCard.KEEP,strPayStat,errSTR);
					if (query_iRet==0)
					{
						break;
					}

				}

				if (query_iRet==0) //判断是否生成订单，如果生成订单，则发起退费，如果没有，则走公交冲正流程
				{
					CDB::update_dgtTxnLog_byKeep(gbl);	//如果生成订单退费	
				//	if (strlen(gbl.TRANSSEQ) >0 )
					if ("S0S" == strPayStat) 
					{
						iRet=dgtCardChargeService("[东莞公交]充值冲正/冲正","INF06205","RGR","86",gbl.TRANSSEQ,errSTR); 
					}
					else
					{
					 	iRet=dgtCardChargeService("[东莞公交]充值冲正/冲正","INF06205","RGR2","86",gbl.TRANSSEQ,errSTR); 

					}
					if (iRet==0)
					{
						CDB::update_dgtTxnLogByStan(gbl.SYSTEMNO,1);
						TS_OutPutMsg(gbl.dPosInfo,"交易失败，请留意账户余额变动\n如有疑问，请咨询在线客服或者客服电话400-80-11888",1,iSelect);
						return CANCLE_KEY;
					}
					else
					{
						TS_OutPutMsg(gbl.dPosInfo,"交易失败，请留意账户余额变动\n如有疑问，请咨询在线客服或者客服电话400-80-11888",1,iSelect);
						return -1;
					}
					
					
				}
				else 
				{
					TS_OutPutMsg(gbl.dPosInfo,"充值失败",1,iSelect);
					return -1;
			
				}

			}


		}

		else //申请成功，进行充值
		{

			bbzero(APTRANSSEQ);
			strcpy(APTRANSSEQ,gbl.TRANSSEQ);
			break;
		}
 	}


	//进行圈存 查询账户余额
	bbzero(gbl.pos_no);
	strcpy(gbl.pos_no,term_id);

	bbzero(gbl.TRANSSEQ);
	strcpy(gbl.TRANSSEQ,APTRANSSEQ);

	ecardInqHdl(); //查询账户余额
	wrLog("圈存时间:%s",gbl.dgtCard.sysTime);
	bbzero(sysTime);
	strcpy(sysTime,gbl.dgtCard.MESSAGEDATETIME);


	write_iRet=CDGTBusTrade::cpuCard_load(gbl.dPosInfo,gbl.dgtCard.MESSAGEDATETIME,gbl.dgtCard.MAC2,TAC,errMSG); 

	//读卡。如果卡内余额变化。并且圈存返回成功。则交易成功。
	if (write_iRet==0 )
	{
		strcpy(gbl.dgtCard.TAC,TAC); //复制TAC
		bbzero(gbl.dgtCard.tradeDate);
		bbzero(gbl.dgtCard.tradeTime);
		memcpy(gbl.dgtCard.tradeDate,gbl.dgtCard.MESSAGEDATETIME,8);
		memcpy(gbl.dgtCard.tradeTime,gbl.dgtCard.MESSAGEDATETIME+8,6);
		bbzero(gbl.dgtCard.tradeMny);
		memcpy(gbl.dgtCard.tradeMny,gbl.amount+4,8);
		
	}
	//再次执行查询

	iRet2 = dgtCardInqHdl(&gbl.dgtCard,3); //卡片充值过程中更新余额查询操作

	if (iRet2==0)
	{

		bbzero(gbl.dgtCard.tradeAfterMny);
		memcpy(gbl.dgtCard.tradeAfterMny,gbl.dgtCard.cardMny+4,8);
		wrLog("比对充值前后金额");
		wrLog("充值前余额:%d",atoi(gbl.dgtCard.tradeBeForeMny));
		wrLog("充值后余额:%d",atoi(gbl.dgtCard.tradeAfterMny));
		wrLog("交易金额:%d",atoi(gbl.amount));
	}

	//查询余额
	if (write_iRet==0  || (iRet2==0 &&(atoi(gbl.dgtCard.tradeAfterMny)==atoi(gbl.amount)+atoi(gbl.dgtCard.tradeBeForeMny)) ) )//成功
	{
		//更新数据
		
		iRet=CDGTBusTrade::wrTxnLogs(gbl.dPosInfo,gbl.dgtSignInfo.POSID,gbl.dgtCard,"02",errMSG);
		if (iRet!=0)
		{
			wrLog("写卡记录失败");
		}

		bbzero(gbl.dgtCard.MESSAGEDATETIME);
		strcpy(gbl.dgtCard.MESSAGEDATETIME,sysTime);
		//读卡器 显示信息
		char showLEDMsg[100];
		char errMsg[200];
		bbzero(errMsg);
		bbzero(showLEDMsg);

		if (write_iRet==0 && iRet2!=0) //对于特殊情况读卡器写卡成功但是读卡失败的情况认为是成功处理
		{

			//更新充值后余额和卡片余额。加值运算
			int showMny;
			showMny=atoi(gbl.dgtCard.tradeBeForeMny)+atoi(gbl.amount);
			bbzero(gbl.dgtCard.tradeAfterMny);
			sprintf(gbl.dgtCard.tradeAfterMny,"%08d",showMny);
			bbzero(gbl.dgtCard.cardMny);
			sprintf(gbl.dgtCard.cardMny,"%012d",showMny);

			sprintf(showLEDMsg,"余额:%.2f元",atof(gbl.dgtCard.cardMny)/100);

		}
		else
		{
			sprintf(showLEDMsg,"余额:%.2f元",atof(gbl.dgtCard.cardMny)/100);
		}

		iRet=CDGTBusTrade::showLEDMsg(gbl.dPosInfo,showLEDMsg,errMsg);
		if (iRet==0)
		{
			iRet=CDGTBusTrade::buzzer(gbl.dPosInfo,errMSG);
		}
		
		//交易成功，需要进行确认
		CDB::insert_dgtTxnLog(gbl,6);

		iRet=dgtCardChargeService("[东莞公交]充值/冲正","INF06205","REG","02",APTRANSSEQ,errSTR); 
	
		if (iRet==0)
		{

			CDB::update_dgtTxnLog(gbl.TRANSSEQ,2);

		}

	}
	else if (write_iRet==-1 &&iRet2!=0) //如果读卡和充值都没有返回，则默认是成功的交易
	{
		//更新数据
		bbzero(gbl.pos_no);
		strcpy(gbl.pos_no,term_id);
		bbzero(gbl.dgtCard.MESSAGEDATETIME);
		strcpy(gbl.dgtCard.MESSAGEDATETIME,sysTime);

		//超时的情况进行处理 更新扣费金额和卡片余额。
		int showMny;
		bbzero(gbl.dgtCard.tradeMny);
		memcpy(gbl.dgtCard.tradeMny,gbl.amount+4,8);
		showMny=atoi(gbl.dgtCard.tradeBeForeMny)+atoi(gbl.dgtCard.tradeMny);
		bbzero(gbl.dgtCard.tradeAfterMny);
		sprintf(gbl.dgtCard.tradeAfterMny,"%08d",showMny);
		bbzero(gbl.dgtCard.cardMny);
		sprintf(gbl.dgtCard.cardMny,"%012d",showMny);


		iRet=dgtCardChargeService("[东莞公交]充值/冲正","INF06205","REG","02",APTRANSSEQ,errSTR); 
		CDB::insert_dgtTxnLog(gbl,6);

		if (iRet==0)
		{
			CDB::update_dgtTxnLog(gbl.TRANSSEQ,2);
		}

		return 0; //疑似成功交易
	}
	else //失败
	{
		//发冲正包

		bbzero(gbl.pos_no);
		strcpy(gbl.pos_no,term_id);
		bbzero(gbl.dgtCard.MESSAGEDATETIME);
		strcpy(gbl.dgtCard.MESSAGEDATETIME,sysTime);
		CDB::insert_dgtTxnLog(gbl,5);
		iRet=dgtCardChargeService("[东莞公交]充值冲正/冲正","INF06205","RGR","86",APTRANSSEQ,errSTR); 
		
		ecardInqHdl(); //查询账户余额

		if (iRet==0)
		{
			CDB::update_dgtTxnLog(gbl.TRANSSEQ,1);
			TS_OutPutMsg(gbl.dPosInfo,"\n交易失败，请留意账户余额变动",1,iSelect);
			return -1;
		}

		else
		{

			if (iRet==-4)
			{
				bbzero(errMSG);
				char stan_no[12+1];
				bbzero(stan_no);
				memcpy(stan_no,gbl.TRANSSEQ+(strlen(gbl.TRANSSEQ)-12),12);
				
				sprintf(errMSG,"交易失败,退费超时，系统参考号:%s\n\n请留意账户余额变动，如需帮助，请联系在线客服或拨打客服电话400-80-11888",stan_no);
				TS_OutPutMsg(gbl.dPosInfo,errMSG,1,iSelect);
				return -4;
			}
			else
			{
				bbzero(errMSG);
				char stan_no[12+1];
				bbzero(stan_no);
				
				sprintf(errMSG,"交易失败,退费状态，系统参考号请留意账户余额变动\n%s",errSTR.c_str());
				TS_OutPutMsg(gbl.dPosInfo,errMSG,1,iSelect);
				return -2;

			}

			
		}
	

	}
	
	return 0;

}

int CTrade::g3_trade(char *title)
{

	TSTradeInfoSend tradeInfoSend;
	TSTradeInfoRecv tradeInfoRecv;
	int iRet,iSelect;
	char errMsg[200];
	char showMsg[500];
	bbzero(errMsg);
	memset(&tradeInfoSend, 0, sizeof(tradeInfoSend));
	memset(&tradeInfoRecv, 0, sizeof(tradeInfoRecv));
	strcpy(tradeInfoSend.acMainTitle, title);
	tradeInfoSend.uHasTradeID = 1;
	tradeInfoSend.uTotalContents = 1;
	strcpy(tradeInfoSend.Contents[0].acTitle, "请输入手机号码");	
	tradeInfoSend.Contents[0].uCommand = TS_INPUT_MATH;	//数字
	tradeInfoSend.Contents[0].uCount = 0;		//输入1次卡号
	tradeInfoSend.Contents[0].uTimeOut = 30;	//超时30秒
	tradeInfoSend.Contents[0].uMinLen = 11;
	tradeInfoSend.Contents[0].uMaxLen = 11;
	iRet = TS_TradeControl(&gbl.dPosInfo, &tradeInfoSend, &tradeInfoRecv);
	
	if(iRet != 0)
	{
		wrLog("TS_TradeControl返回错误[%d]", iRet);
		wrMonitorLog(1, 1, iRet, gbl, pack);	//监控日志
		return iRet;
	}

	memset(gbl.pos_serial,0,sizeof(gbl.pos_serial));
	strcpy(gbl.pos_serial,(char *)tradeInfoRecv.uTradeID);
	gbl.phone_len = tradeInfoRecv.Contents[0].uMsgLen;
	memset( gbl.phone_no,0,sizeof(gbl.phone_no) );
	strcpy( gbl.phone_no,(char *)tradeInfoRecv.Contents[0].uMsg ); //输入手机号码
	//对手机号进行校验
	
	bbzero(errMsg);
	iRet=g3_PhoneCheck(errMsg);
	if (iRet!=0)
	{
		TS_OutPutMsg(gbl.dPosInfo,errMsg,1,iSelect);
		return -1;
	}

	iRet=AutoSelectG3TC(gbl.dPosInfo,gbl.amount,gbl.RECHARGEFLOW);
	if (iRet!=0)
	{
		return CANCLE_KEY;
	}
	
	//在界面上面显示充值手机号及流量并提示用户确认
	bbzero(showMsg);
	sprintf(showMsg,"3G流量卡直充\n\n充值手机号:%s\n充值面值:%d元\n充值流量:%sM\n\n按【Esc】返回 按【Enter】继续",gbl.phone_no,atoi(gbl.amount)/100,gbl.RECHARGEFLOW);
	iRet=TS_OutPutMsg(gbl.dPosInfo,showMsg,0,iSelect);
	if (iSelect!=0)
	{
		return CANCLE_KEY;
	}


	iRet=pay(title,errMsg);

	if (iRet!=0)
	{
		bbzero(showMsg);
		sprintf(showMsg,"\n%s",errMsg);
		TS_OutPutMsg(gbl.dPosInfo,showMsg,0,iSelect);
		return CANCLE_KEY;

	}

	bbzero(showMsg);
	sprintf(showMsg,"交易成功!  \n\n系统参考号:%s\n手机号码:%s\n充值面值:%02d元\n充值流量:%sM\n\n返回请按【Esc】",gbl.stan_no,gbl.phone_no,atoi(gbl.amount)/100,gbl.RECHARGEFLOW);
	TS_OutPutMsg(gbl.dPosInfo,showMsg,0,iSelect);
	
	//打印信息 不打印发票信息；
	/*
	CPrint print;
	print.set_in_par(gbl);
	print.print_g3chargeCard_detail(title);
	*/
	return 0;
}

int CTrade::g3_PhoneCheck(char *errMsg)
{
	int iRet;
	string err_str;
	iRet=accountCheck_service("充值账户校验","INF06004","1",err_str);
	if (iRet!=0)
	{
		strcpy(errMsg,err_str.c_str());
		return -1;
	}

	return 0;
}

int CTrade::AutoSelectG3TC(const TSDLLPosInfo dposInfo,char *money,char *flow)
{    
	TSMENULIST menulist;
	int iSelect;
	int iRet;
	
	bbzero(money);
	bbzero(flow);
	memset(&menulist,0,sizeof(menulist));
	menulist.iTotalNum = 3;
	strcpy(menulist.acTitle,"请选择套餐");
	strcpy(menulist.menuItem[0],"10元(60M)");
	strcpy(menulist.menuItem[1],"20元(150M)");
	strcpy(menulist.menuItem[2],"30元(300M)");
	iRet=TS_Menu(dposInfo,&menulist,iSelect,MENU_TIME_OUT);
	if(iRet==HOTKEY)
	{
		return CANCLE_KEY;
	}
	else if(iRet!=0)
	{
		return iRet;
	}
	else
	{
		NULL;
	}
	switch (iSelect)
	{
	case 1:
		strcpy(money,"000000001000");
		strcpy(flow,"60");
		return 0;
	case 2:
		strcpy(money,"000000002000");
		strcpy(flow,"150");
		return 0;
	case 3:
		strcpy(money,"000000003000");
		strcpy(flow,"300");
		return 0;
	default: 
		return CANCLE_KEY;
	}

}

//扣费
int CTrade::pay(const char *title,char *errMsg)
{
	char operUser[20];
	int iRet;
	int flag;
	bbzero(operUser);
	int iSelect;
	string rspcode="";
	string errStr="";
	int iRet2;
	sprintf(operUser,"%s_01",gbl.pos_no);
	int nowAmo;
	bbzero(errMsg);
	char pos_no[9+1];
	char password[16+1];
	char fee_type[4+1];

	bbzero(fee_type);
	strcpy(fee_type,gbl.fee_type);
	bbzero(password);
	strcpy(pos_no,gbl.pos_no);

	if(CDB::getDayAmo(gbl.dPosInfo.pos_no, &nowAmo)==0)
		//20120105修改-yyx
		//if (CDB::pep_getDayAmo(pgbl->pos_no, &nowAmo) == 0)
	{
		if( gbl.dayAmo!=0 && nowAmo+atoi(gbl.amount)>gbl.dayAmo )
		{
			TS_OutPutMsg(gbl.dPosInfo, "已超出当天的最大消费金额，交易取消", 1, iSelect);
			return -1;
		}
	}
	else
	{
		TS_OutPutMsg(gbl.dPosInfo, "数据库操作出错，交易取消\n请稍候再试!\n 如果交易结果不明确请做 最后一笔交易查询", 1, iSelect);
		return -1;
	}

	//进行缴费，刷卡
	flag = 0;
	for(int curTry=0; curTry<3; curTry++) //只能刷卡三次,否则锁卡
	{
 		if(!flag)
		{
			iRet = mngCard_Hdl(title);
			if(iRet == CANCLE_KEY)
				return CANCLE_KEY;
			else if(iRet != 0)
				return -1;
		}
		

		bbzero(password);
		CTools::byte_to_hex((BYTE *)gbl.password,(BYTE *)password,8);

		switch (atoi(gbl.fee_type))
		{

			case 366: //3g流量卡

				bbzero(gbl.TRANSSEQ);
				iRet=g3DisChargeCard_pay_service(gbl,"3G流量卡充值","INF02021","001","01",operUser,password,gbl.TRANSSEQ,rspcode,errStr); //默认充值类型为直充001
				break;
			case 367://全国话费充值 电信充值
				bbzero(gbl.TRANSSEQ);
				iRet=phone_pay_service("话费充值接口","INF02011","03010008",operUser,password,gbl.TRANSSEQ,rspcode,errStr);
				break;
			case 370://全国联通充值
				bbzero(gbl.TRANSSEQ);
				iRet=phone_pay_service("话费充值接口","INF02011","04010003",operUser,password,gbl.TRANSSEQ,rspcode,errStr);
				break;
			case 369://全国移动充值 
				bbzero(gbl.TRANSSEQ);
				iRet=phone_pay_service("话费充值接口","INF02011","05010005",operUser,password,gbl.TRANSSEQ,rspcode,errStr);
				break;
			case 180://移动（广东省内）手机话费充值 
				bbzero(gbl.TRANSSEQ);
				iRet=phone_pay_serviceGDYD("话费充值接口","INF02038","04010011",operUser,password,gbl.TRANSSEQ,gbl,rspcode,errStr);
				break;
			case 76:
			case 77:
			case 167:
			case 168:
			case 274:
			case 87:
			case 88:
			case 273:
			case 278:
			case 293:
			case 294:
			case 277:
			//	iRet=qq_guanglu_pay_service("广璐QQ充值接口","INF02037",operUser,password,gbl.TRANSSEQ,rspcode,errStr);
				iRet=qq_guanglu_pay_service("彩易QQ充值接口","INF02039",operUser,password,gbl.TRANSSEQ,rspcode,errStr);
				break;
			
			default:
				return -1;
		}

		if (iRet!=0)  
		{

			//返回明确失败的。返回明确失败。其他的返回网络繁忙，请稍后再试
			if (iRet!=-3)
			{
				if (iRet == -4)
				{
					return -5;
				}
				else
				{
					if (errStr.size()>0)
					{
						
						bbzero(errMsg);
						strcpy(errMsg,errStr.c_str());
					}
					else
					{
						
						bbzero(errMsg);
						strcpy(errMsg,"未知错误,请进入自服务门户，查询交易结果!"); //修改业务提示语
					} 
					
					return -1; //如果不是明确返回失败，直接退出

				}
			

			}

			//对于明确返回失败的交易进行处理

			else //有错误吗信息
			{
				if ( strcmp(rspcode.c_str(),"002135")==0)
				{

					flag = 1;
					if(reGetPwd(title) == 0) //密码错误，重新输入密码
						continue;
					else
					return -1;
				}
				else if (strcmp(rspcode.c_str(),"002136")==0)
				{
					bbzero(errMsg);
					strcpy(errMsg,"交易密码已锁，请联系在线客服或者拨打客服电话400-80-11888解锁");

				}
				else if (strcmp(rspcode.c_str(),"006016") ==0 ) //余额不足
				{
					bbzero(errMsg);
					strcpy(errMsg,"余额不足");
				}
				else
				{
				
					bbzero(errMsg);
					strcpy(errMsg,errStr.c_str());
					
					bbzero(gbl.fee_type);
					strcpy(gbl.fee_type,fee_type);
					bbzero(gbl.pos_no);
					strcpy(gbl.pos_no,pos_no);
					
				
				}

				if (strlen(gbl.TRANSSEQ)>0)
				{
					
					bbzero(gbl.stan_no);
					memcpy(gbl.stan_no,gbl.TRANSSEQ+(strlen(gbl.TRANSSEQ)-12),12);
					wrLog("gbl.stan:%s",gbl.stan_no);
					iRet2=CDB::insertEposTxn(gbl,"01"); //交易失败
					if (iRet2!=0)
					{
						wrLog("插入数据库记录失败");
					}
				}	
					return -1;
			
			}
			
		}
		else //成功交易
		{
			
			//返回订单号;
			bbzero(gbl.fee_type);
			strcpy(gbl.fee_type,fee_type);
			bbzero(gbl.stan_no);
			memcpy(gbl.stan_no,gbl.TRANSSEQ+(strlen(gbl.TRANSSEQ)-12),12);
			bbzero(gbl.pos_no);
			strcpy(gbl.pos_no,pos_no);
			bbzero(gbl.password);
			CTools::hex_to_byte((BYTE *)password,(BYTE *)gbl.password,16);

			CDB::setSumDayAmo(atoi(gbl.amount),gbl.pos_no);
			iRet2=CDB::insertEposTxn(gbl,"00");

			if (iRet2!=0)
			{
				wrLog("插入数据库记录失败");
			}

			ecardInqHdl();//查询账户余额
			
			return 0;
		}


	}

	return 0;

}


// 刷卡输密码向PE发扣费包
// 入参：biz_type(4):业务代码；amount(12):金额
// 出参：无
// 返回值
// 0：扣费成功
// 1：扣费失败
// 2：超时返回
int CTrade::YCT_PayPe(YCT_DATA yct_data, BYTE* party, BYTE* rspcode,char *stan,char *pos_serial)
{
	int  iRet, flag,mngCard_count=1,iSelect;
	int b48_len = 0;
	char len_buff[10];
	
	wrLog("【*******PE扣费*******】");	
	
	//传递信息,取得刷卡数据
	flag = 0;	//重输密码标识
	/********************请求刷卡****************/
	mngCard_count=1;
	for(int maxTry=0; maxTry<50; maxTry++)	//密码错误可重输
	{
		if(!flag)
		{
			iRet = mngCard_Hdl("羊城通充值");
			if(iRet == CANCLE_KEY)
			{
				*party = FROMCTSI;
				*rspcode = USERCANCEL;
				return 1;
			}
			else if(iRet != 0)
			{
				*party = FROMCTSI;
				*rspcode = ICTIMEOUT;
				return 1;
			}
		}
		pack.wrField(2, gbl);	//写交费域

		/***********修改一些域信息*********/
		bbzero(pack.FIELD48);
		memcpy(pack.FIELD48,gbl.fee_type,4);	//4位信息码
		b48_len = 4;
		memset(len_buff,0,sizeof(len_buff));
		sprintf(len_buff,"%02d", 25);	//卡号长度
		memcpy(pack.FIELD48+b48_len,len_buff,2);	
		b48_len +=2;
		memcpy(pack.FIELD48+b48_len, yct_data.ticket_no, 16);	//羊城通逻辑卡号
		b48_len += 16;
		memcpy(pack.FIELD48+b48_len, "|", 1);
		b48_len += 1;
		memcpy(pack.FIELD48+b48_len, yct_data.pki_card, 8);	//羊城通物理卡号
		b48_len += 8;
		pack.Packet_Table[48].Real_Length=b48_len;
		/**********************************/
		
		//交费包处理
		//iRet = packHdl(gbl, &pack, 2);
		iRet = packHdl(2);
		if(iRet==0)
		{
			NULL;
		}
		else if(iRet==1)
		{
			*party = FROMCTSI;
			*rspcode = PACKFAIL;
			return iRet;
		}
		else if(iRet==2)
		{
			*party = FROMCTSI_N;
			*rspcode = PAYTIMEOUT;
			return -1;
		}
		else if(iRet==3)
		{
			*party = FROMCTSI_N;
			*rspcode = UNPACKFAIL;
			return iRet;
		}
		
		bbzero(pos_serial);
		CTools::byte_to_hex(pack.FIELD11,(BYTE *)pos_serial,3);
		wrLog("扣费pos_serial：%s",gbl.pos_serial);
		if (!memcmp(pack.FIELD39,"00",2)) 
		{
			bbzero(stan);
			memcpy(stan,(char *)pack.FIELD37,12);
			*party = FROMCTSI;
			*rspcode = SUCC_MSG;
			return 0;
		}
		else if(!memcmp(pack.FIELD39,"55",2))
		{
			flag = 1;
			if(reGetPwd( "羊城通充值" ) == 0) //密码错误，重新输入密码
			{
				continue;
			}
			else
			{
				*party = FROMCTSI;
				*rspcode = USERCANCEL;
				return CANCLE_KEY;
			}
		}
		else if(!memcmp(pack.FIELD39,"14",2)||!memcmp(pack.FIELD39,"15",2)||!memcmp(pack.FIELD39,"33",2)||!memcmp(pack.FIELD39,"35",2)||!memcmp(pack.FIELD39,"36",2)||!memcmp(pack.FIELD39,"56",2)||!memcmp(pack.FIELD39,"57",2)||!memcmp(pack.FIELD39,"60",2)||!memcmp(pack.FIELD39,"62",2)||!memcmp(pack.FIELD39,"91",2))
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n     不支持的卡\n   请换卡重新刷卡", 0, iSelect);
			if (iSelect!=0)
			{
				*party = FROMCTSI;
				*rspcode = CARDNOTFIX;
				return -1;
			}
			else
			{
				continue;
			}
		}
		*party = FROMPE;
		*rspcode = atoi((char *)pack.FIELD39);
		return -1;
	}// end for(int maxTry=0; maxTry<50; maxTry++)
	return -1;
}

//确认与冲正
// 入参：yct_data:羊城通交易信息
// 出参：无
// 返回值：
// 2：确认成功
// 3：确认失败
// 5：冲正成功
// 6：冲正失败
int CTrade::YCT_AckRevTrade( YCT_DATA yct_data,int trade_status)
{
	int iRet=0;

	if(yct_data.status==1 )//羊城通成功和失败都需要发确认包
	{
		bbzero(gbl.pos_serial);
		CTools::getYct_posSerial(gbl.pos_serial);
		memset(gbl.fee_type, 0, sizeof(gbl.fee_type));
		memcpy(gbl.fee_type, "0083", 4);
		cardInq_yctyp();
		iRet=YCT_AckTrade(gbl, yct_data,trade_status);//确认
		wrLog("羊城通交易状态【%d】",iRet);
	}

	else if (yct_data.status==5)//充值失败需要发确认
	{
		bbzero(gbl.pos_serial);
		CTools::getYct_posSerial(gbl.pos_serial);
		iRet=YCT_AckTrade(gbl, yct_data,trade_status);//确认
		wrLog("羊城通交易状态【%d】",iRet);
	}
	
	else if(yct_data.status==4 || yct_data.status==9) //退费交易
	{
		iRet=YCT_RevTrade(gbl, yct_data);//冲正
	}
	else
	{
		iRet = yct_data.status;
	}
	return iRet;
}




// 确认交易
// 入参：yct_data:羊城通交易信息
// 出参：无
// 返回值：
// 2：已确认
// 3：未确认
int CTrade::YCT_AckTrade(CGlobal gbl, YCT_DATA yct_data,int trade_status)
{
	int b48_len, b63_len, iRet;
	char lenBuff[4+1];
	char biz_status[2+1];
	bbzero(biz_status);
	
	if (trade_status==1) //交易成功的确认
	{
		strcpy(biz_status,"00");
	}
	else
	{
	
		strcpy(biz_status,"01");
	}

	for (int i=0;i<3;i++)
	{
		wrLog("【*******PE确认*******】");
		//写确认域
		pack.wrField(4, gbl);
		/************补充48域和63域*********/
		bbzero(pack.FIELD48);
		memcpy(pack.FIELD48,"0056",4);	//4位信息码
		b48_len = 4;
		memcpy(pack.FIELD48+b48_len,biz_status,2);
		b48_len+=2;
		memset(lenBuff,0,sizeof(lenBuff));
		sprintf(lenBuff,"%02d", 25);	//卡号长度
		memcpy(pack.FIELD48+b48_len, lenBuff, 2);	
		b48_len += 2;
		memcpy(pack.FIELD48+b48_len, yct_data.ticket_no, 16);//羊城通逻辑卡号
		b48_len += 16;
		memcpy(pack.FIELD48+b48_len, "|", 1);
		b48_len += 1;
		memcpy(pack.FIELD48+b48_len, yct_data.pki_card, 8);//羊城PKI卡卡号
		b48_len += 8;
		pack.Packet_Table[48].Real_Length = b48_len;
		
		bbzero(pack.FIELD63);
		memcpy(pack.FIELD63, yct_data.yct_serial+2, 8);
		b63_len = 8;
		memcpy(pack.FIELD63 + b63_len, "0001", 4);
		b63_len += 4;
		memcpy(pack.FIELD63 + b63_len, "0000", 4);
		b63_len += 4;
		memcpy(pack.FIELD63 + b63_len, yct_data.ticket_amo_aft+4, 8);
		b63_len += 8;
		pack.Packet_Table[63].Real_Length = b63_len;
		/***********************************/
		//确认包打包
		iRet = packHdl(4);
		if( iRet==0 && memcmp(pack.FIELD39,"00",2)==0 )
		{
			if (trade_status==1) //成功的确认
			{
				return 2;// 2：已确认
			}

			else
			{
				 return 5; //充值失败的确认
			}
		
		}
		else
		{
			;//确认不成功继续确认，直至三次确认次数满
		}
	}

	//成功，但是确认确认失败是3.失败 确认失败 不做处理5
	if(trade_status==1)
	{
		
		return 3; //未确认的状态
	}
	else
	{
		return 5;
	}
	
	
}

//冲正交易
// 入参：yct_data:羊城通交易信息
// 出参：无
// 返回值：
// 5：已冲正
// 6：未冲正
int CTrade::YCT_RevTrade(CGlobal gbl, YCT_DATA yct_data)
{
	int b48_len, iRet;
	char lenBuff[4+1];
	
	for(int i=0; i<3; i++)//冲正不成功发3次
	{
		wrLog("【*******羊城通冲正[%d]*******】", i);
		//写冲正域
		pack.wrField(5, gbl);
		/************补充48域*********/
		bbzero(gbl.pos_serial);
		strcpy(gbl.pos_serial,yct_data.term_serial);

		bbzero(pack.FIELD48);
		memcpy(pack.FIELD48,"0056",4);	//4位信息码
		b48_len = 4;
		memcpy(pack.FIELD48+b48_len, yct_data.term_serial, 6);	//交费时6位原终端流水号
		b48_len += 6;
		memset(lenBuff,0,sizeof(lenBuff));
		sprintf(lenBuff,"%02d", 25);	//卡号长度
		memcpy(pack.FIELD48+b48_len,lenBuff,2);	
		b48_len += 2;
		memcpy(pack.FIELD48+b48_len, yct_data.ticket_no, 16);//羊城通逻辑卡号
		b48_len += 16;
		memcpy(pack.FIELD48+b48_len, "|", 1);
		b48_len += 1;
		memcpy(pack.FIELD48+b48_len, yct_data.pki_card, 8);//羊城PKI卡卡号
		b48_len += 8;
		pack.Packet_Table[48].Real_Length = b48_len;
		/***********************************/
		//确认包打包
		iRet = packHdl(5);
		if( iRet==0 )
		{
			if( memcmp(pack.FIELD39,"00",2)==0 )
			{
				return 5;// 5：已冲正
			}
			else
			{
				return 6;// 6：未冲正
			}
		}
		else if (iRet == 2)
		{
			//超时
			return 6;
		}
	}
	return 6;// 6：未冲正
}


//东莞通以旧换新功能
int CTrade::dgtCardTransfer(char *type)
{
	//读旧卡操作
	CDGTBusTrade dgtBusTrade;
	int iRet;
	int iRet_process;
	char rsp_code[5+1];
	char rsp_message[500];
	char errMsg[500];
	char showMsg[500];
	string errStr="";
	char tradeStatus[3+1];
	int iRet2;
	char unSubmitField[500];
	char processInfo[500];
	int readNewCardFlag=0;//需要读取新卡
	int transfer_iRet; 
	int verify_lastFlag;
	char resubmit_suc[500];
	char resubmit_fail[500];
	char resubmit[1024];

	int iSelect;
	bbzero(resubmit);
	int  APDU_LEN=0;
	char cardMNY[8+1];
	char TAC[8+1];
	char sysTime[14+1];
	int random_value=0; 
	char changeCardno[16+1];
	char openStatus[2+1];
	char cardStatusMsg[100];
	bbzero(resubmit_fail);
	bbzero(resubmit_suc);

	bbzero(openStatus);
	bbzero(changeCardno);
	bbzero(tradeStatus);
	bbzero(rsp_code);
	bbzero(cardMNY);
	bbzero(TAC);
	bbzero(errMsg);
	bbzero(showMsg);
	bbzero(gbl.posId);
	bbzero(gbl.busi_id);
	bbzero(rsp_message);
	bbzero(sysTime);
	bbzero(unSubmitField);
	bbzero(processInfo);
	bbzero(cardStatusMsg);

	gbl.random_value=0;

	iRet=CDB::getDGTDeviceInfo(gbl.pos_no,gbl.posKey,gbl.posId,gbl.busi_id);

	if (iRet!=0)
	{
		TS_OutPutMsg(gbl.dPosInfo,"对不起，你尚未开通东莞通业务,请联系在线客服或致电400-80-11888咨询开通",1,iSelect);
		return CANCLE_KEY;
	}

	//获取用户是否签到。获取签到信息。如果没有签到或者已经签退，提示用户先进入签到业务进行签到
	memset(&gbl.dgtSignInfo,0,sizeof(gbl.dgtSignInfo));

	iRet=CDB::checkSignStatus(gbl.dPosInfo.pos_no,&gbl.dgtSignInfo);
	if (iRet!=0)
	{
		TS_OutPutMsg(gbl.dPosInfo,"您尚未签到，请先签到再进行交易",1,iSelect);
		return CANCLE_KEY;
	}

	//进行换卡未提交检查,待测试 //对于开卡确认，换卡及撤销，及企业账户的确认
	dgtResubmitCheck(&gbl); 

	//获取旧卡换卡申请情况并获取，换卡进度 //读取旧卡信息
	
	memset(&gbl.dgtM1Card,0,sizeof(gbl.dgtM1Card)); //东莞通M1卡信息

	TS_OutPutMsg(gbl.dPosInfo,"\n请将一张旧卡放在读卡器上\n【Enter】确认 【Esc】返回",1,iSelect);
	if (iSelect!=0) 
	{
		return CANCLE_KEY;
	}
	
	iRet=dgtM1CardInqHdl(&gbl.dgtM1Card,1); //查询M1卡片物理信息
	if (iRet!=0) 
	{
		if (iRet==-3)
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n请换汇通智能卡重试 \n",1,iSelect);
			return CANCLE_KEY;
		}
		else if (iRet==-5)
		{
			TS_OutPutMsg(gbl.dPosInfo,"\n读取卡片信息错误 \n",1,iSelect);
			return CANCLE_KEY;
		}
		else if (iRet==-4) //对于空白卡进行处理 
		{
			return CANCLE_KEY;
		}
		else
		{
			wrLog("卡片查询出错"); //进行异常处理
			TS_OutPutMsg(gbl.dPosInfo,"\n卡片查询出错 \n请连接好读卡器，将卡放在读卡区重试",1,iSelect);
			return CANCLE_KEY;
		
		}

	}
	

	//如果是押金卡 也就是也就是25元，直接退出以旧换新流程 公交做次规定
	if (atoi(gbl.dgtM1Card.deposit)==2500)
	{
		TS_OutPutMsg(gbl.dPosInfo,"\n该卡是押金卡 不能进行该业务\n请咨询东莞通客服0769-22021888或0769-22021818进行退换!\n\n请按【Esc】返回",1,iSelect);
		return CANCLE_KEY;
	}
	

	//查询换卡进度
	
	iRet_process=CDB::getCardTransferProcess(&gbl,tradeStatus,processInfo); //换卡进度这个地方如果是开卡失败的情况之外其他，都是需要比对cpu卡片。要求cpu卡必须开卡的同一张卡
	
	bbzero(resubmit);
	strcpy(resubmit,gbl.dgtCard.resubmitField);

	if (iRet_process>0  ) //如果有换卡进度
	{
		if (strcmp(tradeStatus,"FFF") == 0 || (strcmp(tradeStatus,"C01") ==0) ) //如果是开卡失败或者只是到申请这一步
		{

			wrLog("换卡进度:%s",processInfo);
			wrLog("M1卡卡号:%s",gbl.dgtM1Card.bus_showCard); 
			wrLog("M1余额:%.2f",atof(gbl.dgtM1Card.bus_amt)/100); 
			wrLog("移资金额:%.2f元",atof(gbl.ReturnAmt)/100);

		}
		else
		{
			wrLog("换卡进度:%s",processInfo);
			wrLog("M1卡卡号:%s",gbl.dgtM1Card.bus_showCard); 
			wrLog("M1余额:%.2f",atof(gbl.dgtM1Card.bus_amt)/100); 
			wrLog("移资金额:%.2f元",atof(gbl.ReturnAmt)/100);
			wrLog("CPU卡号:%s",gbl.dgtCard.cardShowId);
			wrLog("CPU卡余额:%.2f元",atof(gbl.dgtCard.cardMny)/100);
	
		}
	}
	else
	{
		wrLog("换卡进度:%s",processInfo);

	}

	//如果是第一次换卡 如果是第二次换卡 进入业务首先判断是否已经锁卡
	if (strcmp( gbl.dgtM1Card.cardStatus,"02") !=0) // 卡片状态没有销卡 
	{
			
		iRet=busChargeZero("0373","0元充值"); //此处需要重新读取卡片状态。
		if (iRet==0) 
		{
			CDB::updateM1CardStatus(gbl.dgtM1Card.bus_showCard,"02");
			bbzero(cardStatusMsg);
			strcpy(cardStatusMsg,"已销卡(无法充值及消费)");
			sprintf(showMsg,"\n销卡成功!【Enter】继续交易 【Esc】返回\n\n旧卡卡号:%s\n旧卡余额:%.2f元\n卡片状态:%s\n\n",gbl.dgtM1Card.bus_showCard,atof(gbl.dgtM1Card.bus_amt)/100,cardStatusMsg);
			TS_OutPutMsg(gbl.dPosInfo,showMsg,1,iSelect);
			if (iSelect!=0)
			{
				return CANCLE_KEY;
			}
				
		}
		else
		{

			TS_OutPutMsg(gbl.dPosInfo,"锁卡失败，请稍后再试\n如有需要，请咨询在线客服或致电客服电话400-80-11888",1,iSelect);
			return -1;
		}
			
			
	}
	else //卡片状态是02
	{
			if(iRet_process<0) //如果不是第一次换卡，不需要有提示这些信息
			{
		
				bbzero(cardStatusMsg);
				strcpy(cardStatusMsg,"已销卡(无法充值及消费)");
				sprintf(showMsg,"\n旧卡卡号:%s\n旧卡余额:%.2f元\n卡片状态:%s \n\n【Enter】继续交易 【Esc】返回",gbl.dgtM1Card.bus_showCard,atof(gbl.dgtM1Card.bus_amt)/100,cardStatusMsg);
				TS_OutPutMsg(gbl.dPosInfo,showMsg,1,iSelect);
				if (iSelect!=0)
				{
					return CANCLE_KEY;
				}
				
			}
			else //如果不是第一次换卡，还需要校验卡片金额是否变动
			{
				if (atoi(gbl.dgtM1Card.bus_amt)!=atoi(gbl.ReturnAmt)) //如果m1卡余额与换卡金额不一致
				{
					TS_OutPutMsg(gbl.dPosInfo,"卡片金额与上次换卡金额不一致,无法换卡\n请联系东莞通客服0769-22021888或0769-22021818进行退换",1,iSelect);
					return CANCLE_KEY;
				}

			}

		
	}

	if (iRet_process>0 && strcmp(tradeStatus,"C01")!=0 && strcmp(tradeStatus,"FFF")!=0) //如果开卡失败
	{
	
		bbzero(changeCardno);
		strcpy(changeCardno,gbl.dgtCard.cardShowId);
	}

	if (strcmp(tradeStatus,"S00") ==0) //以旧换新以旧完成
	{
		TS_OutPutMsg(gbl.dPosInfo,"\n该汇通卡已经换过卡\n如有疑问请联系在线客服或致电400-80-11888咨询",1,iSelect);
		return 0;
	}
	
	
	//读取新卡信息 
	if (iRet_process>0 && (strcmp(tradeStatus,"C01") !=0 ) && strcmp(tradeStatus,"FFF") !=0) //不需要开卡，也要需要读取卡片信息
	{

		//读取新卡的信息
		
		TS_OutPutMsg(gbl.dPosInfo,"请将一张东莞通卡放在读卡器感应区 \n\n【温馨提示】如果您上次换卡失败，请将原交易使用的东莞通卡读卡器感应区\n按【Enter】 返回请按【Esc】",1,iSelect);
		if (iSelect!=0)
		{
			TS_OutPutMsg(gbl.dPosInfo,"读取东莞通卡片信息出错",1,iSelect);
			return CANCLE_KEY;
		}

		memset(&gbl.dgtCard,0,sizeof(gbl.dgtCard));
		iRet=dgtCardInqHdl(&gbl.dgtCard,2); //查询卡片物理信息
		if (iRet!=0) 
		{
			
			wrLog("读取东莞通卡片查询出错"); //进行异常处理
			TS_OutPutMsg(gbl.dPosInfo,"读取东莞通卡片出错",1,iSelect);
			return CANCLE_KEY;
			
		}

		//输出cpu卡片的开卡信息及卡片余额信息 此处添加
		wrLog("---------------------------------------------------------------");
		wrLog("输出换卡流程的cpu卡的卡片卡片开卡状态及余额信息");
		bbzero(openStatus);
		CTools::byte_to_hex((BYTE *) gbl.dgtCard.appFlag,(BYTE * ) openStatus,1);
		wrLog("CPU卡片卡号:%s",gbl.dgtCard.cardShowId);
		wrLog("卡片已经激活卡片状态:【%s】",openStatus);
		wrLog("CPU卡片余额信息:%.2f",atof(gbl.dgtCard.cardMny)/100);

		//判断是否是同一张卡
		if (strcmp(gbl.dgtCard.cardShowId,changeCardno) !=0) //如果卡片信息不一致
		{
			bbzero(showMsg);
			char showCardNo[8+1];
			bbzero(showCardNo);
			memcpy(showCardNo,changeCardno+(strlen(changeCardno) -8),8);
			if (strlen(showCardNo) >0) //如果这个卡可以获取
			{
				sprintf(showMsg,"\n请上次换卡使用的东莞通卡(卡号:%s)重试!\n如有疑问,请联系在线客服或致电400-80-11888咨询\n\n       请按【Enter】返回",showCardNo);
			}
			else
			{
				strcpy(showMsg,"\n请上次换卡使用的东莞通卡重试!\n如有疑问,请联系在线客服或致电400-80-11888咨询\n\n       请按【Enter】返回");
			}
			
			TS_OutPutMsg(gbl.dPosInfo,showMsg,1,iSelect);
			return CANCLE_KEY;
		}
		
		if (memcmp(gbl.dgtCard.appFlag,"\x01",1)==0 ) //卡片状态为已经开卡状态
		{

			if (strcmp(tradeStatus,"C0T") ==0) //如果卡片已经激活，更新状态
			{
				//更新交易状态
				CDB::updateTranChargeProcess(&gbl,"C0S"); //需要发送确认报文
				CDB::updateTranOrderStatus(gbl.Centerseqno,"S0X");
				iRet=dgtResubmitCheck(&gbl); //需要保存报文需要发送
				if (iRet==0) //如果处理成功
				{
					CDB::updateTranChargeProcess(&gbl,"C00"); //需要发送确认报文
					bbzero(tradeStatus);
					strcpy(tradeStatus,"C00"); //开卡成功
					verify_lastFlag=1; //属于确认上次交易状态行为

				}
				else
				{
					bbzero(tradeStatus);
					strcpy(tradeStatus,"C0S");
					TS_OutPutMsg(gbl.dPosInfo,"开卡出错，请联系在线客服，或者致电400-80-11888",1,iSelect);
					return CANCLE_KEY;

				}

			}
			 
		
		}
		else
		{
			if (strcmp(tradeStatus,"C0T") ==0) //如果卡片激活失败，更新状态
			{
			  bbzero(tradeStatus);
			  strcpy(tradeStatus,"C01");
			  verify_lastFlag=1; //属于确认上笔开卡交易状态行为
					
			}
				
		}
		

		//对于是sot的交易首先进行需要重新传入的resubmit
		if (strcmp(tradeStatus,"S0T") ==0)
		{
			if (strlen(resubmit) >0 )
			{

				bbzero(resubmit_suc);
				bbzero(resubmit_fail);
				char *resubmit_point;
				//获取需要提交的
				resubmit_point=strtok(resubmit,"|");
				strcpy(resubmit_suc,resubmit_point);
				resubmit_point=strtok(NULL,"|");
				strcpy(resubmit_fail,resubmit_point);
			}
			else
			{
				bbzero(resubmit_fail);
				bbzero(resubmit_suc);
				wrLog("获取提交信息失败，需在交易的时候重新生成");
			
			}

		}

		//如果卡片已经写卡 
		if (atoi(gbl.dgtCard.cardMny) == atoi(gbl.ReturnAmt)) //如果卡片余额等于返回金额
		{
			//已经移动成功
			//圈存超时进行处理
			//对于圈存超时的情况，进行判断

			verify_lastFlag=1;
			//判断交易金额等于0

			//移资金成功。需要补发企业账户确认信息和东莞公交确认信息(卡完成)
			if(strcmp(tradeStatus,"S0T") ==0 ) 
			{
				wrLog("换卡超时过程中确认是成功，正在进行换卡完成报文确认");
				if (strlen(resubmit_suc) > 0)
				{

					bbzero(gbl.dgtCard.resubmitField);
					strcpy(gbl.dgtCard.resubmitField,resubmit_suc);
					CDB::setdgtResubmit(gbl.Centerseqno,gbl.dgtCard.resubmitField);
				}
				else  //重新生成
				{
					bbzero(resubmit_suc);
					int resub_sucLen=0;
					dgtBusTrade.packdgtFunc(&gbl,"3460","53",resubmit_suc,&resub_sucLen);//成功
					bbzero(gbl.dgtCard.resubmitField);
					strcpy(gbl.dgtCard.resubmitField,resubmit_suc);
					CDB::setdgtResubmit(gbl.Centerseqno,gbl.dgtCard.resubmitField);

				}
		

			}

			CDB::updateTranChargeProcess(&gbl,"S01");
			iRet=dgtResubmitCheck(&gbl); //需要保存报文需要发送

			if (iRet==0) //如果撤销成功
			{
				bbzero(tradeStatus);
				strcpy(tradeStatus,"S00");
				verify_lastFlag=1;
				
			}
			else
			{
				
				bbzero(tradeStatus);
				strcpy(tradeStatus,"S01");
				verify_lastFlag=1;
			}
		

		}
		else if (atoi(gbl.dgtCard.cardMny) ==0 ) //如果卡片余额等于0
		{
		
			//圈存超时进行处理
			//对于圈存超时的情况，进行判断
			if(strcmp(tradeStatus,"S0T") ==0 ) //圈存超时,判断交易最终状态
			{
				wrLog("换卡过程圈存超时确认结果是圈存失败，正在进行撤销操作");
				verify_lastFlag=1;
				if (strlen(resubmit_fail) >0 )
				{
					bbzero(gbl.dgtCard.resubmitField);
					strcpy(gbl.dgtCard.resubmitField,resubmit_fail);
					CDB::setdgtResubmit(gbl.Centerseqno,gbl.dgtCard.resubmitField);
				}
				else //需要自动生成
				{
					int iRet_tmp;
					int resub_faiLen;
					iRet_tmp=dgtBusTrade.packdgtFunc(&gbl,"3481","00",resubmit_fail,&resub_faiLen); //结果撤销。
					bbzero(gbl.dgtCard.resubmitField);
					strcpy(gbl.dgtCard.resubmitField,resubmit_fail);
					CDB::setdgtResubmit(gbl.Centerseqno,gbl.dgtCard.resubmitField);

				}
			
				//说明移资失败 需要需要将业务状态修改为
				CDB::updateTranChargeProcess(&gbl,"R01"); //需要向东莞通发送撤销
				iRet=dgtResubmitCheck(&gbl); //需要保存报文需要发送

				if (iRet==0) //如果撤销成功
				{
					CDB::updateTranChargeProcess(&gbl,"R00"); //需要向羊城通发送撤销
					bbzero(tradeStatus);
					strcpy(tradeStatus,"R00");
					verify_lastFlag=1;
				}
				else
				{
						
					bbzero(tradeStatus);
					strcpy(tradeStatus,"R01");
					verify_lastFlag=1;
				}
					
			}
				
				
		}
		else
		{
			TS_OutPutMsg(gbl.dPosInfo,"东莞通卡片卡片余额与实际换卡金额不符,0769-22021888或0769-22021818进行退换!",1,iSelect);
			return CANCLE_KEY;

		}
		
			
	}
	
	//发送换卡请求报文
	//发送换卡请求 transmessage =3458 transtype=51
	
	bbzero(gbl.dgt_LocalSequence);
	bbzero(gbl.dgt_posSerial);
	CTools::get_dgtOrderNo(gbl.dgt_posSerial);
	CTools::getDGTLocalSeq(gbl.dgt_LocalSequence);

	wrLog("东莞通交易流水号:%s",gbl.dgt_LocalSequence);
	wrLog("东莞通终端流水号:%s",gbl.dgt_posSerial);


	//如果是第一次进入需要进行申请，申请失败，第二次进入不需要申请

	//第一次进入或者是开卡失败的需要进度次流程中 申请是once in a life time

	if (iRet_process<0 || strcmp(tradeStatus,"C01") ==0 || strcmp(tradeStatus,"FFF") ==0)  //如果进行换卡请求 1 是开卡失败 7是换卡结果获取失败

	{
	
		if (iRet_process<0 ) //第一次申请 
		{

			bbzero(gbl.Centerseqno);
			bbzero(rsp_code);
			bbzero(rsp_message);
			iRet=dgtBusTrade.cardManagement(&gbl,"3458","51",rsp_code,rsp_message); //如果换卡申请失败。提示用户东莞通处理
			
			if (iRet!=0)
			{
				if (iRet == -2) //网络问题
				{
					bbzero(showMsg);
					sprintf(showMsg,"%s\n请咨询东莞通客服0769-22021888或0769-22021818进行退换 ",rsp_message);
					wrLog("%s",showMsg);
					TS_OutPutMsg(gbl.dPosInfo,rsp_message,1,iSelect);
					return CANCLE_KEY;

				}
				else
				{
					bbzero(showMsg);
					sprintf(showMsg,"%s\n请咨询东莞通客服0769-22021888或0769-22021818进行退换 ",rsp_message);
					wrLog("%s",showMsg);
					TS_OutPutMsg(gbl.dPosInfo,"该卡不能换卡，确定【Enter】\n请咨询东莞通客服0769-22021888或0769-22021818进行退换",1,iSelect);
					return CANCLE_KEY;

				}
			
			}
			
			//申请成功之后，插入数据库中申请记录
			CDB::insert_dgtTransferLog(gbl,"FFF");
			bbzero(tradeStatus);
			strcpy(tradeStatus,"FFF");

		}


	//进行卡操作操作
	//暂时屏蔽有效期检查
	/*
	iRet=dgtEffectiveCheck(0,errMsg);
	
	if (iRet!=0)
	{
		TS_OutPutMsg(gbl.dPosInfo,errMsg,1,iSelect);
		return -1; //有效性检查失败
	}

	*/

	//正在进行开卡流程 
	
	
	bbzero(rsp_code);
	bbzero(rsp_message);
	//读取新卡的信息
	if (verify_lastFlag==1) //如果是确认上次交易,则需要进行提示
	{

		TS_OutPutMsg(gbl.dPosInfo,"请换一张新的东莞通卡,放在读卡器感应区 \n\n【温馨提示】您上次交易过程中开卡失败，请更换一张新的东莞通卡!\n按【Enter】 返回请按【Esc】",1,iSelect);

	}
	else
	{	
		TS_OutPutMsg(gbl.dPosInfo,"请将一张东莞通卡放在读卡器感应区 \n\n【温馨提示】如果您上次换卡失败，请将原交易使用的东莞通卡读卡器感应区\n按【Enter】 返回请按【Esc】",1,iSelect);

	}

	if (iSelect!=0)
	{
		TS_OutPutMsg(gbl.dPosInfo,"读取东莞通卡片信息出错",1,iSelect);
		return CANCLE_KEY;
	}

	memset(&gbl.dgtCard,0,sizeof(gbl.dgtCard));
	iRet=dgtCardInqHdl(&gbl.dgtCard,2); //查询卡片物理信息
	if (iRet!=0) 
	{
		CDB::updateTranChargeProcess(&gbl,"C01");
		wrLog("读取东莞通卡片查询出错"); //进行异常处理
		TS_OutPutMsg(gbl.dPosInfo,"读取东莞通卡片出错,换卡失败 请进入业务重试\n如有疑问,请咨询在线客服或致电客服电话400-80-11888",1,iSelect);
		return CANCLE_KEY;
		
	}

	//输出cpu卡片的开卡信息及卡片余额信息 此处添加
	wrLog("---------------------------------------------------------------");
	wrLog("输出换卡流程的cpu卡的卡片卡片开卡状态及余额信息");
	bbzero(openStatus);
	CTools::byte_to_hex((BYTE *) gbl.dgtCard.appFlag,(BYTE * ) openStatus,1);
	
	if (memcmp(gbl.dgtCard.appFlag,"\x01",1)==0 ) //卡片状态为已经开卡状态
	{
		
		wrLog("CPU卡片已经激活卡片状态:【%s】",openStatus);
		wrLog("CPU卡片余额信息:%.2f",atof(gbl.dgtCard.cardMny)/100);
	}
	else
	{
		wrLog("卡片已经激活卡片状态:【%s】",openStatus);
		wrLog("CPU卡片余额信息:%.2f",atof(gbl.dgtCard.cardMny)/100);
	}
	
	wrLog("-----------------------------------------------------------------");


	TS_OutPutMsg(gbl.dPosInfo,"\n正在进行开卡操作,不要移动卡片\n确认请按【Enter】",1,iSelect);


	iRet=dgtBusTrade.cardTrans_OpenCard(&gbl,rsp_code,rsp_message); //开卡过程中出现发送确认失败的情况，要补发确认

	if (iRet!=0) //如果开卡不成功 或者不明确成功
	{
		if(iRet==-5) //如果是开卡超时
		{

			char resubmitFeild[1024];
			bbzero(resubmitFeild);
			int resubmit_len = 0;
			
			//记录开卡成功的报文，做后续的操作
			iRet=dgtBusTrade.packdgtFunc(&gbl,"2063","52",resubmitFeild,&resubmit_len);
			CDB::setdgtResubmit(gbl.Centerseqno,resubmitFeild); //resubmit 
			return CANCLE_KEY;

		}
		else //开卡失败发送确认报文
		{
			
			return CANCLE_KEY; //开卡不成功。是卡片明确返回失败的情况
		}
	
	}
	else
	{	
		//向企业账户生成订单
		bbzero(tradeStatus);
		strcpy(tradeStatus,"C00");
		bbzero(gbl.TRANSSEQ);
		iRet=dgtOrderProduceService("异步订单生成","INF01022",gbl.TRANSSEQ,errStr);
		if (iRet == 0) //如果生成订单成功，则发送确认成功
		{
				
			CDB::updateTranOrderStatus(gbl.Centerseqno,"S0A");
				
			for( int i =0; i <3 ;i ++)
			{
					
				iRet2=dgtOrderVerifyService("异步订单确认","INF01023",0,"00000","成功",errStr); //开卡成功进行发送
				if (iRet2 == 0)
				{
					CDB::updateTranOrderStatus(gbl.Centerseqno,"S0S");
					break;
				}
			}

			//发送三次确认
			if (iRet2 !=0)
			{
				CDB::updateTranOrderStatus(gbl.Centerseqno,"S0F"); //确认失败，需要重新发送确认报文
			}
			
		}
		else
		
		{
			CDB::updateTranOrderStatus(gbl.Centerseqno,"S0X"); //订单生成失败，需要重新生成
			bbzero(showMsg);
			sprintf(showMsg,"订单生成失败 %s\n如有需要,请联系在线客服或致电400-80-11888",errStr.c_str());
			TS_OutPutMsg(gbl.dPosInfo,showMsg,1,iSelect);
			return CANCLE_KEY;
		}
			
	}

	}
	
	//如果是撤销失败的。先发撤销报文，在进行结果获取。结果获取可以多次 如果上笔交易造成结果仍然是A00
	if (strcmp(tradeStatus,"R01")==0 || strcmp(tradeStatus,"R03")==0 || strcmp(tradeStatus,"A00") ==0 || strcmp(tradeStatus,"A01") ==0 ) //交易撤销失败。系统原因造成撤销失败 。需要重新发送结果撤销交易
	{

		bbzero(rsp_code);
		bbzero(rsp_message);
		iRet=dgtBusTrade.cardManagement(&gbl,"3481","00",rsp_code,rsp_message); //结果获取撤销

		if (iRet!=0)
			
		{
			if (iRet == -2) //网络问题
			{
				TS_OutPutMsg(gbl.dPosInfo,rsp_message,1,iSelect);
				return -1;
			}
			else
			{
			
				bbzero(showMsg);
				sprintf(showMsg,"%s\n换卡失败，请联系在线客服或者致电400-80-11888咨询",rsp_message);
				TS_OutPutMsg(gbl.dPosInfo,showMsg,1,iSelect);
				return -1;
			}
		
		}
		else
		{
		  //更新数据库的状态为R00并且交易状态修改为R00
		  bbzero(tradeStatus);
		  strcpy(tradeStatus,"R00");
		  CDB::updateTranChargeProcess(&gbl,"R00");

		}


	} //撤销失败，联系在线客服
		

	//发送结果获取报文
	
	if (strcmp(tradeStatus,"R00")==0  || strcmp(tradeStatus,"C00")==0) //或者开卡成功 或者换卡撤销成功的
	{
         

		bbzero(rsp_code);
		bbzero(rsp_message);
		iRet=dgtBusTrade.cardManagement(&gbl,"3480","00",rsp_code,rsp_message); //发送结果获取报文 reserved=3458 //结果获取报文出现超时的情况也要发冲正
		//这个地方需要处理发送结果报文返回结果获取报文返回已经申请的情况。

		if (iRet!=0) //结果获取报文失败 处理 26051
		{
		
			//对于返回已经申请过的进行特殊处理
			if (strcmp(rsp_code,"26051") ==0 ) //自动发送撤销
			{
			
				//这个地方需要处理要发撤销
				iRet=dgtRollBack(); 
				if (iRet!=0) //如果提交失败
				{
					CDB::updateTranChargeProcess(&gbl,"R01");

				}
				else
				{
					CDB::updateTranChargeProcess(&gbl,"R00");
				
				}

					TS_OutPutMsg(gbl.dPosInfo,"换卡申请失败。请进入业务重试。如有需要请联系在线客服或者致电400-80-11888咨询",1,iSelect);


			}
			else

			{

				CDB::updateTranChargeProcess(&gbl,"A01");
				TS_OutPutMsg(gbl.dPosInfo,rsp_message,1,iSelect);
			}

			return -4;

	}

	//结果申请成功，在界面上显示申请信息
	CDB::updateTranChargeProcess(&gbl,"A00");
	bbzero(showMsg);
	sprintf(showMsg,"汇通卡号:%s\n卡片余额:%.2f元\n可退金额:%.2f元\n\n请按【Enter】继续交易，按【Esc】返回",gbl.dgtM1Card.bus_showCard,atof(gbl.dgtM1Card.bus_amt)/100,atof(gbl.ReturnAmt)/100);
	TS_OutPutMsg(gbl.dPosInfo,showMsg,1,iSelect);

	if (iSelect!=0)
	{
		//这个地方需要处理要发撤销
		iRet=dgtRollBack(); 
		if (iRet!=0) //如果提交失败
		{
			CDB::updateTranChargeProcess(&gbl,"R01");
		}
		else
		{
			CDB::updateTranChargeProcess(&gbl,"R00");

		}
		
		return CANCLE_KEY;
	}


	//进行充值 充值金额和充值时间

	bbzero(gbl.dgtCard.tradeMny);
	bbzero(gbl.dgtCard.tradeBeForeMny);

	memcpy(gbl.dgtCard.tradeBeForeMny,gbl.dgtCard.cardMny+4,8);
	memcpy(gbl.dgtCard.tradeMny,gbl.ReturnAmt+2,8);

	bbzero(rsp_message);
	bbzero(rsp_code);

	TS_OutPutMsg(gbl.dPosInfo,"正在进行移资操作，请将东莞通卡在读卡器上,不要移动卡片\n确认请按【Enter】",1,iSelect);
	
	transfer_iRet=dgtBusTrade.trans_card_Amt(&gbl,rsp_code,rsp_message); //充值失败

	if (transfer_iRet<0) //交易失败
	{

		iRet=dgtRollBack();
		if (iRet!=0 ) //如果均提交失败
		{
			CDB::updateTranChargeProcess(&gbl,"R01");

		}
		else
		{

			CDB::updateTranChargeProcess(&gbl,"R00");
		}
	

		TS_OutPutMsg(gbl.dPosInfo,"尊重的交费易商户，您移资失败，请进入业务重试!",1,iSelect); //对于移资金失败的情况，要重复多试几次，争取在一笔交易中完成移资的过程
		
		return -1;
	}

	else
	{
		if (transfer_iRet==1) //如果是超时的情况
		{
			char resubmit_suc_tmp[500];
			char resubmit_fail_tmp[500];
			char resubmit_tmp[1024];

			int iRet1;
			int iRet2;
			int resub_sucLen;
			int resub_faiLen;
			bbzero(resubmit_suc_tmp);
			bbzero(resubmit_fail_tmp);
			bbzero(resubmit_tmp);

			iRet1=dgtBusTrade.packdgtFunc(&gbl,"3460","53",resubmit_suc_tmp,&resub_sucLen);
			iRet2=dgtBusTrade.packdgtFunc(&gbl,"3481","00",resubmit_fail_tmp,&resub_faiLen); //结果撤销。
			sprintf(resubmit_tmp,"%s|%s",resubmit_suc_tmp,resubmit_fail_tmp);
			CDB::setdgtResubmit(gbl.Centerseqno,resubmit_tmp);

			CDB::updateTranChargeProcess(&gbl,"S0T");
			TS_OutPutMsg(gbl.dPosInfo,"尊敬的交费易商户，您移资超时,请重新进入业务确认交易结果!",1,iSelect);
			return CANCLE_KEY;
		}
		else
		{
		
			bbzero(tradeStatus);
			strcpy(tradeStatus,"S0S");
			CDB::updateTranChargeProcess(&gbl,"S0S"); //圈存完成

		}
		
	}

	}

	/************************************************************************/
	/* 这一部分进行换卡完成处理                                             */
	/************************************************************************/
	if (strcmp(tradeStatus,"S0S") ==0) //如果圈存完成
	{
		bbzero(rsp_code);
		bbzero(rsp_message);
		iRet=dgtBusTrade.cardTransFinish(&gbl,"3460","53",rsp_code,rsp_message); //需要保存卡完成的报文

		if (iRet!=0) //如果提交失败，数据库中的状态为S01
		{
			CDB::updateTranChargeProcess(&gbl,"S01");
			bbzero(tradeStatus);
			strcpy(tradeStatus,"S01");
		}
		else  
		{
			CDB::updateTranChargeProcess(&gbl,"S00");
			bbzero(tradeStatus);
			strcpy(tradeStatus,"S00");
			
		}
	
	
	}

	if (strcmp(tradeStatus,"S00") ==0) //如果成功
	{
		if (verify_lastFlag==1) //如果是上笔确认
		{
			TS_OutPutMsg(gbl.dPosInfo,"您上笔换卡成功 \n按【Enter】打印凭条 按【Esc】返回,",1,iSelect);
		}
		else
		{
			TS_OutPutMsg(gbl.dPosInfo,"换卡成功 \n按【Enter】打印凭条 按【Esc】返回,",1,iSelect);

		}
		
		if (iSelect==0)
		{
			//打印凭条
			CPrint print;
			print.set_in_par(gbl);
			print.print_dgtBus_detail(type);
			return iRet;
		}
	}
	else
	{
		TS_OutPutMsg(gbl.dPosInfo,"换卡成功 确认失败，请重新进入业务确认结果\n",1,iSelect);
		return CANCLE_KEY;
	}

	return 0;

}

//撤销及确认机制
//
int CTrade::dgtResubmitCheck(CGlobal *pgbl)
{
	char unSubmitField[1024];
	int iRet;
	char tradeStatus[10];
	char orderStatus[10];
	int iSelect;
	char showMsg[500];
	char stan_no[12+1];


	bbzero(showMsg);
	bbzero(tradeStatus);
	bbzero(orderStatus);
	bbzero(unSubmitField);
	bbzero(stan_no);

	//查询用户最近一笔以旧换新交易的情况，
	bbzero(gbl.TRANSSEQ);
	iRet=CDB::getUnsubmitTransfer(pgbl,tradeStatus,orderStatus,pgbl->dgtCard.resubmitField);
	
	if (iRet==0 ) //如果不需要查找数据库或者查找数据库中读取到正确的值
	{
	
		iRet=dgtResubmit(pgbl->dPosInfo,pgbl->dgtCard.resubmitField,tradeStatus,orderStatus); 
		
		if (strcmp(tradeStatus,"C0S")==0 ) 
		{
			if (iRet==0) //如果处理成功
			
			{
					
				TS_OutPutMsg(pgbl->dPosInfo,"您上一笔以旧换新业务开卡成功，请按【Enter】继续移资",1,iSelect);
			}
			else

				{
					TS_OutPutMsg(pgbl->dPosInfo,"您上一笔以旧换新开卡成功，确认失败，请进入业务重试!\n 如有需要,请联系在线客服或者致电客服400-80-11888",1,iSelect);
					return -1;
				}

		
		}
		else if (strcmp(tradeStatus,"S01")==0)
		{


				if (iRet==0)

					{
						TS_OutPutMsg(pgbl->dPosInfo,"您上一笔换卡交易成功，确认成功",1,iSelect);
					}
					else
					{
						bbzero(showMsg);
						bbzero(stan_no);
						memcpy(stan_no,pgbl->TRANSSEQ+(strlen(pgbl->TRANSSEQ)-12),12);
						if (strlen(stan_no) >0)
						{

							sprintf(showMsg,"您上一笔换卡交易成功，确认失败,系统参考号:%s\n如需帮助，请联系在线客服或拨打客服电话400-80-11888咨询",stan_no);
						
						}
						else
						{
							strcpy(showMsg,"您上一笔换卡交易成功，确认失败 \n如需帮助，请联系在线客服或拨打客服电话400-80-11888咨询");
						}
					
						TS_OutPutMsg(pgbl->dPosInfo,showMsg,1,iSelect);
					}
				
			
				
		}

	}

	return 0;

}

//重传
//如果type=0 不需要组装数据包
//如果type=1.不要组装数据包
int CTrade::dgtResubmit(TSDLLPosInfo dPosInfo,char *reSubmitField ,char *tradeStatus,char *orderStatus)
{
	string errStr="";
	int iRet;
	int next=0;
	int stop_step=0;
	int iRet2 ;

	//开卡确认 开卡确认，根据status 来判断是成功还是失败的确认

	if (strcmp(orderStatus,"S0X") ==0 )
	{
		bbzero(gbl.TRANSSEQ);
		iRet=dgtOrderProduceService("异步订单生成","INF01022",gbl.TRANSSEQ,errStr);
		if (iRet == 0) //如果生成订单成功，则发送确认成功
		{
			
			CDB::updateTranOrderStatus(gbl.Centerseqno,"S0A");
			
			for( int i =0; i <3 ;i ++)
			{
				
				iRet2=dgtOrderVerifyService("异步订单确认","INF01023",0,"00000","成功",errStr); //开卡成功进行发送
				if (iRet2 == 0)
				{
					CDB::updateTranOrderStatus(gbl.Centerseqno,"S0S");
					break;
				}
			}
			
			//发送三次确认
			if (iRet2 !=0)
			{
				CDB::updateTranOrderStatus(gbl.Centerseqno,"S0F"); //确认失败，需要重新发送确认报文
			}
			
		}

	}
	
	if (strcmp(orderStatus,"S0F") ==0 ) //目前只会确认成功
		
	{
		
		iRet=dgtOrderVerifyService("异步订单确认","INF01023",0,"00000","成功",errStr);
		if (iRet==0) //确认成功
		{
			CDB::updateTranOrderStatus(gbl.Centerseqno,"S0S"); //确认成功
		}

	}

	//三种，1，只发送给东莞公交 C0S是售卡确人
	if (strcmp(tradeStatus,"R01") ==0 || strcmp(tradeStatus,"S01") ==0 || strcmp(tradeStatus,"C0S")==0 || strcmp(tradeStatus,"R03")==0 || strcmp(tradeStatus,"S03") ==0) 
	{
		
		char sndData[1024]={0};
		char rcvData[1024]={0};
		int sndLen=0;
		int rcvLen=0;
		char rsp_code[5+1];

		if (strlen(reSubmitField) <0) //如果没有
		{
			wrLog("没有提交数据，考虑参数传入的情况进行确认");
			return -1;
		}
		
		strcpy(sndData,reSubmitField);
		sndLen=strlen(sndData);
		
		for (int j=0;j<3;j++)
		{
			iRet=CDGTBusTrade::commuWithDGT( gbl.dPosInfo,sndData,sndLen,rcvData, &rcvLen); //通讯
			if (iRet!=0 )
			{
				//通讯错误
				continue;
			}
			else 
			{
				
				bbzero(rsp_code);
				memcpy(rsp_code,rcvData+rcvLen-5,5);
				if (strcmp(rsp_code,"00000")==0) //如果返回00000
				{

					//如果确认成功
					if (strcmp(tradeStatus,"R01") ==0)
					{
						stop_step=1;
						CDB::updateTranChargeProcess(&gbl,"R00");
						return 0;
						
					}
					else if (strcmp(tradeStatus,"S01") ==0)
					{
						stop_step=1;
						CDB::updateTranChargeProcess(&gbl,"S00");
						return 0;
						
					}
					else if (strcmp(tradeStatus,"C0S")==0)
					{
						stop_step=1;
						CDB::updateTranChargeProcess(&gbl,"C00");
						return 0;
						
					}
					else if (strcmp(tradeStatus,"S03")==0)
					{
						next=1;
						CDB::updateTranChargeProcess(&gbl,"S02");
						break;

					}
					else if (strcmp(tradeStatus,"R03") ==0)
					{
						next=1;
						CDB::updateTranChargeProcess(&gbl,"R02");
						break;
						
					}
					
					break;

				}
					
			}
				
			}
			
		if (stop_step==0 && (strcmp(tradeStatus,"R01") ==0 || strcmp(tradeStatus,"S01")==0) || strcmp(tradeStatus,"C0S")==0)
		{
			return -1;
		}
		
	}

	
	
	//如果向企业账户确认失败
	if (strcmp(tradeStatus,"S02")==0 || strcmp(tradeStatus,"S03") ==0) //如果企业账户确认失败
		
	{

		iRet=dgtOrderVerifyService("异步订单确认","INF01023",0,"00000","成功",errStr);
		if (iRet==0) //确认失败
		{

			if (strcmp(tradeStatus,"S03") ==0 && next==0) //如果确认成功 但是第一步确认失败
			{

				CDB::updateTranChargeProcess(&gbl,"S01");
			}
			else
			{
			
				CDB::updateTranChargeProcess(&gbl,"S00");
			}
		
			return 0;
		}
	
		else
		{
		
			return -1;
		}

	}

	if (strcmp(tradeStatus,"R02") ==0 || strcmp(tradeStatus,"R03")==0 ) 

	{
				
		iRet=dgtOrderVerifyService("异步订单确认","INF01023",1,"00001","系统故障",errStr);
		if (iRet==0) //确认失败
		{
			if (strcmp(tradeStatus,"R03") ==0 && next==0)
			{
				CDB::updateTranChargeProcess(&gbl,"R01");
			}
			else
			{
				CDB::updateTranChargeProcess(&gbl,"R00");

			}

			return 0;
		}
		else 
			return -1;

	}
	


	return iRet;

}


int CTrade::dgtRollBack()
{
	int iRet;
	CDGTBusTrade dgtBusTrade;
	char rsp_code[5+1];
	char rsp_message[500];
	string errStr="";

	bbzero(rsp_message);
	bbzero(rsp_code);

	for (int i=0;i<3;i++)
	{
		iRet=dgtBusTrade.cardManagement(&gbl,"3481","00",rsp_code,rsp_message); //结果获取撤销
		if (iRet==0)
		{
			break;
		}
		
	}

	if (iRet!=0) //提交失败
	{
		return -1;
	}

	return 0;

}






